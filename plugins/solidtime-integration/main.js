/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SolidTimePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  apiKey: "",
  apiBaseUrl: "https://app.solidtime.io/api",
  // Default to production
  selectedOrganizationId: "",
  selectedMemberId: "",
  statusBarUpdateIntervalSeconds: 30,
  autoFetchIntervalMinutes: 15,
  defaultBillable: false
};
var SolidTimeSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.memberships = [];
    this.plugin = plugin;
  }
  async fetchMemberships() {
    this.memberships = [];
    if (this.plugin.settings.apiKey && this.plugin.settings.apiBaseUrl && this.plugin.api) {
      try {
        this.memberships = await this.plugin.api.getMemberships();
      } catch (error) {
        console.error("SolidTime: Failed to fetch memberships for settings", error);
        new import_obsidian.Notice("Failed to fetch SolidTime organizations. Check API key/URL or console.");
      }
    }
    if (!Array.isArray(this.memberships)) {
      this.memberships = [];
    }
  }
  async display() {
    const { containerEl } = this;
    containerEl.empty();
    if (this.plugin.settings.apiKey && this.plugin.settings.apiBaseUrl) {
      await this.fetchMemberships();
    }
    new import_obsidian.Setting(containerEl).setName("SolidTime API key").setDesc("Generate an API token from your SolidTime profile.").addText((text) => {
      text.setPlaceholder("Enter your API key").setValue(this.plugin.settings.apiKey).onChange(async (value) => {
        this.plugin.settings.apiKey = value.trim();
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async () => {
        await this.fetchMemberships();
        this.display();
      });
    });
    new import_obsidian.Setting(containerEl).setName("SolidTime API base URL").setDesc("The base URL for the SolidTime API.").addText((text) => {
      text.setPlaceholder("e.g., https://app.solidtime.io/api").setValue(this.plugin.settings.apiBaseUrl).onChange(async (value) => {
        this.plugin.settings.apiBaseUrl = value.trim().replace(/\/$/, "");
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async () => {
        await this.fetchMemberships();
        this.display();
      });
    });
    const orgSetting = new import_obsidian.Setting(containerEl).setName("Active organization").setDesc("Select the SolidTime organization to use.");
    const canSelectOrg = this.plugin.settings.apiKey && this.plugin.settings.apiBaseUrl && this.memberships.length > 0;
    if (!this.plugin.settings.apiKey || !this.plugin.settings.apiBaseUrl) {
      orgSetting.setDesc("Enter API Key and Base URL above to load organizations.");
    } else if (this.memberships.length === 0) {
      orgSetting.setDesc("Could not load organizations. Check API Key/URL or network.");
      orgSetting.addButton((button) => button.setButtonText("Retry fetch").onClick(async () => {
        await this.fetchMemberships();
        this.display();
      }));
    }
    orgSetting.addDropdown((dropdown) => {
      dropdown.addOption("", "-- Select organization --");
      if (this.memberships.length > 0) {
        this.memberships.forEach((membership) => {
          if (membership.organization) {
            dropdown.addOption(membership.organization.id, membership.organization.name);
          } else {
            console.warn("SolidTime: Membership found without organization details:", membership);
          }
        });
      }
      dropdown.setValue(this.plugin.settings.selectedOrganizationId);
      dropdown.setDisabled(!canSelectOrg);
      dropdown.onChange(async (value) => {
        const selectedMembership = this.memberships.find((m) => {
          var _a;
          return ((_a = m.organization) == null ? void 0 : _a.id) === value;
        });
        this.plugin.settings.selectedOrganizationId = value;
        this.plugin.settings.selectedMemberId = selectedMembership ? selectedMembership.id : "";
        if (!this.plugin.settings.selectedMemberId && value) {
          console.error("Could not find member_id (membership id) for selected organization:", value);
          new import_obsidian.Notice("Error finding member ID for selected organization. Please re-fetch.");
        }
        await this.plugin.saveSettings();
        this.plugin.loadSolidTimeData();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Default billable").setDesc("Set the default billable state for new time entries.").addToggle((toggle) => toggle.setValue(this.plugin.settings.defaultBillable).onChange(async (value) => {
      this.plugin.settings.defaultBillable = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Status bar update interval (seconds)").setDesc("How often to check for the current timer status (0 to disable).").addText((text) => text.setValue(String(this.plugin.settings.statusBarUpdateIntervalSeconds)).onChange(async (value) => {
      const numberValue = parseInt(value, 10);
      if (!isNaN(numberValue) && numberValue >= 0) {
        this.plugin.settings.statusBarUpdateIntervalSeconds = numberValue;
        await this.plugin.saveSettings();
        this.plugin.setupIntervals();
      } else {
        new import_obsidian.Notice("Please enter a valid number (0 or greater).");
      }
    }));
    new import_obsidian.Setting(containerEl).setName("Data auto-fetch interval (minutes)").setDesc("How often to automatically refresh projects, tasks, and tags (0 to disable).").addText((text) => text.setValue(String(this.plugin.settings.autoFetchIntervalMinutes)).onChange(async (value) => {
      const numberValue = parseInt(value, 10);
      if (!isNaN(numberValue) && numberValue >= 0) {
        this.plugin.settings.autoFetchIntervalMinutes = numberValue;
        await this.plugin.saveSettings();
        this.plugin.setupIntervals();
      } else {
        new import_obsidian.Notice("Please enter a valid number (0 or greater).");
      }
    }));
  }
};

// src/api.ts
var import_obsidian2 = require("obsidian");
var SolidTimeApi = class {
  constructor(apiKey, baseUrl) {
    this.apiKey = apiKey;
    this.baseUrl = baseUrl.replace(/\/$/, "");
  }
  async request(options, allowedNon2xxStatuses = []) {
    var _a, _b;
    if (!this.apiKey) {
      throw new Error("SolidTime API Key is not configured.");
    }
    if (!this.baseUrl) {
      throw new Error("SolidTime API Base URL is not configured.");
    }
    const defaultHeaders = {
      "Authorization": `Bearer ${this.apiKey}`,
      "Accept": "application/json",
      "Content-Type": "application/json"
    };
    options.headers = { ...defaultHeaders, ...options.headers };
    let finalUrl = options.url;
    if (finalUrl && !finalUrl.startsWith("http://") && !finalUrl.startsWith("https://")) {
      const separator = finalUrl.startsWith("/") ? "" : "/";
      finalUrl = `${this.baseUrl}${separator}${finalUrl}`;
    }
    options.url = finalUrl;
    try {
      options.throw = false;
      const response = await (0, import_obsidian2.requestUrl)(options);
      const isAllowedNon2xx = allowedNon2xxStatuses.includes(response.status);
      if (response.status >= 200 && response.status < 300 || isAllowedNon2xx) {
        if (response.status === 204) {
          return null;
        }
        if (isAllowedNon2xx) {
          return null;
        }
        if (((_a = response.arrayBuffer) == null ? void 0 : _a.byteLength) > 0 || response.text) {
          return response.json;
        } else {
          return null;
        }
      } else {
        console.error("SolidTime API Error Response:", response);
        let errorMsg = `SolidTime API Error: ${response.status}`;
        let errorJson = null;
        try {
          if (((_b = response.arrayBuffer) == null ? void 0 : _b.byteLength) > 0 || response.text) {
            errorJson = response.json;
          }
          if (errorJson && errorJson.message) {
            errorMsg += ` - ${errorJson.message}`;
            if (errorJson.errors) {
              errorMsg += ` (${JSON.stringify(errorJson.errors)})`;
            }
          } else if (response.text) {
            errorMsg += ` - ${response.text.substring(0, 100)}`;
          }
        } catch (e) {
          console.warn("SolidTime: Could not parse error response as JSON.", e);
          if (response.text) {
            errorMsg += ` - ${response.text.substring(0, 100)}`;
          }
        }
        new import_obsidian2.Notice(errorMsg, 5e3);
        throw new Error(errorMsg);
      }
    } catch (error) {
      console.error("SolidTime API Request Failed:", error);
      if (error instanceof Error && !error.message.startsWith("SolidTime API Error:")) {
        new import_obsidian2.Notice(`SolidTime Network Error: ${error.message}`, 5e3);
      }
      throw error;
    }
  }
  // --- User & Membership ---
  async getMe() {
    const response = await this.request({
      url: "/v1/users/me",
      method: "GET"
    });
    if (!(response == null ? void 0 : response.data)) throw new Error("API did not return expected data for /users/me.");
    return response.data;
  }
  // --- Add getMembers ---
  // Note: This returns a paginated list! Needs pagination handling.
  // For simplicity now, assume we fetch all or enough members on the first page.
  // A full implementation should use fetchAllPaginated or handle pages.
  async getMembers(orgId) {
    if (!orgId) return [];
    const initialUrl = `/v1/organizations/${orgId}/members`;
    try {
      return await this.fetchAllPaginated(initialUrl);
    } catch (error) {
      console.error(`SolidTime: Failed to fetch members for org ${orgId}`, error);
      return [];
    }
  }
  // ... rest of the API methods (getMemberships, getActiveTimeEntry, etc.) ...
  async getMemberships() {
    const response = await this.request({
      url: "/v1/users/me/memberships",
      method: "GET"
    });
    return (response == null ? void 0 : response.data) || [];
  }
  async getActiveTimeEntry() {
    try {
      const response = await this.request({
        url: "/v1/users/me/time-entries/active",
        method: "GET"
      }, [404]);
      if (response === null) {
        return null;
      }
      return (response == null ? void 0 : response.data) || null;
    } catch (error) {
      console.error("SolidTime: Unexpected error fetching active time entry", error);
      throw error;
    }
  }
  // --- Time Entries ---
  async startTimeEntry(orgId, payload) {
    if (!orgId) throw new Error("Organization ID is required to start a time entry.");
    if (!payload.member_id) throw new Error("Member ID is required to start a time entry.");
    const response = await this.request({
      url: `/v1/organizations/${orgId}/time-entries`,
      method: "POST",
      body: JSON.stringify(payload)
    });
    if (!(response == null ? void 0 : response.data)) {
      throw new Error("API did not return expected data on start timer.");
    }
    return response.data;
  }
  async stopTimeEntry(orgId, timeEntryId, payload) {
    if (!orgId) throw new Error("Organization ID is required to stop a time entry.");
    if (!timeEntryId) throw new Error("Time Entry ID is required to stop a time entry.");
    const response = await this.request({
      url: `/v1/organizations/${orgId}/time-entries/${timeEntryId}`,
      method: "PUT",
      body: JSON.stringify(payload)
    });
    if (!(response == null ? void 0 : response.data)) {
      throw new Error("API did not return expected data on stop timer.");
    }
    return response.data;
  }
  // --- Data Fetching (Implement pagination properly) ---
  async fetchAllPaginated(initialUrl) {
    var _a, _b;
    let allData = [];
    let nextPageUrl = initialUrl;
    while (nextPageUrl) {
      const response = await this.request({
        url: nextPageUrl,
        method: "GET"
        // No allowed non-2xx here unless specifically needed for a paginated endpoint
      });
      if (response && Array.isArray(response.data)) {
        allData = allData.concat(response.data);
        const rawNextUrl = (_b = (_a = response.links) == null ? void 0 : _a.next) != null ? _b : null;
        nextPageUrl = rawNextUrl;
      } else {
        if (response !== null) {
          console.warn(`SolidTime: Unexpected response structure during pagination for URL: ${nextPageUrl}`, response);
        }
        nextPageUrl = null;
      }
      if (allData.length > 1e4) {
        console.warn("SolidTime: Fetching aborted, exceeded 10000 items.");
        break;
      }
    }
    return allData;
  }
  async getProjects(orgId) {
    if (!orgId) return [];
    const initialUrl = `/v1/organizations/${orgId}/projects?archived=false`;
    return this.fetchAllPaginated(initialUrl);
  }
  async getTasks(orgId, projectId) {
    if (!orgId) return [];
    let url = `/v1/organizations/${orgId}/tasks?done=false`;
    if (projectId) {
      url += `&project_id=${projectId}`;
    }
    return this.fetchAllPaginated(url);
  }
  async getTags(orgId) {
    if (!orgId) return [];
    try {
      const response = await this.request({
        url: `/v1/organizations/${orgId}/tags`,
        method: "GET"
      });
      return (response == null ? void 0 : response.data) || [];
    } catch (e) {
      console.error("Failed to fetch tags", e);
      return [];
    }
  }
  async createTag(orgId, tagName) {
    if (!orgId) throw new Error("Organization ID is required to create a tag.");
    if (!tagName) throw new Error("Tag name cannot be empty.");
    const payload = { name: tagName };
    const response = await this.request({
      url: `/v1/organizations/${orgId}/tags`,
      method: "POST",
      body: JSON.stringify(payload)
    });
    if (!(response == null ? void 0 : response.data)) throw new Error("API did not return expected data on create tag.");
    return response.data;
  }
};

// src/modals.ts
var import_obsidian3 = require("obsidian");
var ProjectSuggestModal = class extends import_obsidian3.SuggestModal {
  // Allow choosing null (clearing)
  constructor(app, projects, onChoose) {
    super(app);
    this.projects = [{ name: "(No project)", id: "__NONE__" }, ...projects];
    this.onChoose = onChoose;
    this.setPlaceholder("Select a SolidTime project (or 'No project')...");
  }
  getSuggestions(query) {
    const lowerCaseQuery = query.toLowerCase();
    return this.projects.filter(
      (project) => project.name.toLowerCase().includes(lowerCaseQuery)
    );
  }
  renderSuggestion(project, el) {
    el.createEl("div", { text: project.name });
  }
  onChooseSuggestion(project, evt) {
    if (project.id === "__NONE__") {
      this.onChoose(null);
    } else {
      this.onChoose(project);
    }
  }
};
var TaskSuggestModal = class extends import_obsidian3.SuggestModal {
  constructor(app, tasks, onChoose) {
    super(app);
    this.tasks = [{ name: "(No task)", id: "__NONE__" }, ...tasks];
    this.onChoose = onChoose;
    this.setPlaceholder("Select a task (or 'No task')...");
  }
  getSuggestions(query) {
    const lowerCaseQuery = query.toLowerCase();
    return this.tasks.filter(
      (task) => task.name.toLowerCase().includes(lowerCaseQuery)
    );
  }
  renderSuggestion(task, el) {
    el.createEl("div", { text: task.name });
  }
  onChooseSuggestion(task, evt) {
    if (task.id === "__NONE__") {
      this.onChoose(null);
    } else {
      this.onChoose(task);
    }
  }
};
var TagSelectionModal = class extends import_obsidian3.Modal {
  constructor(app, plugin, currentSelectedIds, onSubmit) {
    super(app);
    this.newTagName = "";
    this.plugin = plugin;
    this.availableTags = [...plugin.tags].sort((a, b) => a.name.localeCompare(b.name));
    this.selectedTagIds = new Set(currentSelectedIds);
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("solidtime-tag-modal");
    contentEl.createEl("h2", { text: "Select tags" });
    const newTagSetting = new import_obsidian3.Setting(contentEl).setName("Create new tag").setDesc("Enter name and click Create.");
    newTagSetting.addText(
      (text) => text.setPlaceholder("New tag name...").onChange((value) => this.newTagName = value.trim())
    );
    newTagSetting.addButton(
      (button) => button.setButtonText("Create").setCta().onClick(async () => {
        if (!this.newTagName) {
          new import_obsidian3.Notice("Please enter a tag name.");
          return;
        }
        if (this.availableTags.some((t) => t.name.toLowerCase() === this.newTagName.toLowerCase())) {
          new import_obsidian3.Notice(`Tag "${this.newTagName}" already exists.`);
          return;
        }
        try {
          const newTag = await this.plugin.createTag(this.newTagName);
          if (newTag) {
            new import_obsidian3.Notice(`Tag "${newTag.name}" created.`);
            this.availableTags.push(newTag);
            this.availableTags.sort((a, b) => a.name.localeCompare(b.name));
            this.selectedTagIds.add(newTag.id);
            this.newTagName = "";
            this.renderTagCheckboxes(contentEl.querySelector(".solidtime-tag-checkbox-container"));
            const inputEl = newTagSetting.controlEl.querySelector("input");
            if (inputEl) inputEl.value = "";
          }
        } catch (error) {
          console.error("Failed to create tag", error);
          new import_obsidian3.Notice("Error creating tag. See console.");
        }
      })
    );
    const checkboxContainer = contentEl.createDiv({ cls: "solidtime-tag-checkbox-container" });
    this.renderTagCheckboxes(checkboxContainer);
    new import_obsidian3.Setting(contentEl).setClass("modal-button-container").addButton(
      (button) => button.setButtonText("Update tags").setCta().onClick(() => {
        this.onSubmit(Array.from(this.selectedTagIds));
        this.close();
      })
    );
  }
  renderTagCheckboxes(containerEl) {
    containerEl.empty();
    if (this.availableTags.length === 0) {
      containerEl.createEl("p", { text: "No tags available. Create one above.", cls: "setting-item-description" });
      return;
    }
    this.availableTags.forEach((tag) => {
      const setting = new import_obsidian3.Setting(containerEl).setName(tag.name);
      setting.addToggle(
        (toggle) => toggle.setValue(this.selectedTagIds.has(tag.id)).onChange((value) => {
          if (value) {
            this.selectedTagIds.add(tag.id);
          } else {
            this.selectedTagIds.delete(tag.id);
          }
        })
      );
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};
var StartTimerModal = class extends import_obsidian3.Modal {
  constructor(app, plugin) {
    super(app);
    this.description = "";
    this.selectedProject = null;
    this.selectedTask = null;
    this.selectedTags = [];
    // Data stores from plugin
    this.availableProjects = [];
    this.allTasks = [];
    // All tasks for the org
    this.availableTags = [];
    // Filtered data for display
    this.filteredTasks = [];
    // HTML Elements for updates
    this.projectInputElement = null;
    this.taskInputElement = null;
    this.plugin = plugin;
    this.isBillable = plugin.settings.defaultBillable;
    this.availableProjects = plugin.projects;
    this.allTasks = plugin.tasks;
    this.availableTags = plugin.tags;
    this.filterTasksForSelectedProject();
  }
  filterTasksForSelectedProject() {
    var _a;
    if (this.selectedProject) {
      this.filteredTasks = this.allTasks.filter(
        (task) => {
          var _a2;
          return task.project_id === ((_a2 = this.selectedProject) == null ? void 0 : _a2.id) && !task.is_done;
        }
      );
    } else {
      this.filteredTasks = [];
    }
    if (this.selectedTask && this.selectedTask.project_id !== ((_a = this.selectedProject) == null ? void 0 : _a.id)) {
      this.selectedTask = null;
    }
    if (this.taskInputElement) {
      this.taskInputElement.value = this.selectedTask ? this.selectedTask.name : "";
    }
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("solidtime-modal");
    contentEl.createEl("h2", { text: "Start SolidTime timer" });
    new import_obsidian3.Setting(contentEl).setName("Description").addText((text) => text.setPlaceholder("What are you working on?").setValue(this.description).onChange((value) => this.description = value));
    const projectSetting = new import_obsidian3.Setting(contentEl).setName("Project").setClass("solidtime-modal-setting");
    this.projectInputElement = projectSetting.controlEl.createEl("input", {
      type: "text",
      attr: { placeholder: "Click to select project (optional)", readonly: true }
      // Make it look like a selector
    });
    this.projectInputElement.value = this.selectedProject ? this.selectedProject.name : "";
    this.projectInputElement.addEventListener("click", () => {
      new ProjectSuggestModal(this.app, this.availableProjects, (project) => {
        this.selectedProject = project;
        this.projectInputElement.value = project ? project.name : "";
        this.selectedTask = null;
        this.filterTasksForSelectedProject();
      }).open();
    });
    projectSetting.controlEl.appendChild(this.projectInputElement);
    const taskSetting = new import_obsidian3.Setting(contentEl).setName("Task").setClass("solidtime-modal-setting");
    this.taskInputElement = taskSetting.controlEl.createEl("input", {
      type: "text",
      attr: { placeholder: "Click to select task (optional)", readonly: true }
    });
    this.taskInputElement.value = this.selectedTask ? this.selectedTask.name : "";
    this.taskInputElement.addEventListener("click", () => {
      if (!this.selectedProject) {
        new import_obsidian3.Notice("Please select a project first to see its tasks.");
        return;
      }
      if (this.filteredTasks.length === 0) {
        new import_obsidian3.Notice("No available (non-done) tasks found for this project.");
        return;
      }
      new TaskSuggestModal(this.app, this.filteredTasks, (task) => {
        this.selectedTask = task;
        this.taskInputElement.value = task ? task.name : "";
      }).open();
    });
    taskSetting.controlEl.appendChild(this.taskInputElement);
    new import_obsidian3.Setting(contentEl).setName("Billable").addToggle((toggle) => toggle.setValue(this.isBillable).onChange((value) => this.isBillable = value));
    new import_obsidian3.Setting(contentEl).setClass("modal-button-container").addButton((button) => button.setButtonText("Start timer").setCta().onClick(() => {
      if (!this.plugin.settings.selectedMemberId) {
        new import_obsidian3.Notice("Error: Member ID not set. Please re-select organization in settings.");
        return;
      }
      this.startTimer();
      this.close();
    }));
  }
  startTimer() {
    var _a, _b;
    this.plugin.startTimer({
      description: this.description || null,
      // Ensure null if empty
      projectId: ((_a = this.selectedProject) == null ? void 0 : _a.id) || null,
      taskId: ((_b = this.selectedTask) == null ? void 0 : _b.id) || null,
      tagIds: this.selectedTags.map((t) => t.id),
      // Use selected tag IDs
      billable: this.isBillable
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/view.ts
var import_obsidian4 = require("obsidian");
var SOLIDTIME_VIEW_TYPE = "solidtime-timer-view";
var SolidTimeView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.durationIntervalId = null;
    this.isEditing = false;
    // Elements
    this.descriptionEl = null;
    this.projectEl = null;
    this.projectColorEl = null;
    this.projectNameEl = null;
    // Need specific ref for project name
    this.tagIconEl = null;
    this.billableIconEl = null;
    this.durationEl = null;
    this.playStopButtonEl = null;
    // Keep ref for button state
    // states for idle configuration
    this.pendingDescription = null;
    this.pendingProject = null;
    this.plugin = plugin;
    this.icon = "clock";
  }
  getViewType() {
    return SOLIDTIME_VIEW_TYPE;
  }
  getDisplayText() {
    return "SolidTime tracker";
  }
  getIcon() {
    return "clock";
  }
  async onOpen() {
    this.isEditing = false;
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("solidtime-view-container");
    this.renderViewContent(container);
  }
  async onClose() {
    this.clearDurationInterval();
    this.isEditing = false;
  }
  // Main function to build/update the view content
  renderViewContent(containerEl) {
    var _a, _b;
    if (this.isEditing) {
      return;
    }
    containerEl.empty();
    const timerRunning = !!this.plugin.activeTimeEntry;
    const entry = this.plugin.activeTimeEntry;
    const currentDesc = timerRunning ? entry == null ? void 0 : entry.description : this.pendingDescription;
    this.descriptionEl = containerEl.createEl("div", {
      // Show pending description or placeholder when idle
      text: currentDesc || (timerRunning ? "(No description)" : "(Click to set description)"),
      // Correct idle placeholder
      cls: "solidtime-view-description"
    });
    this.descriptionEl.setAttribute("title", currentDesc || "Click to edit/set description");
    this.descriptionEl.onclick = () => {
      this.editDescription();
    };
    const detailsRow = containerEl.createEl("div", { cls: "solidtime-view-details-row" });
    this.projectEl = detailsRow.createEl("div", { cls: "solidtime-view-project" });
    this.projectColorEl = this.projectEl.createEl("span", { cls: "solidtime-view-project-color" });
    this.projectNameEl = this.projectEl.createEl("span", { cls: "solidtime-view-project-name" });
    const displayProject = timerRunning ? (entry == null ? void 0 : entry.project_id) ? this.plugin.projects.find((p) => p.id === entry.project_id) : null : this.pendingProject;
    const displayProjectId = timerRunning ? entry == null ? void 0 : entry.project_id : (_a = this.pendingProject) == null ? void 0 : _a.id;
    if (displayProject == null ? void 0 : displayProject.color) {
      this.projectColorEl.style.setProperty("--project-color", displayProject.color);
    } else {
      this.projectColorEl.style.removeProperty("--project-color");
    }
    if (displayProject) {
      this.projectNameEl.setText(displayProject.name);
    } else if (displayProjectId) {
      this.projectNameEl.setText(`(ID: ...${displayProjectId.slice(-4)})`);
    } else {
      this.projectNameEl.setText("(Click to select project)");
    }
    this.projectEl.onclick = () => {
      this.selectProject();
    };
    const iconsContainer = detailsRow.createEl("div", { cls: "solidtime-view-icons" });
    this.tagIconEl = iconsContainer.createEl("span", { cls: "solidtime-view-icon" });
    (0, import_obsidian4.setIcon)(this.tagIconEl, "tag");
    const hasTags = timerRunning && !!((entry == null ? void 0 : entry.tags) && entry.tags.length > 0);
    this.tagIconEl.toggleClass("tag-active", hasTags);
    this.tagIconEl.setAttribute("title", `Tags: ${timerRunning ? ((_b = entry == null ? void 0 : entry.tags) == null ? void 0 : _b.length) || 0 : "N/A"}${timerRunning ? ". Click to edit." : ""}`);
    this.tagIconEl.toggleClass("is-interactive", timerRunning);
    this.tagIconEl.onclick = () => {
      if (!timerRunning) return;
      this.selectTags();
    };
    this.billableIconEl = iconsContainer.createEl("span", { cls: "solidtime-view-icon" });
    (0, import_obsidian4.setIcon)(this.billableIconEl, "dollar-sign");
    const isBillable = timerRunning && !!(entry == null ? void 0 : entry.billable);
    this.billableIconEl.toggleClass("billable-active", isBillable);
    this.billableIconEl.setAttribute("title", `Billable: ${timerRunning ? isBillable ? "Yes" : "No" : "N/A"}${timerRunning ? ". Click to toggle." : ""}`);
    this.billableIconEl.toggleClass("is-interactive", timerRunning);
    this.billableIconEl.onclick = () => {
      if (!timerRunning) return;
      this.plugin.updateActiveTimerDetails({ billable: !isBillable });
    };
    const controlsRow = containerEl.createEl("div", { cls: "solidtime-view-controls-row" });
    this.playStopButtonEl = controlsRow.createEl("div", { cls: "solidtime-view-button-container" });
    const button = this.playStopButtonEl.createEl("button", { cls: "solidtime-view-button" });
    this.durationEl = controlsRow.createEl("div", { text: timerRunning ? "00:00:00" : "--:--:--", cls: "solidtime-view-duration" });
    if (timerRunning && (entry == null ? void 0 : entry.start)) {
      (0, import_obsidian4.setIcon)(button, "square");
      button.addClass("stop");
      button.setAttribute("aria-label", "Stop timer");
      button.onclick = () => {
        this.plugin.stopCurrentTimer();
      };
      this.updateDuration();
      this.startDurationInterval();
    } else {
      (0, import_obsidian4.setIcon)(button, "play");
      button.addClass("start");
      button.setAttribute("aria-label", "Start timer with current details");
      button.onclick = () => {
        var _a2;
        if (!this.pendingDescription) {
          new import_obsidian4.Notice("Please enter a description before starting the timer.");
          if (this.descriptionEl) this.editDescription();
          return;
        }
        this.plugin.startTimer({
          description: this.pendingDescription,
          // Now guaranteed to be non-null
          projectId: ((_a2 = this.pendingProject) == null ? void 0 : _a2.id) || null,
          taskId: null,
          tagIds: [],
          billable: this.plugin.settings.defaultBillable
        });
        this.pendingDescription = null;
        this.pendingProject = null;
      };
      this.clearDurationInterval();
    }
  }
  editDescription() {
    var _a;
    if (this.isEditing) return;
    this.isEditing = true;
    const timerRunning = !!this.plugin.activeTimeEntry;
    if (!this.descriptionEl) {
      this.isEditing = false;
      return;
    }
    const currentDescription = (timerRunning ? (_a = this.plugin.activeTimeEntry) == null ? void 0 : _a.description : this.pendingDescription) || "";
    const input = createEl("input", { type: "text", value: currentDescription, cls: "solidtime-view-description-input" });
    this.descriptionEl.replaceWith(input);
    input.focus();
    input.select();
    const finishEdit = (saveChanges) => {
      var _a2;
      this.isEditing = false;
      let newDescription = currentDescription;
      if (saveChanges) {
        newDescription = input.value.trim() || null;
      }
      if (input.parentNode) {
        input.replaceWith(this.descriptionEl);
      } else if (!((_a2 = this.descriptionEl) == null ? void 0 : _a2.parentNode)) {
        console.warn("Input and description div detached during edit finish.");
        this.plugin.updateSolidTimeView();
        return;
      }
      const finalText = newDescription || (timerRunning ? "(No description)" : "(Click to set description)");
      this.descriptionEl.setText(finalText);
      this.descriptionEl.setAttribute("title", newDescription || "Click to edit/set description");
      if (saveChanges && newDescription !== currentDescription) {
        if (timerRunning) {
          this.plugin.updateActiveTimerDetails({ description: newDescription });
        } else {
          this.pendingDescription = newDescription;
        }
      }
    };
    input.addEventListener("blur", () => finishEdit(true));
    input.addEventListener("keydown", (evt) => {
      if (evt.key === "Enter") {
        finishEdit(true);
        evt.preventDefault();
      } else if (evt.key === "Escape") {
        finishEdit(false);
      }
    });
  }
  selectProject() {
    const timerRunning = !!this.plugin.activeTimeEntry;
    new ProjectSuggestModal(this.app, this.plugin.projects, (selectedProject) => {
      var _a, _b, _c, _d, _e;
      const currentProjectId = (timerRunning ? (_a = this.plugin.activeTimeEntry) == null ? void 0 : _a.project_id : (_b = this.pendingProject) == null ? void 0 : _b.id) || null;
      const newProjectId = (selectedProject == null ? void 0 : selectedProject.id) || null;
      if (currentProjectId !== newProjectId) {
        if (timerRunning) {
          this.plugin.updateActiveTimerDetails({ projectId: newProjectId });
        } else {
          this.pendingProject = selectedProject;
          (_c = this.projectNameEl) == null ? void 0 : _c.setText((selectedProject == null ? void 0 : selectedProject.name) || "(Click to select project)");
          if (selectedProject == null ? void 0 : selectedProject.color) {
            (_d = this.projectColorEl) == null ? void 0 : _d.style.setProperty("--project-color", selectedProject.color);
          } else {
            (_e = this.projectColorEl) == null ? void 0 : _e.style.removeProperty("--project-color");
          }
        }
      }
    }).open();
  }
  // --- Select Tags Logic ---
  selectTags() {
    if (!this.plugin.activeTimeEntry) return;
    const currentTagIds = this.plugin.activeTimeEntry.tags || [];
    new TagSelectionModal(this.app, this.plugin, currentTagIds, (newSelectedIds) => {
      const changed = currentTagIds.length !== newSelectedIds.length || !currentTagIds.every((id) => newSelectedIds.includes(id));
      if (changed) {
        this.plugin.updateActiveTimerDetails({ tagIds: newSelectedIds });
      } else {
      }
    }).open();
  }
  clearDurationInterval() {
    if (this.durationIntervalId !== null) {
      window.clearInterval(this.durationIntervalId);
      this.durationIntervalId = null;
    }
  }
  startDurationInterval() {
    this.clearDurationInterval();
    if (this.plugin.activeTimeEntry) {
      this.durationIntervalId = window.setInterval(() => {
        this.updateDuration();
      }, 1e3);
    }
  }
  updateDuration() {
    if (!this.plugin.activeTimeEntry || !this.plugin.activeTimeEntry.start || !this.durationEl) {
      this.clearDurationInterval();
      if (this.durationEl) this.durationEl.setText("--:--:--");
      return;
    }
    const startDateTime = import_obsidian4.moment.utc(this.plugin.activeTimeEntry.start);
    if (!startDateTime.isValid) {
      this.durationEl.setText("Invalid start");
      this.clearDurationInterval();
      return;
    }
    const nowDateTime = import_obsidian4.moment.utc();
    const duration = nowDateTime.diff(startDateTime);
    this.durationEl.setText(this.plugin.formatDuration(duration));
  }
  // Method called by the plugin to trigger a full refresh
  updateView() {
    if (this.containerEl.children[1]) {
      this.renderViewContent(this.containerEl.children[1]);
    }
  }
};

// main.ts
var SolidTimePlugin = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.api = null;
    this.statusBarItemEl = null;
    this.activeTimeEntry = null;
    this.statusIntervalId = null;
    this.fetchIntervalId = null;
    // Data caches
    this.projects = [];
    this.tasks = [];
    this.tags = [];
    this.currentUser = null;
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      SOLIDTIME_VIEW_TYPE,
      (leaf) => new SolidTimeView(leaf, this)
    );
    this.statusBarItemEl = this.addStatusBarItem();
    this.statusBarItemEl.setText("SolidTime: Init...");
    this.statusBarItemEl.addClass("solidtime-statusbar");
    this.addSettingTab(new SolidTimeSettingTab(this.app, this));
    this.setupApi();
    if (this.api) {
      try {
        this.currentUser = await this.api.getMe();
      } catch (e) {
        console.error("SolidTime: Failed to fetch current user on load", e);
        if (this.settings.apiKey && this.settings.apiBaseUrl) {
          new import_obsidian5.Notice("SolidTime: Could not verify user. Check API key/URL.");
        }
      }
    }
    if (this.checkSettingsAndApi(false)) {
      await this.loadSolidTimeData();
      await this.updateStatus();
      this.setupIntervals();
    } else {
      this.statusBarItemEl.setText("SolidTime: Check Settings");
      if (!this.settings.apiKey || !this.settings.apiBaseUrl) {
      } else if (!this.settings.selectedOrganizationId) {
      } else if (!this.currentUser && this.settings.apiKey && this.settings.apiBaseUrl) {
        new import_obsidian5.Notice("SolidTime Plugin: Could not fetch user data. Check connection or API key.");
      }
    }
    this.addCommand({
      id: "start-timer",
      name: "Start timer (prompt)",
      callback: () => {
        if (!this.checkSettingsAndApi()) return;
        new StartTimerModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "stop-timer",
      name: "Stop current timer",
      callback: () => {
        this.stopCurrentTimer();
      }
    });
    this.addCommand({
      id: "show-current-timer",
      name: "Show current timer details",
      callback: () => {
        if (!this.api) {
          new import_obsidian5.Notice("SolidTime: API not configured.");
          return;
        }
        this.showCurrentTimerDetails();
      }
    });
    this.addCommand({
      id: "refresh-data",
      name: "Refresh projects/tasks/tags",
      callback: async () => {
        if (!this.api || !this.settings.selectedOrganizationId) {
          new import_obsidian5.Notice("SolidTime: Configure API and select Organization first.");
          return;
        }
        await this.loadSolidTimeData();
        new import_obsidian5.Notice("SolidTime data refreshed.");
      }
    });
    this.addCommand({
      id: "refresh-user",
      name: "Refresh user info",
      callback: async () => {
        var _a;
        if (!this.api) {
          new import_obsidian5.Notice("SolidTime: API not configured.");
          return;
        }
        try {
          this.currentUser = await this.api.getMe();
          new import_obsidian5.Notice(`SolidTime: User info refreshed (${(_a = this.currentUser) == null ? void 0 : _a.name}).`);
        } catch (e) {
          console.error("SolidTime: Failed to refresh user info", e);
          new import_obsidian5.Notice("SolidTime: Failed to refresh user info.");
        }
      }
    });
    this.addCommand({
      id: "show-view",
      name: "Show tracker view",
      callback: () => {
        this.activateView();
      }
    });
    this.addRibbonIcon("clock", "Open SolidTime tracker", () => {
      this.activateView();
    });
    console.log("SolidTime Plugin Loaded");
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(SOLIDTIME_VIEW_TYPE);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      leaf = workspace.getRightLeaf(false);
      if (!leaf) {
        console.error("SolidTime: Could not get right leaf for the view.");
        return;
      }
      await leaf.setViewState({ type: SOLIDTIME_VIEW_TYPE, active: true });
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
  updateSolidTimeView() {
    const leaves = this.app.workspace.getLeavesOfType(SOLIDTIME_VIEW_TYPE);
    for (const leaf of leaves) {
      if (leaf.view instanceof SolidTimeView) {
        leaf.view.updateView();
      }
    }
  }
  onunload() {
    this.clearTimers();
    if (this.statusBarItemEl) {
      this.statusBarItemEl.remove();
    }
    console.log("SolidTime Plugin Unloaded");
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    const previousApi = this.api;
    this.setupApi();
    if (this.api && (!previousApi || !this.currentUser)) {
      try {
        this.currentUser = await this.api.getMe();
      } catch (e) {
        console.error("SolidTime: Failed to fetch current user after settings save", e);
        this.currentUser = null;
        new import_obsidian5.Notice("SolidTime: Could not verify user with new settings.");
      }
    } else if (!this.api) {
      this.currentUser = null;
    }
    if (this.api && this.settings.selectedOrganizationId) {
      await this.loadSolidTimeData();
      await this.updateStatus();
      this.setupIntervals();
    } else {
      this.clearTimers();
      this.activeTimeEntry = null;
      if (this.statusBarItemEl) {
        this.statusBarItemEl.setText("SolidTime: Check settings");
        this.statusBarItemEl.removeClass("solidtime-active");
        this.statusBarItemEl.removeAttribute("title");
      }
      this.projects = [];
      this.tasks = [];
      this.tags = [];
      this.updateSolidTimeView();
    }
  }
  setupApi() {
    if (this.settings.apiKey && this.settings.apiBaseUrl) {
      if (!this.api || this.api["apiKey"] !== this.settings.apiKey || this.api["baseUrl"] !== this.settings.apiBaseUrl) {
        this.api = new SolidTimeApi(this.settings.apiKey, this.settings.apiBaseUrl);
      }
    } else {
      this.api = null;
    }
  }
  checkSettingsAndApi(showNotice = true) {
    let valid = true;
    let message = "";
    if (!this.settings.apiKey || !this.settings.apiBaseUrl) {
      message = "SolidTime API Key or Base URL not set.";
      valid = false;
    } else if (!this.settings.selectedOrganizationId) {
      message = "SolidTime organization not selected.";
      valid = false;
    } else if (!this.api) {
      message = "SolidTime API client not initialized.";
      this.setupApi();
      if (!this.api) valid = false;
    }
    if (!valid && showNotice) {
      new import_obsidian5.Notice(message + " Please configure in plugin settings.");
    }
    return valid;
  }
  clearTimers() {
    if (this.statusIntervalId) {
      window.clearInterval(this.statusIntervalId);
      this.statusIntervalId = null;
    }
    if (this.fetchIntervalId) {
      window.clearInterval(this.fetchIntervalId);
      this.fetchIntervalId = null;
    }
  }
  setupIntervals() {
    this.clearTimers();
    if (this.settings.statusBarUpdateIntervalSeconds > 0 && this.api) {
      this.statusIntervalId = window.setInterval(() => this.updateStatus(), this.settings.statusBarUpdateIntervalSeconds * 1e3);
    }
    if (this.settings.autoFetchIntervalMinutes > 0 && this.api && this.settings.selectedOrganizationId) {
      this.fetchIntervalId = window.setInterval(() => this.loadSolidTimeData(), this.settings.autoFetchIntervalMinutes * 60 * 1e3);
    }
  }
  async loadSolidTimeData() {
    if (!this.api || !this.settings.selectedOrganizationId) {
      this.projects = [];
      this.tasks = [];
      this.tags = [];
      return;
    }
    try {
      const [projects, tasks, tags] = await Promise.all([
        this.api.getProjects(this.settings.selectedOrganizationId),
        this.api.getTasks(this.settings.selectedOrganizationId),
        this.api.getTags(this.settings.selectedOrganizationId)
      ]);
      this.projects = projects || [];
      this.tasks = tasks || [];
      this.tags = tags || [];
    } catch (error) {
      console.error("SolidTime: Failed to fetch data", error);
      this.projects = [];
      this.tasks = [];
      this.tags = [];
    }
  }
  async updateActiveTimerDetails(updates) {
    if (!this.api) {
      new import_obsidian5.Notice("SolidTime: API not configured.");
      return;
    }
    if (!this.currentUser) {
      try {
        this.currentUser = await this.api.getMe();
      } catch (e) {
        new import_obsidian5.Notice("Error: Could not verify current user.");
        return;
      }
    }
    if (!this.activeTimeEntry) {
      new import_obsidian5.Notice("SolidTime: No timer is running to update.");
      return;
    }
    if (!this.activeTimeEntry.organization_id || !this.activeTimeEntry.start) {
      new import_obsidian5.Notice("Error: Active entry data incomplete.");
      return;
    }
    const entryToUpdate = this.activeTimeEntry;
    const orgIdForEntry = entryToUpdate.organization_id;
    let correctMemberId = null;
    try {
      const members = await this.api.getMembers(orgIdForEntry);
      const currentMembership = members.find((member) => member.user_id === this.currentUser.id);
      if (currentMembership) {
        correctMemberId = currentMembership.id;
      } else {
        new import_obsidian5.Notice(`Error: User not found in org ${orgIdForEntry}.`);
        return;
      }
    } catch (error) {
      new import_obsidian5.Notice("Error fetching members.");
      return;
    }
    if (!correctMemberId) {
      new import_obsidian5.Notice("Error determining Member ID.");
      return;
    }
    const payloadToSend = {
      member_id: correctMemberId,
      // start: entryToUpdate.start, // NO START
      // end: null,                 // NO END
      billable: "billable" in updates ? updates.billable : entryToUpdate.billable,
      project_id: "projectId" in updates ? updates.projectId : entryToUpdate.project_id,
      task_id: "taskId" in updates ? updates.taskId : entryToUpdate.task_id,
      // Keep task if available
      description: "description" in updates ? updates.description : entryToUpdate.description,
      tags: "tagIds" in updates ? updates.tagIds : entryToUpdate.tags
    };
    try {
      new import_obsidian5.Notice("SolidTime: Updating timer...");
      const updatedEntry = await this.api.stopTimeEntry(orgIdForEntry, entryToUpdate.id, payloadToSend);
      this.activeTimeEntry = updatedEntry;
      this.renderStatusBar();
      this.updateSolidTimeView();
      new import_obsidian5.Notice("SolidTime: Timer updated!");
    } catch (error) {
      console.error("SolidTime: Failed to update timer", error);
      new import_obsidian5.Notice("SolidTime: Failed to update timer. Check console.");
      await this.updateStatus();
    }
  }
  async createTag(tagName) {
    if (!this.checkSettingsAndApi()) return null;
    if (!this.settings.selectedOrganizationId) {
      new import_obsidian5.Notice("No organization selected in settings.");
      return null;
    }
    try {
      const newTag = await this.api.createTag(this.settings.selectedOrganizationId, tagName);
      this.tags.push(newTag);
      this.tags.sort((a, b) => a.name.localeCompare(b.name));
      return newTag;
    } catch (error) {
      console.error("Plugin: Failed to create tag via API", error);
      return null;
    }
  }
  async updateStatus() {
    if (!this.api) {
      if (this.statusBarItemEl && this.statusBarItemEl.getText().startsWith("\u23F1\uFE0F")) {
        this.statusBarItemEl.setText("SolidTime: Check Settings");
        this.statusBarItemEl.removeClass("solidtime-active");
        this.statusBarItemEl.removeAttribute("title");
      }
      this.activeTimeEntry = null;
      return;
    }
    try {
      this.activeTimeEntry = await this.api.getActiveTimeEntry();
      this.renderStatusBar();
      this.updateSolidTimeView();
    } catch (error) {
      console.error("SolidTime: Failed to update status", error);
      if (this.statusBarItemEl) {
        if (error instanceof Error && (error.message.includes("401") || error.message.includes("403"))) {
          this.statusBarItemEl.setText("SolidTime: Auth Error");
          new import_obsidian5.Notice("SolidTime: Authentication error fetching status. Check API Key.");
        } else {
          this.statusBarItemEl.setText("SolidTime: Error");
        }
        this.statusBarItemEl.removeClass("solidtime-active");
        this.statusBarItemEl.removeAttribute("title");
      }
      this.activeTimeEntry = null;
      this.updateSolidTimeView();
    }
  }
  renderStatusBar() {
    var _a;
    if (!this.statusBarItemEl) return;
    if (this.activeTimeEntry && this.activeTimeEntry.start) {
      const startDateTime = import_obsidian5.moment.utc(this.activeTimeEntry.start);
      if (!startDateTime.isValid) {
        console.error("SolidTime: Failed to parse start time for status bar:", this.activeTimeEntry.start);
        this.statusBarItemEl.setText("SolidTime: Invalid date");
        this.statusBarItemEl.removeClass("solidtime-active");
        this.statusBarItemEl.removeAttribute("title");
        return;
      }
      const nowDateTime = import_obsidian5.moment.utc();
      const duration = nowDateTime.diff(startDateTime);
      const formattedDuration = this.formatDuration(duration);
      let display = `\u{1F7E2} ${formattedDuration}`;
      const project = this.projects.find((p) => {
        var _a2;
        return p.id === ((_a2 = this.activeTimeEntry) == null ? void 0 : _a2.project_id);
      });
      if (project) {
        display += ` | ${project.name}`;
      } else if (this.activeTimeEntry.project_id) {
        display += ` | (Project?)`;
      }
      if (this.activeTimeEntry.description) {
        const desc = this.activeTimeEntry.description.length > 20 ? this.activeTimeEntry.description.substring(0, 18) + "..." : this.activeTimeEntry.description;
        display += ` - ${desc}`;
      }
      this.statusBarItemEl.setText(display);
      this.statusBarItemEl.addClass("solidtime-active");
      const tooltipProjectName = (project == null ? void 0 : project.name) || `(ID: ...${((_a = this.activeTimeEntry.project_id) == null ? void 0 : _a.slice(-6)) || "None"})`;
      const localStartTime = startDateTime.local().format("YYYY-MM-DD HH:mm");
      this.statusBarItemEl.setAttribute("title", `SolidTime Timer
Description: ${this.activeTimeEntry.description || "(None)"}
Project: ${tooltipProjectName}
Started: ${localStartTime}`);
    } else {
      if (this.api && this.settings.selectedOrganizationId) {
        this.statusBarItemEl.setText("SolidTime");
      } else {
        this.statusBarItemEl.setText("SolidTime: Setup needed");
      }
      this.statusBarItemEl.removeClass("solidtime-active");
      this.statusBarItemEl.removeAttribute("title");
    }
  }
  formatDuration(durationMs) {
    if (isNaN(durationMs) || durationMs < 0) {
      return "00:00:00";
    }
    const momentDuration = import_obsidian5.moment.duration(durationMs);
    const hours = String(Math.floor(momentDuration.asHours())).padStart(2, "0");
    const minutes = String(momentDuration.minutes()).padStart(2, "0");
    const seconds = String(momentDuration.seconds()).padStart(2, "0");
    return `${hours}:${minutes}:${seconds}`;
  }
  async startTimer(options) {
    if (!this.checkSettingsAndApi()) return;
    if (!this.settings.selectedMemberId) {
      new import_obsidian5.Notice("Error: Member ID missing. Please re-select organization in settings.");
      return;
    }
    if (this.activeTimeEntry) {
      new import_obsidian5.Notice("SolidTime: Please stop the current timer first.");
      return;
    }
    const start = import_obsidian5.moment.utc().format("YYYY-MM-DDTHH:mm:ss") + "Z";
    const payload = {
      member_id: this.settings.selectedMemberId,
      start,
      billable: options.billable,
      project_id: options.projectId,
      task_id: options.taskId,
      description: options.description,
      tags: options.tagIds.length > 0 ? options.tagIds : null
    };
    try {
      new import_obsidian5.Notice("SolidTime: Starting timer...");
      const newEntry = await this.api.startTimeEntry(this.settings.selectedOrganizationId, payload);
      this.activeTimeEntry = newEntry;
      this.renderStatusBar();
      this.updateSolidTimeView();
      new import_obsidian5.Notice("SolidTime: Timer started!");
    } catch (error) {
      console.error("SolidTime: Failed to start timer", error);
    }
  }
  async stopCurrentTimer() {
    if (!this.api) {
      new import_obsidian5.Notice("SolidTime: API not configured.");
      return;
    }
    if (!this.currentUser) {
      try {
        this.currentUser = await this.api.getMe();
      } catch (e) {
        console.error("SolidTime: Failed to get current user", e);
        new import_obsidian5.Notice("Error: Could not verify current user. Cannot stop timer.");
        return;
      }
    }
    if (!this.activeTimeEntry) {
      new import_obsidian5.Notice("SolidTime: No timer is currently running.");
      return;
    }
    if (!this.activeTimeEntry.organization_id || !this.activeTimeEntry.start) {
      console.error("SolidTime: Active time entry is missing required data (org_id or start)!", this.activeTimeEntry);
      new import_obsidian5.Notice("Error: Cannot stop timer, active entry data is incomplete. Please refresh.", 5e3);
      await this.updateStatus();
      return;
    }
    const entryToStop = this.activeTimeEntry;
    const orgIdForEntry = entryToStop.organization_id;
    const end = import_obsidian5.moment.utc().format("YYYY-MM-DDTHH:mm:ss") + "Z";
    let correctMemberId = null;
    try {
      const members = await this.api.getMembers(orgIdForEntry);
      const currentMembership = members.find((member) => member.user_id === this.currentUser.id);
      if (currentMembership) {
        correctMemberId = currentMembership.id;
      } else {
        console.error(`SolidTime: Could not find membership for user ${this.currentUser.id} in organization ${orgIdForEntry}.`);
        new import_obsidian5.Notice(`Error: Your user was not found in the timer's organization (${orgIdForEntry}). Cannot stop timer.`);
      }
    } catch (error) {
      console.error(`SolidTime: Failed to fetch members for organization ${orgIdForEntry}`, error);
      new import_obsidian5.Notice("Error: Failed to fetch organization members. Cannot stop timer.");
      return;
    }
    if (!correctMemberId) {
      new import_obsidian5.Notice("Error: Could not determine correct Member ID. Cannot stop timer.");
      return;
    }
    const payloadToSend = {
      member_id: correctMemberId,
      // start: entryToStop.start, // REMOVED 'start' field
      end,
      billable: entryToStop.billable,
      project_id: entryToStop.project_id,
      task_id: entryToStop.task_id,
      description: entryToStop.description,
      tags: entryToStop.tags
    };
    try {
      new import_obsidian5.Notice("SolidTime: Stopping timer...");
      this.activeTimeEntry = null;
      this.renderStatusBar();
      this.updateSolidTimeView();
      await this.api.stopTimeEntry(orgIdForEntry, entryToStop.id, payloadToSend);
      new import_obsidian5.Notice("SolidTime: Timer stopped!");
    } catch (error) {
      console.error("SolidTime: Failed to stop timer", error);
      await this.updateStatus();
      new import_obsidian5.Notice("SolidTime: Failed to stop timer. Status refreshed.");
    }
  }
  // --- End stopCurrentTimer ---
  showCurrentTimerDetails() {
    var _a;
    if (!this.api) {
      new import_obsidian5.Notice("SolidTime: Plugin not configured correctly.");
      return;
    }
    if (!this.activeTimeEntry || !this.activeTimeEntry.start) {
      new import_obsidian5.Notice("SolidTime: No timer is currently running or start time is missing.");
      return;
    }
    const startDateTime = import_obsidian5.moment.utc(this.activeTimeEntry.start);
    if (!startDateTime.isValid) {
      console.error("SolidTime: Failed to parse start time for details:", this.activeTimeEntry.start);
      new import_obsidian5.Notice("SolidTime: Cannot display details, invalid start time data.");
      return;
    }
    const nowDateTime = import_obsidian5.moment.utc();
    const duration = nowDateTime.diff(startDateTime);
    const formattedDuration = this.formatDuration(duration);
    const localStartTime = startDateTime.local().format("YYYY-MM-DD HH:mm:ss");
    let project = this.projects.find((p) => {
      var _a2;
      return p.id === ((_a2 = this.activeTimeEntry) == null ? void 0 : _a2.project_id);
    });
    let task = this.tasks.find((t) => {
      var _a2;
      return t.id === ((_a2 = this.activeTimeEntry) == null ? void 0 : _a2.task_id);
    });
    const activeTags = this.tags.filter((t) => {
      var _a2, _b;
      return (_b = (_a2 = this.activeTimeEntry) == null ? void 0 : _a2.tags) == null ? void 0 : _b.includes(t.id);
    });
    let details = `**SolidTime Timer**
`;
    details += `- Duration: ${formattedDuration}
`;
    if (project) {
      details += `- Project: ${project.name}
`;
    } else if (this.activeTimeEntry.project_id) {
      details += `- Project: (ID: ...${this.activeTimeEntry.project_id.slice(-6)})
`;
    }
    if (task) {
      details += `- Task: ${task.name}
`;
    } else if (this.activeTimeEntry.task_id) {
      details += `- Task: (ID: ...${this.activeTimeEntry.task_id.slice(-6)})
`;
    }
    if (this.activeTimeEntry.description) {
      details += `- Description: ${this.activeTimeEntry.description}
`;
    }
    if (activeTags.length > 0) {
      details += `- Tags: ${activeTags.map((t) => t.name).join(", ")}
`;
    } else if (((_a = this.activeTimeEntry.tags) == null ? void 0 : _a.length) > 0) {
      details += `- Tags: (IDs present, not cached)
`;
    }
    details += `- Billable: ${this.activeTimeEntry.billable ? "Yes" : "No"}
`;
    details += `- Started: ${localStartTime}
`;
    details += `- Org ID: ...${this.activeTimeEntry.organization_id.slice(-6)}`;
    new import_obsidian5.Notice(details.replace(/\n/g, "<br/>"), 15e3);
  }
  showStartTimerModal() {
    if (!this.checkSettingsAndApi()) return;
    if (this.projects.length === 0 && this.tags.length === 0 && this.tasks.length === 0) {
      console.log("SolidTime: Data might not be loaded yet for modal.");
      new import_obsidian5.Notice("Fetching SolidTime data... Please try again shortly.");
      this.loadSolidTimeData();
      return;
    }
    new StartTimerModal(this.app, this).open();
  }
};

/* nosourcemap */