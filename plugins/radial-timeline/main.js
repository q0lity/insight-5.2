/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/regex.ts
function escapeRegExp(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
var init_regex = __esm({
  "src/utils/regex.ts"() {
  }
});

// src/utils/rangeValidation.ts
function parseRange(rangeStr) {
  if (!rangeStr || typeof rangeStr !== "string") return null;
  const cleaned = rangeStr.trim();
  if (/^\d+$/.test(cleaned)) {
    const value = parseInt(cleaned, 10);
    if (!isNaN(value) && value >= 0 && value <= 100) {
      return { min: value, max: value };
    }
    return null;
  }
  const match = cleaned.match(/^(\d+)\s*-\s*(\d+)$/);
  if (match) {
    const min = parseInt(match[1], 10);
    const max = parseInt(match[2], 10);
    if (!isNaN(min) && !isNaN(max) && min >= 0 && max <= 100 && min <= max) {
      return { min, max };
    }
  }
  return null;
}
function isScoreInRange(score, range) {
  return score >= range.min && score <= range.max;
}
var init_rangeValidation = __esm({
  "src/utils/rangeValidation.ts"() {
  }
});

// src/utils/gossamer.ts
var gossamer_exports = {};
__export(gossamer_exports, {
  DefaultGossamerMomentum: () => DefaultGossamerMomentum,
  appendGossamerScore: () => appendGossamerScore,
  buildAllGossamerRuns: () => buildAllGossamerRuns,
  buildRunFromDefault: () => buildRunFromDefault,
  buildRunFromGossamerField: () => buildRunFromGossamerField,
  detectPlotSystem: () => detectPlotSystem,
  extractBeatOrder: () => extractBeatOrder,
  extractPresentBeatScores: () => extractPresentBeatScores,
  filterBeatsBySystem: () => filterBeatsBySystem,
  normalizeBeatName: () => normalizeBeatName,
  shiftGossamerHistory: () => shiftGossamerHistory,
  zeroOffsetRun: () => zeroOffsetRun
});
function filterBeatsBySystem(beats, selectedBeatSystem) {
  if (!selectedBeatSystem || selectedBeatSystem.trim() === "") {
    return beats;
  }
  if (selectedBeatSystem === "Custom") {
    const builtInSystems = ["save the cat", "savethecat", "hero's journey", "herosjourney", "story grid", "storygrid"];
    return beats.filter((b) => {
      const beatModel = b["Beat Model"];
      if (!beatModel || typeof beatModel !== "string") return true;
      const normalizedModel = beatModel.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
      return !builtInSystems.includes(normalizedModel);
    });
  } else {
    const normalizedSelected = selectedBeatSystem.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
    return beats.filter((b) => {
      const beatModel = b["Beat Model"];
      if (!beatModel || typeof beatModel !== "string") return false;
      const normalizedModel = beatModel.toLowerCase().replace(/\s+/g, "").replace(/'/g, "");
      return normalizedModel === normalizedSelected;
    });
  }
}
function normalizeBeatName(name) {
  return (name || "").replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").trim().toLowerCase().replace(/[-\s]/g, "");
}
function buildRunFromGossamerField(scenes, fieldName, selectedBeatModel, includeZeroScores = true) {
  let beats;
  if (!scenes || scenes.length === 0) {
    return {
      beats: [],
      overall: {
        summary: "No scenes provided.",
        refinements: [],
        incompleteBeats: []
      },
      meta: { label: fieldName, date: (/* @__PURE__ */ new Date()).toISOString() }
    };
  }
  let plotNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (selectedBeatModel && selectedBeatModel.trim() !== "" && plotNotes.some((p) => p["Beat Model"])) {
    plotNotes = filterBeatsBySystem(plotNotes, selectedBeatModel);
  }
  if (plotNotes.length === 0) {
    return {
      beats: [],
      overall: {
        summary: selectedBeatModel ? `No Beat notes found with Beat Model: ${selectedBeatModel}` : "No Beat notes found. Create notes with Class: Beat.",
        refinements: [],
        incompleteBeats: []
      },
      meta: { label: fieldName, date: (/* @__PURE__ */ new Date()).toISOString() }
    };
  }
  plotNotes.sort((a, b) => {
    const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
    const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
    const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
    const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
    return aNum - bNum;
  });
  const incompleteBeats = [];
  beats = plotNotes.map((plotNote) => {
    const beatTitle = (plotNote.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
    let parsedScore = void 0;
    const fieldValue = plotNote[fieldName];
    if (fieldValue !== void 0 && fieldValue !== null) {
      const raw = fieldValue;
      if (typeof raw === "number") {
        parsedScore = raw;
      } else if (typeof raw === "string") {
        const match = raw.match(/\d+/);
        if (match) {
          const num = parseInt(match[0], 10);
          if (!isNaN(num) && num >= 0 && num <= 100) {
            parsedScore = num;
          }
        }
      }
    }
    let range = void 0;
    let isOutOfRange = false;
    const rangeValue = plotNote.Range;
    if (typeof rangeValue === "string") {
      const parsed = parseRange(rangeValue);
      if (parsed) {
        range = parsed;
        if (parsedScore !== void 0 && fieldName === "Gossamer1") {
          isOutOfRange = !isScoreInRange(parsedScore, range);
        }
      }
    }
    if (parsedScore !== void 0) {
      return {
        beat: beatTitle,
        score: parsedScore,
        notes: `Score from Beat note frontmatter (${fieldName}).`,
        status: "present",
        range,
        isOutOfRange
      };
    } else if (includeZeroScores) {
      incompleteBeats.push(beatTitle);
      return {
        beat: beatTitle,
        score: 0,
        notes: `No ${fieldName} score in frontmatter - defaulting to 0.`,
        status: "outlineOnly",
        range,
        isOutOfRange: false
        // Missing scores aren't counted as out-of-range
      };
    } else {
      return {
        beat: beatTitle,
        score: 0,
        notes: `No ${fieldName} score in frontmatter.`,
        status: "missing"
      };
    }
  }).filter((beat) => beat.status !== "missing");
  const presentCount = beats.filter((b) => b.status === "present").length;
  return {
    beats,
    overall: {
      summary: presentCount > 0 ? `${fieldName} scores loaded from ${presentCount} of ${plotNotes.length} Beat notes.` : `No ${fieldName} scores found in Beat notes.`,
      refinements: [],
      incompleteBeats
    },
    meta: {
      label: fieldName === "Gossamer1" ? "Score" : fieldName,
      date: (/* @__PURE__ */ new Date()).toISOString(),
      model: selectedBeatModel
    }
  };
}
function buildRunFromDefault(scenes, selectedBeatModel) {
  return buildRunFromGossamerField(scenes, "Gossamer1", selectedBeatModel, true);
}
function buildAllGossamerRuns(scenes, selectedBeatModel) {
  if (!scenes || scenes.length === 0) {
    return {
      current: buildRunFromGossamerField(scenes, "Gossamer1", selectedBeatModel, true),
      historical: [],
      minMax: null,
      hasAnyScores: false
    };
  }
  const current = buildRunFromGossamerField(scenes, "Gossamer1", selectedBeatModel, true);
  const historicalColor = "#c0c0c0";
  const historical = [];
  for (let i = 2; i <= 30; i++) {
    const fieldName = `Gossamer${i}`;
    const hasAnyValue = scenes.some((s) => (s.itemType === "Beat" || s.itemType === "Plot") && s[fieldName] !== void 0 && s[fieldName] !== null);
    if (hasAnyValue) {
      const run = buildRunFromGossamerField(scenes, fieldName, selectedBeatModel, true);
      historical.push({
        label: fieldName,
        points: run.beats.map((b) => ({ beat: b.beat, score: b.score })),
        color: historicalColor
      });
    }
  }
  let minMax = null;
  if (historical.length > 0) {
    const allRuns = [current, ...historical.map((h) => ({ beats: h.points.map((p) => ({ ...p, status: "present", notes: "" })) }))];
    const beatNames = current.beats.map((b) => b.beat);
    const minPoints = [];
    const maxPoints = [];
    beatNames.forEach((beatName) => {
      const scores = [];
      const currentBeat = current.beats.find((b) => b.beat === beatName);
      if (currentBeat && (currentBeat.status === "present" || currentBeat.status === "outlineOnly")) {
        scores.push(currentBeat.score);
      }
      historical.forEach((h) => {
        const point = h.points.find((p) => p.beat === beatName);
        if (point) {
          scores.push(point.score);
        }
      });
      if (scores.length >= 1) {
        const min = Math.min(...scores);
        const max = Math.max(...scores);
        minPoints.push({ beat: beatName, score: min });
        maxPoints.push({ beat: beatName, score: max });
      }
    });
    if (minPoints.length >= 3 && maxPoints.length >= 3) {
      minMax = { min: minPoints, max: maxPoints };
    }
  }
  const hasAnyCurrentScores = current.beats.some((b) => b.status === "present" && typeof b.score === "number");
  const hasHistoricalScores = historical.some((run) => run.points.some((point) => typeof point.score === "number" && !Number.isNaN(point.score)));
  const hasAnyScores = hasAnyCurrentScores || hasHistoricalScores;
  return { current, historical, minMax, hasAnyScores };
}
function zeroOffsetRun(run) {
  const firstBeat = run.beats[0];
  const base = typeof (firstBeat == null ? void 0 : firstBeat.score) === "number" ? firstBeat.score : 0;
  return {
    ...run,
    beats: run.beats.map((b) => ({
      ...b,
      score: typeof b.score === "number" ? Math.max(0, b.score - base) : b.score
    }))
  };
}
function extractPresentBeatScores(run) {
  return run.beats.filter((b) => b.status === "present" && typeof b.score === "number").map((b) => ({ beat: b.beat, score: b.score }));
}
function extractBeatOrder(scenes, selectedBeatModel) {
  let plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (selectedBeatModel && selectedBeatModel.trim() !== "" && plotBeats.some((p) => p["Beat Model"])) {
    plotBeats = filterBeatsBySystem(plotBeats, selectedBeatModel);
  }
  plotBeats.sort((a, b) => {
    const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
    const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
    const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
    const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
    return aNum - bNum;
  });
  const beatNames = plotBeats.map((p) => (p.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim()).filter(Boolean);
  return beatNames;
}
function detectPlotSystem(scenes) {
  const plotNote = scenes.find((s) => (s.itemType === "Beat" || s.itemType === "Plot") && s["Beat Model"]);
  if (plotNote && plotNote["Beat Model"]) {
    return plotNote["Beat Model"];
  }
  return "";
}
function shiftGossamerHistory(frontmatter) {
  const maxHistory = 30;
  const updated = { ...frontmatter };
  const existingScores = {};
  const existingJustifications = {};
  for (let i = 1; i <= maxHistory; i++) {
    const scoreKey = `Gossamer${i}`;
    const justKey = `Gossamer${i} Justification`;
    if (typeof updated[scoreKey] === "number") {
      existingScores[i] = updated[scoreKey];
    }
    if (typeof updated[justKey] === "string") {
      existingJustifications[i] = updated[justKey];
    }
  }
  for (let i = 1; i <= maxHistory + 10; i++) {
    delete updated[`Gossamer${i}`];
    delete updated[`Gossamer${i} Justification`];
  }
  Object.entries(existingScores).forEach(([oldIndex, score]) => {
    const newIndex = parseInt(oldIndex) + 1;
    if (newIndex <= maxHistory) {
      updated[`Gossamer${newIndex}`] = score;
    }
  });
  Object.entries(existingJustifications).forEach(([oldIndex, justification]) => {
    const newIndex = parseInt(oldIndex) + 1;
    if (newIndex <= maxHistory) {
      updated[`Gossamer${newIndex} Justification`] = justification;
    }
  });
  return updated;
}
function appendGossamerScore(frontmatter, maxHistory = 30) {
  const updated = { ...frontmatter };
  const hasValue = (value) => {
    if (value === null || value === void 0) return false;
    if (typeof value === "number") return !Number.isNaN(value);
    if (typeof value === "string") return value.trim().length > 0;
    return false;
  };
  for (let i = 1; i <= maxHistory; i++) {
    const key = `Gossamer${i}`;
    if (!hasValue(updated[key])) {
      return { nextIndex: i, updated };
    }
  }
  for (let i = 2; i <= maxHistory; i++) {
    const currentKey = `Gossamer${i}`;
    const previousKey = `Gossamer${i - 1}`;
    const currentJustKey = `Gossamer${i} Justification`;
    const previousJustKey = `Gossamer${i - 1} Justification`;
    if (hasValue(updated[currentKey])) {
      updated[previousKey] = updated[currentKey];
    } else {
      delete updated[previousKey];
    }
    if (hasValue(updated[currentJustKey])) {
      updated[previousJustKey] = updated[currentJustKey];
    } else {
      delete updated[previousJustKey];
    }
  }
  delete updated[`Gossamer${maxHistory}`];
  delete updated[`Gossamer${maxHistory} Justification`];
  return { nextIndex: maxHistory, updated };
}
var DefaultGossamerMomentum;
var init_gossamer = __esm({
  "src/utils/gossamer.ts"() {
    init_rangeValidation();
    DefaultGossamerMomentum = [
      { beat: "Opening Image", score: 4, notes: "Quiet status quo before disturbance." },
      { beat: "Theme Stated", score: 8, notes: "Subtle tension; hints of deeper change." },
      { beat: "Set-Up", score: 14, notes: "World and protagonist established; mild friction." },
      { beat: "Catalyst", score: 26, notes: "Inciting incident jolts the protagonist\u2019s world." },
      { beat: "Debate", score: 22, notes: "Internal conflict; push\u2013pull before commitment." },
      { beat: "Break into Two", score: 35, notes: "Crossing threshold; tension climbs." },
      { beat: "B Story", score: 40, notes: "Secondary stakes introduced; emotional contrast." },
      { beat: "Fun and Games", score: 46, notes: "Momentum holds steady; stakes rising under surface." },
      { beat: "Midpoint", score: 64, notes: "Major reversal or revelation; visible peak forming." },
      { beat: "Bad Guys Close In", score: 72, notes: "Pressure intensifies; opposing forces gather." },
      { beat: "All Is Lost", score: 86, notes: "Crisis hits; near-peak emotional tension." },
      { beat: "Dark Night of the Soul", score: 78, notes: "Momentary drop before regrouping." },
      { beat: "Break into Three", score: 82, notes: "Decision to fight back; new synthesis." },
      { beat: "Finale", score: 94, notes: "Climactic confrontation; maximum momentum." },
      { beat: "Final Image", score: 42, notes: "Resolution; lingering emotional after-echo." }
    ];
  }
});

// src/utils/beatsSystems.ts
function getPlotSystem(name) {
  return PLOT_SYSTEMS[name] || null;
}
var PLOT_SYSTEMS, PLOT_SYSTEM_NAMES;
var init_beatsSystems = __esm({
  "src/utils/beatsSystems.ts"() {
    PLOT_SYSTEMS = {
      "Save The Cat": {
        name: "Save The Cat",
        beatCount: 15,
        beats: [
          "Opening Image",
          "Theme Stated",
          "Setup",
          "Catalyst",
          "Debate",
          "Break into 2",
          "B Story",
          "Fun and Games",
          "Midpoint",
          "Bad Guys Close In",
          "All Is Lost",
          "Dark Night of the Soul",
          "Break into 3",
          "Finale",
          "Final Image"
        ],
        beatDetails: [
          {
            name: "Opening Image",
            description: "The first impression of your story. A snapshot of the protagonist's life before the journey begins. This 'before' picture sets up the world and establishes what will change by the end. Show the protagonist in their everyday life, revealing the flaw or gap that will be addressed.",
            percentageRange: "0-1%",
            momentumRange: "0-10"
          },
          {
            name: "Theme Stated",
            description: "Someone (often not the protagonist) poses a question or statement that hints at what the story is really about. This thematic truth will be challenged and explored throughout the narrative. It's usually subtle and might go unnoticed by the protagonist initially.",
            percentageRange: "5%",
            momentumRange: "5-15"
          },
          {
            name: "Setup",
            description: "Introduction to the protagonist's world, their relationships, routines, and the stakes. Show what's missing in their life and what they think they want. Establish the status quo that will be disrupted. Every element introduced here should have meaning or relevance to the story ahead.",
            percentageRange: "1-10%",
            momentumRange: "10-20"
          },
          {
            name: "Catalyst",
            description: "The inciting incident that disrupts the protagonist's world. Something happens that presents a problem, opportunity, or challenge that cannot be ignored. This is the moment that sets the story in motion and introduces the central dramatic question.",
            percentageRange: "10%",
            momentumRange: "25-35"
          },
          {
            name: "Debate",
            description: "The protagonist hesitates, questions, or resists the call to action. Internal conflict emerges as they weigh their options and wonder if they're ready for the journey ahead. This section builds tension as the audience anticipates the inevitable leap into Act Two.",
            percentageRange: "10-20%",
            momentumRange: "20-30"
          },
          {
            name: "Break into 2",
            description: "The protagonist makes a choice and crosses the threshold into a new world or situation. They commit to the journey, leaving the familiar behind. This decision propels them into Act Two and sets the main story in motion. There's no turning back.",
            percentageRange: "20%",
            momentumRange: "30-40"
          },
          {
            name: "B Story",
            description: "Introduction of a secondary storyline, often a relationship that provides emotional depth and thematic counterpoint to the main plot. This subplot typically explores the internal journey and helps the protagonist learn what they truly need (versus what they initially wanted).",
            percentageRange: "22%",
            momentumRange: "35-45"
          },
          {
            name: "Fun and Games",
            description: "The promise of the premise. This is where the story delivers what the audience came for\u2014the core concept in action. The protagonist explores the new world, enjoys initial successes, and we see the story's unique appeal. Tension exists but hasn't reached its peak yet.",
            percentageRange: "20-50%",
            momentumRange: "40-55"
          },
          {
            name: "Midpoint",
            description: "A major turning point that raises the stakes and changes the direction of the story. Either a false victory (things seem great but complications loom) or a false defeat (things seem terrible but hope remains). Time clocks and deadlines often appear here, adding urgency.",
            percentageRange: "50%",
            momentumRange: "60-70"
          },
          {
            name: "Bad Guys Close In",
            description: "The opponent's forces regroup and push back harder. Internal and external pressures mount. The protagonist's flaws or weaknesses are exposed. Relationships may fray. The easy wins from Fun and Games evaporate as real obstacles emerge and consequences become clear.",
            percentageRange: "50-75%",
            momentumRange: "65-80"
          },
          {
            name: "All Is Lost",
            description: "The lowest point. The protagonist loses everything or believes they do. The goal seems impossible. This is often the moment of greatest despair, where hope appears lost. Something or someone important may be literally or figuratively lost. The 'whiff of death' moment.",
            percentageRange: "75%",
            momentumRange: "75-85"
          },
          {
            name: "Dark Night of the Soul",
            description: "A moment of reflection and wallowing in defeat. The protagonist processes the loss, questions everything, and confronts their deepest fears. This quiet, internal moment allows both character and audience to feel the full weight of All Is Lost before the final push begins.",
            percentageRange: "75-80%",
            momentumRange: "70-80"
          },
          {
            name: "Break into 3",
            description: "The protagonist has an epiphany or receives crucial information that provides a solution. They synthesize what they've learned from both the A Story and B Story. Armed with new understanding, they formulate a plan and commit to one final attempt. Hope returns with newfound wisdom.",
            percentageRange: "80%",
            momentumRange: "75-85"
          },
          {
            name: "Finale",
            description: "The climactic confrontation where the protagonist applies everything they've learned. They must prove they've changed by using new skills, wisdom, or perspective gained through the journey. The A Story and B Story threads come together. The central question is answered, and the theme is proven.",
            percentageRange: "80-99%",
            momentumRange: "85-100"
          },
          {
            name: "Final Image",
            description: "The 'after' snapshot that mirrors and contrasts with the Opening Image. Show how the protagonist and their world have transformed. This closing image should demonstrate that real change has occurred and reflect the thematic journey. The story comes full circle.",
            percentageRange: "99-100%",
            momentumRange: "30-50"
          }
        ]
      },
      "Hero's Journey": {
        name: "Hero's Journey",
        beatCount: 12,
        beats: [
          "Ordinary World",
          "Call to Adventure",
          "Refusal of the Call",
          "Meeting the Mentor",
          "Crossing the Threshold",
          "Tests, Allies, Enemies",
          "Approach to the Inmost Cave",
          "Ordeal",
          "Reward (Seizing the Sword)",
          "The Road Back",
          "Resurrection",
          "Return with the Elixir"
        ],
        beatDetails: [
          {
            name: "Ordinary World",
            description: "The hero's normal life before the adventure begins. Establish who they are, what they believe, their relationships, and their routine. Show what's lacking or incomplete in their life. This familiar world will be contrasted with the Special World they're about to enter.",
            percentageRange: "0-10%",
            momentumRange: "0-15"
          },
          {
            name: "Call to Adventure",
            description: "The hero is presented with a problem, challenge, or adventure. Something disrupts their Ordinary World and beckons them toward the unknown. This call may come from external events or internal yearning, but it demands a response and offers the possibility of change.",
            percentageRange: "10%",
            momentumRange: "20-30"
          },
          {
            name: "Refusal of the Call",
            description: "The hero hesitates or declines the adventure, usually out of fear, obligation, or insecurity. They may feel unworthy, unprepared, or unwilling to leave their comfort zone. This reluctance makes them relatable and human, building anticipation for when they finally accept.",
            percentageRange: "10-15%",
            momentumRange: "15-25"
          },
          {
            name: "Meeting the Mentor",
            description: "The hero encounters someone who provides guidance, training, gifts, or confidence needed for the journey. The mentor may be a person, a memory, or even an object that inspires. This meeting gives the hero what they need to overcome their fear and commit to the adventure.",
            percentageRange: "15-20%",
            momentumRange: "25-35"
          },
          {
            name: "Crossing the Threshold",
            description: "The hero leaves the Ordinary World and enters the Special World of the adventure. This is the point of no return where they commit fully to the journey. The rules change, stakes rise, and the hero must adapt to this new and unfamiliar environment.",
            percentageRange: "20-25%",
            momentumRange: "35-45"
          },
          {
            name: "Tests, Allies, Enemies",
            description: "The hero faces challenges, makes friends, identifies enemies, and learns the rules of the Special World. Through trials and encounters, they develop new skills and understanding. This section establishes the landscape of Act Two and builds toward greater challenges ahead.",
            percentageRange: "25-50%",
            momentumRange: "40-60"
          },
          {
            name: "Approach to the Inmost Cave",
            description: "The hero prepares for the major challenge ahead, often literally or metaphorically approaching the place of greatest danger. Plans are made, final preparations completed, and the hero steels themselves for the Ordeal. Tension builds as the supreme test draws near.",
            percentageRange: "50-60%",
            momentumRange: "55-70"
          },
          {
            name: "Ordeal",
            description: "The supreme test where the hero faces their greatest fear or most difficult challenge. This is a life-or-death moment (literally or symbolically) where everything hangs in the balance. The hero may appear to fail, die, or lose everything before emerging transformed.",
            percentageRange: "60-70%",
            momentumRange: "75-90"
          },
          {
            name: "Reward (Seizing the Sword)",
            description: "Having survived the Ordeal, the hero claims their reward\u2014knowledge, power, treasure, reconciliation, or love. They take possession of what they came for, though often it's different from what they originally sought. Success brings new understanding and confidence.",
            percentageRange: "70-75%",
            momentumRange: "60-75"
          },
          {
            name: "The Road Back",
            description: "The hero begins the journey home but faces consequences or pursuit from their actions in the Special World. New complications arise, and forces may try to prevent their return. The hero must choose to complete the journey and bring their reward back to the Ordinary World.",
            percentageRange: "75-80%",
            momentumRange: "70-80"
          },
          {
            name: "Resurrection",
            description: "The climactic final test where the hero must use everything they've learned. This is a last purification or rebirth before returning home. The stakes are highest here\u2014often involving life and death for more than just the hero. They must prove their transformation is complete.",
            percentageRange: "80-95%",
            momentumRange: "85-100"
          },
          {
            name: "Return with the Elixir",
            description: "The hero returns to the Ordinary World transformed and bearing something (knowledge, treasure, wisdom, or experience) that benefits their community. The journey is complete, the hero has grown, and life is better than before. The story comes full circle with meaningful change.",
            percentageRange: "95-100%",
            momentumRange: "35-55"
          }
        ]
      },
      "Story Grid": {
        name: "Story Grid",
        beatCount: 15,
        beats: [
          "Act 1: Inciting Incident",
          "Act 1: Progressive Complication 1",
          "Act 1: Progressive Complication 2",
          "Act 1: Crisis",
          "Act 1: Climax",
          "Act 1: Resolution",
          "Act 2: Inciting Incident",
          "Act 2: Progressive Complications",
          "Act 2: Midpoint Shift",
          "Act 2: Crisis",
          "Act 2: Climax",
          "Act 2: Resolution",
          "Act 3: Crisis",
          "Act 3: Climax",
          "Act 3: Resolution"
        ],
        beatDetails: [
          {
            name: "Act 1: Inciting Incident",
            description: "An event beyond the protagonist's control that destabilizes their world and sets the main story in motion. This incident introduces the primary problem or opportunity that will drive the narrative. It disrupts the status quo and creates a need for change or action.",
            percentageRange: "0-12.5%",
            momentumRange: "15-25"
          },
          {
            name: "Act 1: Progressive Complication 1",
            description: "The first major obstacle or turning point that complicates the protagonist's situation. As they attempt to restore balance or pursue their goal, new problems emerge that make the path forward more difficult. Stakes begin to rise.",
            percentageRange: "12.5-18%",
            momentumRange: "20-30"
          },
          {
            name: "Act 1: Progressive Complication 2",
            description: "Another complication that further escalates the situation. The protagonist's initial strategies prove insufficient, forcing them to adapt. Pressure increases and the easy solutions are eliminated, pushing toward a critical decision point.",
            percentageRange: "18-23%",
            momentumRange: "25-35"
          },
          {
            name: "Act 1: Crisis",
            description: "The protagonist faces a difficult choice between two negative outcomes or two equally compelling options (a dilemma or paradox). This decision is truly difficult\u2014there is no 'right' answer. The choice they make will determine the direction of their journey through Act Two.",
            percentageRange: "23-25%",
            momentumRange: "30-40"
          },
          {
            name: "Act 1: Climax",
            description: "The protagonist makes their choice from the Crisis, taking action that propels them into Act Two. This decision is irreversible and commits them to a new path. Their choice reveals character and establishes what kind of journey this will be.",
            percentageRange: "25%",
            momentumRange: "35-45"
          },
          {
            name: "Act 1: Resolution",
            description: "The immediate consequences of the Act I Climax become clear. We see how the protagonist's choice affects their world and relationships. New stakes are established as they enter the middle phase of their journey with complications already mounting.",
            percentageRange: "25-30%",
            momentumRange: "40-50"
          },
          {
            name: "Act 2: Inciting Incident",
            description: "A new destabilizing event that raises stakes and complicates the protagonist's pursuit of their goal. Just as they're adapting to Act Two, something happens that changes the game entirely. This incident shifts the terms of engagement and increases pressure.",
            percentageRange: "30-37.5%",
            momentumRange: "45-55"
          },
          {
            name: "Act 2: Progressive Complications",
            description: "A series of obstacles, setbacks, and escalating problems that test the protagonist through the middle portion of Act Two. Each complication makes the goal harder to achieve and reveals more about what's truly at stake. External and internal pressures mount simultaneously.",
            percentageRange: "37.5-50%",
            momentumRange: "50-65"
          },
          {
            name: "Act 2: Midpoint Shift",
            description: "A major revelation or reversal that transforms the protagonist's understanding of the situation or themselves. What they thought they knew is challenged. Strategies must change, and the second half of Act Two will be fundamentally different from the first. Often a point of no return.",
            percentageRange: "50%",
            momentumRange: "60-70"
          },
          {
            name: "Act 2: Crisis",
            description: "The protagonist faces another critical choice, but this time the stakes are much higher. Having learned from their journey so far, they must make a decision that will determine whether they can achieve their goal. This is often the most difficult choice in the story.",
            percentageRange: "62.5-75%",
            momentumRange: "70-80"
          },
          {
            name: "Act 2: Climax",
            description: "The protagonist acts on their Act II Crisis decision, making a choice that leads directly to the story's final confrontation. This action demonstrates how they've grown and what they've learned. It sets up the conditions for Act Three's resolution.",
            percentageRange: "75%",
            momentumRange: "75-85"
          },
          {
            name: "Act 2: Resolution",
            description: "The consequences of the Act II Climax play out, revealing the true scope of what the protagonist now faces. All threads converge as they head into the final act. The ultimate challenge is now clear and unavoidable.",
            percentageRange: "75-80%",
            momentumRange: "75-85"
          },
          {
            name: "Act 3: Crisis",
            description: "The final and most crucial decision point. The protagonist must choose how to face the ultimate challenge, often with everything they value at stake. This choice must demonstrate the full arc of their transformation and commit them to the final confrontation.",
            percentageRange: "80-87.5%",
            momentumRange: "80-90"
          },
          {
            name: "Act 3: Climax",
            description: "The protagonist takes decisive action based on their final Crisis choice. This is the ultimate test where they prove whether they've truly changed and learned what they needed to learn. Success or failure here determines the story's outcome and validates or challenges the theme.",
            percentageRange: "87.5-95%",
            momentumRange: "90-100"
          },
          {
            name: "Act 3: Resolution",
            description: "The aftermath and new equilibrium. All major questions are answered, relationships reach their final state, and we see the full impact of the protagonist's journey. The world has changed, the protagonist has changed, and the story's thematic statement is complete.",
            percentageRange: "95-100%",
            momentumRange: "40-60"
          }
        ]
      }
    };
    PLOT_SYSTEM_NAMES = Object.keys(PLOT_SYSTEMS);
  }
});

// src/modals/GossamerScoreModal.ts
var import_obsidian, GossamerScoreModal;
var init_GossamerScoreModal = __esm({
  "src/modals/GossamerScoreModal.ts"() {
    import_obsidian = require("obsidian");
    init_gossamer();
    init_GossamerCommands();
    init_beatsSystems();
    GossamerScoreModal = class extends import_obsidian.Modal {
      constructor(app, plugin, plotBeats) {
        super(app);
        this.entries = [];
        this.includeBeatDescriptions = false;
        this.plugin = plugin;
        this.plotBeats = plotBeats;
      }
      // Helper to create Lucide circle-x SVG icon
      createCircleXIcon() {
        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("width", "14");
        svg.setAttribute("height", "14");
        svg.setAttribute("viewBox", "0 0 24 24");
        svg.setAttribute("fill", "none");
        svg.setAttribute("stroke", "currentColor");
        svg.setAttribute("stroke-width", "2");
        svg.setAttribute("stroke-linecap", "round");
        svg.setAttribute("stroke-linejoin", "round");
        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", "12");
        circle.setAttribute("cy", "12");
        circle.setAttribute("r", "10");
        const path1 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path1.setAttribute("d", "m15 9-6 6");
        const path2 = document.createElementNS("http://www.w3.org/2000/svg", "path");
        path2.setAttribute("d", "m9 9 6 6");
        svg.appendChild(circle);
        svg.appendChild(path1);
        svg.appendChild(path2);
        return svg;
      }
      onOpen() {
        const { contentEl, modalEl } = this;
        contentEl.empty();
        if (modalEl) {
          modalEl.style.width = "800px";
          modalEl.style.maxWidth = "90vw";
        }
        contentEl.addClass("rt-gossamer-score-modal");
        const settingsSystem = this.plugin.settings.beatSystem || "Save The Cat";
        const filteredBeats = this.plotBeats.filter((beat) => {
          if (!beat.path) return false;
          const file = this.plugin.app.vault.getAbstractFileByPath(beat.path);
          if (!file) return false;
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          const beatModel = fm == null ? void 0 : fm["Beat Model"];
          if (settingsSystem === "Custom") {
            const recognizedSystems = ["Save The Cat", "Hero's Journey", "Story Grid"];
            return !beatModel || !recognizedSystems.includes(beatModel);
          } else {
            return beatModel === settingsSystem;
          }
        });
        this.plotBeats = filteredBeats;
        const plotSystemTemplate = getPlotSystem(settingsSystem);
        const actualCount = filteredBeats.length;
        const countMismatch = plotSystemTemplate ? actualCount !== plotSystemTemplate.beatCount : false;
        const titleText = `Gossamer momentum scores \u2014 ${settingsSystem}`;
        const titleEl = contentEl.createEl("h2", { text: titleText });
        titleEl.addClass("rt-gossamer-score-title");
        if (actualCount === 0) {
          const noBeatsWarning = contentEl.createEl("div", {
            text: settingsSystem === "Custom" ? `\u26A0\uFE0F No custom story beats found. Create notes with "Class: Beat" without "Beat Model" field, or change beat system in Settings.` : `\u26A0\uFE0F No story beats found with "Beat Model: ${settingsSystem}". Check your beat notes have the correct Beat Model field, or change beat system in Settings.`
          });
          noBeatsWarning.addClass("rt-gossamer-warning");
        } else if (countMismatch && plotSystemTemplate) {
          const warningEl = contentEl.createEl("div", {
            text: `\u26A0\uFE0F Expected ${plotSystemTemplate.beatCount} beats for ${settingsSystem}, but found ${actualCount} story beats with matching Beat Model. Check your vault.`
          });
          warningEl.addClass("rt-gossamer-warning");
        }
        const headerSection = contentEl.createDiv("rt-gossamer-score-header");
        const subtitleEl = headerSection.createEl("p", {
          text: "Enter momentum scores (0-100) for each beat. Previous scores will be saved as history."
        });
        subtitleEl.addClass("rt-gossamer-score-subtitle");
        const copyOptions = headerSection.createDiv("rt-gossamer-copy-options");
        const toggleLabel = copyOptions.createEl("label", { cls: "rt-gossamer-copy-toggle" });
        const toggleInput = toggleLabel.createEl("input", { type: "checkbox" });
        toggleInput.checked = this.includeBeatDescriptions;
        toggleInput.addEventListener("change", () => {
          this.includeBeatDescriptions = toggleInput.checked;
        });
        toggleLabel.appendText("Include beat descriptions when copying template");
        const scoresContainer = contentEl.createDiv("rt-gossamer-scores-container");
        this.buildEntries();
        this.entries.forEach((entry, index) => {
          const entryDiv = scoresContainer.createDiv("rt-gossamer-score-entry");
          const firstRow = entryDiv.createDiv("rt-gossamer-score-row");
          const titleContainer = firstRow.createDiv("rt-gossamer-beat-title-container");
          const beatTitleEl = titleContainer.createEl("span", { text: entry.beatTitle });
          beatTitleEl.addClass("rt-gossamer-beat-title");
          if (entry.range) {
            const rangeEl = titleContainer.createEl("span", { text: ` (${entry.range})` });
            rangeEl.addClass("rt-gossamer-beat-range");
          }
          const inputLabel = firstRow.createSpan({ text: "New Score: " });
          inputLabel.addClass("rt-gossamer-input-label");
          entry.inputEl = new import_obsidian.TextComponent(firstRow);
          entry.inputEl.inputEl.addClass("rt-gossamer-score-input");
          entry.inputEl.setPlaceholder("0-100");
          entry.inputEl.onChange((value) => {
            var _a, _b, _c;
            const num = parseInt(value);
            if (!isNaN(num) && num >= 0 && num <= 100) {
              entry.newScore = num;
              (_a = entry.inputEl) == null ? void 0 : _a.inputEl.removeClass("rt-input-error");
            } else if (value.trim().length > 0) {
              (_b = entry.inputEl) == null ? void 0 : _b.inputEl.addClass("rt-input-error");
              entry.newScore = void 0;
            } else {
              (_c = entry.inputEl) == null ? void 0 : _c.inputEl.removeClass("rt-input-error");
              entry.newScore = void 0;
            }
          });
          const secondRow = entryDiv.createDiv("rt-gossamer-scores-history-row");
          const existingScoresEl = secondRow.createDiv("rt-gossamer-existing-scores-container");
          entry.scoreDisplayEl = existingScoresEl;
          const renderScores = () => {
            existingScoresEl.empty();
            const totalScores = (entry.currentScore !== void 0 && !entry.scoresToDelete.has(1) ? 1 : 0) + entry.history.filter((_, idx) => !entry.scoresToDelete.has(idx + 2)).length;
            if (entry.currentScore !== void 0 && !entry.scoresToDelete.has(1)) {
              const scoreContainer = existingScoresEl.createDiv();
              scoreContainer.addClass("rt-gossamer-score-item-container");
              const iconColumn = scoreContainer.createDiv();
              iconColumn.addClass("rt-gossamer-icon-column");
              iconColumn.appendChild(this.createCircleXIcon());
              const textColumn = scoreContainer.createDiv();
              textColumn.addClass("rt-gossamer-text-column");
              textColumn.textContent = `G1:${entry.currentScore}`;
              scoreContainer.addEventListener("click", () => {
                entry.scoresToDelete.add(1);
                renderScores();
              });
            }
            entry.history.forEach((score, idx) => {
              const gossamerNum = idx + 2;
              if (entry.scoresToDelete.has(gossamerNum)) return;
              const scoreContainer = existingScoresEl.createDiv();
              scoreContainer.addClass("rt-gossamer-score-item-container");
              const iconColumn = scoreContainer.createDiv();
              iconColumn.addClass("rt-gossamer-icon-column");
              iconColumn.appendChild(this.createCircleXIcon());
              const textColumn = scoreContainer.createDiv();
              textColumn.addClass("rt-gossamer-text-column");
              textColumn.textContent = `G${gossamerNum}:${score}`;
              scoreContainer.addEventListener("click", () => {
                entry.scoresToDelete.add(gossamerNum);
                renderScores();
              });
            });
            if (totalScores > 10) {
              const countSpan = existingScoresEl.createSpan({
                text: `(${totalScores} scores)`,
                cls: "rt-gossamer-score-count"
              });
            }
          };
          renderScores();
        });
        const buttonContainer = contentEl.createDiv("rt-gossamer-score-buttons");
        new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Copy template for AI").setTooltip("Copy beat names in AI-ready format").onClick(async () => {
          await this.copyTemplateForAI();
        });
        new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Paste from clipboard").onClick(async () => {
          await this.pasteFromClipboard();
        });
        new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Delete scores").setWarning().onClick(async () => {
          await this.deleteAllScores();
        });
        const rightButtons = buttonContainer.createDiv("rt-gossamer-score-buttons-right");
        new import_obsidian.ButtonComponent(rightButtons).setButtonText("Save scores").setCta().onClick(async () => {
          await this.saveScores();
        });
        new import_obsidian.ButtonComponent(rightButtons).setButtonText("Cancel").onClick(() => {
          this.close();
        });
      }
      buildEntries() {
        const sortedBeats = [...this.plotBeats].sort((a, b) => {
          const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
          const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
          const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
          const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
          return aNum - bNum;
        });
        for (const beat of sortedBeats) {
          if (!beat.title || !beat.path) continue;
          const file = this.plugin.app.vault.getAbstractFileByPath(beat.path);
          if (!file) continue;
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          const entry = {
            beatTitle: beat.title,
            beatName: normalizeBeatName(beat.title),
            history: [],
            scoresToDelete: /* @__PURE__ */ new Set()
          };
          if (fm) {
            if (typeof fm.Range === "string") {
              entry.range = fm.Range;
            }
            if (typeof fm.Description === "string") {
              entry.description = fm.Description;
            } else if (typeof fm.description === "string") {
              entry.description = fm.description;
            }
            if (typeof fm.Gossamer1 === "number") {
              entry.currentScore = fm.Gossamer1;
            } else if (typeof fm.Gossamer1 === "string") {
              const parsed = parseInt(fm.Gossamer1);
              if (!isNaN(parsed)) {
                entry.currentScore = parsed;
              }
            }
            for (let i = 2; i <= 30; i++) {
              const key = `Gossamer${i}`;
              if (typeof fm[key] === "number") {
                entry.history.push(fm[key]);
              } else if (typeof fm[key] === "string") {
                const parsed = parseInt(fm[key]);
                if (!isNaN(parsed)) {
                  entry.history.push(parsed);
                }
              }
            }
          }
          this.entries.push(entry);
        }
      }
      async copyTemplateForAI() {
        try {
          const settingsSystem = this.plugin.settings.beatSystem || "Save The Cat";
          const { name: contextTemplateName, prompt: contextPrompt } = this.getActiveAiContextInfo();
          const lines = [];
          lines.push(`# Beat Momentum Scores (0-100) \u2014 ${settingsSystem}`);
          lines.push("");
          if (contextPrompt) {
            lines.push("## Role & Manuscript Context");
            if (contextTemplateName) {
              lines.push(`Template: ${contextTemplateName}`);
            }
            lines.push(contextPrompt.trim());
            lines.push("Consult the complete manuscript and knowledge base for this project before assigning momentum scores.");
            lines.push("");
          }
          if (this.entries.length === 0) {
            new import_obsidian.Notice("No beats available to copy. Add Beat notes with the selected Beat Model first.");
            return;
          }
          lines.push("## Story Beats Template Guidance");
          lines.push(this.includeBeatDescriptions ? "Descriptions are pulled directly from each beat note's Description field." : "Update each beat note's Range and Description fields to customize this list. Toggle above to include descriptions.");
          lines.push("");
          const missingRangeBeats = [];
          const missingDescriptionBeats = [];
          this.entries.forEach((entry, index) => {
            const metadataParts = [];
            if (entry.range && entry.range.trim().length > 0) {
              metadataParts.push(`Ideal momentum: ${entry.range}`);
            } else {
              missingRangeBeats.push(entry.beatTitle);
            }
            const metadata = metadataParts.length > 0 ? ` (${metadataParts.join(" \u2022 ")})` : "";
            lines.push(`${index + 1}. ${entry.beatTitle}${metadata}`);
            if (this.includeBeatDescriptions) {
              if (entry.description && entry.description.trim().length > 0) {
                lines.push(`   ${entry.description.trim()}`);
              } else {
                missingDescriptionBeats.push(entry.beatTitle);
              }
            }
            lines.push("");
          });
          lines.push("## Momentum Scale:");
          lines.push("- 0-20: Quiet, establishing, low tension");
          lines.push("- 21-40: Building, complications emerging");
          lines.push("- 41-60: Rising stakes, conflict developing");
          lines.push("- 61-80: High tension, major conflicts");
          lines.push("- 81-100: Peak tension, climactic moments");
          lines.push("");
          lines.push("## Consider for each beat:");
          lines.push("- Tension and conflict level");
          lines.push("- Stakes for protagonist");
          lines.push("- Emotional intensity");
          lines.push("- Pacing and urgency");
          lines.push("");
          lines.push("## Output Instructions:");
          lines.push('- Respond with the block titled "## Completed Momentum Scores" exactly as shown below.');
          lines.push("- Replace the blank after each colon with a single integer from 0-100 (no percentage signs or trailing commentary).");
          lines.push("- Keep the beat order identical so the response can be copied directly into the Obsidian modal.");
          lines.push("- Favor the ideal range when it fits the manuscript context, but you may go outside the range if justified by the story.");
          lines.push("");
          lines.push("## Completed Momentum Scores");
          lines.push("");
          for (const entry of this.entries) {
            if (entry.range) {
              lines.push(`${entry.beatTitle} (ideal: ${entry.range}): `);
            } else {
              lines.push(`${entry.beatTitle}: `);
            }
          }
          lines.push("");
          lines.push('# Note: After filling in the numbers, return ONLY the "Completed Momentum Scores" block so it can be pasted back into Obsidian.');
          const template = lines.join("\n");
          await navigator.clipboard.writeText(template);
          new import_obsidian.Notice("\u2713 Template copied! Paste into your AI and have it fill in the scores.");
          if (missingRangeBeats.length > 0) {
            this.showMetadataWarning("Range", missingRangeBeats);
          }
          if (this.includeBeatDescriptions && missingDescriptionBeats.length > 0) {
            this.showMetadataWarning("Description", missingDescriptionBeats);
          }
        } catch (error) {
          console.error("[Gossamer] Failed to copy template:", error);
          new import_obsidian.Notice("Failed to copy template to clipboard.");
        }
      }
      async pasteFromClipboard() {
        var _a;
        try {
          const clipboard = await navigator.clipboard.readText();
          const parsedScores = parseScoresFromClipboard(clipboard);
          if (parsedScores.size === 0) {
            new import_obsidian.Notice('No scores found in clipboard. Expected format: "1: 15, 2: 25" or "Beat Name: 42"');
            return;
          }
          const isPositionalFormat = (_a = Array.from(parsedScores.keys())[0]) == null ? void 0 : _a.startsWith("__position_");
          let matchCount = 0;
          if (isPositionalFormat) {
            for (let i = 0; i < this.entries.length; i++) {
              const entry = this.entries[i];
              const position = i + 1;
              const score = parsedScores.get(`__position_${position}`);
              if (score !== void 0 && entry.inputEl) {
                entry.inputEl.setValue(score.toString());
                entry.newScore = score;
                entry.inputEl.inputEl.removeClass("rt-input-error");
                matchCount++;
              }
            }
            const expectedCount = this.entries.length;
            if (matchCount < expectedCount) {
              new import_obsidian.Notice(`\u26A0\uFE0F Warning: Pasted ${matchCount} scores but expected ${expectedCount}. Some beats may be missing scores.`);
            } else {
              new import_obsidian.Notice(`\u2713 Populated all ${matchCount} scores from clipboard.`);
            }
          } else {
            for (const entry of this.entries) {
              const normalized = normalizeBeatName(entry.beatName);
              let score = parsedScores.get(normalized);
              if (score === void 0) {
                const normalizedLower = normalized.toLowerCase();
                for (const [key, value] of parsedScores.entries()) {
                  if (key.toLowerCase() === normalizedLower) {
                    score = value;
                    break;
                  }
                }
              }
              if (score !== void 0 && entry.inputEl) {
                entry.inputEl.setValue(score.toString());
                entry.newScore = score;
                entry.inputEl.inputEl.removeClass("rt-input-error");
                matchCount++;
              }
            }
            new import_obsidian.Notice(`Populated ${matchCount} scores from clipboard.`);
          }
        } catch (error) {
          console.error("[Gossamer] Failed to paste from clipboard:", error);
          new import_obsidian.Notice("Failed to read clipboard.");
        }
      }
      async saveScores() {
        const scores = /* @__PURE__ */ new Map();
        const deletions = /* @__PURE__ */ new Map();
        const errors = [];
        for (const entry of this.entries) {
          if (entry.newScore !== void 0) {
            scores.set(entry.beatTitle, entry.newScore);
          } else if (entry.inputEl && entry.inputEl.getValue().trim().length > 0) {
            errors.push(`Invalid score for "${entry.beatTitle}"`);
          }
          if (entry.scoresToDelete.size > 0) {
            deletions.set(entry.beatTitle, entry.scoresToDelete);
          }
        }
        if (errors.length > 0) {
          new import_obsidian.Notice(`Errors: ${errors.join(", ")}`);
          return;
        }
        if (scores.size === 0 && deletions.size === 0) {
          new import_obsidian.Notice("No changes to save.");
          return;
        }
        try {
          if (scores.size > 0) {
            await this.plugin.saveGossamerScores(scores);
          }
          if (deletions.size > 0) {
            await this.processDeletions(deletions);
          }
          const changeCount = scores.size + deletions.size;
          new import_obsidian.Notice(`Updated ${changeCount} beat(s).`);
          this.close();
        } catch (error) {
          console.error("[Gossamer] Failed to save scores:", error);
          new import_obsidian.Notice("Failed to save scores. Check console for details.");
        }
      }
      async processDeletions(deletions) {
        const sourcePath = this.plugin.settings.sourcePath || "";
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        const files = sourcePath ? allFiles.filter((f) => f.path.startsWith(sourcePath)) : allFiles;
        for (const [beatTitle, gossamerNums] of deletions) {
          let file = null;
          for (const f of files) {
            if (f.basename === beatTitle || f.basename === beatTitle.replace(/^\d+\s+/, "")) {
              const cache = this.plugin.app.metadataCache.getFileCache(f);
              const fm = cache == null ? void 0 : cache.frontmatter;
              if (fm && (fm.Class === "Beat" || fm.Class === "Plot")) {
                file = f;
                break;
              }
            }
          }
          if (!file) {
            continue;
          }
          try {
            await this.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
              const fm = yaml;
              for (const num of gossamerNums) {
                delete fm[`Gossamer${num}`];
              }
            });
          } catch (error) {
            console.error(`[Gossamer] Failed to delete scores for ${beatTitle}:`, error);
          }
        }
      }
      async deleteAllScores() {
        const sourcePath = this.plugin.settings.sourcePath || "";
        const allFiles = this.plugin.app.vault.getMarkdownFiles();
        const files = sourcePath ? allFiles.filter((f) => f.path.startsWith(sourcePath)) : allFiles;
        let hasAnyScores = false;
        for (const file of files) {
          const cache = this.plugin.app.metadataCache.getFileCache(file);
          const fm = cache == null ? void 0 : cache.frontmatter;
          if (fm && (fm.Class === "Beat" || fm.class === "Beat")) {
            for (let i = 1; i <= 30; i++) {
              if (fm[`Gossamer${i}`] !== void 0) {
                hasAnyScores = true;
                break;
              }
            }
            if (hasAnyScores) break;
          }
        }
        if (!hasAnyScores) {
          new import_obsidian.Notice("No Gossamer scores found to delete.");
          return;
        }
        const confirmed = await new Promise((resolve) => {
          const modal = new import_obsidian.Modal(this.app);
          modal.titleEl.setText("Delete all Gossamer scores");
          const content = modal.contentEl.createDiv();
          content.addClass("rt-gossamer-confirm-content");
          const warningEl = content.createEl("div", {
            text: "This will permanently delete ALL Gossamer scores (Gossamer1-30) and their justifications from ALL Beat notes. This action cannot be undone."
          });
          warningEl.addClass("rt-gossamer-confirm-warning");
          const buttonContainer = content.createDiv("rt-gossamer-confirm-buttons");
          new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Delete all scores").setWarning().onClick(async () => {
            modal.close();
            resolve(true);
          });
          new import_obsidian.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
            modal.close();
            resolve(false);
          });
          modal.open();
        });
        if (!confirmed) return;
        try {
          let deletedCount = 0;
          for (const file of files) {
            const cache = this.plugin.app.metadataCache.getFileCache(file);
            const fm = cache == null ? void 0 : cache.frontmatter;
            if (fm && (fm.Class === "Beat" || fm.class === "Beat")) {
              let hasGossamerScores = false;
              for (let i = 1; i <= 30; i++) {
                if (fm[`Gossamer${i}`] !== void 0) {
                  hasGossamerScores = true;
                  break;
                }
              }
              if (hasGossamerScores) {
                await this.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
                  const frontmatter = yaml;
                  for (let i = 1; i <= 30; i++) {
                    delete frontmatter[`Gossamer${i}`];
                    delete frontmatter[`Gossamer${i} Justification`];
                  }
                  delete frontmatter["Gossamer Last Updated"];
                });
                deletedCount++;
              }
            }
          }
          new import_obsidian.Notice(`\u2713 Deleted all Gossamer scores and justifications from ${deletedCount} Beat note(s).`);
          this.close();
        } catch (error) {
          console.error("[Gossamer] Failed to delete all scores:", error);
          new import_obsidian.Notice("Failed to delete all scores. Check console for details.");
        }
      }
      showMetadataWarning(field, beats) {
        const preview = beats.slice(0, 3).join(", ");
        const remainder = beats.length > 3 ? `, +${beats.length - 3} more` : "";
        new import_obsidian.Notice(`Missing ${field} in Beat frontmatter for: ${preview}${remainder}. Update the beat notes to customize the AI template.`);
      }
      getActiveAiContextInfo() {
        const templates = this.plugin.settings.aiContextTemplates || [];
        const activeId = this.plugin.settings.activeAiContextTemplateId;
        const active = templates.find((t) => t.id === activeId) || templates[0];
        if (active) {
          return { name: active.name, prompt: active.prompt };
        }
        return {
          name: "Generic Editor",
          prompt: "Act as a developmental editor evaluating narrative momentum, emotional stakes, and pacing across the manuscript beats."
        };
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/GossamerProcessingModal.ts
var import_obsidian2, GossamerProcessingModal;
var init_GossamerProcessingModal = __esm({
  "src/modals/GossamerProcessingModal.ts"() {
    import_obsidian2 = require("obsidian");
    GossamerProcessingModal = class extends import_obsidian2.Modal {
      constructor(app, plugin, onConfirm) {
        super(app);
        this.isProcessing = false;
        this.analysisOptions = {
          requestScores: true
        };
        this.currentStatus = "Initializing...";
        this.plugin = plugin;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, titleEl, modalEl } = this;
        titleEl.setText("Gossamer gemini momentum analysis");
        if (modalEl) {
          modalEl.style.width = "700px";
          modalEl.style.maxWidth = "90vw";
        }
        contentEl.classList.add("rt-gossamer-processing-modal");
        this.showConfirmationView();
      }
      onClose() {
        if (this.timerInterval) {
          window.clearInterval(this.timerInterval);
          this.timerInterval = void 0;
        }
      }
      /**
       * Override close() to allow minimizing while processing continues
       */
      close() {
        if (this.isProcessing) {
          new import_obsidian2.Notice("Analysis continues in background.");
        }
        super.close();
      }
      showConfirmationView() {
        const { contentEl } = this;
        contentEl.empty();
        this.confirmationView = contentEl;
        const infoEl = contentEl.createDiv({ cls: "rt-beats-info" });
        const beatSystemEl = infoEl.createDiv({ cls: "rt-gossamer-beat-system-info" });
        beatSystemEl.setText("Gathering manuscript details...");
        infoEl.createDiv({
          cls: "rt-gossamer-description",
          text: "This will analyze your entire manuscript using Gemini AI to evaluate narrative momentum at each story beat."
        });
        const infoSection = contentEl.createDiv({ cls: "rt-gossamer-info-section" });
        infoSection.createEl("h3", { text: "Manuscript Information", cls: "rt-gossamer-section-title" });
        this.manuscriptInfoEl = infoSection.createDiv({ cls: "rt-gossamer-manuscript-info" });
        this.manuscriptInfoEl.setText("Gathering manuscript details...");
        if (!this.plugin.settings.geminiApiKey) {
          const warningEl = contentEl.createDiv({ cls: "rt-beats-warning" });
          warningEl.setText("\u26A0\uFE0F Gemini API key not configured. Please set your API key in Settings \u2192 AI \u2192 Gemini API key.");
        }
        const buttonRow = contentEl.createDiv({ cls: "rt-beats-actions" });
        new import_obsidian2.ButtonComponent(buttonRow).setButtonText("Begin Analysis").setCta().setDisabled(!this.plugin.settings.geminiApiKey).onClick(async () => {
          await this.startProcessing();
        });
        new import_obsidian2.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
      async startProcessing() {
        this.isProcessing = true;
        this.showProcessingView();
        try {
          await this.onConfirm(this.analysisOptions);
        } catch (error) {
          console.error("[Gossamer AI] Processing error:", error);
        }
      }
      showProcessingView() {
        const { contentEl } = this;
        contentEl.empty();
        const infoSection = contentEl.createDiv({ cls: "rt-gossamer-info-section" });
        infoSection.createEl("h3", { text: "Manuscript Information", cls: "rt-gossamer-section-title" });
        this.manuscriptInfoEl = infoSection.createDiv({ cls: "rt-gossamer-manuscript-info" });
        this.manuscriptInfoEl.setText("Assembling manuscript...");
        const progressContainer = contentEl.createDiv({ cls: "rt-gossamer-progress-container" });
        const progressBg = progressContainer.createDiv({ cls: "rt-gossamer-progress-bg" });
        this.progressBarEl = progressBg.createDiv({ cls: "rt-gossamer-progress-bar" });
        this.progressBarEl.style.setProperty("--progress-width", "0%");
        const statusSection = contentEl.createDiv({ cls: "rt-gossamer-status-section" });
        statusSection.createEl("h3", { text: "Status", cls: "rt-gossamer-section-title" });
        this.statusTextEl = statusSection.createDiv({ cls: "rt-gossamer-status-text" });
        this.statusTextEl.setText(this.currentStatus);
        const apiSection = contentEl.createDiv({ cls: "rt-gossamer-api-section" });
        apiSection.createEl("h3", { text: "API Activity", cls: "rt-gossamer-section-title" });
        this.apiStatusEl = apiSection.createDiv({ cls: "rt-gossamer-api-status" });
        this.apiStatusEl.setText("Waiting to send...");
        this.errorListEl = contentEl.createDiv({ cls: "rt-beats-error-list rt-hidden" });
        const buttonContainer = contentEl.createDiv({ cls: "rt-gossamer-actions" });
        this.closeButtonEl = new import_obsidian2.ButtonComponent(buttonContainer).setButtonText("Close").setDisabled(true).onClick(() => this.close());
      }
      /**
       * Update manuscript assembly information
       */
      setManuscriptInfo(info) {
        var _a;
        this.manuscriptInfo = info;
        if (this.manuscriptInfoEl) {
          this.manuscriptInfoEl.empty();
          const stats = this.manuscriptInfoEl.createDiv({ cls: "rt-gossamer-stats" });
          stats.createDiv({
            cls: "rt-gossamer-stat-row",
            text: `Beat System: ${info.beatSystem}`
          });
          stats.createDiv({
            cls: "rt-gossamer-stat-row",
            text: `Scenes: ${info.totalScenes.toLocaleString()}`
          });
          stats.createDiv({
            cls: "rt-gossamer-stat-row",
            text: `Words: ${info.totalWords.toLocaleString()}`
          });
          stats.createDiv({
            cls: "rt-gossamer-stat-row",
            text: `Estimated tokens: ~${info.estimatedTokens.toLocaleString()}`
          });
          stats.createDiv({
            cls: "rt-gossamer-stat-row",
            text: `Story beats: ${info.beatCount}`
          });
          if (info.hasIterativeContext) {
            stats.createDiv({
              cls: "rt-gossamer-stat-row rt-gossamer-iterative-note",
              text: `Iterative refinement: Previous analysis will be sent for comparison`
            });
          }
        }
        const beatSystemInfoEl = (_a = this.confirmationView) == null ? void 0 : _a.querySelector(".rt-gossamer-beat-system-info");
        if (beatSystemInfoEl) {
          beatSystemInfoEl.setText(`Beat System: ${info.beatSystem}`);
        }
      }
      /**
       * Update current status message
       */
      setStatus(status) {
        this.currentStatus = status;
        if (this.statusTextEl) {
          this.statusTextEl.setText(status);
        }
      }
      /**
       * Mark API call as started
       */
      apiCallStarted() {
        this.apiCallStartTime = Date.now();
        if (this.apiStatusEl) {
          this.apiStatusEl.empty();
          this.updateTimer();
          this.timerInterval = window.setInterval(() => {
            this.updateTimer();
          }, 1e3);
        }
        if (this.progressBarEl) {
          this.progressBarEl.addClass("rt-gossamer-progress-active");
          this.progressBarEl.style.setProperty("--progress-width", "50%");
        }
      }
      /**
       * Update elapsed time display
       */
      updateTimer() {
        if (!this.apiStatusEl || !this.apiCallStartTime) return;
        const elapsed = Math.floor((Date.now() - this.apiCallStartTime) / 1e3);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        const timeStr = minutes > 0 ? `${minutes}:${seconds.toString().padStart(2, "0")}` : `${seconds}s`;
        let message;
        if (elapsed < 30) {
          message = `Sending manuscript to Gemini... ${timeStr}`;
        } else if (elapsed < 60) {
          message = `Evaluating beats... ${timeStr}`;
        } else {
          message = `Preparing response... ${timeStr}`;
        }
        const estimate = elapsed < 90 ? " (typically 30-90 seconds)" : " (large manuscript)";
        this.apiStatusEl.setText(message + estimate);
      }
      /**
       * Mark API call as successful
       */
      apiCallSuccess() {
        if (this.timerInterval) {
          window.clearInterval(this.timerInterval);
          this.timerInterval = void 0;
        }
        const elapsed = this.apiCallStartTime ? ((Date.now() - this.apiCallStartTime) / 1e3).toFixed(1) : "?";
        if (this.apiStatusEl) {
          this.apiStatusEl.empty();
          this.apiStatusEl.setText(`\u2713 Response received (${elapsed}s)`);
        }
        if (this.progressBarEl) {
          this.progressBarEl.removeClass("rt-gossamer-progress-active");
          this.progressBarEl.addClass("rt-progress-complete");
          this.progressBarEl.style.setProperty("--progress-width", "100%");
        }
      }
      /**
       * Mark API call as failed with error
       */
      apiCallError(error) {
        if (this.timerInterval) {
          window.clearInterval(this.timerInterval);
          this.timerInterval = void 0;
        }
        if (this.apiStatusEl) {
          this.apiStatusEl.empty();
          this.apiStatusEl.setText(`\u2717 API call failed`);
        }
        if (this.progressBarEl) {
          this.progressBarEl.removeClass("rt-gossamer-progress-active");
          this.progressBarEl.addClass("rt-progress-complete");
          this.progressBarEl.style.setProperty("--progress-width", "0%");
        }
        this.addError(error);
      }
      /**
       * Add error message to error section (using Scene Analysis styling)
       */
      addError(message) {
        if (!this.errorListEl) return;
        if (this.errorListEl.hasClass("rt-hidden")) {
          this.errorListEl.removeClass("rt-hidden");
          const header = this.errorListEl.createDiv({ cls: "rt-beats-error-header" });
          header.setText("Errors encountered:");
        }
        const errorItem = this.errorListEl.createDiv({ cls: "rt-beats-error-item" });
        errorItem.setText(message);
      }
      /**
       * Mark processing as complete
       */
      completeProcessing(success, message) {
        this.isProcessing = false;
        if (this.statusTextEl) {
          this.statusTextEl.setText(message);
        }
        if (this.progressBarEl) {
          this.progressBarEl.removeClass("rt-gossamer-progress-active");
          this.progressBarEl.addClass("rt-progress-complete");
          if (success) {
            this.progressBarEl.style.setProperty("--progress-width", "100%");
          }
        }
        if (this.closeButtonEl) {
          this.closeButtonEl.setDisabled(false);
          if (success) {
            this.closeButtonEl.setCta();
          }
        }
      }
      /**
       * Show rate limit notification
       */
      showRateLimitWarning(retryAfter) {
        const message = retryAfter ? `Rate limit reached. Please try again in ${retryAfter} seconds.` : "Rate limit reached. Please try again later.";
        this.addError(message);
        if (this.apiStatusEl) {
          this.apiStatusEl.setText("\u26A0\uFE0F Rate limited");
        }
      }
    };
  }
});

// src/modes/ModeDefinition.ts
var ModeDefinition_exports = {};
__export(ModeDefinition_exports, {
  TimelineMode: () => TimelineMode,
  isTimelineMode: () => isTimelineMode
});
function isTimelineMode(value) {
  return Object.values(TimelineMode).includes(value);
}
var TimelineMode;
var init_ModeDefinition = __esm({
  "src/modes/ModeDefinition.ts"() {
    TimelineMode = /* @__PURE__ */ ((TimelineMode2) => {
      TimelineMode2["NARRATIVE"] = "narrative";
      TimelineMode2["SUBPLOT"] = "subplot";
      TimelineMode2["GOSSAMER"] = "gossamer";
      TimelineMode2["CHRONOLOGUE"] = "chronologue";
      return TimelineMode2;
    })(TimelineMode || {});
  }
});

// src/utils/date.ts
function parseMonthName(value) {
  if (!value) return null;
  const key = value.toLowerCase().replace(".", "");
  return key in MONTH_NAME_MAP ? MONTH_NAME_MAP[key] : null;
}
function createLocalDate(year, monthIndex, day, hour = 12, minute = 0, second = 0) {
  const date = new Date(year, monthIndex, day, hour, minute, second, 0);
  return isNaN(date.getTime()) ? null : date;
}
function parseWhenField(when) {
  if (!when || typeof when !== "string") return null;
  const trimmed = when.trim();
  const dateOnlyMatch = /^(\d{4})-(\d{1,2})-(\d{1,2})$/.exec(trimmed);
  if (dateOnlyMatch) {
    const year = parseInt(dateOnlyMatch[1], 10);
    const month = parseInt(dateOnlyMatch[2], 10) - 1;
    const day = parseInt(dateOnlyMatch[3], 10);
    const date = new Date(year, month, day, 12, 0, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const iso8601SecondsMatch = /^(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (iso8601SecondsMatch) {
    const year = parseInt(iso8601SecondsMatch[1], 10);
    const month = parseInt(iso8601SecondsMatch[2], 10) - 1;
    const day = parseInt(iso8601SecondsMatch[3], 10);
    const hour = parseInt(iso8601SecondsMatch[4], 10);
    const minute = parseInt(iso8601SecondsMatch[5], 10);
    const second = parseInt(iso8601SecondsMatch[6], 10);
    const date = new Date(year, month, day, hour, minute, second, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const iso8601Match = /^(\d{4})-(\d{1,2})-(\d{1,2})T(\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (iso8601Match) {
    const year = parseInt(iso8601Match[1], 10);
    const month = parseInt(iso8601Match[2], 10) - 1;
    const day = parseInt(iso8601Match[3], 10);
    const hour = parseInt(iso8601Match[4], 10);
    const minute = parseInt(iso8601Match[5], 10);
    const date = new Date(year, month, day, hour, minute, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const dateTimeSecondsMatch = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (dateTimeSecondsMatch) {
    const year = parseInt(dateTimeSecondsMatch[1], 10);
    const month = parseInt(dateTimeSecondsMatch[2], 10) - 1;
    const day = parseInt(dateTimeSecondsMatch[3], 10);
    const hour = parseInt(dateTimeSecondsMatch[4], 10);
    const minute = parseInt(dateTimeSecondsMatch[5], 10);
    const second = parseInt(dateTimeSecondsMatch[6], 10);
    const date = new Date(year, month, day, hour, minute, second, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const dateTimeMatch = /^(\d{4})-(\d{1,2})-(\d{1,2}) (\d{1,2}):(\d{1,2})$/.exec(trimmed);
  if (dateTimeMatch) {
    const year = parseInt(dateTimeMatch[1], 10);
    const month = parseInt(dateTimeMatch[2], 10) - 1;
    const day = parseInt(dateTimeMatch[3], 10);
    const hour = parseInt(dateTimeMatch[4], 10);
    const minute = parseInt(dateTimeMatch[5], 10);
    const date = new Date(year, month, day, hour, minute, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const ampmMatch = /^(\d{4})-(\d{1,2})-(\d{1,2})\s+(\d{1,2})(?::(\d{2}))?\s*(am|pm)$/i.exec(trimmed);
  if (ampmMatch) {
    const year = parseInt(ampmMatch[1], 10);
    const month = parseInt(ampmMatch[2], 10) - 1;
    const day = parseInt(ampmMatch[3], 10);
    let hour = parseInt(ampmMatch[4], 10);
    const minute = ampmMatch[5] ? parseInt(ampmMatch[5], 10) : 0;
    const ampm = ampmMatch[6].toLowerCase();
    if (ampm === "pm" && hour < 12) {
      hour += 12;
    } else if (ampm === "am" && hour === 12) {
      hour = 0;
    }
    const date = new Date(year, month, day, hour, minute, 0, 0);
    return isNaN(date.getTime()) ? null : date;
  }
  const yearMonthMatch = /^(\d{4})-(\d{1,2})$/.exec(trimmed);
  if (yearMonthMatch) {
    const year = parseInt(yearMonthMatch[1], 10);
    const month = parseInt(yearMonthMatch[2], 10) - 1;
    return createLocalDate(year, month, 1);
  }
  const yearOnlyMatch = /^(\d{4})$/.exec(trimmed);
  if (yearOnlyMatch) {
    const year = parseInt(yearOnlyMatch[1], 10);
    return createLocalDate(year, 0, 1);
  }
  const monthYearMatch = /^([A-Za-z]+)\s*,?\s*(\d{4})$/.exec(trimmed);
  if (monthYearMatch) {
    const month = parseMonthName(monthYearMatch[1]);
    const year = parseInt(monthYearMatch[2], 10);
    if (month !== null) {
      return createLocalDate(year, month, 1);
    }
  }
  const monthDayYearMatch = /^([A-Za-z]+)\s+(\d{1,2})(?:st|nd|rd|th)?(?:,)?\s+(\d{4})$/.exec(trimmed);
  if (monthDayYearMatch) {
    const month = parseMonthName(monthDayYearMatch[1]);
    const day = parseInt(monthDayYearMatch[2], 10);
    const year = parseInt(monthDayYearMatch[3], 10);
    if (month !== null) {
      return createLocalDate(year, month, day);
    }
  }
  const dayMonthYearMatch = /^(\d{1,2})(?:st|nd|rd|th)?\s+([A-Za-z]+)(?:,)?\s+(\d{4})$/.exec(trimmed);
  if (dayMonthYearMatch) {
    const day = parseInt(dayMonthYearMatch[1], 10);
    const month = parseMonthName(dayMonthYearMatch[2]);
    const year = parseInt(dayMonthYearMatch[3], 10);
    if (month !== null) {
      return createLocalDate(year, month, day);
    }
  }
  return null;
}
function calculateTimeSpan(dates) {
  if (dates.length === 0) {
    return {
      totalMs: 0,
      minutes: 0,
      hours: 0,
      days: 0,
      weeks: 0,
      months: 0,
      years: 0,
      recommendedUnit: "days"
    };
  }
  const sortedDates = dates.slice().sort((a, b) => a.getTime() - b.getTime());
  const earliest = sortedDates[0];
  const latest = sortedDates[sortedDates.length - 1];
  const totalMs = latest.getTime() - earliest.getTime();
  const minutes = totalMs / (1e3 * 60);
  const hours = minutes / 60;
  const days = hours / 24;
  const weeks = days / 7;
  const months = days / 30.44;
  const years = days / 365.25;
  let recommendedUnit;
  if (hours <= 3) {
    recommendedUnit = "minutes";
  } else if (hours <= 48) {
    recommendedUnit = "hours";
  } else if (days <= 14) {
    recommendedUnit = "days";
  } else if (weeks <= 8) {
    recommendedUnit = "weeks";
  } else if (months <= 24) {
    recommendedUnit = "months";
  } else {
    recommendedUnit = "years";
  }
  return {
    totalMs,
    minutes,
    hours,
    days,
    weeks,
    months,
    years,
    recommendedUnit
  };
}
function formatUnitLabel(value, unitKey) {
  var _a;
  const unit = (_a = ELAPSED_TIME_UNIT_LABELS[unitKey]) != null ? _a : {
    singular: unitKey,
    plural: `${unitKey}s`
  };
  const isSingular = Math.abs(Math.abs(value) - 1) < 1e-9;
  return isSingular ? unit.singular : unit.plural;
}
function buildPrimaryComponent(ms, requestedUnit) {
  const unitDef = ELAPSED_UNIT_SEQUENCE[requestedUnit];
  if (!unitDef || ms <= 0) {
    return {
      text: `0 ${formatUnitLabel(0, requestedUnit)}`,
      remainderMs: 0,
      usedUnit: requestedUnit
    };
  }
  const wholeValue = Math.floor(ms / unitDef.ms);
  if (wholeValue <= 0) {
    if (unitDef.next) {
      return buildPrimaryComponent(ms, unitDef.next);
    }
    const secondsValue = Math.max(1, Math.round(ms / MS_PER_SECOND));
    return {
      text: `${secondsValue} ${formatUnitLabel(secondsValue, "second")}`,
      remainderMs: 0,
      usedUnit: "second"
    };
  }
  const consumed = wholeValue * unitDef.ms;
  return {
    text: `${wholeValue} ${formatUnitLabel(wholeValue, requestedUnit)}`,
    remainderMs: Math.max(0, ms - consumed),
    usedUnit: requestedUnit
  };
}
function buildSecondaryComponent(remainderMs, startUnit) {
  if (!startUnit || remainderMs <= 0) return null;
  const unitDef = ELAPSED_UNIT_SEQUENCE[startUnit];
  if (!unitDef) return null;
  const wholeValue = Math.floor(remainderMs / unitDef.ms);
  if (wholeValue > 0) {
    return {
      text: `${wholeValue} ${formatUnitLabel(wholeValue, startUnit)}`,
      usedUnit: startUnit
    };
  }
  if (unitDef.next) {
    return buildSecondaryComponent(remainderMs, unitDef.next);
  }
  const secondsValue = Math.round(remainderMs / MS_PER_SECOND);
  if (secondsValue > 0) {
    return {
      text: `${secondsValue} ${formatUnitLabel(secondsValue, "second")}`,
      usedUnit: "second"
    };
  }
  return null;
}
function formatCompositeDuration(ms, primaryUnit) {
  var _a;
  const positiveMs = Math.max(0, ms);
  const primary = buildPrimaryComponent(positiveMs, primaryUnit);
  const parts = [primary.text];
  const nextUnit = (_a = ELAPSED_UNIT_SEQUENCE[primary.usedUnit]) == null ? void 0 : _a.next;
  const secondary = buildSecondaryComponent(primary.remainderMs, nextUnit);
  if (secondary) {
    parts.push(secondary.text);
  }
  return parts.join(" + ");
}
function pickAutoElapsedUnit(ms) {
  if (ms < MS_PER_MINUTE) {
    return "second";
  }
  if (ms < MS_PER_HOUR) {
    return "minute";
  }
  if (ms < MS_PER_DAY) {
    return "hour";
  }
  if (ms < MS_PER_WEEK) {
    return "day";
  }
  if (ms < MS_PER_WEEK * 8) {
    return "week";
  }
  if (ms < MS_PER_MONTH * 24) {
    return "month";
  }
  return "year";
}
function formatElapsedTime(ms, clickCount = 0) {
  if (!Number.isFinite(ms)) {
    return "0 minutes";
  }
  const safeMs = Math.max(0, Math.abs(ms));
  if (safeMs === 0) {
    return "0 minutes";
  }
  const unitIndex = (clickCount % 5 + 5) % 5;
  let unit;
  switch (unitIndex) {
    case 0:
      unit = pickAutoElapsedUnit(safeMs);
      break;
    case 1:
      unit = "hour";
      break;
    case 2:
      unit = "day";
      break;
    case 3:
      unit = "week";
      break;
    case 4:
    default:
      unit = "month";
      break;
  }
  return formatCompositeDuration(safeMs, unit);
}
function dateToAngle(date) {
  const startOfYear = new Date(date.getFullYear(), 0, 1);
  const dayOfYear = (date.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24);
  const daysInYear = (new Date(date.getFullYear(), 11, 31).getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24) + 1;
  const progress = dayOfYear / daysInYear;
  return progress * 2 * Math.PI - Math.PI / 2;
}
function isOverdueDateString(dueString, today = /* @__PURE__ */ new Date()) {
  if (!dueString || typeof dueString !== "string") return false;
  const parts = dueString.split("-").map(Number);
  if (parts.length !== 3 || parts.some((n) => isNaN(n))) return false;
  const [dueYear, dueMonth1, dueDay] = parts;
  const dueMonth = dueMonth1 - 1;
  const todayY = today.getFullYear();
  const todayM = today.getMonth();
  const todayD = today.getDate();
  if (dueYear < todayY) return true;
  if (dueYear > todayY) return false;
  if (dueMonth < todayM) return true;
  if (dueMonth > todayM) return false;
  return dueDay < todayD;
}
function formatDurationValue(value) {
  if (Number.isNaN(value)) return "";
  if (Number.isInteger(value)) return value.toString();
  return value.toFixed(2).replace(/\.?0+$/, "");
}
function matchDurationDetail(duration) {
  if (!duration || typeof duration !== "string") return null;
  const trimmed = duration.trim().toLowerCase();
  if (!trimmed) return null;
  const match = trimmed.match(/^([\d.]+)\s*([a-z]+)$/);
  if (!match) return null;
  const numeric = parseFloat(match[1]);
  if (!Number.isFinite(numeric) || numeric < 0) return null;
  const unitAlias = match[2];
  const unitDef = DURATION_UNIT_ALIAS_MAP.get(unitAlias);
  if (!unitDef) return null;
  return { value: numeric, valueText: match[1], unit: unitDef };
}
function parseDuration(duration) {
  if (!duration || typeof duration !== "string") return null;
  const trimmed = duration.trim().toLowerCase();
  if (trimmed === "" || trimmed === "0") return 0;
  const match = matchDurationDetail(duration);
  if (!match) return null;
  if (match.value === 0) return 0;
  return match.value * match.unit.multiplier;
}
function parseDurationDetail(duration) {
  const match = matchDurationDetail(duration);
  if (!match) return null;
  if (match.value <= 0) return null;
  return {
    value: match.value,
    valueText: formatDurationValue(match.value),
    unitKey: match.unit.key,
    unitSingular: match.unit.singular,
    unitPlural: match.unit.plural,
    ms: match.value * match.unit.multiplier
  };
}
function durationSelectionToMs(selection) {
  if (!selection || selection === "auto") return null;
  const [valuePart, unitKey] = selection.split("|");
  if (!valuePart || !unitKey) return null;
  const value = parseFloat(valuePart);
  if (!Number.isFinite(value) || value <= 0) return null;
  const unitDef = DURATION_UNIT_DEFINITIONS.find((def) => def.key === unitKey);
  if (!unitDef) return null;
  return value * unitDef.multiplier;
}
function formatDurationSelectionLabel(selection) {
  if (!selection || selection === "auto") return null;
  const [valuePart, unitKey] = selection.split("|");
  if (!valuePart || !unitKey) return null;
  const value = parseFloat(valuePart);
  if (!Number.isFinite(value) || value <= 0) return null;
  const unitDef = DURATION_UNIT_DEFINITIONS.find((def) => def.key === unitKey);
  if (!unitDef) return null;
  const formattedValue = formatDurationValue(value);
  const unitLabel = value === 1 ? unitDef.singular : unitDef.plural;
  return `${formattedValue} ${unitLabel}`;
}
function prepareScenesForDiscontinuityDetection(scenes) {
  const uniqueScenesMap = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    if (scene.itemType !== "Scene") return;
    if (!(scene.when instanceof Date)) return;
    const key = scene.path || `title:${scene.title || ""}`;
    if (!uniqueScenesMap.has(key)) {
      uniqueScenesMap.set(key, { when: scene.when });
    }
  });
  const uniqueScenes = Array.from(uniqueScenesMap.values());
  return uniqueScenes.sort((a, b) => a.when.getTime() - b.when.getTime());
}
function calculateAutoDiscontinuityThreshold(scenes) {
  const preparedScenes = prepareScenesForDiscontinuityDetection(scenes);
  if (preparedScenes.length < 3) {
    return null;
  }
  const gaps = [];
  for (let i = 1; i < preparedScenes.length; i++) {
    const gap = preparedScenes[i].when.getTime() - preparedScenes[i - 1].when.getTime();
    if (gap >= 0) {
      gaps.push(gap);
    }
  }
  if (gaps.length === 0) {
    return null;
  }
  const sortedGaps = [...gaps].sort((a, b) => a - b);
  const medianIndex = Math.floor(sortedGaps.length / 2);
  const medianGap = sortedGaps[medianIndex];
  if (medianGap === 0) {
    const nonZeroGaps = sortedGaps.filter((g) => g > 0);
    if (nonZeroGaps.length === 0) {
      return null;
    }
    const nonZeroMedianIndex = Math.floor(nonZeroGaps.length / 2);
    const nonZeroMedian = nonZeroGaps[nonZeroMedianIndex];
    return nonZeroMedian * 3;
  }
  return medianGap * 3;
}
function detectDiscontinuities(scenes, thresholdMs) {
  if (scenes.length < 3) {
    return [];
  }
  if (!thresholdMs || thresholdMs <= 0) {
    return [];
  }
  const discontinuityIndices = [];
  for (let i = 1; i < scenes.length; i++) {
    const prev = scenes[i - 1].when;
    const curr = scenes[i].when;
    if (prev && curr) {
      const gap = curr.getTime() - prev.getTime();
      if (gap >= 0 && gap >= thresholdMs) {
        discontinuityIndices.push(i);
      }
    }
  }
  return discontinuityIndices;
}
function detectSceneOverlaps(scenes) {
  const overlaps = /* @__PURE__ */ new Set();
  for (let i = 0; i < scenes.length - 1; i++) {
    const current = scenes[i];
    const next = scenes[i + 1];
    if (!current.when || !next.when) continue;
    const durationMs = parseDuration(current.Duration);
    if (durationMs === null || durationMs === 0) continue;
    const currentEnd = current.when.getTime() + durationMs;
    const nextStart = next.when.getTime();
    if (currentEnd > nextStart) {
      overlaps.add(i);
    }
  }
  return overlaps;
}
function generateChronologicalTicks(scenes, sceneStartAngles, sceneAngularSize, timeSpan) {
  const validScenes = [];
  scenes.forEach((s, idx) => {
    if (s.when && !isNaN(s.when.getTime())) {
      validScenes.push({ date: s.when, sortedIndex: idx });
    }
  });
  if (validScenes.length === 0) {
    return [];
  }
  const validDates = validScenes.map((s) => s.date);
  const span = timeSpan || calculateTimeSpan(validDates);
  const earliestDate = validDates[0];
  if (validScenes.length === 1) {
    const singleDate = validScenes[0].date;
    const month = singleDate.toLocaleString("en-US", { month: "short" });
    const day = singleDate.getDate();
    const year = singleDate.getFullYear();
    const dateLabel = `${month} ${day}, ${year}`;
    return [{
      angle: -Math.PI / 2,
      // Top of circle
      name: dateLabel,
      shortName: dateLabel,
      isMajor: true
    }];
  }
  const ticks = [];
  const numScenes = validScenes.length;
  const getSceneStartAngle = (sortedIndex) => {
    if (sceneStartAngles && sceneStartAngles[sortedIndex] !== void 0) {
      return sceneStartAngles[sortedIndex];
    }
    const anglePerScene = 2 * Math.PI / numScenes;
    return -Math.PI / 2 + sortedIndex * anglePerScene;
  };
  const firstScene = validScenes[0];
  const lastScene = validScenes[numScenes - 1];
  const firstAngle = getSceneStartAngle(firstScene.sortedIndex);
  const lastAngle = getSceneStartAngle(lastScene.sortedIndex);
  const MAX_MAJOR_TICKS = 20;
  let step = 1;
  let numMajorTicks = numScenes;
  if (numScenes > MAX_MAJOR_TICKS) {
    step = Math.ceil(numScenes / MAX_MAJOR_TICKS);
    let bestStep = step;
    let bestMajorCount = Math.ceil((numScenes - 1) / step) + 1;
    for (let testStep = step; testStep >= 1; testStep--) {
      const testMajorCount = Math.ceil((numScenes - 1) / testStep) + 1;
      if (testMajorCount <= MAX_MAJOR_TICKS && (numScenes - 1) % testStep === 0) {
        bestStep = testStep;
        bestMajorCount = testMajorCount;
        break;
      }
    }
    step = bestStep;
    numMajorTicks = bestMajorCount;
  }
  const promoteSet = /* @__PURE__ */ new Set();
  promoteSet.add(0);
  promoteSet.add(numScenes - 1);
  for (let i = step; i < numScenes - 1; i += step) {
    promoteSet.add(i);
  }
  const angleDiff = Math.abs(lastAngle - firstAngle);
  const normalizedDiff = Math.min(angleDiff, Math.abs(angleDiff - 2 * Math.PI));
  const wouldOverlap = normalizedDiff < 0.01 || normalizedDiff > 2 * Math.PI - 0.01;
  const sceneGaps = [];
  for (let i = 0; i < validScenes.length; i++) {
    if (i === 0) {
      sceneGaps.push(0);
    } else {
      const gapMs = validScenes[i].date.getTime() - validScenes[i - 1].date.getTime();
      sceneGaps.push(gapMs);
    }
  }
  const generateLabel = (sceneDate, sceneIndex, isFirst, isLast) => {
    const formatTime12Hour = (date) => {
      const hour = date.getHours();
      const minute = date.getMinutes();
      if (hour === 12 && minute === 0) {
        return "noon";
      } else if (hour === 0 && minute === 0) {
        return "midnight";
      }
      const ampm = hour >= 12 ? "pm" : "am";
      const displayHour = hour % 12 || 12;
      const minuteStr = minute.toString().padStart(2, "0");
      return `${displayHour}:${minuteStr}${ampm}`;
    };
    const month = sceneDate.toLocaleString("en-US", { month: "short" });
    const day = sceneDate.getDate();
    const year = sceneDate.getFullYear();
    const timeStr = formatTime12Hour(sceneDate);
    const gapMs = sceneGaps[sceneIndex];
    const gapHours = gapMs / (1e3 * 60 * 60);
    const gapDays = gapHours / 24;
    if (isFirst) {
      const totalSpanHours = span.hours;
      if (totalSpanHours < 48) {
        return { name: `${month} ${day}
${timeStr}`, shortName: `${month} ${day}
${timeStr}` };
      } else {
        return { name: `${year}
${month} ${day}`, shortName: `${year}
${month} ${day}` };
      }
    }
    if (isLast) {
      const totalSpanHours = span.hours;
      if (totalSpanHours < 48) {
        return { name: `${month} ${day}
${timeStr}`, shortName: `${month} ${day}
${timeStr}` };
      } else {
        return { name: `${year}
${month} ${day}`, shortName: `${year}
${month} ${day}` };
      }
    }
    if (gapHours < 6) {
      return { name: timeStr, shortName: timeStr };
    } else if (gapHours < 48) {
      return { name: `${month} ${day}
${timeStr}`, shortName: `${month} ${day}
${timeStr}` };
    } else {
      return { name: `${month} ${day}`, shortName: `${month} ${day}` };
    }
  };
  let lastLabeledSceneDate = null;
  for (let i = 0; i < numScenes; i++) {
    const scene = validScenes[i];
    const sceneStartAngle = getSceneStartAngle(scene.sortedIndex);
    let gapFromLastLabel = 0;
    if (lastLabeledSceneDate !== null) {
      gapFromLastLabel = scene.date.getTime() - lastLabeledSceneDate.getTime();
    }
    if (i === 0) {
      sceneGaps[i] = 0;
    } else if (lastLabeledSceneDate === null) {
      sceneGaps[i] = 0;
    } else {
      sceneGaps[i] = gapFromLastLabel;
    }
    if (i === 0) {
      const labels = generateLabel(scene.date, i, true, false);
      ticks.push({
        angle: sceneStartAngle,
        name: labels.name,
        shortName: labels.shortName,
        isMajor: true,
        isFirst: true,
        sceneIndex: scene.sortedIndex
      });
      lastLabeledSceneDate = scene.date;
    } else if (i === numScenes - 1) {
      let tickAngle = sceneStartAngle;
      if (wouldOverlap && sceneAngularSize !== void 0) {
        tickAngle = sceneStartAngle + sceneAngularSize;
        if (tickAngle > Math.PI) tickAngle -= 2 * Math.PI;
      }
      const labels = generateLabel(scene.date, i, false, true);
      ticks.push({
        angle: tickAngle,
        name: labels.name,
        shortName: labels.shortName,
        isMajor: true,
        isLast: true,
        sceneIndex: scene.sortedIndex
      });
      lastLabeledSceneDate = scene.date;
    } else if (promoteSet.has(i)) {
      const labels = generateLabel(scene.date, i, false, false);
      ticks.push({
        angle: sceneStartAngle,
        name: labels.name,
        shortName: labels.shortName,
        isMajor: true,
        sceneIndex: scene.sortedIndex
      });
      lastLabeledSceneDate = scene.date;
    } else {
      ticks.push({
        angle: sceneStartAngle,
        name: "",
        shortName: "",
        isMajor: false,
        sceneIndex: scene.sortedIndex
      });
    }
  }
  const hasMinorTicks = ticks.some((tick) => tick.isMajor === false);
  if (!hasMinorTicks && ticks.length > 1) {
    const SYNTHETIC_INTERVAL = Math.PI / 24;
    const MAX_SYNTHETIC_PER_GAP = 12;
    const majorTicks = ticks.filter((tick) => tick.isMajor !== false).map((tick) => ({
      tick,
      positiveAngle: normalizeAnglePositive(tick.angle)
    })).sort((a, b) => a.positiveAngle - b.positiveAngle);
    const syntheticTicks = [];
    for (let i = 0; i < majorTicks.length; i++) {
      const current = majorTicks[i];
      const next = majorTicks[(i + 1) % majorTicks.length];
      let start = current.positiveAngle;
      let end = next.positiveAngle;
      if (i === majorTicks.length - 1 || end <= start) {
        end += Math.PI * 2;
      }
      const gap = end - start;
      const subdivisions = Math.min(MAX_SYNTHETIC_PER_GAP + 1, Math.floor(gap / SYNTHETIC_INTERVAL));
      for (let step2 = 1; step2 < subdivisions; step2++) {
        const anglePositive = start + gap * step2 / subdivisions;
        let angle = normalizeAngleCanonical(anglePositive);
        if (Math.abs(angle - current.tick.angle) < 1e-3 || Math.abs(angle - next.tick.angle) < 1e-3) {
          continue;
        }
        syntheticTicks.push({
          angle,
          name: "",
          shortName: "",
          isMajor: false
        });
      }
    }
    if (syntheticTicks.length > 0) {
      ticks.push(...syntheticTicks);
      ticks.sort((a, b) => normalizeAngleCanonical(a.angle) - normalizeAngleCanonical(b.angle));
    }
  }
  return ticks;
}
function normalizeAngleCanonical(angle) {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized <= -Math.PI) {
    normalized += twoPi;
  } else if (normalized > Math.PI) {
    normalized -= twoPi;
  }
  return normalized;
}
function normalizeAnglePositive(angle) {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized < 0) {
    normalized += twoPi;
  }
  return normalized;
}
var MONTH_NAME_MAP, MS_PER_SECOND, MS_PER_MINUTE, MS_PER_HOUR, MS_PER_DAY, MS_PER_WEEK, MS_PER_MONTH, MS_PER_YEAR, ELAPSED_TIME_UNIT_LABELS, ELAPSED_UNIT_SEQUENCE, DURATION_UNIT_DEFINITIONS, DURATION_UNIT_ALIAS_MAP;
var init_date = __esm({
  "src/utils/date.ts"() {
    MONTH_NAME_MAP = {
      january: 0,
      jan: 0,
      february: 1,
      feb: 1,
      march: 2,
      mar: 2,
      april: 3,
      apr: 3,
      may: 4,
      june: 5,
      jun: 5,
      july: 6,
      jul: 6,
      august: 7,
      aug: 7,
      september: 8,
      sept: 8,
      sep: 8,
      october: 9,
      oct: 9,
      november: 10,
      nov: 10,
      december: 11,
      dec: 11
    };
    MS_PER_SECOND = 1e3;
    MS_PER_MINUTE = 60 * MS_PER_SECOND;
    MS_PER_HOUR = 60 * MS_PER_MINUTE;
    MS_PER_DAY = 24 * MS_PER_HOUR;
    MS_PER_WEEK = 7 * MS_PER_DAY;
    MS_PER_MONTH = 30.44 * MS_PER_DAY;
    MS_PER_YEAR = 365.25 * MS_PER_DAY;
    ELAPSED_TIME_UNIT_LABELS = {
      second: { singular: "second", plural: "seconds" },
      minute: { singular: "minute", plural: "minutes" },
      hour: { singular: "hour", plural: "hours" },
      day: { singular: "day", plural: "days" },
      week: { singular: "week", plural: "weeks" },
      month: { singular: "month", plural: "months" },
      year: { singular: "year", plural: "years" }
    };
    ELAPSED_UNIT_SEQUENCE = {
      year: { ms: MS_PER_YEAR, next: "month" },
      month: { ms: MS_PER_MONTH, next: "day" },
      week: { ms: MS_PER_WEEK, next: "day" },
      day: { ms: MS_PER_DAY, next: "hour" },
      hour: { ms: MS_PER_HOUR, next: "minute" },
      minute: { ms: MS_PER_MINUTE, next: "second" },
      second: { ms: MS_PER_SECOND }
    };
    DURATION_UNIT_DEFINITIONS = [
      { key: "seconds", aliases: ["s", "sec", "secs", "second", "seconds"], multiplier: MS_PER_SECOND, singular: "second", plural: "seconds" },
      { key: "minutes", aliases: ["m", "min", "mins", "minute", "minutes"], multiplier: MS_PER_MINUTE, singular: "minute", plural: "minutes" },
      { key: "hours", aliases: ["h", "hr", "hrs", "hour", "hours"], multiplier: MS_PER_HOUR, singular: "hour", plural: "hours" },
      { key: "days", aliases: ["d", "day", "days"], multiplier: MS_PER_DAY, singular: "day", plural: "days" },
      { key: "weeks", aliases: ["w", "wk", "wks", "week", "weeks"], multiplier: MS_PER_WEEK, singular: "week", plural: "weeks" },
      { key: "months", aliases: ["mo", "mon", "mos", "month", "months"], multiplier: MS_PER_MONTH, singular: "month", plural: "months" },
      { key: "years", aliases: ["y", "yr", "yrs", "year", "years"], multiplier: MS_PER_YEAR, singular: "year", plural: "years" }
    ];
    DURATION_UNIT_ALIAS_MAP = /* @__PURE__ */ new Map();
    DURATION_UNIT_DEFINITIONS.forEach((def) => {
      def.aliases.forEach((alias) => DURATION_UNIT_ALIAS_MAP.set(alias, def));
    });
  }
});

// src/utils/sceneHelpers.ts
var sceneHelpers_exports = {};
__export(sceneHelpers_exports, {
  buildSquareClasses: () => buildSquareClasses,
  buildTextClasses: () => buildTextClasses,
  extractGradeFromScene: () => extractGradeFromScene,
  extractPosition: () => extractPosition,
  getSceneState: () => getSceneState,
  isBeatNote: () => isBeatNote,
  isStoryBeat: () => isStoryBeat,
  normalizeBooleanValue: () => normalizeBooleanValue,
  shouldDisplayMissingWhenWarning: () => shouldDisplayMissingWhenWarning,
  sortByManuscriptOrder: () => sortByManuscriptOrder,
  sortScenes: () => sortScenes,
  sortScenesChronologically: () => sortScenesChronologically
});
function normalizeBooleanValue(value) {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    const lower = value.toLowerCase().trim();
    if (lower === "" || lower === " ") {
      return false;
    }
    return lower === "yes" || lower === "true" || lower === "1";
  }
  if (typeof value === "number") {
    return value === 1;
  }
  return false;
}
function isStoryBeat(classValue) {
  if (typeof classValue !== "string") return false;
  const normalized = classValue.toLowerCase().trim();
  return normalized === "plot" || normalized === "beat";
}
function isBeatNote(scene) {
  return scene.itemType === "Beat" || scene.itemType === "Plot";
}
function sortScenes(scenes, sortByWhen, forceChronological = false) {
  if (!forceChronological && !sortByWhen) {
    return scenes.slice().sort(sortByManuscriptOrder);
  }
  return sortScenesChronologically(scenes);
}
function extractGradeFromScene(scene, sceneId, sceneGrades, plugin) {
  if (!plugin.settings.enableAiSceneAnalysis) return;
  const analysisText = scene["currentSceneAnalysis"];
  if (!analysisText) return;
  try {
    const firstLine = typeof analysisText === "string" ? analysisText.substring(0, analysisText.indexOf("\n") > -1 ? analysisText.indexOf("\n") : analysisText.length).trim() : "";
    if (!firstLine) return;
    const gradeMatch = firstLine.match(/^-?\s*(?:\d+(?:\.\d+)?\s+)?([ABC])(?![A-Za-z0-9])/i);
    if (gradeMatch && gradeMatch[1]) {
      sceneGrades.set(sceneId, gradeMatch[1].toUpperCase());
    }
  } catch (e) {
  }
}
function getSceneState(scene, plugin) {
  const isSceneOpen = !!(scene.path && plugin.openScenePaths.has(scene.path));
  const isSearchMatch = !!(plugin.searchActive && scene.path && plugin.searchResults.has(scene.path));
  const hasEdits = !!(scene.pendingEdits && scene.pendingEdits.trim() !== "");
  return { isSceneOpen, isSearchMatch, hasEdits };
}
function buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits) {
  let classes = "rt-number-square";
  if (isSceneOpen) classes += " rt-scene-is-open";
  if (isSearchMatch) classes += " rt-search-result";
  if (hasEdits) classes += " rt-has-edits";
  return classes;
}
function buildTextClasses(isSceneOpen, isSearchMatch, hasEdits) {
  let classes = "rt-number-text";
  if (isSceneOpen) classes += " rt-scene-is-open";
  if (isSearchMatch) classes += " rt-search-result";
  if (hasEdits) classes += " rt-has-edits";
  return classes;
}
function normalizeStatusValue(status) {
  if (!status) return null;
  if (Array.isArray(status)) {
    for (const entry of status) {
      if (typeof entry === "string") {
        const trimmed = entry.trim();
        if (trimmed) return trimmed;
      }
    }
    return null;
  }
  if (typeof status === "string") {
    const trimmed = status.trim();
    return trimmed || null;
  }
  return null;
}
function shouldDisplayMissingWhenWarning(scene) {
  if (!scene || !scene.missingWhen) return false;
  const normalizedStatus = normalizeStatusValue(scene.status);
  if (!normalizedStatus) return false;
  return STATUSES_REQUIRING_WHEN.has(normalizedStatus.toLowerCase());
}
function sortScenesChronologically(scenes) {
  return scenes.slice().sort((a, b) => {
    const aWhen = a.when instanceof Date ? a.when : parseWhenField(typeof a.when === "string" ? a.when : "");
    const bWhen = b.when instanceof Date ? b.when : parseWhenField(typeof b.when === "string" ? b.when : "");
    const aHasWhen = !!(aWhen && !isNaN(aWhen.getTime()));
    const bHasWhen = !!(bWhen && !isNaN(bWhen.getTime()));
    if (aHasWhen && bHasWhen && aWhen && bWhen) {
      const timeDiff = aWhen.getTime() - bWhen.getTime();
      if (timeDiff !== 0) return timeDiff;
      return sortByManuscriptOrder(a, b);
    }
    if (!aHasWhen && !bHasWhen) {
      return sortByManuscriptOrder(a, b);
    }
    if (!aHasWhen && bHasWhen) return -1;
    if (aHasWhen && !bHasWhen) return 1;
    return 0;
  });
}
function extractPosition(item) {
  const title = item.title || "";
  const prefixMatch = title.match(/^(\d+(?:\.\d+)?)\s*/);
  if (prefixMatch) {
    return parseFloat(prefixMatch[1]);
  }
  return Infinity;
}
function sortByManuscriptOrder(a, b) {
  const aPos = extractPosition(a);
  const bPos = extractPosition(b);
  if (aPos !== bPos) {
    if (aPos === Infinity && bPos === Infinity) {
      return (a.title || "").localeCompare(b.title || "");
    }
    return aPos - bPos;
  }
  return (a.title || "").localeCompare(b.title || "");
}
var STATUSES_REQUIRING_WHEN;
var init_sceneHelpers = __esm({
  "src/utils/sceneHelpers.ts"() {
    init_date();
    STATUSES_REQUIRING_WHEN = /* @__PURE__ */ new Set(["working", "complete"]);
  }
});

// src/utils/manuscript.ts
var manuscript_exports = {};
__export(manuscript_exports, {
  assembleManuscript: () => assembleManuscript,
  countWords: () => countWords,
  estimateTokens: () => estimateTokens,
  extractBodyText: () => extractBodyText,
  getSortedSceneFiles: () => getSortedSceneFiles
});
function stripYamlFrontmatter(content) {
  const yamlPattern = /^---\s*\n([\s\S]*?)\n---\s*\n/;
  return content.replace(yamlPattern, "");
}
function stripObsidianComments(content) {
  content = content.replace(/%%.*?%%/g, "");
  content = content.replace(/%%[\s\S]*?%%/g, "");
  return content;
}
function extractBodyText(content) {
  let text = stripYamlFrontmatter(content);
  text = stripObsidianComments(text);
  return text.trim();
}
function countWords(text) {
  const words = text.split(/\s+/).filter((word) => word.length > 0);
  return words.length;
}
function estimateTokens(wordCount) {
  return Math.ceil(wordCount / 0.75);
}
async function getSortedSceneFiles(plugin) {
  var _a;
  const allScenes = await plugin.getSceneData();
  const uniquePaths = /* @__PURE__ */ new Set();
  const uniqueScenes = allScenes.filter((s) => {
    if (s.itemType === "Scene" && s.path && !uniquePaths.has(s.path)) {
      uniquePaths.add(s.path);
      return true;
    }
    return false;
  });
  const currentMode = plugin.settings.currentMode || "narrative";
  const isChronologueMode = currentMode === "chronologue";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  const forceChronological = isChronologueMode;
  const { sortScenes: sortScenes2 } = await Promise.resolve().then(() => (init_sceneHelpers(), sceneHelpers_exports));
  const sortedScenes = sortScenes2(uniqueScenes, sortByWhen, forceChronological);
  const sceneFiles = sortedScenes.map((s) => plugin.app.vault.getAbstractFileByPath(s.path)).filter((f) => f instanceof import_obsidian3.TFile);
  let sortOrder;
  if (isChronologueMode) {
    sortOrder = "Chronological (by When date/time)";
  } else {
    sortOrder = "Narrative (by scene title/number)";
  }
  return { files: sceneFiles, sortOrder };
}
function generateTableOfContents(scenes, totalWords, useObsidianLinks = false, sortOrder) {
  const tocLines = [
    "# TABLE OF CONTENTS",
    "",
    `Total Scenes: ${scenes.length} | Total Words: ${totalWords.toLocaleString()}`,
    ""
  ];
  if (sortOrder) {
    tocLines.push(`**Sort Order:** ${sortOrder}`);
    tocLines.push("");
    tocLines.push("Note: Narrative mode sorts scenes by scene title/number (for all scenes, main plot, and Gossamer modes). Chronologue mode sorts scenes chronologically by When date/time. These may produce the same order depending on your scene title structure.");
    tocLines.push("");
  }
  tocLines.push("---", "");
  scenes.forEach((scene, index) => {
    const sceneNum = index + 1;
    if (useObsidianLinks) {
      tocLines.push(`${sceneNum}. [[#${scene.title}]] (${scene.wordCount.toLocaleString()} words)`);
    } else {
      tocLines.push(`${sceneNum}. ${scene.title} (${scene.wordCount.toLocaleString()} words)`);
    }
  });
  tocLines.push("", "---", "", "");
  return tocLines.join("\n");
}
async function assembleManuscript(sceneFiles, vault, progressCallback, useObsidianLinks = false, sortOrder) {
  const scenes = [];
  const textParts = [];
  let totalWords = 0;
  for (let i = 0; i < sceneFiles.length; i++) {
    const file = sceneFiles[i];
    const title = file.basename;
    if (progressCallback) {
      progressCallback(i + 1, title, sceneFiles.length);
    }
    try {
      const content = await vault.read(file);
      const bodyText = extractBodyText(content);
      const wordCount = countWords(bodyText);
      scenes.push({ title, bodyText, wordCount });
      totalWords += wordCount;
      textParts.push(`## ${title}

${bodyText}

`);
    } catch (error) {
      console.error(`Error reading scene file ${file.path}:`, error);
      textParts.push(`## ${title}

[Error reading scene]

`);
    }
  }
  const toc = generateTableOfContents(scenes, totalWords, useObsidianLinks, sortOrder);
  const manuscriptText = toc + textParts.join("");
  return {
    text: manuscriptText,
    totalWords,
    totalScenes: sceneFiles.length,
    scenes,
    sortOrder
  };
}
var import_obsidian3;
var init_manuscript = __esm({
  "src/utils/manuscript.ts"() {
    import_obsidian3 = require("obsidian");
  }
});

// src/ai/prompts/unifiedBeatAnalysis.ts
function getUnifiedBeatAnalysisJsonSchema() {
  return UNIFIED_BEAT_ANALYSIS_SCHEMA;
}
function buildUnifiedBeatAnalysisPrompt(manuscriptText, beats, beatSystem) {
  const hasPreviousAnalysis = beats.some((b) => b.previousScore !== void 0);
  const beatList = beats.map((b, i) => {
    let line = `${i + 1}. ${b.beatName} (ideal momentum: ${b.idealRange})`;
    if (b.previousScore !== void 0) {
      line += `
   Previous Score: ${b.previousScore}/100`;
      if (b.previousJustification) {
        line += `
   Previous Justification: "${b.previousJustification}"`;
      }
    }
    return line;
  }).join("\n");
  const previousAnalysisSection = hasPreviousAnalysis ? `
ITERATIVE REFINEMENT:
Previous scores are shown above. Compare and adjust based on deeper understanding.

` : "";
  const prompt = `You are analyzing narrative momentum in a manuscript using the ${beatSystem} beat system.

BEAT STRUCTURE:
${beatList}

MOMENTUM SCALE (0-100):
- 0-20: Quiet, establishing, low tension
- 21-40: Building, complications emerging
- 41-60: Rising stakes, conflict developing
- 61-80: High tension, major conflicts
- 81-100: Peak tension, climactic moments

${previousAnalysisSection}YOUR TASK:
Use the table of contents to locate each beat. Read the manuscript and score the narrative momentum at each story beat.

- Assign momentum score (0-100) for tension/stakes at each beat
- Provide brief justification (one sentence)
- Consider: tension level, stakes, emotional intensity

Return ONLY valid JSON (no markdown, no preamble):

{
  "beats": [
    {
      "beatName": "Opening Image",
      "momentumScore": 15,
      "idealRange": "0-20",
      "isWithinRange": true,
      "justification": "Establishes quiet status quo before inciting incident"
    }
    // ... for each beat
  ],
  "overallAssessment": {
    "summary": "Brief assessment of overall momentum arc",
    "strengths": ["Strength 1", "Strength 2"],
    "improvements": ["Improvement 1", "Improvement 2"]
  }
}

MANUSCRIPT:

${manuscriptText}`;
  return prompt;
}
var UNIFIED_BEAT_ANALYSIS_SCHEMA;
var init_unifiedBeatAnalysis = __esm({
  "src/ai/prompts/unifiedBeatAnalysis.ts"() {
    UNIFIED_BEAT_ANALYSIS_SCHEMA = {
      type: "object",
      properties: {
        beats: {
          type: "array",
          description: "Momentum analysis for each story beat",
          items: {
            type: "object",
            properties: {
              beatName: {
                type: "string",
                description: "Name of the beat"
              },
              momentumScore: {
                type: "number",
                description: "Narrative momentum score 0-100",
                minimum: 0,
                maximum: 100
              },
              idealRange: {
                type: "string",
                description: "Ideal momentum range for this beat"
              },
              isWithinRange: {
                type: "boolean",
                description: "True if momentum score is within ideal range"
              },
              justification: {
                type: "string",
                description: "Brief justification for the score (one sentence)"
              }
            },
            required: ["beatName", "momentumScore", "idealRange", "isWithinRange", "justification"]
          }
        },
        overallAssessment: {
          type: "object",
          description: "Overall manuscript assessment",
          properties: {
            summary: {
              type: "string",
              description: "Brief summary of overall momentum (max 30 words)"
            },
            strengths: {
              type: "array",
              items: { type: "string" },
              description: "List of 2-3 strengths"
            },
            improvements: {
              type: "array",
              items: { type: "string" },
              description: "List of 2-3 suggested improvements"
            }
          },
          required: ["summary", "strengths", "improvements"]
        }
      },
      required: ["beats", "overallAssessment"]
    };
  }
});

// src/api/geminiApi.ts
async function callGeminiApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens = 4e3, temperature = 0.7, jsonSchema, disableThinking = false) {
  var _a, _b, _c, _d, _e, _f, _g;
  if (!apiKey) {
    return { success: false, content: null, responseData: { error: { message: "Gemini API key not configured." } }, error: "Gemini API key not configured." };
  }
  if (!modelId) {
    return { success: false, content: null, responseData: { error: { message: "Gemini model ID not configured." } }, error: "Gemini model ID not configured." };
  }
  const url = `https://generativelanguage.googleapis.com/v1beta/models/${encodeURIComponent(modelId)}:generateContent?key=${encodeURIComponent(apiKey)}`;
  const body = {
    contents: [
      {
        role: "user",
        parts: [{ text: userPrompt }]
      }
    ],
    generationConfig: {
      temperature
    }
  };
  if (systemPrompt) {
    body.systemInstruction = { parts: [{ text: systemPrompt }] };
  }
  if (maxTokens !== null) {
    body.generationConfig.maxOutputTokens = maxTokens;
  }
  if (disableThinking) {
    body.generationConfig.thinkingConfig = { mode: "NONE" };
  }
  if (jsonSchema) {
    body.generationConfig.responseMimeType = "application/json";
    body.generationConfig.responseSchema = jsonSchema;
  }
  let responseData;
  try {
    const resp = await (0, import_obsidian4.requestUrl)({
      url,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
      throw: false
    });
    responseData = resp.json;
    if (resp.status >= 400) {
      const err = responseData;
      const msg = (_c = (_b = (_a = err == null ? void 0 : err.error) == null ? void 0 : _a.message) != null ? _b : resp.text) != null ? _c : `Gemini error (${resp.status})`;
      return { success: false, content: null, responseData, error: msg };
    }
    const success = responseData;
    if ((success == null ? void 0 : success.promptFeedback) && success.promptFeedback.blockReason) {
      const reason = success.promptFeedback.blockReason;
      return { success: false, content: null, responseData, error: `Gemini safety blocked: ${reason}` };
    }
    const candidate = (_d = success == null ? void 0 : success.candidates) == null ? void 0 : _d[0];
    if (candidate == null ? void 0 : candidate.finishReason) {
      if (candidate.finishReason === "MAX_TOKENS") {
        return {
          success: false,
          content: null,
          responseData,
          error: "Response exceeded maximum token limit. The output was truncated before completion. Try reducing the manuscript size or increasing maxOutputTokens."
        };
      }
      if (candidate.finishReason === "SAFETY") {
        return {
          success: false,
          content: null,
          responseData,
          error: "Response blocked by Gemini safety filters."
        };
      }
      if (candidate.finishReason === "RECITATION") {
        return {
          success: false,
          content: null,
          responseData,
          error: "Response blocked due to recitation concerns."
        };
      }
    }
    const text = (_f = (_e = candidate == null ? void 0 : candidate.content) == null ? void 0 : _e.parts) == null ? void 0 : _f.map((p) => p.text || "").join("").trim();
    if (text) return { success: true, content: text, responseData };
    console.error("[Gemini API] Invalid response structure:", {
      hasCandidates: !!(success == null ? void 0 : success.candidates),
      candidatesLength: ((_g = success == null ? void 0 : success.candidates) == null ? void 0 : _g.length) || 0,
      finishReason: candidate == null ? void 0 : candidate.finishReason
    });
    return { success: false, content: null, responseData, error: "Invalid response structure from Gemini." };
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    responseData = { error: { message: msg } };
    return { success: false, content: null, responseData, error: msg };
  }
}
async function fetchGeminiModels(apiKey) {
  if (!apiKey) throw new Error("Gemini API key is required to fetch models.");
  const url = `https://generativelanguage.googleapis.com/v1beta/models?key=${encodeURIComponent(apiKey)}`;
  const resp = await (0, import_obsidian4.requestUrl)({ url, method: "GET", throw: false });
  const data = resp.json;
  if (resp.status >= 400 || !Array.isArray(data == null ? void 0 : data.models)) {
    throw new Error(`Error fetching Gemini models (${resp.status})`);
  }
  const mapped = data.models.map((m) => {
    var _a;
    const id = ((_a = m.name) == null ? void 0 : _a.includes("/")) ? m.name.split("/").pop() || m.name : m.name;
    return { id, name: m.displayName || id };
  });
  return mapped.sort((a, b) => a.id.localeCompare(b.id));
}
var import_obsidian4;
var init_geminiApi = __esm({
  "src/api/geminiApi.ts"() {
    import_obsidian4 = require("obsidian");
  }
});

// src/GossamerCommands.ts
var GossamerCommands_exports = {};
__export(GossamerCommands_exports, {
  getActiveGossamerRun: () => getActiveGossamerRun,
  openGossamerScoreEntry: () => openGossamerScoreEntry,
  parseScoresFromClipboard: () => parseScoresFromClipboard,
  resetGossamerModeState: () => resetGossamerModeState,
  resetRotation: () => resetRotation,
  restoreBaseMode: () => restoreBaseMode,
  runGossamerAiAnalysis: () => runGossamerAiAnalysis,
  setBaseModeAllScenes: () => setBaseModeAllScenes,
  toggleGossamerMode: () => toggleGossamerMode
});
function parseScoresFromClipboard(clipboardText) {
  const scores = /* @__PURE__ */ new Map();
  const simpleFormatRegex = /(\d+)\s*:\s*(\d+)/g;
  const simpleMatches = Array.from(clipboardText.matchAll(simpleFormatRegex));
  if (simpleMatches.length > 0) {
    for (const match2 of simpleMatches) {
      const position = parseInt(match2[1]);
      const score = parseInt(match2[2]);
      if (!isNaN(position) && !isNaN(score) && score >= 0 && score <= 100) {
        scores.set(`__position_${position}`, score);
      }
    }
    return scores;
  }
  const lineRegex = /^(.+?):\s*(\d+)\s*$/gm;
  let match;
  while ((match = lineRegex.exec(clipboardText)) !== null) {
    const beatName = match[1].trim();
    const score = parseInt(match[2]);
    if (!isNaN(score) && score >= 0 && score <= 100) {
      scores.set(beatName, score);
      const normalizedBeat = normalizeBeatName(beatName);
      scores.set(normalizedBeat, score);
      const withoutNumber = beatName.replace(/^\d+\.?\s*/, "").trim();
      if (withoutNumber !== beatName) {
        scores.set(withoutNumber, score);
        scores.set(normalizeBeatName(withoutNumber), score);
      }
      const withoutPercent = beatName.replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").trim();
      if (withoutPercent !== beatName) {
        scores.set(withoutPercent, score);
        scores.set(normalizeBeatName(withoutPercent), score);
      }
      const withoutNumberAndPercent = beatName.replace(/^\d+\.?\s*/, "").replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").trim();
      if (withoutNumberAndPercent !== beatName && withoutNumberAndPercent !== withoutNumber && withoutNumberAndPercent !== withoutPercent) {
        scores.set(withoutNumberAndPercent, score);
        scores.set(normalizeBeatName(withoutNumberAndPercent), score);
      }
      const coreBeatName = beatName.replace(/^\d+\.?\s*/, "").replace(/\s*\d+(?:\s*-\s*\d+)?\s*%?\s*$/i, "").replace(/\s+of\s+/gi, " ").trim();
      if (coreBeatName !== beatName && coreBeatName !== withoutNumber && coreBeatName !== withoutPercent && coreBeatName !== withoutNumberAndPercent) {
        scores.set(coreBeatName, score);
        scores.set(normalizeBeatName(coreBeatName), score);
      }
    }
  }
  return scores;
}
function setInMemoryRun(plugin, run) {
  lastRunByPlugin.set(plugin, run);
  plugin._gossamerLastRun = run;
}
async function openGossamerScoreEntry(plugin) {
  const scenes = await plugin.getSceneData();
  const plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
  if (plotBeats.length === 0) {
    new import_obsidian5.Notice('No story beats found. Create notes with frontmatter "Class: Beat" (or "Class: Plot" deprecated).');
    return;
  }
  const modal = new GossamerScoreModal(plugin.app, plugin, plotBeats);
  modal.open();
}
function getActiveGossamerRun(plugin) {
  var _a;
  return (_a = lastRunByPlugin.get(plugin)) != null ? _a : null;
}
async function toggleGossamerMode(plugin) {
  var _a;
  const view = getFirstView(plugin);
  if (!view) return;
  const current = getInteractionMode(view) === "gossamer";
  if (current) {
    exitGossamerMode(plugin);
  } else {
    const scenes = await plugin.getSceneData();
    const beatNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
    if (beatNotes.length === 0) {
      new import_obsidian5.Notice('Cannot enter Gossamer mode: No story beats found. Create notes with frontmatter "Class: Beat" (or "Class: Plot" for backward compatibility).');
      return;
    }
    const selectedBeatModel = ((_a = plugin.settings.beatSystem) == null ? void 0 : _a.trim()) || void 0;
    const allRuns = buildAllGossamerRuns(scenes, selectedBeatModel);
    if (allRuns.current.beats.length === 0) {
      const systemMsg = selectedBeatModel ? ` with Beat Model: ${selectedBeatModel}` : "";
      new import_obsidian5.Notice(`Cannot enter Gossamer mode: No story beat notes found${systemMsg}. Create notes with Class: Beat (or Class: Plot for backward compatibility).`);
      return;
    }
    if (!allRuns.hasAnyScores) {
      new import_obsidian5.Notice('No Gossamer scores found. Showing ideal ranges and spokes. Add scores using "Gossamer enter momentum scores" command.');
    }
    setInMemoryRun(plugin, allRuns.current);
    plugin._gossamerHistoricalRuns = allRuns.historical;
    plugin._gossamerMinMax = allRuns.minMax;
    setBaseModeAllScenes(plugin);
    resetRotation(plugin);
    plugin.clearSearch();
    enterGossamerMode(plugin);
  }
}
async function enterGossamerMode(plugin) {
  var _a, _b;
  const view = getFirstView(plugin);
  if (!view) return;
  const modeManager = hasKey(view, "getModeManager") && typeof view.getModeManager === "function" ? view.getModeManager() : null;
  if (modeManager) {
    await modeManager.switchMode("gossamer" /* GOSSAMER */);
  } else {
    if (hasKey(view, "currentMode")) {
      view.currentMode = "gossamer";
    }
    plugin.settings.currentMode = "gossamer";
    plugin.saveSettings();
  }
  if (!modeManager) {
    const v = view;
    const svg = (_b = (_a = v == null ? void 0 : v.containerEl) == null ? void 0 : _a.querySelector) == null ? void 0 : _b.call(_a, ".radial-timeline-svg");
    let didSelective = false;
    try {
      const rs = plugin.getRendererService && plugin.getRendererService() || plugin.rendererService;
      if (rs && v) {
        v.sceneData = plugin.lastSceneData || v.sceneData;
        v.currentMode = "gossamer";
        const viewArg = {
          containerEl: v.containerEl,
          plugin,
          sceneData: v.sceneData,
          currentMode: "gossamer"
        };
        didSelective = rs.updateGossamerLayer(viewArg);
      }
      if (didSelective && svg) {
        svg.setAttribute("data-gossamer-mode", "true");
        const allElements = svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
        allElements.forEach((el) => {
          const group = el.closest(".rt-scene-group");
          const itemType = group == null ? void 0 : group.getAttribute("data-item-type");
          if (itemType !== "Beat") {
            el.classList.add("rt-non-selected");
          }
        });
        const modeToggle = svg.querySelector("#mode-toggle");
        if (modeToggle) {
          const originalMode = _previousBaseMode || "narrative";
          modeToggle.setAttribute("data-current-mode", originalMode);
          const title = modeToggle.querySelector("title");
          if (title) {
            title.textContent = originalMode === "allscenes" ? "Switch to Main Plot mode" : "Switch to All Scenes mode";
          }
        }
        const setup = v == null ? void 0 : v.setupGossamerEventListeners;
        if (typeof setup === "function") setup(svg);
      }
    } catch (e) {
    }
    if (!didSelective) {
      plugin.refreshTimelineIfNeeded(void 0);
    }
  }
}
async function exitGossamerMode(plugin) {
  var _a;
  if (_isExitingGossamer) {
    return;
  }
  const view = getFirstView(plugin);
  if (!view) {
    return;
  }
  _isExitingGossamer = true;
  const modeManager = hasKey(view, "getModeManager") && typeof view.getModeManager === "function" ? view.getModeManager() : null;
  if (modeManager) {
    const restoredMode2 = restoreBaseMode(plugin);
    await modeManager.switchMode(restoredMode2);
    window.setTimeout(() => {
      _isExitingGossamer = false;
    }, 100);
    return;
  }
  const svg = (_a = view == null ? void 0 : view.containerEl) == null ? void 0 : _a.querySelector(".radial-timeline-svg");
  if (svg) {
    const allElements = svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-subplot-ring-label-text");
    allElements.forEach((el) => el.classList.remove("rt-non-selected"));
    svg.removeAttribute("data-gossamer-mode");
  }
  if (svg && typeof view.removeGossamerEventListeners === "function") {
    view.removeGossamerEventListeners(svg);
  }
  const restoredMode = restoreBaseMode(plugin);
  if (hasKey(view, "currentMode")) {
    view.currentMode = restoredMode;
  }
  plugin.settings.currentMode = restoredMode;
  plugin.saveSettings();
  if (typeof view.refreshTimeline === "function") {
    view.refreshTimeline();
  } else {
    plugin.refreshTimelineIfNeeded(null);
  }
  window.setTimeout(() => {
    _isExitingGossamer = false;
  }, 100);
}
function setBaseModeAllScenes(plugin) {
  if (_previousBaseMode === null) {
    _previousBaseMode = plugin.settings.currentMode || "narrative";
  }
}
function restoreBaseMode(plugin) {
  if (_previousBaseMode !== null) {
    const mode = _previousBaseMode;
    _previousBaseMode = null;
    return mode;
  }
  return "narrative";
}
function resetGossamerModeState() {
  _previousBaseMode = null;
}
function resetRotation(plugin) {
  const views = getAllViews(plugin);
  if (!Array.isArray(views)) return;
  views.forEach((view) => {
    if (hasKey(view, "rotationState")) {
      view.rotationState = false;
    }
  });
}
function getAllViews(plugin) {
  const timelineService = plugin.timelineService;
  if (timelineService && typeof timelineService.getTimelineViews === "function") {
    return timelineService.getTimelineViews();
  }
  return null;
}
function getFirstView(plugin) {
  const timelineService = plugin.timelineService;
  if (timelineService && typeof timelineService.getFirstTimelineView === "function") {
    return timelineService.getFirstTimelineView();
  }
  const views = getAllViews(plugin);
  return views && views.length > 0 ? views[0] : null;
}
function hasKey(obj, key) {
  return typeof obj === "object" && obj !== null && key in obj;
}
function getInteractionMode(view) {
  if (hasKey(view, "currentMode")) {
    const val = view.currentMode;
    if (val === "narrative" || val === "gossamer" || val === "subplot") return val;
  }
  return void 0;
}
async function runGossamerAiAnalysis(plugin) {
  var _a;
  const settingsBeatSystem = plugin.settings.beatSystem || "Save The Cat";
  let beatSystemDisplayName = settingsBeatSystem;
  if (settingsBeatSystem === "Custom") {
    const scenes = await plugin.getSceneData({ filterBeatsBySystem: false });
    const allBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
    const recognizedSystems = ["Save The Cat", "Hero's Journey", "Story Grid"];
    for (const beat of allBeats) {
      if (!beat.path) continue;
      const file = plugin.app.vault.getAbstractFileByPath(beat.path);
      if (!file) continue;
      const cache = plugin.app.metadataCache.getFileCache(file);
      const beatModel = (_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a["Beat Model"];
      if (beatModel && !recognizedSystems.includes(beatModel)) {
        beatSystemDisplayName = beatModel;
        break;
      }
    }
  }
  const beatSystem = settingsBeatSystem;
  const processAnalysis = async (options, modal) => {
    var _a2;
    try {
      modal.setStatus("Validating configuration...");
      if (!plugin.settings.geminiApiKey || plugin.settings.geminiApiKey.trim() === "") {
        modal.addError("Gemini API key not configured. Go to Settings \u2192 AI \u2192 Gemini API key.");
        modal.completeProcessing(false, "Configuration error");
        new import_obsidian5.Notice("Gemini API key not configured. Go to Settings \u2192 AI \u2192 Gemini API key.");
        return;
      }
      modal.setStatus("Loading story beats...");
      const scenes = await plugin.getSceneData();
      let plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
      const { filterBeatsBySystem: filterBeatsBySystem2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
      if (beatSystem && beatSystem.trim() !== "" && plotBeats.some((p) => p["Beat Model"])) {
        plotBeats = filterBeatsBySystem2(plotBeats, beatSystem);
      }
      if (plotBeats.length === 0) {
        modal.addError('No story beats found. Create notes with frontmatter "Class: Beat".');
        modal.completeProcessing(false, "No beats found");
        new import_obsidian5.Notice('No story beats found. Create notes with frontmatter "Class: Beat".');
        return;
      }
      const beats = plotBeats.sort((a, b) => {
        const aMatch = (a.title || "").match(/^(\d+(?:\.\d+)?)/);
        const bMatch = (b.title || "").match(/^(\d+(?:\.\d+)?)/);
        const aNum = aMatch ? parseFloat(aMatch[1]) : 0;
        const bNum = bMatch ? parseFloat(bMatch[1]) : 0;
        return aNum - bNum;
      }).map((beat, index) => {
        const beatData = beat;
        const file = plugin.app.vault.getAbstractFileByPath(beat.path || "");
        const cache = file ? plugin.app.metadataCache.getFileCache(file) : null;
        const fm = cache == null ? void 0 : cache.frontmatter;
        const rangeValue = typeof (fm == null ? void 0 : fm.Range) === "string" ? fm.Range : "0-100";
        return {
          beatName: (beat.title || "Unknown Beat").replace(/^\d+(?:\.\d+)?\s+/, ""),
          beatNumber: index + 1,
          idealRange: rangeValue,
          previousScore: typeof beatData.Gossamer1 === "number" ? beatData.Gossamer1 : void 0,
          previousJustification: typeof beatData["Gossamer1 Justification"] === "string" ? beatData["Gossamer1 Justification"] : void 0
        };
      });
      modal.setStatus("Assembling manuscript with table of contents...");
      const { getSortedSceneFiles: getSortedSceneFiles2 } = await Promise.resolve().then(() => (init_manuscript(), manuscript_exports));
      const { files: sceneFiles, sortOrder } = await getSortedSceneFiles2(plugin);
      if (sceneFiles.length === 0) {
        modal.addError("No scenes found in source path.");
        modal.completeProcessing(false, "No scenes found");
        new import_obsidian5.Notice("No scenes found in source path.");
        return;
      }
      const manuscript = await assembleManuscript(sceneFiles, plugin.app.vault, void 0, true, sortOrder);
      if (!manuscript.text || manuscript.text.trim().length === 0) {
        modal.addError("Manuscript is empty. Check that your scene files have content.");
        modal.completeProcessing(false, "Empty manuscript");
        new import_obsidian5.Notice("Manuscript is empty. Check that your scene files have content.");
        return;
      }
      const estimatedTokens = Math.ceil(manuscript.text.length / 4);
      const manuscriptInfo = {
        totalScenes: manuscript.totalScenes,
        totalWords: manuscript.totalWords,
        estimatedTokens,
        beatCount: beats.length,
        beatSystem: beatSystemDisplayName,
        // Use display name (may include custom name)
        hasIterativeContext: beats.some((b) => b.previousScore !== void 0)
      };
      modal.setManuscriptInfo(manuscriptInfo);
      modal.setStatus("Building analysis prompt...");
      const prompt = buildUnifiedBeatAnalysisPrompt(manuscript.text, beats, beatSystem);
      const schema = getUnifiedBeatAnalysisJsonSchema();
      modal.setStatus("Sending manuscript to Gemini API for momentum analysis...");
      modal.apiCallStarted();
      const result = await callGeminiApi(
        plugin.settings.geminiApiKey,
        plugin.settings.geminiModelId || "gemini-2.0-flash-exp",
        null,
        // No system prompt - instructions in user prompt
        prompt,
        4e3,
        // Default max tokens for response
        0.7,
        // Temperature
        schema
      );
      if (!result.success || !result.content) {
        modal.apiCallError(result.error || "Failed to get response from Gemini");
        modal.completeProcessing(false, "API call failed");
        if ((_a2 = result.error) == null ? void 0 : _a2.toLowerCase().includes("rate limit")) {
          modal.showRateLimitWarning();
        }
        if (plugin.settings.logApiInteractions) {
          await createFailureDiagnosticReport(
            plugin,
            manuscript,
            beats,
            beatSystem,
            prompt,
            result.error || "Unknown error"
          );
        }
        throw new Error(result.error || "Failed to get response from Gemini");
      }
      modal.apiCallSuccess();
      modal.setStatus("Parsing AI response...");
      const analysis = JSON.parse(result.content);
      modal.setStatus("Updating beat notes...");
      const files = plugin.app.vault.getMarkdownFiles();
      let updateCount = 0;
      const unmatchedBeats = [];
      for (let i = 0; i < analysis.beats.length; i++) {
        const beat = analysis.beats[i];
        const matchingBeat = plotBeats[i];
        if (!matchingBeat) {
          unmatchedBeats.push(beat.beatName);
          continue;
        }
        const file = matchingBeat.path ? plugin.app.vault.getAbstractFileByPath(matchingBeat.path) : null;
        if (!file || !(file instanceof import_obsidian5.TFile)) {
          unmatchedBeats.push(beat.beatName);
          continue;
        }
        await plugin.app.fileManager.processFrontMatter(file, (yaml) => {
          const fm = yaml;
          const { nextIndex, updated } = appendGossamerScore(fm);
          Object.assign(fm, updated);
          fm[`Gossamer${nextIndex}`] = beat.momentumScore;
          fm[`Gossamer${nextIndex} Justification`] = beat.justification || "";
          const now = /* @__PURE__ */ new Date();
          const timestamp2 = now.toLocaleString(void 0, {
            year: "numeric",
            month: "short",
            day: "numeric",
            hour: "numeric",
            minute: "2-digit",
            hour12: true
          });
          const modelId = plugin.settings.geminiModelId || "gemini-2.0-flash-exp";
          fm["Gossamer Last Updated"] = `${timestamp2} by ${modelId}`;
        });
        updateCount++;
      }
      if (unmatchedBeats.length > 0) {
        modal.addError(`Could not match ${unmatchedBeats.length} beat(s): ${unmatchedBeats.join(", ")}`);
      }
      modal.setStatus("Generating analysis report...");
      const reportTimestamp = /* @__PURE__ */ new Date();
      const timestamp = reportTimestamp.toLocaleString();
      const reportLines = [
        `# Gossamer Momentum Analysis Report`,
        ``,
        `**Date:** ${timestamp}`,
        `**Beat System:** ${beatSystem}`,
        `**Model:** ${plugin.settings.geminiModelId || "gemini-2.0-flash-exp"}`,
        `**Manuscript:** ${manuscript.totalScenes} scenes, ${manuscript.totalWords.toLocaleString()} words`,
        `**Beats Updated:** ${updateCount} of ${analysis.beats.length}`,
        ``,
        `---`,
        ``,
        `## Summary`,
        ``,
        analysis.overallAssessment.summary,
        ``,
        `**Strengths:**`,
        ...analysis.overallAssessment.strengths.map((s) => `- ${s}`),
        ``,
        `**Improvements:**`,
        ...analysis.overallAssessment.improvements.map((i) => `- ${i}`),
        ``
      ];
      if (unmatchedBeats.length > 0) {
        reportLines.push(`**\u26A0\uFE0F Unmatched Beats:** ${unmatchedBeats.length} beat(s) could not be matched to notes: ${unmatchedBeats.join(", ")}`);
        reportLines.push(``);
      }
      reportLines.push(`**Beat Scores:**`);
      reportLines.push(``);
      reportLines.push(`| Beat | Score | Range | Status |`);
      reportLines.push(`|------|-------|-------|--------|`);
      for (const beat of analysis.beats) {
        const status = beat.isWithinRange ? "\u2713" : "\u26A0\uFE0F";
        reportLines.push(`| ${beat.beatName} | ${beat.momentumScore} | ${beat.idealRange} | ${status} |`);
      }
      reportLines.push(``);
      reportLines.push(`---`);
      reportLines.push(``);
      reportLines.push(`## Debug Information`);
      reportLines.push(``);
      reportLines.push(`### Manuscript Scenes Sent`);
      reportLines.push(``);
      reportLines.push(`The following ${manuscript.totalScenes} scenes were assembled and sent to Gemini (with table of contents):`);
      reportLines.push(``);
      manuscript.scenes.forEach((scene, idx) => {
        const wordCount = scene.wordCount || 0;
        reportLines.push(`${idx + 1}. ${scene.title || "Untitled Scene"} (${wordCount.toLocaleString()} words)`);
      });
      reportLines.push(``);
      reportLines.push(`**Total Words:** ${manuscript.totalWords.toLocaleString()}`);
      reportLines.push(``);
      reportLines.push(`### Prompt Sent to Gemini`);
      reportLines.push(``);
      reportLines.push(`\`\`\`markdown`);
      reportLines.push(prompt);
      reportLines.push(`\`\`\``);
      reportLines.push(``);
      reportLines.push(`### JSON Response Received from Gemini`);
      reportLines.push(``);
      reportLines.push(`\`\`\`json`);
      reportLines.push(result.content || "");
      reportLines.push(`\`\`\``);
      reportLines.push(``);
      let reportFile;
      if (plugin.settings.logApiInteractions) {
        const reportDate = /* @__PURE__ */ new Date();
        const dateStr = reportDate.toLocaleDateString(void 0, {
          year: "numeric",
          month: "short",
          day: "numeric"
        });
        const timeStr = reportDate.toLocaleTimeString(void 0, {
          hour: "numeric",
          minute: "2-digit",
          hour12: true
        }).replace(/:/g, ".");
        const reportPath = `AI/Gossamer Analysis ${dateStr} ${timeStr}.md`;
        try {
          await plugin.app.vault.createFolder("AI");
        } catch (e) {
        }
        reportFile = await plugin.app.vault.create(reportPath, reportLines.join("\n"));
        const leaf = plugin.app.workspace.getLeaf("tab");
        await leaf.openFile(reportFile);
      }
      const successMessage = `\u2713 Updated ${updateCount} beats with momentum scores`;
      const logMessage = plugin.settings.logApiInteractions ? `${successMessage}. Report saved to AI folder (includes full manuscript).` : `${successMessage}. (Logging disabled - no report saved)`;
      modal.completeProcessing(true, successMessage);
      new import_obsidian5.Notice(logMessage);
    } catch (e) {
      const errorMsg = (e == null ? void 0 : e.message) || "Unknown error";
      modal.addError(`Processing failed: ${errorMsg}`);
      modal.completeProcessing(false, "Processing failed");
      new import_obsidian5.Notice(`Failed to run Gossamer AI analysis: ${errorMsg}`);
      console.error("[Gossamer AI]", e);
    }
  };
  try {
    const scenes = await plugin.getSceneData();
    let plotBeats = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
    const { filterBeatsBySystem: filterBeatsBySystem2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
    if (beatSystem && beatSystem.trim() !== "" && plotBeats.some((p) => p["Beat Model"])) {
      plotBeats = filterBeatsBySystem2(plotBeats, beatSystem);
    }
    const { getSortedSceneFiles: getSortedSceneFiles2 } = await Promise.resolve().then(() => (init_manuscript(), manuscript_exports));
    const { files: sceneFiles } = await getSortedSceneFiles2(plugin);
    const manuscript = await assembleManuscript(sceneFiles, plugin.app.vault);
    const estimatedTokens = Math.ceil(manuscript.text.length / 4);
    const beatsWithPreviousAnalysis = plotBeats.filter((beat) => {
      const beatData = beat;
      return typeof beatData["Gossamer1 Justification"] === "string" && beatData["Gossamer1 Justification"].trim().length > 0;
    }).length;
    const manuscriptInfo = {
      totalScenes: manuscript.totalScenes,
      totalWords: manuscript.totalWords,
      estimatedTokens,
      beatCount: plotBeats.length,
      beatSystem: beatSystemDisplayName,
      // Use display name (may include custom name)
      hasIterativeContext: beatsWithPreviousAnalysis > 0
    };
    const modal = new GossamerProcessingModal(plugin.app, plugin, async (options) => {
      await processAnalysis(options, modal);
    });
    modal.open();
    modal.setManuscriptInfo(manuscriptInfo);
  } catch (e) {
    const errorMsg = (e == null ? void 0 : e.message) || "Unknown error";
    new import_obsidian5.Notice(`Failed to prepare Gossamer analysis: ${errorMsg}`);
    console.error("[Gossamer AI Pre-check]", e);
  }
}
async function createFailureDiagnosticReport(plugin, manuscript, beats, beatSystem, prompt, errorMessage) {
  const reportTimestamp = /* @__PURE__ */ new Date();
  const timestamp = reportTimestamp.toLocaleString();
  const reportLines = [
    `# Gossamer AI Analysis - FAILED`,
    ``,
    `**Date:** ${timestamp}`,
    `**Beat System:** ${beatSystem}`,
    `**Model:** ${plugin.settings.geminiModelId || "gemini-2.0-flash-exp"}`,
    `**Error:** ${errorMessage}`,
    ``,
    `---`,
    ``,
    `## Error Details`,
    ``,
    errorMessage,
    ``,
    `## Manuscript Sent`,
    ``,
    `**Scenes:** ${manuscript.totalScenes}`,
    `**Words:** ${manuscript.totalWords.toLocaleString()}`,
    `**Estimated Input Tokens:** ~${Math.ceil(manuscript.text.length / 4).toLocaleString()}`,
    `**Story Beats:** ${beats.length}`,
    ``,
    `### Scene List`,
    ``
  ];
  manuscript.scenes.forEach((scene, idx) => {
    const wordCount = scene.wordCount || 0;
    reportLines.push(`${idx + 1}. ${scene.title || "Untitled Scene"} (${wordCount.toLocaleString()} words)`);
  });
  reportLines.push(``);
  reportLines.push(`### Prompt Sent to Gemini`);
  reportLines.push(``);
  reportLines.push(`\`\`\`markdown`);
  reportLines.push(prompt);
  reportLines.push(`\`\`\``);
  reportLines.push(``);
  const reportDate = /* @__PURE__ */ new Date();
  const dateStr = reportDate.toLocaleDateString(void 0, {
    year: "numeric",
    month: "short",
    day: "numeric"
  });
  const timeStr = reportDate.toLocaleTimeString(void 0, {
    hour: "numeric",
    minute: "2-digit",
    hour12: true
  }).replace(/:/g, ".");
  const reportPath = `AI/Gossamer Analysis FAILED ${dateStr} ${timeStr}.md`;
  try {
    await plugin.app.vault.createFolder("AI");
  } catch (e) {
  }
  const reportFile = await plugin.app.vault.create(reportPath, reportLines.join("\n"));
  const leaf = plugin.app.workspace.getLeaf("tab");
  await leaf.openFile(reportFile);
  new import_obsidian5.Notice(`\u26A0\uFE0F Analysis failed. Diagnostic report saved to AI folder.`);
}
var import_obsidian5, lastRunByPlugin, _previousBaseMode, _isExitingGossamer;
var init_GossamerCommands = __esm({
  "src/GossamerCommands.ts"() {
    init_gossamer();
    import_obsidian5 = require("obsidian");
    init_GossamerScoreModal();
    init_GossamerProcessingModal();
    init_ModeDefinition();
    init_manuscript();
    init_unifiedBeatAnalysis();
    init_geminiApi();
    lastRunByPlugin = /* @__PURE__ */ new WeakMap();
    _previousBaseMode = null;
    _isExitingGossamer = false;
  }
});

// src/modes/definitions/AllScenesMode.ts
var NARRATIVE_MODE;
var init_AllScenesMode = __esm({
  "src/modes/definitions/AllScenesMode.ts"() {
    init_ModeDefinition();
    NARRATIVE_MODE = {
      id: "narrative" /* NARRATIVE */,
      name: "Narrative",
      description: "View all scenes across all subplots in manuscript order with subplot coloring",
      rendering: {
        outerRingContent: "narrative",
        innerRingContent: "subplot-scenes",
        beatDisplay: "outer-ring-slices",
        sceneColoring: "subplot",
        numberSquares: "full",
        overlayLayers: [],
        visualMuting: []
      },
      interactions: {
        hoverBehavior: "standard-scene-hover",
        clickBehavior: "open-scene-file",
        enableZeroDraftMode: true,
        exitBehavior: "toggle-button"
      },
      ui: {
        acronym: "NARR",
        tooltip: "Switch to Subplot mode",
        showInToggleButton: true,
        order: 1
      }
    };
  }
});

// src/modes/definitions/MainPlotMode.ts
var SUBPLOT_MODE;
var init_MainPlotMode = __esm({
  "src/modes/definitions/MainPlotMode.ts"() {
    init_ModeDefinition();
    SUBPLOT_MODE = {
      id: "subplot" /* SUBPLOT */,
      name: "Subplot",
      description: "View Main Plot scenes with publish stage coloring, other subplots in inner rings",
      rendering: {
        outerRingContent: "subplot-only",
        innerRingContent: "subplot-scenes",
        beatDisplay: "none",
        sceneColoring: "publish-stage",
        numberSquares: "full",
        overlayLayers: [],
        visualMuting: ["non-main-plot"]
      },
      interactions: {
        hoverBehavior: "plot-only-hover",
        clickBehavior: "open-plot-file",
        enableZeroDraftMode: true,
        exitBehavior: "toggle-button"
      },
      ui: {
        acronym: "SUBP",
        tooltip: "Switch to Narrative mode",
        showInToggleButton: true,
        order: 2
      }
    };
  }
});

// src/modes/definitions/GossamerMode.ts
var import_obsidian6, GOSSAMER_MODE;
var init_GossamerMode = __esm({
  "src/modes/definitions/GossamerMode.ts"() {
    import_obsidian6 = require("obsidian");
    init_ModeDefinition();
    GOSSAMER_MODE = {
      id: "gossamer" /* GOSSAMER */,
      name: "Gossamer",
      description: "Gossamer score analysis overlay with beat tracking and historical data",
      rendering: {
        outerRingContent: "narrative",
        innerRingContent: "subplot-scenes",
        beatDisplay: "outer-ring-slices",
        sceneColoring: "subplot",
        numberSquares: "full",
        overlayLayers: [
          "gossamer-dots",
          "gossamer-spokes",
          "gossamer-outlines",
          "confidence-band"
        ],
        visualMuting: ["non-plot"]
      },
      interactions: {
        hoverBehavior: "gossamer-bidirectional",
        clickBehavior: "gossamer-open-file",
        enableZeroDraftMode: false,
        // Gossamer mode has its own click behavior
        exitBehavior: "click-background"
        // Custom handlers are registered in GossamerMode.ts in view/modes
      },
      ui: {
        acronym: "GOSS",
        tooltip: "Switch to Gossamer mode",
        showInToggleButton: true,
        // Show in mode toggle button
        order: 3
      },
      // Lifecycle hooks
      onEnter: async (view) => {
        var _a;
        const plugin = view.plugin;
        const scenes = await plugin.getSceneData();
        const beatNotes = scenes.filter((s) => s.itemType === "Beat" || s.itemType === "Plot");
        if (beatNotes.length === 0) {
          new import_obsidian6.Notice('Cannot enter Gossamer mode: No story beats found. Create notes with frontmatter "Class: Beat" (or "Class: Plot" for backward compatibility).');
          throw new Error("Cannot enter Gossamer mode: No story beats found");
        }
        const { buildAllGossamerRuns: buildAllGossamerRuns2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
        const { setBaseModeAllScenes: setBaseModeAllScenes2, resetRotation: resetRotation2 } = await Promise.resolve().then(() => (init_GossamerCommands(), GossamerCommands_exports));
        const selectedBeatModel = ((_a = plugin.settings.beatSystem) == null ? void 0 : _a.trim()) || void 0;
        const allRuns = buildAllGossamerRuns2(scenes, selectedBeatModel);
        if (allRuns.current.beats.length === 0) {
          const systemMsg = selectedBeatModel ? ` with Beat Model: ${selectedBeatModel}` : "";
          new import_obsidian6.Notice(`Cannot enter Gossamer mode: No story beat notes found${systemMsg}. Create notes with Class: Beat (or Class: Plot for backward compatibility).`);
          throw new Error(`Cannot enter Gossamer mode: No beats found for system: ${selectedBeatModel}`);
        }
        if (!allRuns.hasAnyScores) {
          new import_obsidian6.Notice('No Gossamer scores found. Showing ideal ranges and spokes. Add scores using "Gossamer enter momentum scores" command.');
        }
        plugin._gossamerLastRun = allRuns.current;
        plugin._gossamerHistoricalRuns = allRuns.historical;
        plugin._gossamerMinMax = allRuns.minMax;
        setBaseModeAllScenes2(plugin);
        resetRotation2(plugin);
        plugin.clearSearch();
        view.interactionMode = "gossamer";
      },
      onExit: async (view) => {
      }
    };
  }
});

// src/utils/svg.ts
function formatNumber(num) {
  if (Math.abs(num) < 1e-3) return "0";
  return num.toFixed(3).replace(/\.0+$/, "").replace(/\.$/, "");
}
function escapeXml(unsafe) {
  return unsafe.replace(/&(?!(amp;|lt;|gt;|quot;|apos;|#\d+;|#x[0-9a-fA-F]+;))/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&apos;");
}
var init_svg = __esm({
  "src/utils/svg.ts"() {
  }
});

// src/renderer/components/ChronologueTimeline.ts
function collectChronologueSceneEntries(scenes) {
  const seenKeys = /* @__PURE__ */ new Set();
  const entries = [];
  scenes.forEach((scene, index) => {
    var _a;
    const whenDate = scene.when instanceof Date ? scene.when : parseWhenField(typeof scene.when === "string" ? scene.when : "");
    if (!whenDate) return;
    const key = scene.path ? `path:${scene.path}` : `title:${(_a = scene.title) != null ? _a : ""}::${whenDate.getTime()}`;
    if (seenKeys.has(key)) return;
    seenKeys.add(key);
    entries.push({ scene, date: whenDate, sourceIndex: index });
  });
  return entries;
}
function renderChronologueTimelineArc(scenes, outerRadius, scenePositions, durationCapMs, arcRadius = 758, precomputedEntries) {
  const sceneEntries = precomputedEntries != null ? precomputedEntries : collectChronologueSceneEntries(scenes);
  const validDates = sceneEntries.map((entry) => entry.date);
  if (validDates.length === 0) {
    return "";
  }
  const timeSpan = calculateTimeSpan(validDates);
  const earliestDate = validDates.reduce(
    (earliest, current) => current.getTime() < earliest.getTime() ? current : earliest
  );
  let svg = "";
  svg += `<g class="rt-chronologue-timeline-arc">`;
  if (scenePositions) {
    const durationSegments = renderDurationTickArcs({
      sceneEntries,
      arcRadius,
      timeSpanTotalMs: timeSpan.totalMs,
      scenePositions,
      durationCapMs
    });
    if (durationSegments) {
      svg += durationSegments;
    }
  }
  svg += `</g>`;
  return svg;
}
function renderDurationTickArcs(params) {
  const { sceneEntries, arcRadius, timeSpanTotalMs, scenePositions, durationCapMs } = params;
  if (sceneEntries.length === 0 || timeSpanTotalMs <= 0) {
    return null;
  }
  const sortedEntries = sceneEntries.slice().sort((a, b) => a.date.getTime() - b.date.getTime());
  const parsedDurations = sortedEntries.map((entry) => {
    const raw = entry.scene.Duration;
    if (!raw) {
      return { durationMs: 0, rawDuration: raw };
    }
    const value = parseDuration(raw);
    if (value === null) {
      return { durationMs: null, rawDuration: raw };
    }
    return { durationMs: value, rawDuration: raw };
  });
  const validDurationValues = [];
  parsedDurations.forEach((info) => {
    if (info.durationMs && info.durationMs > 0) {
      validDurationValues.push(info.durationMs);
    }
  });
  if (validDurationValues.length === 0 && !parsedDurations.some((d) => d.durationMs === null || d.durationMs === 0)) {
    return null;
  }
  const observedMaxDurationMs = validDurationValues.length > 0 ? Math.max(...validDurationValues) : 0;
  const scaleCapMs = typeof durationCapMs === "number" && durationCapMs > 0 ? durationCapMs : observedMaxDurationMs;
  const scaleMs = scaleCapMs > 0 ? scaleCapMs : observedMaxDurationMs > 0 ? observedMaxDurationMs : 1;
  const overlapIndices = detectSceneOverlaps(sortedEntries.map((entry) => ({
    when: entry.date,
    Duration: entry.scene.Duration
  })));
  const durationPaths = [];
  const TWO_PI = Math.PI * 2;
  const EDGE_MARGIN_RAD = Math.PI / 360;
  const STUB_FILL_RATIO = 0.2;
  sortedEntries.forEach((entry, idx) => {
    const durationInfo = parsedDurations[idx];
    const durationMs = durationInfo.durationMs;
    const sceneKey = entry.scene.path || `title:${entry.scene.title || ""}`;
    const manuscriptPosition = scenePositions.get(sceneKey);
    if (!manuscriptPosition) {
      return;
    }
    const marginAngle = 2 / arcRadius;
    const startAngle = manuscriptPosition.startAngle + marginAngle;
    const endAngle = manuscriptPosition.endAngle - marginAngle;
    const availableAngle = endAngle - startAngle;
    if (availableAngle <= 0) return;
    let spanAngle;
    let isUnparseable = false;
    let isOngoing = false;
    let isOverlap = overlapIndices.has(idx);
    if (durationMs === null || durationMs === 0) {
      if (durationInfo.rawDuration && durationInfo.rawDuration.toLowerCase().trim() === "ongoing") {
        spanAngle = availableAngle;
        isOngoing = true;
        isOverlap = true;
      } else {
        spanAngle = availableAngle * STUB_FILL_RATIO;
        isUnparseable = true;
      }
    } else {
      const ratio = scaleMs > 0 ? Math.min(durationMs / scaleMs, 1) : 1;
      spanAngle = availableAngle * ratio;
    }
    if (spanAngle <= 0) return;
    const arcStart = startAngle;
    const arcEnd = arcStart + spanAngle;
    const largeArcFlag = spanAngle > Math.PI ? 1 : 0;
    let arcClass = "rt-duration-arc";
    if (isUnparseable) {
      arcClass += " rt-duration-arc-unparseable";
    }
    if (isOverlap) {
      arcClass += " rt-duration-arc-overlap";
    }
    if (isOngoing) {
      arcClass += " rt-duration-arc-ongoing";
    }
    const x1 = formatNumber(arcRadius * Math.cos(arcStart));
    const y1 = formatNumber(arcRadius * Math.sin(arcStart));
    const x2 = formatNumber(arcRadius * Math.cos(arcEnd));
    const y2 = formatNumber(arcRadius * Math.sin(arcEnd));
    durationPaths.push(
      `<path d="M ${x1} ${y1} A ${formatNumber(arcRadius)} ${formatNumber(arcRadius)} 0 ${largeArcFlag} 1 ${x2} ${y2}" class="${arcClass}" />`
    );
  });
  if (durationPaths.length === 0) {
    return null;
  }
  return `<g class="rt-chronologue-duration-ticks">
        ${durationPaths.join("")}
    </g>`;
}
function mapTimeToAngle(timeMs, startMs, endMs) {
  const progress = (timeMs - startMs) / (endMs - startMs);
  return progress * 2 * Math.PI - Math.PI / 2;
}
function renderElapsedTimeArc(scene1, scene2, outerRadius, arcWidth = 2) {
  const date1 = parseWhenField(typeof scene1.when === "string" ? scene1.when : "");
  const date2 = parseWhenField(typeof scene2.when === "string" ? scene2.when : "");
  if (!date1 || !date2) {
    return "";
  }
  const [earlierScene, laterScene] = date1.getTime() < date2.getTime() ? [scene1, scene2] : [scene2, scene1];
  const [earlierDate, laterDate] = date1.getTime() < date2.getTime() ? [date1, date2] : [date2, date1];
  const arcRadius = outerRadius + 15;
  const startAngle = mapTimeToAngle(earlierDate.getTime(), earlierDate.getTime(), laterDate.getTime());
  const endAngle = mapTimeToAngle(laterDate.getTime(), earlierDate.getTime(), laterDate.getTime());
  const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
  const x1 = formatNumber(arcRadius * Math.cos(startAngle));
  const y1 = formatNumber(arcRadius * Math.sin(startAngle));
  const x2 = formatNumber(arcRadius * Math.cos(endAngle));
  const y2 = formatNumber(arcRadius * Math.sin(endAngle));
  const arcPath2 = `M ${x1} ${y1} A ${formatNumber(arcRadius)} ${formatNumber(arcRadius)} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
  return `<g class="rt-elapsed-time-arc">
        <path d="${arcPath2}" fill="none" stroke="var(--interactive-accent)" stroke-width="${arcWidth}" opacity="0.8"/>
    </g>`;
}
function renderChronologicalBackboneArc(scenes, outerRingInnerRadius, outerRingOuterRadius, discontinuityThreshold = 3, scenePositions, precomputedEntries, customThresholdMs) {
  const sceneEntries = precomputedEntries != null ? precomputedEntries : collectChronologueSceneEntries(scenes);
  if (sceneEntries.length === 0 || !scenePositions) return "";
  const preparedScenes = prepareScenesForDiscontinuityDetection(scenes);
  if (preparedScenes.length < 3) return "";
  const autoThreshold = calculateAutoDiscontinuityThreshold(scenes);
  const effectiveThreshold = customThresholdMs != null ? customThresholdMs : autoThreshold;
  if (!effectiveThreshold || effectiveThreshold <= 0) {
    return "";
  }
  const discontinuityIndices = detectDiscontinuities(preparedScenes, effectiveThreshold);
  if (discontinuityIndices.length === 0) {
    return "";
  }
  const timestampToEntry = /* @__PURE__ */ new Map();
  sceneEntries.forEach((entry) => {
    if (entry.scene.itemType === "Scene") {
      timestampToEntry.set(entry.date.getTime(), entry);
    }
  });
  const markerRadius = (outerRingInnerRadius + outerRingOuterRadius) / 2;
  let svg = `<g class="rt-chronologue-backbone-discontinuities">`;
  discontinuityIndices.forEach((sceneIndex) => {
    if (sceneIndex >= preparedScenes.length) return;
    const currScene = preparedScenes[sceneIndex];
    const nextScene = sceneIndex < preparedScenes.length - 1 ? preparedScenes[sceneIndex + 1] : null;
    const TIME_TOLERANCE_MS = 6e4;
    const hasAdjacentSameTime = nextScene && Math.abs(currScene.when.getTime() - nextScene.when.getTime()) < TIME_TOLERANCE_MS;
    if (hasAdjacentSameTime) {
      return;
    }
    const sceneEntry = timestampToEntry.get(currScene.when.getTime());
    if (!sceneEntry) return;
    const sceneKey = sceneEntry.scene.path || `title:${sceneEntry.scene.title || ""}`;
    const manuscriptPosition = scenePositions.get(sceneKey);
    if (!manuscriptPosition) return;
    const midAngle = (manuscriptPosition.startAngle + manuscriptPosition.endAngle) / 2;
    const x = formatNumber(markerRadius * Math.cos(midAngle));
    const y = formatNumber(markerRadius * Math.sin(midAngle));
    const angularWidth = manuscriptPosition.endAngle - manuscriptPosition.startAngle;
    const arcLengthAtMarker = markerRadius * angularWidth;
    const dynamicFontSize = Math.max(8, Math.min(20, arcLengthAtMarker * 0.6));
    const dynamicStrokeWidth = Math.max(2, Math.min(6, dynamicFontSize * 0.3));
    svg += `<text x="${x}" y="${y}" class="rt-discontinuity-marker" text-anchor="middle" dominant-baseline="middle" font-size="${formatNumber(dynamicFontSize)}" stroke-width="${formatNumber(dynamicStrokeWidth)}">\u221E</text>`;
  });
  svg += `</g>`;
  return svg;
}
var init_ChronologueTimeline = __esm({
  "src/renderer/components/ChronologueTimeline.ts"() {
    init_svg();
    init_date();
  }
});

// src/renderer/layout/LayoutConstants.ts
var SVG_SIZE, INNER_RADIUS, SUBPLOT_OUTER_RADIUS_MAINPLOT, SUBPLOT_OUTER_RADIUS_STANDARD, SUBPLOT_OUTER_RADIUS_CHRONOLOGUE, MONTH_LABEL_RADIUS, CHRONOLOGUE_DATE_RADIUS, MONTH_TICK_END, MONTH_TICK_START, ACT_LABEL_RADIUS, CHRONOLOGUE_DURATION_ARC_RADIUS, ELAPSED_ARC_RADIUS, ELAPSED_TICK_LENGTH, SCENE_TITLE_INSET, SYNOPSIS_INSET, BEAT_TITLE_INSET, TEXTPATH_START_NUDGE_RAD, MAX_TEXT_WIDTH, PLOT_PIXEL_WIDTH, BEAT_FONT_PX, CHAR_WIDTH_EM, LETTER_SPACING_EM, ESTIMATE_FUDGE_RENDER, PADDING_RENDER_PX, BOOK_TITLE_POS_X, BOOK_TITLE_POS_Y, MODE_TITLE_POS_X, MODE_TITLE_POS_Y, MODE_SELECTOR_POS_X, MODE_SELECTOR_POS_Y, SHIFT_BUTTON_POS_X, SHIFT_BUTTON_POS_Y;
var init_LayoutConstants = __esm({
  "src/renderer/layout/LayoutConstants.ts"() {
    SVG_SIZE = 1600;
    INNER_RADIUS = 200;
    SUBPLOT_OUTER_RADIUS_MAINPLOT = 778;
    SUBPLOT_OUTER_RADIUS_STANDARD = 766;
    SUBPLOT_OUTER_RADIUS_CHRONOLOGUE = 750;
    MONTH_LABEL_RADIUS = 790;
    CHRONOLOGUE_DATE_RADIUS = 792;
    MONTH_TICK_END = 799;
    MONTH_TICK_START = 764;
    ACT_LABEL_RADIUS = 790;
    CHRONOLOGUE_DURATION_ARC_RADIUS = 758;
    ELAPSED_ARC_RADIUS = 766;
    ELAPSED_TICK_LENGTH = 14;
    SCENE_TITLE_INSET = 22;
    SYNOPSIS_INSET = 0;
    BEAT_TITLE_INSET = -3;
    TEXTPATH_START_NUDGE_RAD = 0.02;
    MAX_TEXT_WIDTH = 500;
    PLOT_PIXEL_WIDTH = 18;
    BEAT_FONT_PX = 9;
    CHAR_WIDTH_EM = 0.62;
    LETTER_SPACING_EM = 0.07;
    ESTIMATE_FUDGE_RENDER = 1.35;
    PADDING_RENDER_PX = 24;
    BOOK_TITLE_POS_X = 568;
    BOOK_TITLE_POS_Y = -784;
    MODE_TITLE_POS_X = 567;
    MODE_TITLE_POS_Y = -762;
    MODE_SELECTOR_POS_X = 658;
    MODE_SELECTOR_POS_Y = -750;
    SHIFT_BUTTON_POS_X = -700;
    SHIFT_BUTTON_POS_Y = -750;
  }
});

// src/view/interactions/ChronologueShiftController.ts
var ChronologueShiftController_exports = {};
__export(ChronologueShiftController_exports, {
  isShiftModeActive: () => isShiftModeActive,
  resetShiftModeState: () => resetShiftModeState,
  setupChronologueShiftController: () => setupChronologueShiftController
});
function isShiftModeActive() {
  return globalShiftModeActive;
}
function resetShiftModeState() {
  globalShiftModeActive = false;
}
function setupChronologueShiftController(view, svg) {
  if (view.currentMode !== "chronologue") {
    return;
  }
  let shiftModeActive = false;
  let selectedScenes = [];
  let hoveredScenePath = null;
  let elapsedTimeClickCount = 0;
  const viewBox = svg.getAttribute("viewBox");
  let outerRadius = 300;
  if (viewBox) {
    const [, , width, height] = viewBox.split(" ").map(parseFloat);
    const size = Math.min(width, height);
    outerRadius = size / 2 - 50;
  }
  const sceneGeometry = /* @__PURE__ */ new Map();
  const sceneGroupBySceneId = /* @__PURE__ */ new Map();
  const sceneSubplotIndexBySceneId = /* @__PURE__ */ new Map();
  const numberSquareBySceneId = /* @__PURE__ */ new Map();
  const numberTextBySceneId = /* @__PURE__ */ new Map();
  const subplotColors = [];
  for (let i = 0; i < 16; i++) {
    const varName = `--rt-subplot-colors-${i}`;
    const computed = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    subplotColors[i] = computed || "#EFBDEB";
  }
  const allSynopsisElements = Array.from(svg.querySelectorAll(".rt-scene-info"));
  const synopsisBySceneId = /* @__PURE__ */ new Map();
  allSynopsisElements.forEach((synopsis) => {
    const sceneId = synopsis.getAttribute("data-for-scene");
    if (sceneId) {
      synopsisBySceneId.set(sceneId, synopsis);
    }
  });
  const sceneIdCache = /* @__PURE__ */ new WeakMap();
  const getSceneIdFromGroup = (group) => {
    var _a;
    const cached = sceneIdCache.get(group);
    if (cached) return cached;
    const pathEl = group.querySelector(".rt-scene-path");
    const sceneId = (_a = pathEl == null ? void 0 : pathEl.id) != null ? _a : null;
    if (sceneId) {
      sceneIdCache.set(group, sceneId);
    }
    return sceneId;
  };
  const sceneGroups = Array.from(svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]'));
  sceneGroups.forEach((group) => {
    var _a;
    const sceneId = getSceneIdFromGroup(group);
    if (sceneId) {
      sceneGroupBySceneId.set(sceneId, group);
      const subplotIndexAttr = group.getAttribute("data-subplot-index");
      if (subplotIndexAttr) {
        const subplotIndex = parseInt(subplotIndexAttr, 10);
        if (!isNaN(subplotIndex)) {
          sceneSubplotIndexBySceneId.set(sceneId, subplotIndex);
        }
      }
      const square = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
      const text = svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
      if (square) numberSquareBySceneId.set(sceneId, square);
      if (text) numberTextBySceneId.set(sceneId, text);
    }
    const scenePath = group.getAttribute("data-path");
    if (!scenePath) return;
    const ringAttr = group.getAttribute("data-ring");
    const ringIndex = ringAttr ? parseInt(ringAttr, 10) : 0;
    const startAngleAttr = group.getAttribute("data-start-angle");
    const outerRadiusAttr = group.getAttribute("data-outer-r");
    const angle = startAngleAttr ? parseFloat(startAngleAttr) : NaN;
    const outerRadiusValue = outerRadiusAttr ? parseFloat(outerRadiusAttr) : NaN;
    if (isNaN(angle)) return;
    const existing = sceneGeometry.get(scenePath);
    if (!existing || ringIndex > existing.ring) {
      sceneGeometry.set(scenePath, {
        startAngle: angle,
        outerRadius: !isNaN(outerRadiusValue) ? outerRadiusValue : (_a = existing == null ? void 0 : existing.outerRadius) != null ? _a : null,
        ring: ringIndex
      });
    }
  });
  const shiftButton = createShiftButton();
  svg.appendChild(shiftButton);
  const activateShiftMode = () => {
    if (!shiftModeActive) {
      shiftModeActive = true;
      globalShiftModeActive = true;
      updateShiftButtonState(shiftButton, true);
      svg.setAttribute("data-shift-mode", "active");
      applyShiftModeToAllScenes(svg);
      allSynopsisElements.forEach((syn) => {
        if (syn.classList.contains("rt-visible")) {
          syn.classList.remove("rt-visible");
        }
      });
      const hoveredGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]:hover');
      if (hoveredGroups.length > 0) {
        const hoveredGroup = hoveredGroups[0];
        const scenePathEncoded = hoveredGroup.getAttribute("data-path");
        if (scenePathEncoded) {
          hoveredScenePath = scenePathEncoded;
          hoveredGroup.classList.add("rt-shift-hover");
          const sid = getSceneIdFromGroup(hoveredGroup);
          setNumberSquareActiveBySceneId(sid, true, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
        }
      }
    }
  };
  const deactivateShiftMode = () => {
    if (shiftModeActive) {
      shiftModeActive = false;
      globalShiftModeActive = false;
      updateShiftButtonState(shiftButton, false);
      selectedScenes = [];
      rebuildSelectedPathsSet();
      hoveredScenePath = null;
      elapsedTimeClickCount = 0;
      removeElapsedTimeArc(svg);
      removeSceneHighlights(svg);
      removeShiftModeFromAllScenes(svg);
      svg.removeAttribute("data-shift-mode");
      svg.classList.remove("rt-global-fade");
      svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-discontinuity-marker").forEach((el) => {
        el.classList.remove("rt-selected", "rt-non-selected");
      });
      svg.querySelectorAll(".rt-scene-info.rt-visible").forEach((syn) => {
        syn.classList.remove("rt-visible");
      });
      svg.classList.remove("scene-hover");
      const hoveredSceneGroup = svg.querySelector('.rt-scene-group[data-item-type="Scene"]:hover');
    }
  };
  view.registerDomEvent(shiftButton, "click", (e) => {
    e.stopPropagation();
    if (shiftModeActive) {
      deactivateShiftMode();
    } else {
      activateShiftMode();
    }
  });
  let capsLockState = false;
  let pendingCapsLockSync = false;
  const syncShiftModeToCapsLock = (isActive) => {
    if (capsLockState === isActive) {
      return;
    }
    capsLockState = isActive;
    if (isActive) {
      if (!shiftModeActive) activateShiftMode();
    } else {
      if (shiftModeActive) deactivateShiftMode();
    }
  };
  const handleKeyDown = (e) => {
    var _a, _b, _c;
    const activeView = (_c = (_b = (_a = view.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.activeLeaf) == null ? void 0 : _c.view;
    if (activeView !== view || view.currentMode !== "chronologue") {
      return;
    }
    const activeEl = document.activeElement;
    if (activeEl) {
      const tag = activeEl.tagName.toUpperCase();
      if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || activeEl.isContentEditable) {
        return;
      }
    }
    if (e.key === "Shift") {
      activateShiftMode();
    } else if (e.key === "CapsLock") {
      if (e.repeat) {
        return;
      }
      const reportedState = e.getModifierState("CapsLock");
      if (reportedState !== capsLockState) {
        syncShiftModeToCapsLock(reportedState);
        pendingCapsLockSync = false;
      } else {
        pendingCapsLockSync = true;
      }
    }
  };
  const handleKeyUp = (e) => {
    var _a, _b, _c;
    const activeView = (_c = (_b = (_a = view.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.activeLeaf) == null ? void 0 : _c.view;
    if (activeView !== view || view.currentMode !== "chronologue") {
      return;
    }
    const activeElUp = document.activeElement;
    if (activeElUp) {
      const tagUp = activeElUp.tagName.toUpperCase();
      if (tagUp === "INPUT" || tagUp === "TEXTAREA" || tagUp === "SELECT" || activeElUp.isContentEditable) {
        return;
      }
    }
    if (e.key === "Shift") {
      deactivateShiftMode();
    } else if (e.key === "CapsLock") {
      const reportedState = e.getModifierState("CapsLock");
      if (pendingCapsLockSync || reportedState !== capsLockState) {
        pendingCapsLockSync = false;
        syncShiftModeToCapsLock(reportedState);
      }
    }
  };
  document.addEventListener("keydown", handleKeyDown);
  document.addEventListener("keyup", handleKeyUp);
  view._chronologueShiftCleanup = () => {
    document.removeEventListener("keydown", handleKeyDown);
    document.removeEventListener("keyup", handleKeyUp);
  };
  const findSceneByPath = (path) => {
    const decodedPath = decodeURIComponent(path);
    const allScenes = view.sceneData || view.scenes;
    if (allScenes && Array.isArray(allScenes)) {
      const scene = allScenes.find((s) => s.path === decodedPath);
      if (scene) {
        return scene;
      }
    }
    const sceneGroup = svg.querySelector(`.rt-scene-group[data-path="${path}"]`);
    if (!sceneGroup) return null;
    return {
      path: decodedPath,
      when: void 0,
      title: "",
      subplot: "",
      itemType: "Scene"
    };
  };
  const setupShiftModeHover = () => {
    let selectedPathsSet = /* @__PURE__ */ new Set();
    const rebuildSelectedPathsSet2 = () => {
      selectedPathsSet = new Set(selectedScenes.map((s) => s.path ? encodeURIComponent(s.path) : "").filter((p) => p));
    };
    view.registerDomEvent(svg, "pointerover", (e) => {
      if (!shiftModeActive) return;
      const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
      if (!g) return;
      e.stopImmediatePropagation();
      e.preventDefault();
      const scenePathEncoded = g.getAttribute("data-path");
      if (!scenePathEncoded) return;
      const isLocked = selectedPathsSet.has(scenePathEncoded);
      if (!isLocked) {
        hoveredScenePath = scenePathEncoded;
        g.classList.add("rt-shift-hover");
        const sid = getSceneIdFromGroup(g);
        setNumberSquareActiveBySceneId(sid, true, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
    }, { capture: true });
    view.registerDomEvent(svg, "pointerout", (e) => {
      if (!shiftModeActive) return;
      const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
      if (!g) return;
      e.stopImmediatePropagation();
      e.preventDefault();
      const scenePathEncoded = g.getAttribute("data-path");
      if (!scenePathEncoded) return;
      const isLocked = selectedPathsSet.has(scenePathEncoded);
      if (!isLocked) {
        hoveredScenePath = null;
        g.classList.remove("rt-shift-hover");
        const sid = getSceneIdFromGroup(g);
        setNumberSquareActiveBySceneId(sid, false, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
    }, { capture: true });
    return rebuildSelectedPathsSet2;
  };
  const rebuildSelectedPathsSet = setupShiftModeHover();
  view.handleShiftModeClick = (e, sceneGroup) => {
    if (!shiftModeActive) return false;
    e.preventDefault();
    e.stopPropagation();
    const scenePathEncoded = sceneGroup.getAttribute("data-path");
    if (!scenePathEncoded) return true;
    const scene = findSceneByPath(scenePathEncoded);
    if (!scene) return true;
    const isAlreadyLocked = selectedScenes.some((s) => {
      const encoded = s.path ? encodeURIComponent(s.path) : "";
      return encoded === scenePathEncoded;
    });
    if (isAlreadyLocked) {
      selectedScenes = selectedScenes.filter((s) => {
        const encoded = s.path ? encodeURIComponent(s.path) : "";
        return encoded !== scenePathEncoded;
      });
      rebuildSelectedPathsSet();
      updateSceneSelection(svg, selectedScenes, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      if (selectedScenes.length < 2) {
        removeElapsedTimeArc(svg);
      } else {
        showElapsedTime(svg, selectedScenes, elapsedTimeClickCount, sceneGeometry, outerRadius);
      }
      return true;
    }
    selectedScenes.push(scene);
    if (selectedScenes.length > 2) {
      selectedScenes = selectedScenes.slice(-2);
    }
    rebuildSelectedPathsSet();
    updateSceneSelection(svg, selectedScenes, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
    if (selectedScenes.length === 2) {
      showElapsedTime(svg, selectedScenes, elapsedTimeClickCount, sceneGeometry, outerRadius);
    }
    return true;
  };
  view.registerDomEvent(svg, "click", (e) => {
    if (!shiftModeActive || selectedScenes.length !== 2) return;
    const elapsedTimeLabel = e.target.closest(".rt-elapsed-time-label");
    if (!elapsedTimeLabel) return;
    e.preventDefault();
    e.stopPropagation();
    elapsedTimeClickCount++;
    showElapsedTime(svg, selectedScenes, elapsedTimeClickCount, sceneGeometry, outerRadius);
  });
}
function createShiftButtonShape() {
  return "M0 11C0 4.92487 4.92487 0 11 0H103C119.569 0 133 13.4315 133 30V57C133 63.0751 128.075 68 122 68H11C4.92487 68 0 63.0751 0 57V11Z";
}
function createShiftButton() {
  const button = document.createElementNS("http://www.w3.org/2000/svg", "g");
  button.setAttribute("class", "rt-shift-mode-button");
  button.setAttribute("id", "shift-mode-toggle");
  button.setAttribute("transform", `translate(${SHIFT_BUTTON_POS_X}, ${SHIFT_BUTTON_POS_Y}) scale(${SHIFT_BUTTON_BASE_SCALE})`);
  const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
  path.setAttribute("d", createShiftButtonShape());
  path.setAttribute("class", "rt-shift-button-bg");
  path.setAttribute("fill", "var(--interactive-normal)");
  path.setAttribute("stroke", "var(--text-normal)");
  path.setAttribute("stroke-width", "2");
  const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
  text.setAttribute("x", "66.5");
  text.setAttribute("y", "52");
  text.setAttribute("text-anchor", "middle");
  text.setAttribute("dominant-baseline", "middle");
  text.setAttribute("class", "rt-shift-button-text");
  text.textContent = "\u2191 SHIFT";
  const title = document.createElementNS("http://www.w3.org/2000/svg", "title");
  title.textContent = "Toggle Shift Mode for elapsed time comparison";
  button.appendChild(path);
  button.appendChild(text);
  button.appendChild(title);
  return button;
}
function updateShiftButtonState(button, active) {
  const bg = button.querySelector(".rt-shift-button-bg");
  const text = button.querySelector(".rt-shift-button-text");
  const currentTransform = button.getAttribute("transform") || "";
  const baseTransform = currentTransform.replace(/scale\([^)]+\)/, "").trim();
  if (active) {
    button.setAttribute("transform", `${baseTransform} scale(${SHIFT_BUTTON_ACTIVE_SCALE})`);
    button.classList.add("rt-shift-mode-active");
  } else {
    button.setAttribute("transform", `${baseTransform} scale(${SHIFT_BUTTON_BASE_SCALE})`);
    button.classList.remove("rt-shift-mode-active");
  }
}
function setNumberSquareActiveBySceneId(sceneId, active, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors) {
  if (!sceneId) return;
  const square = numberSquareBySceneId.get(sceneId);
  const text = numberTextBySceneId.get(sceneId);
  if (square) {
    square.classList.toggle("rt-shift-active", active);
    if (active) {
      const subplotIndex = sceneSubplotIndexBySceneId.get(sceneId);
      if (subplotIndex !== void 0) {
        const colorIdx = subplotIndex % 16;
        square.setAttribute("data-subplot-idx", colorIdx.toString());
      }
    } else {
      square.removeAttribute("data-subplot-idx");
    }
  }
  if (text) text.classList.toggle("rt-shift-active", active);
}
function applyShiftModeToAllScenes(svg) {
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    group.classList.remove("rt-shift-hover");
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-locked", "rt-shift-selected");
    }
  });
}
function removeShiftModeFromAllScenes(svg) {
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    group.classList.remove("rt-shift-hover");
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-locked", "rt-shift-selected", "rt-shift-non-select");
    }
  });
  svg.querySelectorAll(".rt-number-square.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
  svg.querySelectorAll(".rt-number-text.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
}
function updateSceneSelection(svg, selectedScenes, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors) {
  const selectedPaths = new Set(selectedScenes.map((s) => s.path ? encodeURIComponent(s.path) : "").filter((p) => p));
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    var _a;
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-locked", "rt-shift-selected");
    }
    const scenePathEncoded = group.getAttribute("data-path");
    if (scenePathEncoded && selectedPaths.has(scenePathEncoded)) {
      group.classList.remove("rt-shift-hover");
    }
    const sid = ((_a = group.querySelector(".rt-scene-path")) == null ? void 0 : _a.id) || null;
    setNumberSquareActiveBySceneId(sid, false, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
  });
  selectedScenes.forEach((scene) => {
    const encodedPath = scene.path ? encodeURIComponent(scene.path) : "";
    if (!encodedPath) return;
    const sceneGroup = svg.querySelector(`.rt-scene-group[data-path="${encodedPath}"]`);
    if (sceneGroup) {
      const path = sceneGroup.querySelector(".rt-scene-path");
      if (path) {
        path.classList.add("rt-shift-locked");
        path.classList.add("rt-shift-selected");
        setNumberSquareActiveBySceneId(path.id, true, numberSquareBySceneId, numberTextBySceneId, sceneSubplotIndexBySceneId, subplotColors);
      }
      sceneGroup.classList.remove("rt-shift-hover");
    }
  });
}
function removeSceneHighlights(svg) {
  const allSceneGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]');
  allSceneGroups.forEach((group) => {
    const path = group.querySelector(".rt-scene-path");
    if (path) {
      path.classList.remove("rt-shift-selected", "rt-shift-locked");
    }
    group.classList.remove("rt-shift-hover");
  });
  svg.querySelectorAll(".rt-number-square.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
  svg.querySelectorAll(".rt-number-text.rt-shift-active").forEach((el) => el.classList.remove("rt-shift-active"));
}
function showElapsedTime(svg, scenes, clickCount, sceneGeometry, defaultOuterRadius) {
  var _a, _b;
  removeElapsedTimeArc(svg);
  if (scenes.length !== 2) {
    return;
  }
  const [scene1, scene2] = scenes;
  const encodedPath1 = encodeURIComponent(scene1.path || "");
  const encodedPath2 = encodeURIComponent(scene2.path || "");
  const geometry1 = sceneGeometry.get(encodedPath1);
  const geometry2 = sceneGeometry.get(encodedPath2);
  const parseSceneDate = (scene) => {
    if (scene.when instanceof Date) return scene.when;
    if (typeof scene.when === "string") return parseWhenField(scene.when);
    return null;
  };
  const date1 = parseSceneDate(scene1);
  const date2 = parseSceneDate(scene2);
  if (!date1 || !date2) {
    return;
  }
  const elapsedMs = Math.abs(date2.getTime() - date1.getTime());
  const elapsedTimeText = formatElapsedTime(elapsedMs, clickCount);
  if (geometry1 && geometry2) {
    const startAngleScene1 = geometry1.startAngle;
    const startAngleScene2 = geometry2.startAngle;
    const firstSceneIsEarlier = date1.getTime() <= date2.getTime();
    const startAngle = firstSceneIsEarlier ? startAngleScene1 : startAngleScene2;
    const endAngle = firstSceneIsEarlier ? startAngleScene2 : startAngleScene1;
    let normalizedStart = startAngle;
    let normalizedEnd = endAngle;
    if (normalizedEnd < normalizedStart) {
      normalizedEnd += 2 * Math.PI;
    }
    const sweep = normalizedEnd - normalizedStart;
    const largeArcFlag = sweep > Math.PI ? 1 : 0;
    const baseOuterRadius = Math.max(
      (_a = geometry1.outerRadius) != null ? _a : defaultOuterRadius,
      (_b = geometry2.outerRadius) != null ? _b : defaultOuterRadius,
      defaultOuterRadius
    );
    const arcRadius = ELAPSED_ARC_RADIUS;
    const x1 = arcRadius * Math.cos(startAngle);
    const y1 = arcRadius * Math.sin(startAngle);
    const x2 = arcRadius * Math.cos(endAngle);
    const y2 = arcRadius * Math.sin(endAngle);
    const arcPath2 = `M ${x1} ${y1} A ${arcRadius} ${arcRadius} 0 ${largeArcFlag} 1 ${x2} ${y2}`;
    const arcGroup2 = document.createElementNS("http://www.w3.org/2000/svg", "g");
    arcGroup2.setAttribute("class", "rt-elapsed-time-arc");
    const arcPathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
    arcPathElement.setAttribute("d", arcPath2);
    arcPathElement.setAttribute("class", "rt-elapsed-arc-path");
    arcGroup2.appendChild(arcPathElement);
    const addEndpointMarker = (angle) => {
      const innerRadius = arcRadius;
      const outerRadius = arcRadius + ELAPSED_TICK_LENGTH;
      const innerX = innerRadius * Math.cos(angle);
      const innerY = innerRadius * Math.sin(angle);
      const outerX = outerRadius * Math.cos(angle);
      const outerY = outerRadius * Math.sin(angle);
      const marker = document.createElementNS("http://www.w3.org/2000/svg", "line");
      marker.setAttribute("x1", `${innerX}`);
      marker.setAttribute("y1", `${innerY}`);
      marker.setAttribute("x2", `${outerX}`);
      marker.setAttribute("y2", `${outerY}`);
      marker.setAttribute("class", "rt-elapsed-endpoint-marker");
      arcGroup2.appendChild(marker);
    };
    addEndpointMarker(startAngle);
    addEndpointMarker(endAngle);
    hideOverlappingTicks(svg, startAngle, endAngle);
    const midpointNormalized = normalizedStart + sweep / 2;
    const midpointAngle2 = normalizeAngle(midpointNormalized);
    const labelRadius2 = arcRadius + 24;
    const labelX2 = labelRadius2 * Math.cos(midpointAngle2);
    const labelY2 = labelRadius2 * Math.sin(midpointAngle2);
    const labelGroup2 = createElapsedTimeLabel(labelX2, labelY2, elapsedTimeText);
    const chronologueArcLayer2 = svg.querySelector(".rt-chronologue-timeline-arc");
    if (chronologueArcLayer2) {
      chronologueArcLayer2.appendChild(arcGroup2);
      chronologueArcLayer2.appendChild(labelGroup2);
      const parent = chronologueArcLayer2.parentElement;
      if (parent) {
        parent.appendChild(chronologueArcLayer2);
      }
    } else {
      svg.appendChild(arcGroup2);
      svg.appendChild(labelGroup2);
    }
    return;
  }
  const fallbackArc = renderElapsedTimeArc(scene1, scene2, defaultOuterRadius);
  const arcGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  arcGroup.setAttribute("class", "rt-elapsed-time-arc");
  arcGroup.innerHTML = fallbackArc;
  const midpointTime = (date1.getTime() + date2.getTime()) / 2;
  const earliestTime = Math.min(date1.getTime(), date2.getTime());
  const latestTime = Math.max(date1.getTime(), date2.getTime());
  const timeRange = latestTime - earliestTime;
  const progress = timeRange > 0 ? (midpointTime - earliestTime) / timeRange : 0.5;
  const midpointAngle = -Math.PI / 2 + progress * 2 * Math.PI;
  const labelRadius = defaultOuterRadius + 30;
  const labelX = labelRadius * Math.cos(midpointAngle);
  const labelY = labelRadius * Math.sin(midpointAngle);
  const labelGroup = createElapsedTimeLabel(labelX, labelY, elapsedTimeText);
  const chronologueArcLayer = svg.querySelector(".rt-chronologue-timeline-arc");
  if (chronologueArcLayer) {
    chronologueArcLayer.appendChild(arcGroup);
    chronologueArcLayer.appendChild(labelGroup);
    const parent = chronologueArcLayer.parentElement;
    if (parent) {
      parent.appendChild(chronologueArcLayer);
    }
  } else {
    svg.appendChild(arcGroup);
    svg.appendChild(labelGroup);
  }
}
function createElapsedTimeLabel(x, y, value) {
  const labelGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  labelGroup.setAttribute("class", "rt-elapsed-time-group");
  const labelText = document.createElementNS("http://www.w3.org/2000/svg", "text");
  labelText.setAttribute("x", `${x}`);
  labelText.setAttribute("y", `${y}`);
  labelText.setAttribute("text-anchor", "middle");
  labelText.setAttribute("dominant-baseline", "middle");
  labelText.setAttribute("fill", "var(--interactive-accent)");
  labelText.setAttribute("class", "rt-elapsed-time-label");
  labelText.textContent = value;
  labelGroup.appendChild(labelText);
  return labelGroup;
}
function normalizeAngle(angle) {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized < 0) {
    normalized += twoPi;
  }
  return normalized;
}
function removeElapsedTimeArc(svg) {
  const existingArc = svg.querySelector(".rt-elapsed-time-arc");
  const existingGroup = svg.querySelector(".rt-elapsed-time-group");
  if (existingArc) existingArc.remove();
  if (existingGroup) existingGroup.remove();
  restoreHiddenTicks(svg);
}
function hideOverlappingTicks(svg, angle1, angle2) {
  const ANGLE_TOLERANCE = 0.01;
  const ticks = Array.from(svg.querySelectorAll(".rt-chronological-tick"));
  ticks.forEach((tick) => {
    const x1Str = tick.getAttribute("x1");
    const y1Str = tick.getAttribute("y1");
    if (!x1Str || !y1Str) return;
    const x1 = parseFloat(x1Str);
    const y1 = parseFloat(y1Str);
    const tickAngle = Math.atan2(y1, x1);
    const normalizeAngle3 = (angle) => {
      let normalized = angle;
      while (normalized > Math.PI) normalized -= 2 * Math.PI;
      while (normalized < -Math.PI) normalized += 2 * Math.PI;
      return normalized;
    };
    const normalizedTickAngle = normalizeAngle3(tickAngle);
    const normalizedAngle1 = normalizeAngle3(angle1);
    const normalizedAngle2 = normalizeAngle3(angle2);
    const matchesAngle1 = Math.abs(normalizedTickAngle - normalizedAngle1) < ANGLE_TOLERANCE;
    const matchesAngle2 = Math.abs(normalizedTickAngle - normalizedAngle2) < ANGLE_TOLERANCE;
    if (matchesAngle1 || matchesAngle2) {
      tick.classList.add("rt-tick-hidden");
    }
  });
}
function restoreHiddenTicks(svg) {
  const hiddenTicks = Array.from(svg.querySelectorAll(".rt-tick-hidden"));
  hiddenTicks.forEach((tick) => tick.classList.remove("rt-tick-hidden"));
}
var SHIFT_BUTTON_BASE_WIDTH, SHIFT_BUTTON_INACTIVE_WIDTH, SHIFT_BUTTON_ACTIVE_WIDTH, SHIFT_BUTTON_BASE_SCALE, SHIFT_BUTTON_ACTIVE_SCALE, globalShiftModeActive;
var init_ChronologueShiftController = __esm({
  "src/view/interactions/ChronologueShiftController.ts"() {
    init_date();
    init_ChronologueTimeline();
    init_LayoutConstants();
    SHIFT_BUTTON_BASE_WIDTH = 133;
    SHIFT_BUTTON_INACTIVE_WIDTH = 106;
    SHIFT_BUTTON_ACTIVE_WIDTH = 128;
    SHIFT_BUTTON_BASE_SCALE = SHIFT_BUTTON_INACTIVE_WIDTH / SHIFT_BUTTON_BASE_WIDTH;
    SHIFT_BUTTON_ACTIVE_SCALE = SHIFT_BUTTON_ACTIVE_WIDTH / SHIFT_BUTTON_BASE_WIDTH;
    globalShiftModeActive = false;
  }
});

// src/modes/definitions/ChronologueMode.ts
var CHRONOLOGUE_MODE;
var init_ChronologueMode = __esm({
  "src/modes/definitions/ChronologueMode.ts"() {
    init_ModeDefinition();
    CHRONOLOGUE_MODE = {
      id: "chronologue" /* CHRONOLOGUE */,
      name: "Chronologue",
      description: "View scenes in chronological story order based on When field",
      rendering: {
        outerRingContent: "chronologue",
        innerRingContent: "chronologue",
        beatDisplay: "none",
        sceneColoring: "subplot",
        numberSquares: "full",
        overlayLayers: ["chronological-timeline"],
        visualMuting: []
      },
      interactions: {
        hoverBehavior: "standard-scene-hover",
        clickBehavior: "open-scene-file",
        enableZeroDraftMode: true,
        exitBehavior: "toggle-button"
      },
      ui: {
        acronym: "CHRO",
        tooltip: "Switch to Chronologue mode",
        showInToggleButton: true,
        order: 3
      },
      /**
       * Exit lifecycle hook - Clean up shift mode state
       */
      onExit: async (view) => {
        if (view._chronologueShiftCleanup) {
          view._chronologueShiftCleanup();
          delete view._chronologueShiftCleanup;
        }
        const { resetShiftModeState: resetShiftModeState2 } = await Promise.resolve().then(() => (init_ChronologueShiftController(), ChronologueShiftController_exports));
        resetShiftModeState2();
        const container = view.containerEl;
        if (container) {
          const svg = container.querySelector(".radial-timeline-svg");
          if (svg) {
            svg.removeAttribute("data-shift-mode");
            const shiftButton = svg.querySelector("#shift-mode-toggle");
            if (shiftButton) {
              shiftButton.remove();
            }
            svg.querySelectorAll(".rt-shift-hover, .rt-shift-locked, .rt-shift-selected, .rt-shift-non-select").forEach((el) => {
              el.classList.remove("rt-shift-hover", "rt-shift-locked", "rt-shift-selected", "rt-shift-non-select");
            });
            svg.querySelectorAll(".rt-shift-active").forEach((el) => {
              el.classList.remove("rt-shift-active");
              el.removeAttribute("data-subplot-idx");
            });
            svg.querySelectorAll(".rt-elapsed-time-arc, .rt-elapsed-time-group").forEach((el) => {
              el.remove();
            });
            svg.querySelectorAll(".rt-selected, .rt-non-selected").forEach((el) => {
              el.classList.remove("rt-selected", "rt-non-selected");
            });
          }
        }
      }
    };
  }
});

// src/modes/ModeRegistry.ts
var ModeRegistry_exports = {};
__export(ModeRegistry_exports, {
  getAllModes: () => getAllModes,
  getModeDefinition: () => getModeDefinition,
  getNextToggleMode: () => getNextToggleMode,
  getToggleableModes: () => getToggleableModes,
  isModeRegistered: () => isModeRegistered
});
function getModeDefinition(mode) {
  const definition = MODE_REGISTRY.get(mode);
  if (!definition) {
    return NARRATIVE_MODE;
  }
  return definition;
}
function getAllModes() {
  return Array.from(MODE_REGISTRY.values());
}
function getToggleableModes() {
  return getAllModes().filter((mode) => mode.ui.showInToggleButton).sort((a, b) => a.ui.order - b.ui.order);
}
function getNextToggleMode(currentMode) {
  var _a;
  const toggleable = getToggleableModes();
  const currentIndex = toggleable.findIndex((mode) => mode.id === currentMode);
  if (currentIndex === -1) {
    return ((_a = toggleable[0]) == null ? void 0 : _a.id) || "narrative" /* NARRATIVE */;
  }
  const nextIndex = (currentIndex + 1) % toggleable.length;
  return toggleable[nextIndex].id;
}
function isModeRegistered(mode) {
  return MODE_REGISTRY.has(mode);
}
var MODE_REGISTRY;
var init_ModeRegistry = __esm({
  "src/modes/ModeRegistry.ts"() {
    init_ModeDefinition();
    init_AllScenesMode();
    init_MainPlotMode();
    init_GossamerMode();
    init_ChronologueMode();
    MODE_REGISTRY = /* @__PURE__ */ new Map([
      ["narrative" /* NARRATIVE */, NARRATIVE_MODE],
      ["subplot" /* SUBPLOT */, SUBPLOT_MODE],
      ["chronologue" /* CHRONOLOGUE */, CHRONOLOGUE_MODE],
      ["gossamer" /* GOSSAMER */, GOSSAMER_MODE]
    ]);
  }
});

// src/utils/fileUtils.ts
async function openOrRevealFile(app, file, newLeaf = false) {
  const leaves = app.workspace.getLeavesOfType("markdown");
  const existingLeaf = leaves.find((leaf) => {
    var _a;
    const view = leaf.view;
    return view instanceof import_obsidian7.MarkdownView && ((_a = view.file) == null ? void 0 : _a.path) === file.path;
  });
  if (existingLeaf) {
    app.workspace.setActiveLeaf(existingLeaf);
    return;
  }
  await app.workspace.openLinkText(file.path, "", newLeaf);
}
async function openOrRevealFileByPath(app, filePath, newLeaf = false) {
  const file = app.vault.getAbstractFileByPath(filePath);
  if (!(file instanceof import_obsidian7.TFile)) {
    throw new Error(`File not found: ${filePath}`);
  }
  await openOrRevealFile(app, file, newLeaf);
}
var import_obsidian7;
var init_fileUtils = __esm({
  "src/utils/fileUtils.ts"() {
    import_obsidian7 = require("obsidian");
  }
});

// src/view/interactions/DominantSubplotHandler.ts
async function handleDominantSubplotSelection(view, clickedGroup, svgElement, scenes) {
  var _a, _b, _c, _d;
  const subplotIndexAttr = clickedGroup.getAttribute("data-subplot-index");
  const encodedPath = clickedGroup.getAttribute("data-path");
  if (!subplotIndexAttr || !encodedPath) {
    return;
  }
  const subplotIndex = parseInt(subplotIndexAttr, 10);
  if (isNaN(subplotIndex)) {
    return;
  }
  const subplotLabels = Array.from(svgElement.querySelectorAll(".rt-subplot-ring-label-text"));
  const masterSubplotOrder = subplotLabels.map((label) => label.getAttribute("data-subplot-name")).filter((name) => name !== null);
  if (subplotIndex >= masterSubplotOrder.length) {
    return;
  }
  const clickedSubplot = masterSubplotOrder[subplotIndex];
  const scenesInClickedSubplot = scenes.filter((s) => s.subplot === clickedSubplot);
  const pathToScenes = /* @__PURE__ */ new Map();
  scenes.forEach((s) => {
    if (s.path) {
      if (!pathToScenes.has(s.path)) {
        pathToScenes.set(s.path, []);
      }
      pathToScenes.get(s.path).push(s);
    }
  });
  let updatedCount = 0;
  if (!view.plugin.settings.dominantSubplots) {
    view.plugin.settings.dominantSubplots = {};
  }
  scenesInClickedSubplot.forEach((scene) => {
    if (!scene.path) return;
    const scenesWithSamePath = pathToScenes.get(scene.path) || [];
    if (scenesWithSamePath.length > 1) {
      view.plugin.settings.dominantSubplots[scene.path] = clickedSubplot;
      updatedCount++;
    }
  });
  if (updatedCount > 0) {
    if (view.plugin.saveSettings) {
      await view.plugin.saveSettings();
    }
    const timelineView = (_d = (_c = (_b = (_a = view.plugin.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.getLeavesOfType("radial-timeline")) == null ? void 0 : _c[0]) == null ? void 0 : _d.view;
    if (timelineView == null ? void 0 : timelineView.refreshTimeline) {
      timelineView.refreshTimeline();
    }
  }
}
var init_DominantSubplotHandler = __esm({
  "src/view/interactions/DominantSubplotHandler.ts"() {
  }
});

// src/view/interactions/SynopsisTitleColorManager.ts
function updateSynopsisTitleColor(synopsis, sceneId, mode) {
  var _a;
  const titleTspans = synopsis.querySelectorAll('.rt-scene-title-bold[data-item-type="title"]');
  if (titleTspans.length === 0) return;
  let color = null;
  if (mode === "narrative" || mode === "chronologue") {
    const sceneGroup = (_a = document.getElementById(sceneId)) == null ? void 0 : _a.closest(".rt-scene-group");
    if (sceneGroup) {
      const subplotIndex = sceneGroup.getAttribute("data-subplot-index");
      if (subplotIndex) {
        const idx = parseInt(subplotIndex, 10) % 15;
        const varName = `--rt-subplot-colors-${idx}`;
        color = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
      }
    }
  } else if (mode === "subplot") {
    color = synopsis.getAttribute("data-stage-color");
  }
  if (color) {
    titleTspans.forEach((tspan) => {
      tspan.style.setProperty("--rt-dynamic-color", color);
    });
  }
}
var init_SynopsisTitleColorManager = __esm({
  "src/view/interactions/SynopsisTitleColorManager.ts"() {
  }
});

// src/view/interactions/SceneTitleExpansion.ts
function needsExpansion(textWidth, currentArcLength, midRadius) {
  const angularNudgePx = TEXTPATH_START_NUDGE_RAD2 * midRadius;
  const requiredArcPx = textWidth + PADDING_PX + TEXTPATH_START_OFFSET_PX + angularNudgePx;
  return currentArcLength < requiredArcPx;
}
function calculateTargetSize(textWidth, midRadius) {
  const angularNudgePx = TEXTPATH_START_NUDGE_RAD2 * midRadius;
  const requiredArcPx = textWidth + PADDING_PX + TEXTPATH_START_OFFSET_PX + angularNudgePx;
  const targetArcPx = requiredArcPx * HOVER_EXPAND_FACTOR;
  return targetArcPx / midRadius;
}
function getActBoundaries(actNumber) {
  if (actNumber === 0) {
    return {
      start: -Math.PI / 2,
      end: -Math.PI / 2 + 2 * Math.PI
    };
  } else {
    const NUM_ACTS2 = 3;
    return {
      start: actNumber * 2 * Math.PI / NUM_ACTS2 - Math.PI / 2,
      end: (actNumber + 1) * 2 * Math.PI / NUM_ACTS2 - Math.PI / 2
    };
  }
}
function redistributeAngles(elements, hoveredId, targetSize, actStartAngle) {
  const scenes = elements.filter((e) => e.isScene);
  const beats = elements.filter((e) => !e.isScene);
  const totalBeatSpace = beats.reduce((sum, beat) => sum + (beat.endAngle - beat.startAngle), 0);
  const totalActSpace = elements.reduce((sum, el) => sum + (el.endAngle - el.startAngle), 0);
  const availableSceneSpace = totalActSpace - totalBeatSpace;
  const spaceForOtherScenes = availableSceneSpace - targetSize;
  const sizePerOtherScene = spaceForOtherScenes / (scenes.length - 1);
  const results = [];
  let currentAngle = actStartAngle;
  for (const element of elements) {
    let newStart = currentAngle;
    let newEnd;
    if (element.id === hoveredId) {
      newEnd = currentAngle + targetSize;
    } else if (element.isScene) {
      newEnd = currentAngle + sizePerOtherScene;
    } else {
      const originalSize = element.endAngle - element.startAngle;
      newEnd = currentAngle + originalSize;
    }
    results.push({
      id: element.id,
      newStartAngle: newStart,
      newEndAngle: newEnd
    });
    currentAngle = newEnd;
  }
  return results;
}
function buildArcPath(innerRadius, outerRadius, startAngle, endAngle) {
  const formatNumber2 = (n) => n.toFixed(6);
  const largeArcFlag = endAngle - startAngle > Math.PI ? 1 : 0;
  return `
        M ${formatNumber2(innerRadius * Math.cos(startAngle))} ${formatNumber2(innerRadius * Math.sin(startAngle))}
        L ${formatNumber2(outerRadius * Math.cos(startAngle))} ${formatNumber2(outerRadius * Math.sin(startAngle))}
        A ${formatNumber2(outerRadius)} ${formatNumber2(outerRadius)} 0 ${largeArcFlag} 1 ${formatNumber2(outerRadius * Math.cos(endAngle))} ${formatNumber2(outerRadius * Math.sin(endAngle))}
        L ${formatNumber2(innerRadius * Math.cos(endAngle))} ${formatNumber2(innerRadius * Math.sin(endAngle))}
        A ${formatNumber2(innerRadius)} ${formatNumber2(innerRadius)} 0 ${largeArcFlag} 0 ${formatNumber2(innerRadius * Math.cos(startAngle))} ${formatNumber2(innerRadius * Math.sin(startAngle))}
    `;
}
function buildTextPath(radius, startAngle, endAngle) {
  const formatNumber2 = (n) => n.toFixed(6);
  const textStart = startAngle + TEXTPATH_START_NUDGE_RAD2;
  const largeArcFlag = endAngle - textStart > Math.PI ? 1 : 0;
  return `M ${formatNumber2(radius * Math.cos(textStart))} ${formatNumber2(radius * Math.sin(textStart))} A ${formatNumber2(radius)} ${formatNumber2(radius)} 0 ${largeArcFlag} 1 ${formatNumber2(radius * Math.cos(endAngle))} ${formatNumber2(radius * Math.sin(endAngle))}`;
}
var HOVER_EXPAND_FACTOR, SCENE_TITLE_INSET2, TEXTPATH_START_NUDGE_RAD2, TEXTPATH_START_OFFSET_PX, PADDING_PX;
var init_SceneTitleExpansion = __esm({
  "src/view/interactions/SceneTitleExpansion.ts"() {
    HOVER_EXPAND_FACTOR = 1.1;
    SCENE_TITLE_INSET2 = 22;
    TEXTPATH_START_NUDGE_RAD2 = 0.02;
    TEXTPATH_START_OFFSET_PX = 4;
    PADDING_PX = 8;
  }
});

// src/view/interactions/SceneInteractionManager.ts
var SceneInteractionManager;
var init_SceneInteractionManager = __esm({
  "src/view/interactions/SceneInteractionManager.ts"() {
    init_SynopsisTitleColorManager();
    init_SceneTitleExpansion();
    SceneInteractionManager = class {
      constructor(view, svg) {
        this.enabled = true;
        // State tracking
        this.currentGroup = null;
        this.currentSynopsis = null;
        this.currentSceneId = null;
        this.rafId = null;
        this.registerFn = null;
        // Original state storage for reset
        this.originalAngles = /* @__PURE__ */ new Map();
        this.originalSquareTransforms = /* @__PURE__ */ new Map();
        // Cleanup registration (for Obsidian's Component system)
        this.cleanupCallbacks = [];
        this.svg = svg;
        this.registerFn = typeof view.register === "function" ? view.register.bind(view) : null;
        this.measurementText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        this.measurementText.classList.add("rt-measure-text");
        svg.appendChild(this.measurementText);
        this.registerCleanup(() => {
          if (this.rafId !== null) {
            cancelAnimationFrame(this.rafId);
            this.rafId = null;
          }
        });
      }
      /**
       * Get the view (uses getLeavesOfType to avoid persistent reference)
       */
      getView() {
        const doc = this.svg.ownerDocument;
        if (!doc || !doc.defaultView) return null;
        const win = doc.defaultView;
        if (!win.app) return null;
        const leaves = win.app.workspace.getLeavesOfType("radial-timeline");
        if (!leaves || leaves.length === 0) return null;
        return leaves[0].view;
      }
      /**
       * Enable or disable title expansion based on settings
       */
      setTitleExpansionEnabled(enabled) {
        this.enabled = enabled;
      }
      /**
       * Handle scene hover
       */
      onSceneHover(group, sceneId, mouseEvent) {
        const view = this.getView();
        if (!view) return;
        this.currentGroup = group;
        this.currentSceneId = sceneId;
        this.currentSynopsis = this.findSynopsisForScene(sceneId);
        this.applySelection(group, sceneId);
        if (this.currentSynopsis) {
          if (mouseEvent) {
            view.plugin.synopsisManager.updatePosition(
              this.currentSynopsis,
              mouseEvent,
              this.svg,
              sceneId
            );
          }
          const currentMode = view.plugin.settings.currentMode || "narrative";
          updateSynopsisTitleColor(this.currentSynopsis, sceneId, currentMode);
          this.currentSynopsis.classList.add("rt-visible");
        }
        if (this.enabled && view.plugin.settings.enableSceneTitleAutoExpand) {
          const sceneTitle = group.querySelector(".rt-scene-title");
          if (sceneTitle) {
            this.redistributeActScenes(group);
          }
        }
      }
      /**
       * Handle scene leave
       */
      onSceneLeave() {
        if (this.originalAngles.size > 0) {
          this.resetAngularRedistribution();
        }
        this.clearSelection();
        this.currentGroup = null;
        this.currentSynopsis = null;
        this.currentSceneId = null;
      }
      /**
       * Update synopsis position on mouse move
       */
      onMouseMove(e) {
        if (this.rafId !== null) return;
        const rafId = window.requestAnimationFrame(() => {
          this.rafId = null;
          const view = this.getView();
          if (!view || !this.currentSynopsis || !this.currentSceneId) return;
          if (!this.currentSynopsis.classList.contains("rt-visible")) return;
          view.plugin.synopsisManager.updatePosition(
            this.currentSynopsis,
            e,
            this.svg,
            this.currentSceneId
          );
        });
        this.rafId = rafId;
      }
      /**
       * Clean up resources
       */
      cleanup() {
        if (this.rafId !== null) {
          cancelAnimationFrame(this.rafId);
          this.rafId = null;
        }
        if (this.measurementText && this.measurementText.parentNode) {
          this.measurementText.parentNode.removeChild(this.measurementText);
        }
        this.resetAngularRedistribution();
        this.clearSelection();
        this.cleanupCallbacks.forEach((fn) => {
          try {
            fn();
          } catch (e) {
          }
        });
        this.cleanupCallbacks = [];
      }
      // ========================================================================
      // Private Helper Methods
      // ========================================================================
      findSynopsisForScene(sceneId) {
        return this.svg.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
      }
      clearSelection() {
        const all = this.svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-discontinuity-marker");
        all.forEach((el) => el.classList.remove("rt-selected"));
        const view = this.getView();
        if (view && view.currentMode !== "gossamer") {
          all.forEach((el) => el.classList.remove("rt-non-selected"));
        }
        if (this.currentSynopsis) {
          this.currentSynopsis.classList.remove("rt-visible");
        }
      }
      applySelection(group, sceneId) {
        const pathEl = group.querySelector(".rt-scene-path");
        if (pathEl) pathEl.classList.add("rt-selected");
        const numberSquare = this.svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
        if (numberSquare) numberSquare.classList.add("rt-selected");
        const numberText = this.svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
        if (numberText) numberText.classList.add("rt-selected");
        const sceneTitle = group.querySelector(".rt-scene-title");
        if (sceneTitle) sceneTitle.classList.add("rt-selected");
        const related = /* @__PURE__ */ new Set();
        const currentPathAttr = group.getAttribute("data-path");
        if (currentPathAttr) {
          const matches = this.svg.querySelectorAll(`[data-path="${currentPathAttr}"]`);
          matches.forEach((mg) => {
            if (mg === group) return;
            const rp = mg.querySelector(".rt-scene-path");
            if (rp) related.add(rp);
            const rt = mg.querySelector(".rt-scene-title");
            if (rt) related.add(rt);
            const rid = rp == null ? void 0 : rp.id;
            if (rid) {
              const rsq = this.svg.querySelector(`.rt-number-square[data-scene-id="${rid}"]`);
              if (rsq) related.add(rsq);
              const rtx = this.svg.querySelector(`.rt-number-text[data-scene-id="${rid}"]`);
              if (rtx) related.add(rtx);
            }
          });
        }
        const all = this.svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title, .rt-discontinuity-marker");
        all.forEach((el) => {
          if (!el.classList.contains("rt-selected") && !related.has(el)) {
            el.classList.add("rt-non-selected");
          }
        });
      }
      // ========================================================================
      // Scene Title Expansion Logic
      // ========================================================================
      storeOriginalAngles() {
        if (this.originalAngles.size > 0) return;
        const view = this.getView();
        if (!view) return;
        this.svg.querySelectorAll(".rt-scene-group").forEach((group) => {
          const start = Number(group.getAttribute("data-start-angle")) || 0;
          const end = Number(group.getAttribute("data-end-angle")) || 0;
          this.originalAngles.set(group.id, { start, end });
          const scenePathEl = group.querySelector(".rt-scene-path");
          if (scenePathEl) {
            const sceneId = scenePathEl.id;
            const numberSquareGroup = view.getSquareGroupForSceneId(this.svg, sceneId);
            if (numberSquareGroup) {
              const originalTransform = numberSquareGroup.getAttribute("transform") || "";
              this.originalSquareTransforms.set(sceneId, originalTransform);
            }
          }
        });
      }
      resetAngularRedistribution() {
        this.originalAngles.forEach((angles, groupId) => {
          const group = this.svg.getElementById(groupId);
          if (!group) return;
          const innerR = Number(group.getAttribute("data-inner-r")) || 0;
          const outerR = Number(group.getAttribute("data-outer-r")) || 0;
          const path = group.querySelector(".rt-scene-path");
          if (path) {
            path.setAttribute("d", buildArcPath(innerR, outerR, angles.start, angles.end));
          }
          const textPath = group.querySelector('path[id^="textPath-"]');
          if (textPath) {
            const textPathRadius = Math.max(innerR, outerR - SCENE_TITLE_INSET2);
            textPath.setAttribute("d", buildTextPath(textPathRadius, angles.start, angles.end));
          }
          const scenePathEl = group.querySelector(".rt-scene-path");
          if (scenePathEl) {
            const sceneId = scenePathEl.id;
            const originalTransform = this.originalSquareTransforms.get(sceneId);
            if (originalTransform !== void 0) {
              const match = originalTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
              if (match) {
                const view = this.getView();
                if (view) {
                  view.setNumberSquareGroupPosition(
                    this.svg,
                    sceneId,
                    parseFloat(match[1]),
                    parseFloat(match[2])
                  );
                }
              }
            }
          }
        });
        this.originalAngles.clear();
        this.originalSquareTransforms.clear();
      }
      redistributeActScenes(hoveredGroup) {
        this.storeOriginalAngles();
        const hoveredAct = hoveredGroup.getAttribute("data-act");
        const hoveredRing = hoveredGroup.getAttribute("data-ring");
        if (!hoveredAct || !hoveredRing) return;
        const actElements = [];
        const sceneElements = [];
        this.svg.querySelectorAll(".rt-scene-group").forEach((group) => {
          if (group.getAttribute("data-act") === hoveredAct && group.getAttribute("data-ring") === hoveredRing) {
            const path = group.querySelector(".rt-scene-path");
            if (path) {
              const sceneTitle = group.querySelector(".rt-scene-title");
              const isScene = !!sceneTitle;
              if (isScene) {
                sceneElements.push(group);
              }
              actElements.push({
                id: group.id,
                startAngle: Number(group.getAttribute("data-start-angle")) || 0,
                endAngle: Number(group.getAttribute("data-end-angle")) || 0,
                innerRadius: Number(group.getAttribute("data-inner-r")) || 0,
                outerRadius: Number(group.getAttribute("data-outer-r")) || 0,
                isScene
              });
            }
          }
        });
        if (actElements.length <= 1) return;
        if (!sceneElements.includes(hoveredGroup)) return;
        const hoveredData = actElements.find((e) => e.id === hoveredGroup.id);
        if (!hoveredData) return;
        const hoveredMidR = (hoveredData.innerRadius + hoveredData.outerRadius) / 2;
        const currentArcPx = (hoveredData.endAngle - hoveredData.startAngle) * hoveredMidR;
        const hoveredSceneTitle = hoveredGroup.querySelector(".rt-scene-title");
        if (!hoveredSceneTitle) return;
        const titleText = hoveredSceneTitle.textContent || "";
        if (!titleText.trim()) return;
        this.measurementText.textContent = titleText;
        const hoveredComputed = getComputedStyle(hoveredSceneTitle);
        const fontFamily = hoveredComputed.fontFamily || "sans-serif";
        const fontSize = hoveredComputed.fontSize || "18px";
        this.measurementText.style.setProperty("--rt-measurement-font-family", fontFamily);
        this.measurementText.style.setProperty("--rt-measurement-font-size", fontSize);
        const textBBox = this.measurementText.getBBox();
        const textWidth = textBBox.width;
        if (!needsExpansion(textWidth, currentArcPx, hoveredMidR)) {
          return;
        }
        const targetSize = calculateTargetSize(textWidth, hoveredMidR);
        const actNum = Number(hoveredAct);
        const actBounds = getActBoundaries(actNum);
        const redistribution = redistributeAngles(
          actElements,
          hoveredGroup.id,
          targetSize,
          actBounds.start
        );
        redistribution.forEach((result) => {
          const group = this.svg.getElementById(result.id);
          if (!group) return;
          const innerR = Number(group.getAttribute("data-inner-r")) || 0;
          const outerR = Number(group.getAttribute("data-outer-r")) || 0;
          const path = group.querySelector(".rt-scene-path");
          if (path) {
            path.setAttribute("d", buildArcPath(innerR, outerR, result.newStartAngle, result.newEndAngle));
          }
          const textPath = group.querySelector('path[id^="textPath-"]');
          if (textPath) {
            const textPathRadius = Math.max(innerR, outerR - SCENE_TITLE_INSET2);
            textPath.setAttribute("d", buildTextPath(textPathRadius, result.newStartAngle, result.newEndAngle));
          }
          const scenePathEl = group.querySelector(".rt-scene-path");
          if (scenePathEl) {
            const sceneId = scenePathEl.id;
            const squareRadius = (innerR + outerR) / 2;
            const squareX = squareRadius * Math.cos(result.newStartAngle);
            const squareY = squareRadius * Math.sin(result.newStartAngle);
            const view = this.getView();
            if (view) {
              view.setNumberSquareGroupPosition(this.svg, sceneId, squareX, squareY);
            }
          }
        });
      }
      registerCleanup(fn) {
        if (this.registerFn) {
          try {
            this.registerFn(fn);
            return;
          } catch (e) {
          }
        }
        this.cleanupCallbacks.push(fn);
      }
    };
  }
});

// src/modals/ZeroDraftModal.ts
var ZeroDraftModal_exports = {};
__export(ZeroDraftModal_exports, {
  ZeroDraftModal: () => ZeroDraftModal,
  default: () => ZeroDraftModal_default
});
var import_obsidian8, ZeroDraftModal, ZeroDraftModal_default;
var init_ZeroDraftModal = __esm({
  "src/modals/ZeroDraftModal.ts"() {
    import_obsidian8 = require("obsidian");
    ZeroDraftModal = class extends import_obsidian8.Modal {
      constructor(app, options) {
        super(app);
        this.titleText = options.titleText;
        this.originalText = (options.initialText || "").trim();
        this.onOk = options.onOk;
        this.onOverride = options.onOverride;
      }
      onOpen() {
        const { contentEl, titleEl } = this;
        titleEl.setText(this.titleText);
        const infoEl = contentEl.createDiv({ cls: "rt-zero-draft-info" });
        infoEl.setText("Zero draft mode is enabled. This scene has Publish Stage = Zero and Status = Complete. Enter Pending Edits below, or click Override to open the note. You can turn this off in Settings \u2192 Zero draft mode.");
        this.textareaEl = contentEl.createEl("textarea", { cls: "rt-zero-draft-textarea" });
        this.textareaEl.value = this.originalText;
        const buttonRow = contentEl.createDiv({ cls: "rt-zero-draft-buttons" });
        new import_obsidian8.ButtonComponent(buttonRow).setButtonText("OK").onClick(() => {
          const next = (this.textareaEl.value || "").trim();
          if (this.originalText.length > 0 && next.length === 0) {
            const confirmed = window.confirm("Delete existing pending edits content? This will remove all previous text.");
            if (!confirmed) return;
          }
          this.onOk(next);
          this.close();
        });
        new import_obsidian8.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => {
          const current = (this.textareaEl.value || "").trim();
          const isDirty = current !== this.originalText;
          if (isDirty) {
            const discard = window.confirm("Discard changes?");
            if (!discard) return;
          }
          this.close();
        });
        const overrideBtn = new import_obsidian8.ButtonComponent(buttonRow).setButtonText("Override").onClick(() => {
          const current = (this.textareaEl.value || "").trim();
          const isDirty = current !== this.originalText;
          if (isDirty) {
            const discard = window.confirm("Discard changes?");
            if (!discard) return;
          }
          this.onOverride();
          this.close();
        });
        overrideBtn.buttonEl.classList.add("rt-zero-draft-override");
      }
    };
    ZeroDraftModal_default = ZeroDraftModal;
  }
});

// src/view/modes/AllScenesMode.ts
var AllScenesMode_exports = {};
__export(AllScenesMode_exports, {
  setupAllScenesDelegatedHover: () => setupAllScenesDelegatedHover,
  setupSceneInteractions: () => setupSceneInteractions
});
function setupSceneInteractions(view, group, svgElement, scenes) {
  if (view.currentMode !== "narrative") return;
  const path = group.querySelector(".rt-scene-path");
  if (!path) return;
  const encodedPath = group.getAttribute("data-path");
  if (encodedPath && encodedPath !== "") {
    const filePath = decodeURIComponent(encodedPath);
    view.registerDomEvent(path, "click", async (evt) => {
      var _a, _b, _c;
      const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian9.TFile)) return;
      await handleDominantSubplotSelection(view, group, svgElement, scenes);
      if (view.plugin.settings.enableZeroDraftMode) {
        const cache = view.plugin.app.metadataCache.getFileCache(file);
        const fm = cache && cache.frontmatter ? cache.frontmatter : {};
        const getFm = (key) => {
          if (!fm) return void 0;
          const lower = key.toLowerCase();
          for (const k of Object.keys(fm)) {
            if (k.toLowerCase() === lower) return fm[k];
          }
          return void 0;
        };
        const stageValue = String((_a = getFm("Publish Stage")) != null ? _a : "Zero");
        const statusValue = String((_b = getFm("Status")) != null ? _b : "Todo");
        const isStageZero = stageValue.trim().toLowerCase() === "zero";
        const isStatusComplete = statusValue.trim().toLowerCase() === "complete";
        if (isStageZero && isStatusComplete) {
          evt.preventDefault();
          evt.stopPropagation();
          const pendingEdits = String((_c = getFm("Pending Edits")) != null ? _c : "").trim();
          const sceneTitle = file.basename || "Scene";
          const modal = new (init_ZeroDraftModal(), __toCommonJS(ZeroDraftModal_exports)).default(view.plugin.app, {
            titleText: `Pending Edits \u2014 ${sceneTitle}`,
            initialText: pendingEdits,
            onOk: async (nextText) => {
              try {
                await view.plugin.app.fileManager.processFrontMatter(file, (yaml) => {
                  yaml["Pending Edits"] = nextText;
                });
              } catch (e) {
              }
            },
            onOverride: async () => {
              await openOrRevealFile(view.plugin.app, file, false);
            }
          });
          modal.open();
          return;
        }
      }
      await openOrRevealFile(view.plugin.app, file, false);
    });
    view.registerDomEvent(group, "mouseenter", () => {
      const itemType = group.getAttribute("data-item-type");
      if (view.currentMode === "gossamer" && itemType !== "Beat") return;
    });
    view.registerDomEvent(group, "mouseleave", () => {
      const itemType = group.getAttribute("data-item-type");
      if (view.currentMode === "gossamer" && itemType !== "Beat") return;
    });
  }
}
function setupAllScenesDelegatedHover(view, container, scenes) {
  var _a;
  const svg = container.querySelector(".radial-timeline-svg");
  if (!svg) return;
  const manager = new SceneInteractionManager(view, svg);
  manager.setTitleExpansionEnabled((_a = view.plugin.settings.enableSceneTitleAutoExpand) != null ? _a : true);
  let currentGroup = null;
  let currentSceneId = null;
  let rafId = null;
  const clearSelection = () => {
    manager.onSceneLeave();
    currentGroup = null;
    currentSceneId = null;
  };
  const getSceneIdFromGroup = (group) => {
    const pathEl = group.querySelector(".rt-scene-path");
    return (pathEl == null ? void 0 : pathEl.id) || null;
  };
  view.registerDomEvent(svg, "pointerover", (e) => {
    const svgMode = svg.getAttribute("data-mode");
    if (svgMode === "gossamer") return;
    const g = e.target.closest(".rt-scene-group");
    if (!g || g === currentGroup) return;
    clearSelection();
    const sid = getSceneIdFromGroup(g);
    if (!sid) return;
    svg.classList.add("scene-hover");
    currentGroup = g;
    currentSceneId = sid;
    manager.onSceneHover(g, sid, e);
  });
  view.registerDomEvent(svg, "pointerout", (e) => {
    const svgMode = svg.getAttribute("data-mode");
    if (svgMode === "gossamer") return;
    const toEl = e.relatedTarget;
    if (currentGroup && toEl && currentGroup.contains(toEl)) return;
    svg.classList.remove("scene-hover");
    clearSelection();
  });
  view.registerDomEvent(svg, "pointermove", (e) => {
    if (rafId !== null) return;
    rafId = window.requestAnimationFrame(() => {
      manager.onMouseMove(e);
      rafId = null;
    });
  });
  view.registerDomEvent(svg, "pointerout", () => {
    if (rafId !== null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  });
}
var import_obsidian9;
var init_AllScenesMode2 = __esm({
  "src/view/modes/AllScenesMode.ts"() {
    import_obsidian9 = require("obsidian");
    init_fileUtils();
    init_DominantSubplotHandler();
    init_SceneInteractionManager();
  }
});

// src/view/modes/MainPlotMode.ts
var MainPlotMode_exports = {};
__export(MainPlotMode_exports, {
  setupMainPlotMode: () => setupMainPlotMode
});
function setupMainPlotMode(view, svg) {
  var _a;
  const manager = new SceneInteractionManager(view, svg);
  manager.setTitleExpansionEnabled((_a = view.plugin.settings.enableSceneTitleAutoExpand) != null ? _a : true);
  let currentGroup = null;
  let currentSceneId = null;
  let rafId = null;
  const clearSelection = () => {
    manager.onSceneLeave();
    currentGroup = null;
    currentSceneId = null;
  };
  const getSceneIdFromGroup = (group) => {
    const pathEl = group.querySelector(".rt-scene-path");
    return (pathEl == null ? void 0 : pathEl.id) || null;
  };
  view.registerDomEvent(svg, "pointerover", (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g || g === currentGroup) return;
    const sid = getSceneIdFromGroup(g);
    if (!sid) return;
    clearSelection();
    svg.classList.add("scene-hover");
    currentGroup = g;
    currentSceneId = sid;
    manager.onSceneHover(g, sid, e);
  });
  view.registerDomEvent(svg, "pointerout", (e) => {
    const toEl = e.relatedTarget;
    if (currentGroup && toEl && currentGroup.contains(toEl)) return;
    svg.classList.remove("scene-hover");
    clearSelection();
  });
  view.registerDomEvent(svg, "pointermove", (e) => {
    if (rafId !== null) return;
    rafId = window.requestAnimationFrame(() => {
      manager.onMouseMove(e);
      rafId = null;
    });
  });
  view.registerDomEvent(svg, "pointerout", () => {
    if (rafId !== null) {
      cancelAnimationFrame(rafId);
      rafId = null;
    }
  });
  view.registerDomEvent(svg, "click", async (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g) return;
    e.stopPropagation();
    const encodedPath = g.getAttribute("data-path");
    if (!encodedPath) return;
    const filePath = decodeURIComponent(encodedPath);
    const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian10.TFile) {
      await openOrRevealFile(view.plugin.app, file);
    }
  });
}
var import_obsidian10;
var init_MainPlotMode2 = __esm({
  "src/view/modes/MainPlotMode.ts"() {
    import_obsidian10 = require("obsidian");
    init_fileUtils();
    init_SceneInteractionManager();
  }
});

// src/view/modes/GossamerMode.ts
var GossamerMode_exports = {};
__export(GossamerMode_exports, {
  setupGossamerMode: () => setupGossamerMode
});
function setupGossamerMode(view, svg) {
  let currentGroup = null;
  let currentSynopsis = null;
  const findSynopsisForScene = (sceneId) => {
    return svg.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
  };
  const getSceneIdFromGroup = (group) => {
    const pathEl = group.querySelector(".rt-scene-path");
    return (pathEl == null ? void 0 : pathEl.id) || null;
  };
  const beatSliceOver = (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Beat"]');
    if (!g) return;
    beatSliceEnter(g, e);
  };
  const beatSliceEnter = (g, e) => {
    var _a;
    if (g === currentGroup) return;
    currentGroup = g;
    svg.classList.add("scene-hover");
    const sid = getSceneIdFromGroup(g);
    if (sid) {
      currentSynopsis = findSynopsisForScene(sid);
      if (currentSynopsis) {
        currentSynopsis.classList.add("rt-visible");
        view.plugin.synopsisManager.updatePosition(currentSynopsis, e, svg, sid);
      }
    }
    const encodedPath = g.getAttribute("data-path") || "";
    if (encodedPath) {
      const dotOrScore = svg.querySelector(`.rt-gossamer-dot[data-path="${encodedPath}"], .rt-gossamer-score-text[data-path="${encodedPath}"]`);
      let beatName = null;
      if (dotOrScore) {
        dotOrScore.classList.add("rt-hover");
        beatName = dotOrScore.getAttribute("data-beat");
      }
      if (!beatName) {
        const titleEl = g.querySelector(".rt-storybeat-title");
        if (titleEl) {
          beatName = ((_a = titleEl.textContent) == null ? void 0 : _a.trim()) || null;
        }
      }
      if (beatName) {
        const centerDot = svg.querySelector(`.rt-gossamer-dot-center[data-beat="${beatName}"]`);
        if (centerDot) centerDot.classList.add("rt-hover");
        const spoke = svg.querySelector(`.rt-gossamer-spoke[data-beat="${beatName}"]`);
        if (spoke) spoke.classList.add("rt-gossamer-spoke-hover");
        const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
        if (beatOutline) beatOutline.classList.add("rt-hover");
        const historicalDots = svg.querySelectorAll(`.rt-gossamer-dot-historical[data-beat="${beatName}"]`);
        historicalDots.forEach((hd) => hd.classList.add("rt-hover"));
        const rangeValues = svg.querySelectorAll(`.rt-gossamer-range-value[data-beat="${beatName}"]`);
        rangeValues.forEach((rv) => rv.classList.add("rt-hidden"));
        g.classList.add("rt-gossamer-hover");
      }
    }
  };
  const beatSliceOut = (e) => {
    var _a;
    if (!currentGroup) return;
    const toEl = e.relatedTarget;
    if (toEl && (currentGroup.contains(toEl) || !!toEl.closest(".rt-gossamer-dot") || !!toEl.closest(".rt-gossamer-score-text"))) return;
    svg.classList.remove("scene-hover");
    if (currentSynopsis) {
      currentSynopsis.classList.remove("rt-visible");
      currentSynopsis = null;
    }
    const encodedPath = currentGroup.getAttribute("data-path") || "";
    if (encodedPath) {
      const dotOrScore = svg.querySelector(`.rt-gossamer-dot[data-path="${encodedPath}"], .rt-gossamer-score-text[data-path="${encodedPath}"]`);
      let beatName = null;
      if (dotOrScore) {
        dotOrScore.classList.remove("rt-hover");
        beatName = dotOrScore.getAttribute("data-beat");
      }
      if (!beatName) {
        const titleEl = currentGroup.querySelector(".rt-storybeat-title");
        if (titleEl) {
          beatName = ((_a = titleEl.textContent) == null ? void 0 : _a.trim()) || null;
        }
      }
      if (beatName) {
        const centerDot = svg.querySelector(`.rt-gossamer-dot-center[data-beat="${beatName}"]`);
        if (centerDot) centerDot.classList.remove("rt-hover");
        const spoke = svg.querySelector(`.rt-gossamer-spoke[data-beat="${beatName}"]`);
        if (spoke) spoke.classList.remove("rt-gossamer-spoke-hover");
        const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
        if (beatOutline) beatOutline.classList.remove("rt-hover");
        const historicalDots = svg.querySelectorAll(`.rt-gossamer-dot-historical[data-beat="${beatName}"]`);
        historicalDots.forEach((hd) => hd.classList.remove("rt-hover"));
        const rangeValues = svg.querySelectorAll(`.rt-gossamer-range-value[data-beat="${beatName}"]`);
        rangeValues.forEach((rv) => rv.classList.remove("rt-hidden"));
        currentGroup.classList.remove("rt-gossamer-hover");
      }
    }
    currentGroup = null;
  };
  const dotOver = (e) => {
    const dot = e.target.closest(".rt-gossamer-dot, .rt-gossamer-score-text");
    if (!dot) return;
    dot.classList.add("rt-hover");
    const encodedPath = dot.getAttribute("data-path");
    const beatName = dot.getAttribute("data-beat");
    if (!encodedPath) return;
    svg.classList.add("scene-hover");
    if (beatName) {
      const centerDot = svg.querySelector(`.rt-gossamer-dot-center[data-beat="${beatName}"]`);
      if (centerDot) centerDot.classList.add("rt-hover");
      const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
      if (beatOutline) beatOutline.classList.add("rt-hover");
      const rangeValues = svg.querySelectorAll(`.rt-gossamer-range-value[data-beat="${beatName}"]`);
      rangeValues.forEach((rv) => rv.classList.add("rt-hidden"));
    }
    const beatGroup = svg.querySelector(`.rt-scene-group[data-path="${encodedPath}"]`);
    if (beatGroup) {
      currentGroup = beatGroup;
      beatGroup.classList.add("rt-gossamer-hover");
      const sid = getSceneIdFromGroup(beatGroup);
      if (sid) {
        currentSynopsis = findSynopsisForScene(sid);
        if (currentSynopsis) {
          currentSynopsis.classList.add("rt-visible");
          view.plugin.synopsisManager.updatePosition(currentSynopsis, e, svg, sid);
        }
      }
    }
    if (beatName) {
      const spoke = svg.querySelector(`.rt-gossamer-spoke[data-beat="${beatName}"]`);
      if (spoke) {
        spoke.classList.add("rt-gossamer-spoke-hover");
      }
      const beatOutline = svg.querySelector(`.rt-gossamer-beat-outline[data-beat="${beatName}"]`);
      if (beatOutline) {
        beatOutline.classList.add("rt-hover");
      }
      const historicalDots = svg.querySelectorAll(`.rt-gossamer-dot-historical[data-beat="${beatName}"]`);
      historicalDots.forEach((hd) => hd.classList.add("rt-hover"));
    }
  };
  const dotOut = (e) => {
    const toEl = e.relatedTarget;
    if (toEl && (toEl.closest('.rt-scene-group[data-item-type="Beat"]') || toEl.closest(".rt-gossamer-dot") || toEl.closest(".rt-gossamer-score-text"))) return;
    svg.classList.remove("scene-hover");
    if (currentSynopsis) {
      currentSynopsis.classList.remove("rt-visible");
      currentSynopsis = null;
    }
    if (currentGroup) {
      currentGroup.classList.remove("rt-gossamer-hover");
      currentGroup = null;
    }
    svg.querySelectorAll(".rt-gossamer-spoke-hover").forEach((el) => {
      el.classList.remove("rt-gossamer-spoke-hover");
    });
    svg.querySelectorAll(".rt-gossamer-dot.rt-hover, .rt-gossamer-score-text.rt-hover").forEach((el) => {
      el.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-dot-center.rt-hover").forEach((el) => {
      el.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-beat-outline.rt-hover").forEach((el) => {
      el.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-dot-historical.rt-hover").forEach((hd) => {
      hd.classList.remove("rt-hover");
    });
    svg.querySelectorAll(".rt-gossamer-range-value.rt-hidden").forEach((rv) => {
      rv.classList.remove("rt-hidden");
    });
  };
  const beatSliceClick = async (e) => {
    const g = e.target.closest('.rt-scene-group[data-item-type="Beat"]');
    if (!g) return;
    e.stopPropagation();
    const encodedPath = g.getAttribute("data-path");
    if (!encodedPath) return;
    const filePath = decodeURIComponent(encodedPath);
    const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
    if (file instanceof import_obsidian11.TFile) {
      await openOrRevealFile(view.plugin.app, file);
    }
  };
  const dotClick = async (e) => {
    const dot = e.target.closest(".rt-gossamer-dot, .rt-gossamer-score-text");
    if (!dot) return;
    e.stopPropagation();
    const encodedPath = dot.getAttribute("data-path");
    if (!encodedPath) return;
    const path = decodeURIComponent(encodedPath);
    const file = view.plugin.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian11.TFile) {
      await openOrRevealFile(view.plugin.app, file);
    }
  };
  const backgroundClick = (e) => {
    const target = e.target;
    if (target.closest(".rt-gossamer-dot") || target.closest(".rt-gossamer-score-text") || target.closest('.rt-scene-group[data-item-type="Beat"]')) {
      return;
    }
    Promise.resolve().then(() => (init_GossamerCommands(), GossamerCommands_exports)).then(({ toggleGossamerMode: toggleGossamerMode2 }) => {
      toggleGossamerMode2(view.plugin);
    });
  };
  view.registerDomEvent(svg, "click", beatSliceClick);
  view.registerDomEvent(svg, "click", dotClick);
  view.registerDomEvent(svg, "click", backgroundClick);
  view.registerDomEvent(svg, "pointerover", beatSliceOver);
  view.registerDomEvent(svg, "pointerout", beatSliceOut);
  view.registerDomEvent(svg, "pointerover", dotOver);
  view.registerDomEvent(svg, "pointerout", dotOut);
  view.registerGossamerHandler("pointerover::svg", beatSliceOver);
  view.registerGossamerHandler("pointerout::svg", beatSliceOut);
  view.registerGossamerHandler("pointerover::dot::svg", dotOver);
  view.registerGossamerHandler("pointerout::dot::svg", dotOut);
  view.registerGossamerHandler("click::beat::svg", beatSliceClick);
  view.registerGossamerHandler("click::dot::svg", dotClick);
  view.registerGossamerHandler("click::bg::svg", backgroundClick);
  const beatGroups = svg.querySelectorAll('.rt-scene-group[data-item-type="Beat"]');
  beatGroups.forEach((el) => {
    view.registerDomEvent(el, "pointerenter", (ev) => beatSliceEnter(el, ev));
    view.registerDomEvent(el, "pointerleave", (ev) => beatSliceOut(ev));
    view.registerDomEvent(el, "click", (ev) => beatSliceClick(ev));
  });
}
var import_obsidian11;
var init_GossamerMode2 = __esm({
  "src/view/modes/GossamerMode.ts"() {
    import_obsidian11 = require("obsidian");
    init_fileUtils();
  }
});

// src/view/modes/ChronologueMode.ts
var ChronologueMode_exports = {};
__export(ChronologueMode_exports, {
  setupChronologueMode: () => setupChronologueMode
});
function setupChronologueMode(view, svg) {
  if (view.currentMode !== "chronologue") {
    return;
  }
  setupChronologueShiftController(view, svg);
  setupSceneHoverInteractions(view, svg);
  setupSceneClickInteractions(view, svg);
}
function setupSceneHoverInteractions(view, svg) {
  const manager = new SceneInteractionManager(view, svg);
  manager.setTitleExpansionEnabled(false);
  const sceneIdCache = /* @__PURE__ */ new WeakMap();
  const getSceneIdFromGroup = (group) => {
    var _a;
    const cached = sceneIdCache.get(group);
    if (cached) return cached;
    const pathEl = group.querySelector(".rt-scene-path");
    const sceneId = (_a = pathEl == null ? void 0 : pathEl.id) != null ? _a : null;
    if (sceneId) {
      sceneIdCache.set(group, sceneId);
    }
    return sceneId;
  };
  const synopsisBySceneId = /* @__PURE__ */ new Map();
  svg.querySelectorAll(".rt-scene-info[data-for-scene]").forEach((synopsis) => {
    const sceneId = synopsis.getAttribute("data-for-scene");
    if (sceneId) {
      synopsisBySceneId.set(sceneId, synopsis);
    }
  });
  const numberSquareBySceneId = /* @__PURE__ */ new Map();
  svg.querySelectorAll(".rt-number-square[data-scene-id]").forEach((square) => {
    const sceneId = square.getAttribute("data-scene-id");
    if (sceneId) {
      numberSquareBySceneId.set(sceneId, square);
    }
  });
  const numberTextBySceneId = /* @__PURE__ */ new Map();
  svg.querySelectorAll(".rt-number-text[data-scene-id]").forEach((text) => {
    const sceneId = text.getAttribute("data-scene-id");
    if (sceneId) {
      numberTextBySceneId.set(sceneId, text);
    }
  });
  const sceneElementRefs = /* @__PURE__ */ new Map();
  const scenesByPath = /* @__PURE__ */ new Map();
  svg.querySelectorAll('.rt-scene-group[data-item-type="Scene"]').forEach((group) => {
    var _a, _b;
    const sceneId = getSceneIdFromGroup(group);
    if (!sceneId) return;
    const pathEl = group.querySelector(".rt-scene-path");
    const titleEl = group.querySelector(".rt-scene-title");
    sceneElementRefs.set(sceneId, {
      path: pathEl,
      numberSquare: (_a = numberSquareBySceneId.get(sceneId)) != null ? _a : null,
      numberText: (_b = numberTextBySceneId.get(sceneId)) != null ? _b : null,
      title: titleEl != null ? titleEl : null
    });
    const pathAttr = group.getAttribute("data-path");
    if (pathAttr) {
      if (!scenesByPath.has(pathAttr)) {
        scenesByPath.set(pathAttr, []);
      }
      scenesByPath.get(pathAttr).push(sceneId);
    }
  });
  const fadeTargets = [];
  const seen = /* @__PURE__ */ new Set();
  svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title").forEach((el) => {
    if (!seen.has(el)) {
      fadeTargets.push(el);
      seen.add(el);
    }
  });
  let currentHoveredSceneId = null;
  const applyGlobalFade = () => {
    if (svg.classList.contains("rt-global-fade")) return;
    svg.classList.add("rt-global-fade");
  };
  const clearGlobalFade = () => {
    if (!svg.classList.contains("rt-global-fade")) return;
    svg.classList.remove("rt-global-fade");
  };
  const highlightScene = (sceneId) => {
    var _a;
    const refs = sceneElementRefs.get(sceneId);
    if (!refs) return;
    if (refs.path) {
      refs.path.classList.add("rt-selected");
      refs.path.classList.remove("rt-non-selected");
    }
    if (refs.numberSquare) {
      refs.numberSquare.classList.remove("rt-non-selected");
    }
    if (refs.numberText) {
      refs.numberText.classList.remove("rt-non-selected");
    }
    if (refs.title) {
      refs.title.classList.remove("rt-non-selected");
    }
    const primaryGroup = (_a = refs.path) == null ? void 0 : _a.closest('.rt-scene-group[data-item-type="Scene"]');
    const currentPathAttr = primaryGroup == null ? void 0 : primaryGroup.getAttribute("data-path");
    if (currentPathAttr) {
      const matchingSceneIds = scenesByPath.get(currentPathAttr);
      if (matchingSceneIds) {
        matchingSceneIds.forEach((matchSceneId) => {
          if (matchSceneId === sceneId) return;
          const matchRefs = sceneElementRefs.get(matchSceneId);
          if (!matchRefs) return;
          if (matchRefs.path) {
            matchRefs.path.classList.add("rt-selected");
            matchRefs.path.classList.remove("rt-non-selected");
          }
          if (matchRefs.numberSquare) {
            matchRefs.numberSquare.classList.remove("rt-non-selected");
          }
          if (matchRefs.numberText) {
            matchRefs.numberText.classList.remove("rt-non-selected");
          }
          if (matchRefs.title) {
            matchRefs.title.classList.remove("rt-non-selected");
          }
        });
      }
    }
  };
  const unhighlightScene = (sceneId, keepFaded) => {
    var _a;
    const refs = sceneElementRefs.get(sceneId);
    if (!refs) return;
    if (refs.path) {
      refs.path.classList.remove("rt-selected");
      if (keepFaded) {
        refs.path.classList.add("rt-non-selected");
      } else {
        refs.path.classList.remove("rt-non-selected");
      }
    }
    const toggleFade = (el) => {
      if (!el) return;
      if (keepFaded) {
        el.classList.add("rt-non-selected");
      } else {
        el.classList.remove("rt-non-selected");
      }
    };
    toggleFade(refs.numberSquare);
    toggleFade(refs.numberText);
    toggleFade(refs.title);
    const primaryGroup = (_a = refs.path) == null ? void 0 : _a.closest('.rt-scene-group[data-item-type="Scene"]');
    const currentPathAttr = primaryGroup == null ? void 0 : primaryGroup.getAttribute("data-path");
    if (currentPathAttr) {
      const matchingSceneIds = scenesByPath.get(currentPathAttr);
      if (matchingSceneIds) {
        matchingSceneIds.forEach((matchSceneId) => {
          if (matchSceneId === sceneId) return;
          const matchRefs = sceneElementRefs.get(matchSceneId);
          if (!matchRefs) return;
          if (matchRefs.path) {
            matchRefs.path.classList.remove("rt-selected");
            if (keepFaded) {
              matchRefs.path.classList.add("rt-non-selected");
            } else {
              matchRefs.path.classList.remove("rt-non-selected");
            }
          }
          toggleFade(matchRefs.numberSquare);
          toggleFade(matchRefs.numberText);
          toggleFade(matchRefs.title);
        });
      }
    }
  };
  view.registerDomEvent(svg, "pointerover", (e) => {
    var _a;
    if (isShiftModeActive()) {
      return;
    }
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g) return;
    const sid = (_a = sceneIdCache.get(g)) != null ? _a : getSceneIdFromGroup(g);
    if (!sid) return;
    if (currentHoveredSceneId === sid) {
      const syn2 = synopsisBySceneId.get(sid);
      if (syn2) {
        view.plugin.synopsisManager.updatePosition(syn2, e, svg, sid);
        updateSynopsisTitleColor(syn2, sid, "chronologue");
        syn2.classList.add("rt-visible");
      }
      if (g.classList.contains("rt-chronologue-warning")) {
        showWhenFieldWarning(svg, g, e);
      } else {
        hideWhenFieldWarning(svg);
      }
      return;
    }
    const previousSceneId = currentHoveredSceneId;
    applyGlobalFade();
    currentHoveredSceneId = sid;
    if (previousSceneId) {
      const previousSynopsis = synopsisBySceneId.get(previousSceneId);
      if (previousSynopsis) {
        previousSynopsis.classList.remove("rt-visible");
      }
      unhighlightScene(previousSceneId, true);
    }
    svg.classList.add("scene-hover");
    const syn = synopsisBySceneId.get(sid);
    if (syn) {
      view.plugin.synopsisManager.updatePosition(syn, e, svg, sid);
      updateSynopsisTitleColor(syn, sid, "chronologue");
      syn.classList.add("rt-visible");
    }
    highlightScene(sid);
    manager.onSceneHover(g, sid);
    if (g.classList.contains("rt-chronologue-warning")) {
      showWhenFieldWarning(svg, g, e);
    } else {
      hideWhenFieldWarning(svg);
    }
  });
  view.registerDomEvent(svg, "pointerout", (e) => {
    var _a;
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g) return;
    const sid = (_a = sceneIdCache.get(g)) != null ? _a : getSceneIdFromGroup(g);
    if (!sid) return;
    const related = e.relatedTarget;
    manager.onSceneLeave();
    if (related == null ? void 0 : related.closest('.rt-scene-group[data-item-type="Scene"]')) {
      return;
    }
    const syn = synopsisBySceneId.get(sid);
    if (syn) {
      syn.classList.remove("rt-visible");
    }
    if (currentHoveredSceneId) {
      unhighlightScene(currentHoveredSceneId, false);
      currentHoveredSceneId = null;
    }
    svg.classList.remove("scene-hover");
    clearGlobalFade();
    hideWhenFieldWarning(svg);
  });
}
function setupSceneClickInteractions(view, svg) {
  view.registerDomEvent(svg, "click", async (e) => {
    var _a;
    const g = e.target.closest('.rt-scene-group[data-item-type="Scene"]');
    if (!g) return;
    if (isShiftModeActive()) {
      const handled = (_a = view.handleShiftModeClick) == null ? void 0 : _a.call(view, e, g);
      if (handled) {
        return;
      }
    }
    const scenes = view.sceneData || view.scenes || [];
    if (scenes.length > 0) {
      await handleDominantSubplotSelection(view, g, svg, scenes);
    }
    e.stopPropagation();
    const encodedPath = g.getAttribute("data-path");
    if (!encodedPath) return;
    const filePath = decodeURIComponent(encodedPath);
    if (view.plugin.app) {
      const file = view.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian12.TFile) {
        await openOrRevealFile(view.plugin.app, file);
      }
    }
  });
}
function showWhenFieldWarning(svg, sceneGroup, event) {
  hideWhenFieldWarning(svg);
  const warning = document.createElementNS("http://www.w3.org/2000/svg", "g");
  warning.setAttribute("class", "rt-when-field-warning");
  const x = event.clientX;
  const y = event.clientY;
  warning.innerHTML = ` // SAFE: innerHTML used for SVG element creation from trusted internal template
        <rect x="${x - 60}" y="${y - 30}" width="120" height="20" 
              rx="4" fill="var(--background-primary)" 
              stroke="var(--text-error)" stroke-width="1"/>
        <text x="${x}" y="${y - 15}" 
              text-anchor="middle" dominant-baseline="middle"
              font-family="var(--font-text)" font-size="10" font-weight="600"
              fill="var(--text-error)">
            Missing When field
        </text>
    `;
  svg.appendChild(warning);
}
function hideWhenFieldWarning(svg) {
  const existingWarning = svg.querySelector(".rt-when-field-warning");
  if (existingWarning) {
    existingWarning.remove();
  }
}
var import_obsidian12;
var init_ChronologueMode2 = __esm({
  "src/view/modes/ChronologueMode.ts"() {
    import_obsidian12 = require("obsidian");
    init_ChronologueShiftController();
    init_fileUtils();
    init_DominantSubplotHandler();
    init_SceneInteractionManager();
    init_SynopsisTitleColorManager();
  }
});

// src/utils/sceneCreation.ts
function sanitizeSourcePath(sourcePath) {
  const p = (sourcePath || "").trim();
  return p ? (0, import_obsidian13.normalizePath)(p) : "";
}
function buildInitialSceneFilename(sanitizedSourcePath, baseName = "1 Test Scene.md") {
  return `${sanitizedSourcePath ? sanitizedSourcePath + "/" : ""}${baseName}`;
}
var import_obsidian13;
var init_sceneCreation = __esm({
  "src/utils/sceneCreation.ts"() {
    import_obsidian13 = require("obsidian");
  }
});

// src/api/anthropicApi.ts
async function callAnthropicApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens = 4e3) {
  var _a, _b, _c, _d, _e, _f;
  const apiUrl = "https://api.anthropic.com/v1/messages";
  const apiVersion = "2023-06-01";
  if (!apiKey) {
    return { success: false, content: null, responseData: { type: "error", error: { type: "plugin_config_error", message: "Anthropic API key not configured." } }, error: "Anthropic API key not configured." };
  }
  if (!modelId) {
    return { success: false, content: null, responseData: { type: "error", error: { type: "plugin_config_error", message: "Anthropic model ID not configured." } }, error: "Anthropic model ID not configured." };
  }
  const requestBody = { model: modelId, messages: [{ role: "user", content: userPrompt }], max_tokens: maxTokens };
  if (systemPrompt) requestBody.system = systemPrompt;
  let responseData;
  try {
    const response = await (0, import_obsidian14.requestUrl)({
      url: apiUrl,
      method: "POST",
      headers: {
        "anthropic-version": apiVersion,
        "x-api-key": apiKey,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody),
      throw: false
    });
    responseData = response.json;
    if (response.status >= 400) {
      const err = responseData;
      const msg = (_c = (_b = (_a = err == null ? void 0 : err.error) == null ? void 0 : _a.message) != null ? _b : response.text) != null ? _c : `Anthropic error (${response.status})`;
      return { success: false, content: null, responseData, error: msg };
    }
    const success = responseData;
    const content = (_f = (_e = (_d = success == null ? void 0 : success.content) == null ? void 0 : _d[0]) == null ? void 0 : _e.text) == null ? void 0 : _f.trim();
    if (content) return { success: true, content, responseData };
    return { success: false, content: null, responseData, error: "Invalid response structure from Anthropic." };
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    responseData = { type: "error", error: { type: "network_or_execution_error", message: msg } };
    return { success: false, content: null, responseData, error: msg };
  }
}
async function fetchAnthropicModels(apiKey) {
  if (!apiKey) throw new Error("Anthropic API key is required to fetch models.");
  const response = await (0, import_obsidian14.requestUrl)({
    url: "https://api.anthropic.com/v1/models",
    method: "GET",
    headers: {
      "anthropic-version": "2023-06-01",
      "x-api-key": apiKey
    },
    throw: false
  });
  const data = response.json;
  if (response.status >= 400 || !Array.isArray(data == null ? void 0 : data.models)) {
    throw new Error(`Error fetching Anthropic models (${response.status})`);
  }
  return data.models.sort((a, b) => a.id.localeCompare(b.id));
}
var import_obsidian14;
var init_anthropicApi = __esm({
  "src/api/anthropicApi.ts"() {
    import_obsidian14 = require("obsidian");
  }
});

// src/api/openaiApi.ts
async function callOpenAiApi(apiKey, modelId, systemPrompt, userPrompt, maxTokens = 4e3, temperature = 0.7, enableJsonMode = false) {
  var _a, _b, _c, _d, _e, _f, _g;
  const apiUrl = "https://api.openai.com/v1/chat/completions";
  if (!apiKey) {
    return { success: false, content: null, responseData: { error: { message: "API key not configured.", type: "plugin_error" } }, error: "OpenAI API key not configured." };
  }
  if (!modelId) {
    return { success: false, content: null, responseData: { error: { message: "Model ID not configured.", type: "plugin_error" } }, error: "OpenAI Model ID not configured." };
  }
  const messages = [];
  if (systemPrompt) messages.push({ role: "system", content: systemPrompt });
  messages.push({ role: "user", content: userPrompt });
  const requestBody = { model: modelId, messages, temperature };
  if (maxTokens !== null) requestBody.max_tokens = maxTokens;
  if (enableJsonMode) {
    requestBody.response_format = { type: "json_object" };
  }
  let responseData;
  try {
    const response = await (0, import_obsidian15.requestUrl)({
      url: apiUrl,
      method: "POST",
      headers: {
        Authorization: `Bearer ${apiKey}`,
        "Content-Type": "application/json"
      },
      body: JSON.stringify(requestBody),
      throw: false
    });
    responseData = response.json;
    if (response.status >= 400) {
      const errorDetails = responseData;
      const msg = (_c = (_b = (_a = errorDetails == null ? void 0 : errorDetails.error) == null ? void 0 : _a.message) != null ? _b : response.text) != null ? _c : `OpenAI error (${response.status})`;
      return { success: false, content: null, responseData, error: msg };
    }
    const success = responseData;
    const content = (_g = (_f = (_e = (_d = success == null ? void 0 : success.choices) == null ? void 0 : _d[0]) == null ? void 0 : _e.message) == null ? void 0 : _f.content) == null ? void 0 : _g.trim();
    if (content) return { success: true, content, responseData };
    return { success: false, content: null, responseData, error: "Invalid response structure from OpenAI." };
  } catch (err) {
    const msg = err instanceof Error ? err.message : String(err);
    responseData = { error: { message: msg, type: "network_or_execution_error" } };
    return { success: false, content: null, responseData, error: msg };
  }
}
async function fetchOpenAiModels(apiKey) {
  if (!apiKey) throw new Error("OpenAI API key is required to fetch models.");
  const response = await (0, import_obsidian15.requestUrl)({
    url: "https://api.openai.com/v1/models",
    method: "GET",
    headers: { Authorization: `Bearer ${apiKey}` },
    throw: false
  });
  const data = response.json;
  if (response.status >= 400 || !Array.isArray(data == null ? void 0 : data.data)) {
    throw new Error(`Error fetching models (${response.status})`);
  }
  return data.data.sort((a, b) => a.id.localeCompare(b.id));
}
var import_obsidian15;
var init_openaiApi = __esm({
  "src/api/openaiApi.ts"() {
    import_obsidian15 = require("obsidian");
  }
});

// src/modals/SceneAnalysisProcessingModal.ts
var import_obsidian16, ConfirmationModal, SceneAnalysisProcessingModal;
var init_SceneAnalysisProcessingModal = __esm({
  "src/modals/SceneAnalysisProcessingModal.ts"() {
    import_obsidian16 = require("obsidian");
    ConfirmationModal = class extends import_obsidian16.Modal {
      constructor(app, message, onConfirm) {
        super(app);
        this.message = message;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, titleEl } = this;
        titleEl.setText("Confirm action");
        const messageEl = contentEl.createDiv({ cls: "rt-confirmation-message" });
        messageEl.setText(this.message);
        const buttonRow = contentEl.createDiv({ cls: "rt-beats-actions" });
        new import_obsidian16.ButtonComponent(buttonRow).setButtonText("Continue").setCta().onClick(() => {
          this.close();
          this.onConfirm();
        });
        new import_obsidian16.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
    };
    SceneAnalysisProcessingModal = class extends import_obsidian16.Modal {
      constructor(app, plugin, getSceneCount, onConfirm, resumeCommandId, subplotName, isEntireSubplot) {
        super(app);
        // Track if this is "entire subplot" vs "flagged scenes"
        this.selectedMode = "flagged";
        this.isProcessing = false;
        this.abortController = null;
        // Statistics
        this.processedCount = 0;
        this.totalCount = 0;
        this.errorCount = 0;
        this.warningCount = 0;
        this.pendingRafId = null;
        this.plugin = plugin;
        this.getSceneCount = getSceneCount;
        this.onConfirm = onConfirm;
        this.resumeCommandId = resumeCommandId;
        this.subplotName = subplotName;
        this.isEntireSubplot = isEntireSubplot;
      }
      onOpen() {
        const { contentEl, titleEl } = this;
        titleEl.setText("Scene beats analysis");
        if (this.isProcessing) {
          this.showProgressView();
        } else {
          this.showConfirmationView();
        }
      }
      onClose() {
        if (this.pendingRafId !== null) {
          cancelAnimationFrame(this.pendingRafId);
          this.pendingRafId = null;
        }
      }
      /**
       * Override close() to allow minimizing while processing continues
       */
      close() {
        if (this.isProcessing) {
          new import_obsidian16.Notice("Processing continues in background. Use command palette to reopen progress window.");
        }
        super.close();
      }
      showConfirmationView() {
        const { contentEl, modalEl } = this;
        contentEl.empty();
        if (modalEl) {
          modalEl.style.width = "700px";
          modalEl.style.maxWidth = "90vw";
        }
        contentEl.classList.add("rt-beats-modal");
        const infoEl = contentEl.createDiv({ cls: "rt-beats-info" });
        infoEl.setText("Select how many scenes to process. This will analyze scenes in manuscript order and update their beat metadata.");
        const modesSection = contentEl.createDiv({ cls: "rt-beats-modes" });
        const mode1 = this.createModeOption(
          modesSection,
          "flagged",
          "Process flagged scenes (Recommended)",
          "Processes scenes with Beats Update: Yes and Status: Working or Complete. Use when you've revised scenes and want to update their beats.",
          true
        );
        const mode2 = this.createModeOption(
          modesSection,
          "unprocessed",
          "Process unprocessed scenes",
          "Processes scenes with Status: Complete or Working that don't have beats yet. Perfect for resuming after interruptions. Ignores Beats Update flag.",
          false
        );
        const mode3 = this.createModeOption(
          modesSection,
          "force-all",
          "Reprocess ALL scenes",
          "Reprocesses ALL scenes with Status: Complete or Working, even if they already have beats. Use when changing AI templates or doing complete reanalysis. WARNING: May be expensive!",
          false
        );
        const countSection = contentEl.createDiv({ cls: "rt-beats-count" });
        const countEl = countSection.createDiv({ cls: "rt-beats-count-number" });
        countEl.setText("Calculating...");
        const updateCount = async () => {
          countEl.empty();
          countEl.setText("Calculating...");
          try {
            const count = await this.getSceneCount(this.selectedMode);
            const estimatedMinutes = Math.ceil(count * 0.1);
            countEl.empty();
            const countText = countEl.createDiv({ cls: "rt-beats-count-text" });
            countText.createSpan({ text: "Scenes to process: ", cls: "rt-beats-label" });
            countText.createSpan({ text: `${count}`, cls: "rt-beats-number" });
            const timeText = countEl.createDiv({ cls: "rt-beats-time-text" });
            timeText.createSpan({ text: "Estimated time: ", cls: "rt-beats-label" });
            timeText.createSpan({ text: `~${estimatedMinutes} minutes`, cls: "rt-beats-number" });
            if (count > 50) {
              const warning = countEl.createDiv({ cls: "rt-beats-warning" });
              warning.setText("Large batch processing may take significant time and API costs.");
            }
          } catch (error) {
            countEl.empty();
            countEl.setText(`Error calculating scene count: ${error instanceof Error ? error.message : String(error)}`);
          }
        };
        const rafId = requestAnimationFrame(() => {
          updateCount();
        });
        this.pendingRafId = rafId;
        [mode1, mode2, mode3].forEach((radio) => {
          radio.addEventListener("change", () => updateCount());
        });
        const buttonRow = contentEl.createDiv({ cls: "rt-beats-actions" });
        new import_obsidian16.ButtonComponent(buttonRow).setButtonText("Start processing").setCta().onClick(async () => {
          try {
            const count = await this.getSceneCount(this.selectedMode);
            if (count === 0) {
              new import_obsidian16.Notice("No scenes to process with the selected mode.");
              return;
            }
            if (count > 50 || this.selectedMode === "force-all" || this.selectedMode === "unprocessed") {
              const confirmModal = new ConfirmationModal(
                this.app,
                `You are about to process ${count} scenes. This may take ${Math.ceil(count * 0.1)} minutes and incur API costs. Continue?`,
                async () => {
                  await this.startProcessing();
                }
              );
              confirmModal.open();
              return;
            }
            await this.startProcessing();
          } catch (error) {
            new import_obsidian16.Notice(`Error: ${error instanceof Error ? error.message : String(error)}`);
          }
        });
        new import_obsidian16.ButtonComponent(buttonRow).setButtonText("Purge all beats").setWarning().onClick(async () => {
          try {
            const { purgeBeatsByManuscriptOrder: purgeBeatsByManuscriptOrder2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
            this.close();
            await purgeBeatsByManuscriptOrder2(this.plugin, this.plugin.app.vault);
          } catch (error) {
            new import_obsidian16.Notice(`Error: ${error instanceof Error ? error.message : String(error)}`);
          }
        });
        new import_obsidian16.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
      createModeOption(container, mode, title, description, isDefault) {
        const optionEl = container.createDiv({ cls: "rt-beats-mode-option" });
        const radioEl = optionEl.createEl("input", {
          type: "radio",
          attr: { name: "processing-mode", value: mode }
        });
        radioEl.checked = isDefault;
        if (isDefault) this.selectedMode = mode;
        radioEl.addEventListener("change", () => {
          if (radioEl.checked) {
            this.selectedMode = mode;
          }
        });
        const labelContainer = optionEl.createDiv({ cls: "rt-beats-mode-label" });
        const titleEl = labelContainer.createDiv({ cls: "rt-beats-mode-title" });
        titleEl.setText(title);
        const descEl = labelContainer.createDiv({ cls: "rt-beats-mode-desc" });
        descEl.setText(description);
        optionEl.addEventListener("click", () => {
          radioEl.checked = true;
          this.selectedMode = mode;
          radioEl.dispatchEvent(new Event("change"));
        });
        return radioEl;
      }
      async startProcessing() {
        this.isProcessing = true;
        this.abortController = new AbortController();
        this.plugin.activeBeatsModal = this;
        this.plugin.showBeatsStatusBar(0, 0);
        this.showProgressView();
        try {
          await this.onConfirm(this.selectedMode);
          if (this.abortController && this.abortController.signal.aborted) {
            this.showCompletionSummary("Processing aborted");
          } else {
            this.showCompletionSummary("Processing completed successfully!");
          }
        } catch (error) {
          if (!this.abortController.signal.aborted) {
            this.addError(`Fatal error: ${error instanceof Error ? error.message : String(error)}`);
            this.showCompletionSummary("Processing stopped due to error");
          } else {
            this.showCompletionSummary("Processing aborted");
          }
        } finally {
          this.isProcessing = false;
          this.abortController = null;
          this.plugin.activeBeatsModal = null;
          this.plugin.hideBeatsStatusBar();
        }
      }
      showProgressView() {
        const { contentEl, titleEl } = this;
        contentEl.empty();
        titleEl.setText("Processing scene beats analysis...");
        const modelName = this.getActiveModelDisplayName();
        const modelInfoEl = contentEl.createDiv({ cls: "rt-beats-model-info" });
        modelInfoEl.setText(`Model: ${modelName}`);
        const progressContainer = contentEl.createDiv({ cls: "rt-beats-progress-container" });
        const progressBg = progressContainer.createDiv({ cls: "rt-beats-progress-bg" });
        this.progressBarEl = progressBg.createDiv({ cls: "rt-beats-progress-bar" });
        this.progressBarEl.style.setProperty("--progress-width", "0%");
        this.progressTextEl = progressContainer.createDiv({ cls: "rt-beats-progress-text" });
        this.progressTextEl.setText("Starting...");
        this.statusTextEl = contentEl.createDiv({ cls: "rt-beats-status-text" });
        this.statusTextEl.setText("Initializing...");
        this.tripletTextEl = contentEl.createDiv({ cls: "rt-beats-triplet-text" });
        this.tripletTextEl.setText("Triplet: prev=N/A, current=N/A, next=N/A");
        this.errorListEl = contentEl.createDiv({ cls: "rt-beats-error-list rt-hidden" });
        this.actionButtonContainer = contentEl.createDiv({ cls: "rt-beats-actions" });
        this.abortButtonEl = new import_obsidian16.ButtonComponent(this.actionButtonContainer).setButtonText("Abort processing").setWarning().onClick(() => this.abortProcessing());
      }
      abortProcessing() {
        if (!this.abortController) return;
        const confirmModal = new ConfirmationModal(
          this.app,
          "Are you sure you want to abort processing? Progress will be saved up to the current scene.",
          () => {
            var _a, _b, _c;
            (_a = this.abortController) == null ? void 0 : _a.abort();
            (_b = this.statusTextEl) == null ? void 0 : _b.setText("Aborting... Please wait.");
            (_c = this.abortButtonEl) == null ? void 0 : _c.setDisabled(true);
            new import_obsidian16.Notice("Processing aborted by user");
          }
        );
        confirmModal.open();
      }
      updateProgress(current, total, sceneName) {
        if (!this.isProcessing) return;
        this.processedCount = current;
        this.totalCount = total;
        const percentage = total > 0 ? Math.round(current / total * 100) : 0;
        this.plugin.showBeatsStatusBar(current, total);
        if (this.progressBarEl) {
          this.progressBarEl.style.setProperty("--progress-width", `${percentage}%`);
        }
        if (this.progressTextEl) {
          this.progressTextEl.setText(`${current} / ${total} scenes (${percentage}%)`);
        }
        if (this.statusTextEl) {
          this.statusTextEl.setText(`Processing: ${sceneName}`);
        }
      }
      addError(message) {
        if (!this.errorListEl) return;
        this.errorCount++;
        if (this.errorListEl.hasClass("rt-hidden")) {
          this.errorListEl.removeClass("rt-hidden");
          const header = this.errorListEl.createDiv({ cls: "rt-beats-error-header" });
          header.setText("Errors encountered:");
        }
        const errorItem = this.errorListEl.createDiv({ cls: "rt-beats-error-item" });
        errorItem.setText(message);
      }
      setTripletInfo(prevNum, currentNum, nextNum) {
        if (!this.tripletTextEl) return;
        this.tripletTextEl.setText(`Triplet: prev=${prevNum || "N/A"}, current=${currentNum || "N/A"}, next=${nextNum || "N/A"}`);
      }
      addWarning(message) {
        if (!this.errorListEl) return;
        this.warningCount++;
        if (this.errorListEl.hasClass("rt-hidden")) {
          this.errorListEl.removeClass("rt-hidden");
          const header = this.errorListEl.createDiv({ cls: "rt-beats-error-header" });
          header.setText("Issues encountered:");
        }
        const warningItem = this.errorListEl.createDiv({ cls: "rt-beats-error-item rt-beats-warning-item" });
        warningItem.setText(message);
      }
      showCompletionSummary(statusMessage) {
        const { contentEl, titleEl } = this;
        titleEl.setText("Processing complete");
        if (this.progressBarEl) {
          this.progressBarEl.style.setProperty("--progress-width", "100%");
          this.progressBarEl.addClass("rt-progress-complete");
        }
        const successCount = Math.max(0, this.processedCount - this.errorCount);
        let summaryText = `${successCount} scene${successCount !== 1 ? "s" : ""} processed successfully`;
        if (this.errorCount > 0) {
          summaryText += `, ${this.errorCount} error${this.errorCount !== 1 ? "s" : ""}`;
        }
        if (this.warningCount > 0) {
          summaryText += `, ${this.warningCount} skipped`;
        }
        if (this.statusTextEl) {
          this.statusTextEl.setText(summaryText);
        }
        const completionMsgEl = contentEl.createDiv({ cls: "rt-beats-completion-message" });
        completionMsgEl.setText(statusMessage);
        const hasIssues = this.errorCount > 0 || this.warningCount > 0;
        const remainingScenes = this.totalCount - this.processedCount;
        if (hasIssues) {
          const summaryContainer = contentEl.createDiv({ cls: "rt-beats-summary" });
          summaryContainer.createEl("h3", { text: "Details", cls: "rt-beats-summary-title" });
          const summaryStats = summaryContainer.createDiv({ cls: "rt-beats-summary-stats" });
          if (this.errorCount > 0) {
            summaryStats.createDiv({
              cls: "rt-beats-summary-row rt-beats-summary-error",
              text: `Errors: ${this.errorCount}`
            });
          }
          if (this.warningCount > 0) {
            summaryStats.createDiv({
              cls: "rt-beats-summary-row rt-beats-summary-warning",
              text: `Warnings: ${this.warningCount} (scenes skipped due to validation)`
            });
          }
        }
        if (remainingScenes > 0) {
          const tipEl = contentEl.createDiv({ cls: "rt-beats-summary-tip" });
          tipEl.createEl("strong", { text: "Tip: " });
          if (this.resumeCommandId || this.subplotName) {
            tipEl.appendText("Click Resume to complete all scenes not updated today. Scenes already processed today will be skipped automatically.");
          } else {
            tipEl.appendText('Run the command again in "Unprocessed" mode to process remaining or failed scenes. Already-processed scenes will be skipped automatically.');
          }
        }
        if (this.plugin.settings.logApiInteractions) {
          const logNoteEl = contentEl.createDiv({ cls: "rt-beats-summary-tip" });
          logNoteEl.createEl("strong", { text: "Note: " });
          logNoteEl.appendText("Detailed AI interaction logs have been saved to the AI folder for review.");
        }
        if (this.actionButtonContainer) {
          this.actionButtonContainer.empty();
          if (remainingScenes > 0 && (this.resumeCommandId || this.subplotName)) {
            new import_obsidian16.ButtonComponent(this.actionButtonContainer).setButtonText(`Resume (${remainingScenes} remaining)`).setCta().onClick(async () => {
              this.close();
              if (this.subplotName) {
                const subplotName = this.subplotName;
                const isEntireSubplot = this.isEntireSubplot;
                window.setTimeout(async () => {
                  const { processBySubplotNameWithModal: processBySubplotNameWithModal2, processEntireSubplotWithModal: processEntireSubplotWithModal2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
                  if (isEntireSubplot) {
                    await processEntireSubplotWithModal2(this.plugin, this.plugin.app.vault, subplotName, true);
                  } else {
                    await processBySubplotNameWithModal2(this.plugin, this.plugin.app.vault, subplotName);
                  }
                }, 100);
              } else if (this.resumeCommandId) {
                this.plugin.settings._isResuming = true;
                await this.plugin.saveSettings();
                window.setTimeout(() => {
                  this.app.commands.executeCommandById(this.resumeCommandId);
                }, 100);
              }
            });
          }
          new import_obsidian16.ButtonComponent(this.actionButtonContainer).setButtonText("Close").onClick(() => this.close());
        }
      }
      isAborted() {
        var _a, _b;
        return (_b = (_a = this.abortController) == null ? void 0 : _a.signal.aborted) != null ? _b : false;
      }
      getAbortSignal() {
        var _a, _b;
        return (_b = (_a = this.abortController) == null ? void 0 : _a.signal) != null ? _b : null;
      }
      /**
       * Programmatically abort processing (e.g., due to rate limiting)
       * Unlike abortProcessing(), this doesn't show a confirmation dialog
       */
      abort() {
        var _a, _b;
        if (!this.abortController) return;
        this.abortController.abort();
        (_a = this.statusTextEl) == null ? void 0 : _a.setText("Processing stopped due to error");
        (_b = this.abortButtonEl) == null ? void 0 : _b.setDisabled(true);
      }
      getActiveModelDisplayName() {
        const provider = this.plugin.settings.defaultAiProvider || "openai";
        const normalize = (value) => value.toLowerCase();
        if (provider === "anthropic") {
          const id2 = this.plugin.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
          const normalized2 = normalize(id2);
          if (normalized2.includes("sonnet-4-5") || normalized2.includes("sonnet-4.5")) return "Claude Sonnet 4.5";
          if (normalized2.includes("sonnet-4")) return "Claude Sonnet 4";
          if (normalized2.includes("opus-4-1") || normalized2.includes("opus-4.1")) return "Claude Opus 4.1";
          if (normalized2.includes("opus-4")) return "Claude Opus 4";
          return id2;
        }
        if (provider === "gemini") {
          const id2 = this.plugin.settings.geminiModelId || "gemini-2.5-pro";
          const normalized2 = normalize(id2);
          if (normalized2.includes("2.5-pro") || normalized2.includes("2-5-pro")) return "Gemini 2.5 Pro";
          if (normalized2.includes("2.0-pro") || normalized2.includes("2-0-pro")) return "Gemini 2.0 Pro";
          return id2;
        }
        const id = this.plugin.settings.openaiModelId || "gpt-4.1";
        const normalized = normalize(id);
        if (normalized.includes("4.1") || normalized.includes("4-1")) return "GPT-4.1";
        if (normalized.includes("4o") || normalized.includes("4-0") || normalized.includes("gpt-4o")) return "GPT-4o";
        if (normalized.includes("gpt-o1") || normalized.includes("o1")) return "GPT-o1";
        return id;
      }
    };
  }
});

// src/ai/prompts/sceneAnalysis.ts
function getSceneAnalysisJsonSchema() {
  return SCENE_ANALYSIS_JSON_SCHEMA;
}
function buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt) {
  const contextPrefix = (contextPrompt == null ? void 0 : contextPrompt.trim()) ? `${contextPrompt.trim()}

` : "You are a developmental editor for fiction. Keep analysis suitable for general audiences; avoid explicit detail.\n\n";
  const isPrevAvailable = !!prevBody;
  const isNextAvailable = !!nextBody;
  if (!isPrevAvailable && !isNextAvailable) {
    return `${contextPrefix}Evaluate the single scene below. Return ONLY valid JSON matching this structure:

{
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Concise editorial comment (max 10 words)"
    }
    // ... 3-5 more beats
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks, no preamble, no commentary.
- First item in currentSceneAnalysis must have grade A/B/C (overall scene quality).
- Subsequent items use +/-/? for connection strength.
- Keep comments concise (first item max 15 words, others max 10 words).

Scene ${currentNum}:
${currentBody || "N/A"}
`;
  }
  if (!isPrevAvailable && isNextAvailable) {
    return `${contextPrefix}Evaluate the first scene in context of the following scene. Return ONLY valid JSON matching this structure:

{
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats
  ],
  "nextSceneAnalysis": [
    {
      "scene": "${nextNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats analyzing next scene
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks, no preamble.
- First currentSceneAnalysis item: grade A/B/C (overall quality). Others: +/-/? (connection strength).
- nextSceneAnalysis items: +/-/? showing how next scene builds on current.

Scene ${currentNum}:
${currentBody || "N/A"}

Scene ${nextNum}:
${nextBody != null ? nextBody : "N/A"}
`;
  }
  if (isPrevAvailable && !isNextAvailable) {
    return `${contextPrefix}Evaluate the last scene in context of the previous scene. Return ONLY valid JSON matching this structure:

{
  "previousSceneAnalysis": [
    {
      "scene": "${prevNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats analyzing previous scene
  ],
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks, no preamble.
- previousSceneAnalysis items: +/-/? showing how previous scene sets up current.
- First currentSceneAnalysis item: grade A/B/C (overall quality). Others: +/-/? (connection strength).

Scene ${prevNum}:
${prevBody != null ? prevBody : "N/A"}

Scene ${currentNum}:
${currentBody || "N/A"}
`;
  }
  return `${contextPrefix}For each of the three scenes below, generate concise narrative beats from the perspective of the middle scene (${currentNum}), showing connections between previous (${prevNum}) and next (${nextNum}) scenes. Return ONLY valid JSON matching this structure:

{
  "previousSceneAnalysis": [
    {
      "scene": "${prevNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats analyzing how previous scene sets up current
  ],
  "currentSceneAnalysis": [
    {
      "scene": "${currentNum}",
      "title": "Overall Scene Grade",
      "grade": "A" or "B" or "C",
      "comment": "Instructions on how to improve it (max 15 words)"
    },
    {
      "scene": "${currentNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats analyzing current scene
  ],
  "nextSceneAnalysis": [
    {
      "scene": "${nextNum}",
      "title": "Beat title",
      "grade": "+" or "-" or "?",
      "comment": "Editorial comment (max 10 words)"
    }
    // ... 3-5 more beats analyzing how next scene builds on current
  ]
}

Rules:
- Output ONLY valid JSON. No markdown code blocks (no \`\`\`json), no preamble, no commentary.
- First currentSceneAnalysis item must have grade A/B/C (A=nearly perfect, C=needs improvement).
- All other items use +/-/?: "+" for strong connections, "-" for weak, "?" for neutral.
- Keep comments concise (first currentSceneAnalysis max 15 words, all others max 10 words).

Scene ${prevNum}:
${prevBody != null ? prevBody : "N/A"}

Scene ${currentNum}:
${currentBody || "N/A"}

Scene ${nextNum}:
${nextBody != null ? nextBody : "N/A"}
`;
}
var SCENE_ANALYSIS_JSON_SCHEMA;
var init_sceneAnalysis = __esm({
  "src/ai/prompts/sceneAnalysis.ts"() {
    SCENE_ANALYSIS_JSON_SCHEMA = {
      type: "object",
      properties: {
        "previousSceneAnalysis": {
          type: "array",
          items: {
            type: "object",
            properties: {
              scene: { type: "string", description: "Scene number" },
              title: { type: "string", description: "Short analysis title" },
              grade: { type: "string", enum: ["+", "-", "?"], description: "Connection strength" },
              comment: { type: "string", description: "Editorial comment (max 10 words)" }
            },
            required: ["scene", "title", "grade", "comment"]
          }
        },
        "currentSceneAnalysis": {
          type: "array",
          items: {
            type: "object",
            properties: {
              scene: { type: "string", description: "Scene number" },
              title: { type: "string", description: "Short analysis title or grade (A/B/C for first item)" },
              grade: { type: "string", enum: ["+", "-", "?", "A", "B", "C"], description: "Grade or connection strength" },
              comment: { type: "string", description: "Editorial comment (max 15 words for first item, 10 for others)" }
            },
            required: ["scene", "title", "grade", "comment"]
          }
        },
        "nextSceneAnalysis": {
          type: "array",
          items: {
            type: "object",
            properties: {
              scene: { type: "string", description: "Scene number" },
              title: { type: "string", description: "Short analysis title" },
              grade: { type: "string", enum: ["+", "-", "?"], description: "Connection strength" },
              comment: { type: "string", description: "Editorial comment (max 10 words)" }
            },
            required: ["scene", "title", "grade", "comment"]
          }
        }
      },
      required: ["currentSceneAnalysis"]
    };
  }
});

// src/utils/text.ts
function decodeHtmlEntities(text) {
  var _a, _b;
  if (!text) return "";
  if (text.includes("<tspan") || text.includes("&lt;tspan")) return text;
  try {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<!DOCTYPE html><body><span>${text}</span></body>`, "text/html");
    const span = doc.querySelector("span");
    return (_a = span == null ? void 0 : span.textContent) != null ? _a : "";
  } catch (e) {
    const span = document.createElement("span");
    span.textContent = text;
    return (_b = span.textContent) != null ? _b : "";
  }
}
function parseSceneTitleComponents(titleText, sceneNumber, date, duration) {
  const result = { sceneNumber: "", title: "", date: "", duration: "" };
  if (!titleText) return result;
  if (sceneNumber !== null && sceneNumber !== void 0) {
    result.sceneNumber = String(sceneNumber);
  }
  if (date) {
    result.date = date;
  }
  if (duration) {
    result.duration = duration;
  }
  const decodedText = decodeHtmlEntities(titleText);
  if (decodedText.includes("<tspan")) {
    result.title = decodedText;
    return result;
  }
  if (result.sceneNumber === "" || result.date === "") {
    const dateMatch = decodedText.match(/\s{3,}(.+?)$/);
    if (dateMatch && result.date === "") {
      result.date = dateMatch[1].trim();
      const titlePart = decodedText.substring(0, dateMatch.index).trim();
      const titleMatch = titlePart.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
      if (titleMatch) {
        if (result.sceneNumber === "") result.sceneNumber = titleMatch[1];
        result.title = titleMatch[2];
      } else {
        result.title = titlePart;
      }
    } else {
      const titleMatch = decodedText.match(/^(\d+(?:\.\d+)?)\s+(.+)$/);
      if (titleMatch) {
        if (result.sceneNumber === "") result.sceneNumber = titleMatch[1];
        result.title = titleMatch[2];
      } else {
        result.title = decodedText;
      }
    }
  } else {
    result.title = decodedText.replace(/^\d+(?:\.\d+)?\s+/, "").replace(/\s{3,}(.+?)$/, "").trim();
  }
  return result;
}
function splitIntoBalancedLines(text, maxWidth) {
  if (!text) return [""];
  if (text.includes("<tspan")) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg"><text>${text}</text></svg>`, "image/svg+xml");
    if (doc.querySelector("parsererror")) return [text];
    const textElement = doc.querySelector("text");
    if (!textElement) return [text];
    const plainText = textElement.textContent || "";
    const plainLines = splitPlainTextIntoLines(plainText, maxWidth);
    return plainLines.length <= 1 ? [text] : [text];
  }
  return splitPlainTextIntoLines(text, maxWidth);
}
function splitPlainTextIntoLines(text, maxWidth) {
  const words = text.split(/\s+/);
  const lines = [];
  let currentLine = "";
  let currentWidth = 0;
  const approxCharWidth = 8;
  const maxCharsPerLine = Math.max(10, Math.round((maxWidth || 400) / approxCharWidth)) || 50;
  for (const word of words) {
    const wordWidth = word.length;
    if (currentWidth + wordWidth > maxCharsPerLine && currentLine !== "") {
      lines.push(currentLine.trim());
      currentLine = word;
      currentWidth = wordWidth;
    } else {
      currentLine += (currentLine ? " " : "") + word;
      currentWidth += wordWidth + (currentLine ? 1 : 0);
    }
  }
  if (currentLine) lines.push(currentLine.trim());
  return lines;
}
function parseSceneTitle(title, sceneNumber) {
  if (!title) return { number: "0", text: "" };
  if (sceneNumber !== null && sceneNumber !== void 0) {
    const cleanTitle = title.replace(/^\d+(?:\.\d+)?\s+/, "");
    return { number: String(sceneNumber), text: escapeXml(cleanTitle) };
  }
  const match = title.match(/^(\d+(?:\.\d+)?)\s+(.+)/);
  if (match) {
    const number = match[1];
    const text = match[2];
    return { number, text: escapeXml(text) };
  }
  return { number: "", text: escapeXml(title) };
}
function normalizeStatus(raw) {
  var _a;
  if (raw == null) return "Todo";
  const v = Array.isArray(raw) ? String((_a = raw[0]) != null ? _a : "").trim().toLowerCase() : String(raw).trim().toLowerCase();
  if (!v) return "Todo";
  if (v === "complete" || v === "done" || v === "completed") return "Completed";
  if (v === "working" || v === "in progress" || v === "progress") return "Working";
  if (v === "todo" || v === "to do" || v === "tbd") return "Todo";
  return null;
}
function getScenePrefixNumber(title, sceneNumber) {
  if (!title) return null;
  if (sceneNumber !== null && sceneNumber !== void 0) {
    return String(sceneNumber);
  }
  const decoded = decodeHtmlEntities(title);
  const m = decoded.match(/^(\d+(?:\.\d+)?)\s+.+/);
  return m ? m[1] : null;
}
function getNumberSquareSize(num) {
  const height = 18;
  if (num.includes(".")) {
    return {
      width: num.length <= 3 ? 24 : num.length <= 4 ? 32 : 36,
      height
    };
  }
  return {
    width: num.length === 1 ? 20 : num.length === 2 ? 24 : 28,
    height
  };
}
function stripObsidianComments2(text) {
  if (!text) return text;
  return text.replace(/%%[\s\S]*?%%/g, "").trim();
}
function stripWikiLinks(text) {
  if (!text) return text;
  return text.replace(/\[\[([^\]|]+)(?:\|([^\]]+))?\]\]/g, (_, link, alias) => alias || link).trim();
}
var init_text = __esm({
  "src/utils/text.ts"() {
    init_regex();
    init_svg();
  }
});

// src/utils/frontmatter.ts
function normalizeFrontmatterKeys(fm) {
  const normalized = {};
  const keyMappings = {
    "class": "Class",
    "itemtype": "itemType",
    "plotsystem": "Plot System",
    "beatmodel": "Beat Model",
    "beatsupdate": "Beats Update",
    "publishstage": "Publish Stage",
    "scenenumber": "Scene Number",
    "subplot": "Subplot",
    "character": "Character",
    "location": "Location",
    "act": "Act",
    "date": "Date",
    "status": "Status",
    "synopsis": "Synopsis",
    "description": "Description",
    "range": "Range",
    "words": "Words",
    "totaltime": "Total Time",
    "book": "Book",
    "supportfiles": "Support Files",
    "due": "Due",
    "pendingedits": "Pending Edits",
    "revision": "Revision",
    "pov": "POV",
    "duration": "Duration",
    "type": "Type",
    "shift": "Shift",
    "questions": "Questions",
    "readeremotion": "Reader Emotion",
    "internal": "Internal",
    "gossamer1": "Gossamer1",
    "gossamer2": "Gossamer2",
    "gossamer3": "Gossamer3",
    "gossamer4": "Gossamer4",
    "gossamer5": "Gossamer5",
    "gossamer6": "Gossamer6",
    "gossamer7": "Gossamer7",
    "gossamer8": "Gossamer8",
    "gossamer9": "Gossamer9",
    "gossamer10": "Gossamer10",
    "gossamer11": "Gossamer11",
    "gossamer12": "Gossamer12",
    "gossamer13": "Gossamer13",
    "gossamer14": "Gossamer14",
    "gossamer15": "Gossamer15",
    "gossamer16": "Gossamer16",
    "gossamer17": "Gossamer17",
    "gossamer18": "Gossamer18",
    "gossamer19": "Gossamer19",
    "gossamer20": "Gossamer20",
    "gossamer21": "Gossamer21",
    "gossamer22": "Gossamer22",
    "gossamer23": "Gossamer23",
    "gossamer24": "Gossamer24",
    "gossamer25": "Gossamer25",
    "gossamer26": "Gossamer26",
    "gossamer27": "Gossamer27",
    "gossamer28": "Gossamer28",
    "gossamer29": "Gossamer29",
    "gossamer30": "Gossamer30",
    "1beats": "1beats",
    "2beats": "2beats",
    "3beats": "3beats",
    "beats1": "beats1",
    "beats2": "beats2",
    "beats3": "beats3",
    "beatslastupdated": "Beats Last Updated"
  };
  for (const [key, value] of Object.entries(fm)) {
    const normalizedKey = key.toLowerCase().replace(/[\s_-]/g, "");
    const canonicalKey = keyMappings[normalizedKey] || key;
    if (!(canonicalKey in normalized)) {
      normalized[canonicalKey] = value;
    }
  }
  return normalized;
}
var init_frontmatter = __esm({
  "src/utils/frontmatter.ts"() {
  }
});

// src/sceneAnalysis/TripletBuilder.ts
function buildTripletsByIndex(contextList, targets, keyFn) {
  const ctxIndexByKey = /* @__PURE__ */ new Map();
  contextList.forEach((item, idx) => ctxIndexByKey.set(keyFn(item), idx));
  const triplets = [];
  for (const current of targets) {
    const key = keyFn(current);
    const idx = ctxIndexByKey.get(key);
    if (typeof idx !== "number") {
      triplets.push({ prev: null, current, next: null });
      continue;
    }
    const prev = idx > 0 ? contextList[idx - 1] : null;
    const next = idx < contextList.length - 1 ? contextList[idx + 1] : null;
    triplets.push({ prev, current, next });
  }
  return triplets;
}
var init_TripletBuilder = __esm({
  "src/sceneAnalysis/TripletBuilder.ts"() {
  }
});

// src/sceneAnalysis/FileUpdater.ts
async function updateSceneAnalysis(vault, file, parsedAnalysis, plugin, modelIdUsed) {
  try {
    const toArray = (block) => block.split("\n").map((s) => s.replace(/^\s*-\s*/, "").trim()).filter(Boolean);
    await plugin.app.fileManager.processFrontMatter(file, (fm) => {
      var _a, _b, _c;
      const fmObj = fm;
      delete fmObj["previousSceneAnalysis"];
      delete fmObj["currentSceneAnalysis"];
      delete fmObj["nextSceneAnalysis"];
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toLocaleString(void 0, {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      fmObj["Beats Last Updated"] = `${timestamp}${modelIdUsed ? ` by ${modelIdUsed}` : " by Unknown Model"}`;
      if (Object.prototype.hasOwnProperty.call(fmObj, "beatsupdate")) fmObj["beatsupdate"] = false;
      else fmObj["Beats Update"] = false;
      const b1 = (_a = parsedAnalysis["previousSceneAnalysis"]) == null ? void 0 : _a.trim();
      const b2 = (_b = parsedAnalysis["currentSceneAnalysis"]) == null ? void 0 : _b.trim();
      const b3 = (_c = parsedAnalysis["nextSceneAnalysis"]) == null ? void 0 : _c.trim();
      if (b1) fmObj["previousSceneAnalysis"] = toArray(b1);
      if (b2) fmObj["currentSceneAnalysis"] = toArray(b2);
      if (b3) fmObj["nextSceneAnalysis"] = toArray(b3);
    });
    return true;
  } catch (e) {
    console.error("[updateSceneBeats] Error updating file:", e);
    return false;
  }
}
var init_FileUpdater = __esm({
  "src/sceneAnalysis/FileUpdater.ts"() {
  }
});

// src/sceneAnalysis/RequestRunner.ts
function createAiRunner(plugin, vault, callAiProvider2) {
  return (userPrompt, subplotName, commandContext, sceneName, tripletInfo) => callAiProvider2(plugin, vault, userPrompt, subplotName, commandContext, sceneName, tripletInfo);
}
var init_RequestRunner = __esm({
  "src/sceneAnalysis/RequestRunner.ts"() {
  }
});

// src/SceneAnalysisCommands.ts
var SceneAnalysisCommands_exports = {};
__export(SceneAnalysisCommands_exports, {
  calculateFlaggedCount: () => calculateFlaggedCount,
  calculateSceneCount: () => calculateSceneCount,
  createTemplateScene: () => createTemplateScene,
  getDistinctSubplotNames: () => getDistinctSubplotNames,
  processByManuscriptOrder: () => processByManuscriptOrder,
  processBySubplotNameWithModal: () => processBySubplotNameWithModal,
  processBySubplotOrder: () => processBySubplotOrder,
  processEntireSubplotWithModal: () => processEntireSubplotWithModal,
  purgeBeatsByManuscriptOrder: () => purgeBeatsByManuscriptOrder,
  purgeBeatsBySubplotName: () => purgeBeatsBySubplotName,
  testYamlUpdateFormatting: () => testYamlUpdateFormatting
});
function normalizeBooleanValue2(value) {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "string") {
    const lower = value.toLowerCase().trim();
    if (lower === "" || lower === " ") {
      return false;
    }
    return lower === "yes" || lower === "true" || lower === "1";
  }
  if (typeof value === "number") {
    return value === 1;
  }
  return false;
}
function extractSceneNumber(filename) {
  const match = filename.match(/^(\d+(\.\d+)?)/);
  return match ? parseFloat(match[1]) : null;
}
function compareScenesByOrder(a, b) {
  const parse = (name) => {
    const m = name.match(/^(\d+)(?:\.(\d+))?/);
    if (!m) return { major: Number.POSITIVE_INFINITY, minor: Number.POSITIVE_INFINITY };
    const major = parseInt(m[1], 10);
    const minor = typeof m[2] !== "undefined" ? parseInt(m[2], 10) : -1;
    return { major, minor };
  };
  const A = parse(a.file.name);
  const B = parse(b.file.name);
  if (A.major !== B.major) return A.major - B.major;
  return A.minor - B.minor;
}
function getSubplotNamesFromFM(fm) {
  var _a;
  const value = (_a = fm == null ? void 0 : fm.Subplot) != null ? _a : fm == null ? void 0 : fm.subplot;
  if (typeof value === "string" && value.trim()) {
    return [value.trim()];
  }
  if (Array.isArray(value)) {
    return value.map((v) => String(v).trim()).filter(Boolean);
  }
  return [];
}
function hasProcessableContent(fm) {
  if (!fm) return false;
  const status = fm.Status || fm.status;
  if (typeof status === "string") {
    const lower = status.toLowerCase();
    return lower === "complete" || lower === "working";
  }
  if (Array.isArray(status)) {
    return status.some((s) => {
      if (typeof s === "string") {
        const lower = s.toLowerCase();
        return lower === "complete" || lower === "working";
      }
      return false;
    });
  }
  return false;
}
async function getAllSceneData(plugin, vault) {
  const sourcePath = plugin.settings.sourcePath.trim();
  const allFiles = vault.getMarkdownFiles();
  const filesInPath = allFiles.filter((file) => {
    if (sourcePath === "") return true;
    return file.path.startsWith(sourcePath + "/") || file.path === sourcePath;
  });
  const sceneDataPromises = filesInPath.map(async (file) => {
    var _a, _b, _c;
    const filePath = file.path;
    try {
      const content = await vault.read(file);
      const fmInfo = (0, import_obsidian17.getFrontMatterInfo)(content);
      if (!fmInfo || !fmInfo.exists) {
        return null;
      }
      let frontmatter = {};
      try {
        const fmText = (_a = fmInfo.frontmatter) != null ? _a : "";
        const rawFrontmatter = fmText ? (0, import_obsidian17.parseYaml)(fmText) || {} : {};
        frontmatter = normalizeFrontmatterKeys(rawFrontmatter);
      } catch (e) {
        return null;
      }
      const fileClass = frontmatter == null ? void 0 : frontmatter.Class;
      if (typeof fileClass !== "string" || fileClass.toLowerCase() !== "scene") {
        const foundClass = fileClass ? `'${fileClass}'` : "Not found";
        return null;
      }
      const sceneNumber = extractSceneNumber(file.name);
      let body = content;
      try {
        const endOffset = (_c = (_b = fmInfo.position) == null ? void 0 : _b.end) == null ? void 0 : _c.offset;
        if (typeof endOffset === "number" && endOffset >= 0 && endOffset <= content.length) {
          body = content.slice(endOffset).trim();
        } else {
          body = content.replace(/^---[\s\S]*?\n---/, "").trim();
        }
      } catch (e) {
        body = content.replace(/^---[\s\S]*?\n---/, "").trim();
      }
      body = stripObsidianComments2(body);
      return { file, frontmatter, sceneNumber, body };
    } catch (e) {
      return null;
    }
  });
  const results = await Promise.all(sceneDataPromises);
  const validScenes = results.filter((item) => item !== null);
  return validScenes;
}
function getActiveContextPrompt(plugin) {
  const templates = plugin.settings.aiContextTemplates || [];
  const activeId = plugin.settings.activeAiContextTemplateId;
  const active = templates.find((t) => t.id === activeId);
  return active == null ? void 0 : active.prompt;
}
function wasProcessedToday(frontmatter) {
  if (!frontmatter) return false;
  const beatsLastUpdated = frontmatter["Beats Last Updated"];
  if (!beatsLastUpdated || typeof beatsLastUpdated !== "string") return false;
  const match = beatsLastUpdated.match(/^(.+?)\s+by\s+/);
  if (!match) return false;
  try {
    const timestampDate = new Date(match[1]);
    if (isNaN(timestampDate.getTime())) return false;
    const today = /* @__PURE__ */ new Date();
    return timestampDate.toDateString() === today.toDateString();
  } catch (e) {
    return false;
  }
}
function hasBeenProcessedForBeats(frontmatter, options = {}) {
  if (!frontmatter) return false;
  const hasTimestamp = !!frontmatter["Beats Last Updated"];
  const hasAnalysis = !!frontmatter["previousSceneAnalysis"] || !!frontmatter["currentSceneAnalysis"] || !!frontmatter["nextSceneAnalysis"];
  if (!hasTimestamp && !hasAnalysis) return false;
  if (options.todayOnly) {
    return hasTimestamp && wasProcessedToday(frontmatter);
  }
  return hasTimestamp || hasAnalysis;
}
async function calculateSceneCount(plugin, vault, mode) {
  const isResuming = plugin.settings._isResuming || false;
  const allScenes = await getAllSceneData(plugin, vault);
  allScenes.sort(compareScenesByOrder);
  const processableScenes = allScenes.filter((scene) => {
    var _a, _b, _c, _d, _e;
    if (mode === "flagged") {
      const beatsUpdateFlag = (_e = (_c = (_a = scene.frontmatter) == null ? void 0 : _a.beatsupdate) != null ? _c : (_b = scene.frontmatter) == null ? void 0 : _b.BeatsUpdate) != null ? _e : (_d = scene.frontmatter) == null ? void 0 : _d["Beats Update"];
      return normalizeBooleanValue2(beatsUpdateFlag) && hasProcessableContent(scene.frontmatter);
    }
    return hasProcessableContent(scene.frontmatter);
  });
  if (mode === "flagged") {
    return processableScenes.length;
  }
  if (mode === "force-all") {
    if (isResuming) {
      return processableScenes.filter(
        (scene) => !hasBeenProcessedForBeats(scene.frontmatter, { todayOnly: true })
      ).length;
    }
    return processableScenes.length;
  }
  if (mode === "unprocessed") {
    if (isResuming) {
      return processableScenes.filter(
        (scene) => !hasBeenProcessedForBeats(scene.frontmatter, { todayOnly: true })
      ).length;
    }
    return processableScenes.filter(
      (scene) => !hasBeenProcessedForBeats(scene.frontmatter)
    ).length;
  }
  return 0;
}
async function calculateFlaggedCount(plugin, vault, mode) {
  const allScenes = await getAllSceneData(plugin, vault);
  allScenes.sort(compareScenesByOrder);
  const isFlagged = (scene) => {
    var _a, _b, _c, _d, _e;
    return normalizeBooleanValue2((_e = (_c = (_a = scene.frontmatter) == null ? void 0 : _a.beatsupdate) != null ? _c : (_b = scene.frontmatter) == null ? void 0 : _b.BeatsUpdate) != null ? _e : (_d = scene.frontmatter) == null ? void 0 : _d["Beats Update"]);
  };
  if (mode === "flagged") {
    return allScenes.filter(isFlagged).length;
  }
  if (mode === "force-all") return allScenes.length;
  if (mode === "unprocessed") return allScenes.filter((s) => hasProcessableContent(s.frontmatter) && !hasBeenProcessedForBeats(s.frontmatter)).length;
  return 0;
}
async function logApiInteractionToFile(plugin, vault, provider, modelId, requestData, responseData, subplotName, commandContext, sceneName, tripletInfo) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  if (!plugin.settings.logApiInteractions) {
    return;
  }
  const logFolder = "AI";
  const timestamp = (/* @__PURE__ */ new Date()).toLocaleString(void 0, {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "2-digit",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
    timeZoneName: "short"
  }).replace(/\//g, "-").replace(/(\d{1,2}):(\d{2}):(\d{2})\s*(AM|PM)\s*([A-Z]{3,})/g, "at $1.$2.$3 $4 $5").replace(/[\s,]+/g, " ").trim();
  const friendlyModelForFilename = (() => {
    const mid = (modelId || "").toLowerCase();
    if (provider === "anthropic") {
      if (mid.includes("sonnet-4-5") || mid.includes("sonnet-4.5")) return "Claude Sonnet 4.5";
      if (mid.includes("opus-4-1") || mid.includes("opus-4.1")) return "Claude Opus 4.1";
      if (mid.includes("sonnet-4")) return "Claude Sonnet 4";
      if (mid.includes("opus-4")) return "Claude Opus 4";
    } else if (provider === "gemini") {
      if (mid.includes("2.5-pro") || mid.includes("2-5-pro")) return "Gemini 2.5 Pro";
    } else if (provider === "openai") {
      if (mid.includes("gpt-4.1") || mid.includes("gpt-4-1")) return "GPT-4.1";
    }
    return modelId;
  })();
  let fileName;
  if (sceneName) {
    const cleanSceneName = sceneName.replace(/[<>:"/\\|?*]/g, "").trim();
    fileName = `${cleanSceneName} \u2014 ${friendlyModelForFilename} \u2014 ${timestamp}.md`;
  } else {
    fileName = `${provider}-log-${timestamp}.md`;
  }
  const filePath = `${logFolder}/${fileName}`;
  const isObject = (data) => {
    return typeof data === "object" && data !== null;
  };
  const safeRequestData = isObject(requestData) ? requestData : null;
  const requestJson = JSON.stringify(requestData, null, 2);
  const responseJson = JSON.stringify(responseData, null, 2);
  let usageString = "**Usage:** N/A";
  try {
    if (responseData && typeof responseData === "object") {
      const rd = responseData;
      if (provider === "openai" && rd && typeof rd === "object" && "usage" in rd) {
        const u = rd.usage;
        if (u && (typeof u.prompt_tokens === "number" || typeof u.completion_tokens === "number")) {
          usageString = `**Usage (OpenAI):** prompt=${(_a = u.prompt_tokens) != null ? _a : "n/a"}, output=${(_b = u.completion_tokens) != null ? _b : "n/a"}`;
        }
      } else if (provider === "anthropic" && rd && typeof rd === "object" && "usage" in rd) {
        const u = rd.usage;
        if (u && (typeof u.input_tokens === "number" || typeof u.output_tokens === "number")) {
          usageString = `**Usage (Anthropic):** input=${(_c = u.input_tokens) != null ? _c : "n/a"}, output=${(_d = u.output_tokens) != null ? _d : "n/a"}`;
        }
      } else if (provider === "gemini" && rd && typeof rd === "object" && "usageMetadata" in rd) {
        const u = rd.usageMetadata;
        usageString = `**Usage (Gemini):** total=${(_e = u == null ? void 0 : u.totalTokenCount) != null ? _e : "n/a"}, prompt=${(_f = u == null ? void 0 : u.promptTokenCount) != null ? _f : "n/a"}, output=${(_g = u == null ? void 0 : u.candidatesTokenCount) != null ? _g : "n/a"}`;
      }
    }
  } catch (e) {
  }
  let outcomeSection = "## Outcome\n\n";
  if (responseData && typeof responseData === "object") {
    const responseAsRecord = responseData;
    if (responseAsRecord.error) {
      outcomeSection += `**Status:** Failed
`;
      const errObj = responseAsRecord.error;
      outcomeSection += `**Error Type:** ${String((_h = errObj == null ? void 0 : errObj.type) != null ? _h : "Unknown")}
`;
      outcomeSection += `**Message:** ${String((_i = errObj == null ? void 0 : errObj.message) != null ? _i : "No message provided")}
`;
      if (typeof (errObj == null ? void 0 : errObj.status) !== "undefined") {
        outcomeSection += `**Status Code:** ${String(errObj.status)}
`;
      }
      outcomeSection += "\n";
    } else {
      let success = false;
      let contentForCheck = null;
      if (provider === "openai") {
        const choices = responseAsRecord.choices;
        if (Array.isArray(choices) && choices[0] && typeof choices[0] === "object") {
          const msg = choices[0].message;
          const content = msg == null ? void 0 : msg.content;
          contentForCheck = content;
        }
        success = !!contentForCheck;
      } else if (provider === "anthropic") {
        const contentArr = responseAsRecord.content;
        if (Array.isArray(contentArr) && contentArr[0] && typeof contentArr[0] === "object") {
          const text = contentArr[0].text;
          contentForCheck = text != null ? text : responseData.content;
        }
        success = !!contentForCheck;
      } else if (provider === "gemini") {
        const candidates = responseAsRecord.candidates;
        let parts = void 0;
        if (Array.isArray(candidates) && candidates[0] && typeof candidates[0] === "object") {
          const contentObj = candidates[0].content;
          parts = contentObj == null ? void 0 : contentObj.parts;
        }
        if (Array.isArray(parts)) {
          const arr = parts;
          contentForCheck = arr.map((p) => {
            var _a2;
            return (_a2 = p == null ? void 0 : p.text) != null ? _a2 : "";
          }).join("").trim();
          success = !!contentForCheck;
        }
      }
      if (success) {
        outcomeSection += `**Status:** Success (Content Received)
`;
        outcomeSection += "\n";
      } else {
        outcomeSection += `**Status:** Response Structure Error
`;
        outcomeSection += `**Details:** Could not find expected content structure for ${provider} in the response.
`;
        outcomeSection += `**Actual Response Structure (relevant part):**
\`\`\`json
`;
        if (provider === "openai") {
          outcomeSection += JSON.stringify(responseAsRecord.choices, null, 2);
        } else if (provider === "anthropic") {
          outcomeSection += JSON.stringify(responseAsRecord.content, null, 2);
        } else if (provider === "gemini") {
          outcomeSection += JSON.stringify(responseAsRecord.candidates, null, 2);
        } else {
          outcomeSection += JSON.stringify(responseData, null, 2);
        }
        outcomeSection += `
\`\`\`
`;
      }
    }
  } else {
    outcomeSection += `**Status:** Unexpected Response Format
`;
    outcomeSection += `**Response Received:** ${JSON.stringify(responseData)}
`;
  }
  const contextHeader = subplotName ? `**Subplot Context:** ${subplotName}` : `**Context:** Manuscript Order`;
  const friendlyModel = (() => {
    const mid = (modelId || "").toLowerCase();
    if (provider === "anthropic") {
      if (mid.includes("sonnet-4-5") || mid.includes("sonnet-4.5")) return "Claude Sonnet 4.5";
      if (mid.includes("opus-4-1") || mid.includes("opus-4.1")) return "Claude Opus 4.1";
      if (mid.includes("sonnet-4")) return "Claude Sonnet 4";
      if (mid.includes("opus-4")) return "Claude Opus 4";
    } else if (provider === "gemini") {
      if (mid.includes("2.5-pro") || mid.includes("2-5-pro")) return "Gemini 2.5 Pro";
    } else if (provider === "openai") {
      if (mid.includes("gpt-4.1") || mid.includes("gpt-4-1")) return "GPT-4.1";
    }
    return modelId;
  })();
  const scenesSummaryForTitle = tripletInfo || { prev: void 0, current: void 0, next: void 0 };
  const providerTitle = provider.charAt(0).toUpperCase() + provider.slice(1);
  const readableTimestamp = (/* @__PURE__ */ new Date()).toLocaleString(void 0, {
    year: "numeric",
    month: "2-digit",
    day: "2-digit",
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
    timeZoneName: "short"
  });
  const sceneTitle = scenesSummaryForTitle.current ? `Scene ${scenesSummaryForTitle.current}` : "Scene Processed";
  let fileContent = `**Command:** ${commandContext}
`;
  fileContent += `**Provider:** ${provider}
`;
  fileContent += `**Model:** ${friendlyModel}
`;
  fileContent += `**Model ID:** ${modelId}
`;
  fileContent += `**Timestamp:** ${readableTimestamp}
`;
  const activeTemplate = (_j = plugin.settings.aiContextTemplates) == null ? void 0 : _j.find((t) => t.id === plugin.settings.activeAiContextTemplateId);
  if (activeTemplate) {
    fileContent += `**Active Template:** ${activeTemplate.name}
`;
  } else {
    fileContent += `**Active Template:** None (using default)
`;
  }
  fileContent += `${contextHeader}
`;
  let userPromptContent = "User prompt not logged correctly";
  let fullUserPrompt;
  if (provider === "openai" && (safeRequestData == null ? void 0 : safeRequestData.messages) && Array.isArray(safeRequestData.messages)) {
    const userMessage = safeRequestData.messages.find((m) => m.role === "user");
    if (userMessage) fullUserPrompt = userMessage.content;
  } else if (provider === "anthropic" && safeRequestData) {
    const anthropicMsg = (_l = (_k = safeRequestData.messages) == null ? void 0 : _k[0]) == null ? void 0 : _l.content;
    if (typeof anthropicMsg === "string") fullUserPrompt = anthropicMsg;
  } else if (provider === "gemini") {
    const rd = requestData;
    if (rd && typeof rd === "object" && rd.contents) {
      const contents = rd.contents;
      if (Array.isArray(contents) && contents[0] && typeof contents[0] === "object") {
        const first = contents[0];
        const parts = first.parts;
        if (Array.isArray(parts)) {
          const arr = parts;
          fullUserPrompt = arr.map((p) => {
            var _a2;
            return (_a2 = p == null ? void 0 : p.text) != null ? _a2 : "";
          }).join("").trim();
        }
      }
    }
  }
  const scenesLine = `**Scenes:** prev=${(_m = tripletInfo == null ? void 0 : tripletInfo.prev) != null ? _m : "N/A"}, current=${(_n = tripletInfo == null ? void 0 : tripletInfo.current) != null ? _n : "N/A"}, next=${(_o = tripletInfo == null ? void 0 : tripletInfo.next) != null ? _o : "N/A"}`;
  fileContent += `${scenesLine}
`;
  const redactPrompt = (text) => {
    if (!text) return "Unavailable";
    const lines = text.split(/\r?\n/);
    const headerRe = /^\s*Scene\s+[^:]+:\s*$/i;
    const idx = lines.findIndex((l) => headerRe.test(l));
    const kept = idx >= 0 ? lines.slice(0, idx) : lines;
    return kept.join("\n");
  };
  userPromptContent = redactPrompt(fullUserPrompt);
  fileContent += `## Prompt Template

\`\`\`
${userPromptContent}
\`\`\`

`;
  let systemPromptContent = null;
  if (safeRequestData) {
    if (provider === "openai" && safeRequestData.messages && Array.isArray(safeRequestData.messages)) {
      systemPromptContent = (_p = safeRequestData.messages.find((m) => m.role === "system")) == null ? void 0 : _p.content;
    } else if (provider === "anthropic") {
      systemPromptContent = safeRequestData.system;
    } else if (provider === "gemini") {
      const rd = requestData;
      if (rd && typeof rd === "object") {
        const sys = rd.systemInstruction;
        if (sys && typeof sys === "object") {
          const parts = sys.parts;
          if (Array.isArray(parts)) {
            const arr = parts;
            systemPromptContent = arr.map((p) => {
              var _a2;
              return (_a2 = p == null ? void 0 : p.text) != null ? _a2 : "";
            }).join("").trim();
          }
        }
      }
    }
  }
  if (systemPromptContent) {
    fileContent += `## System Prompt Used

\`\`\`
${systemPromptContent}
\`\`\`

`;
  }
  fileContent += `## Request Sent

`;
  fileContent += `\`\`\`json
${requestJson}
\`\`\`

`;
  fileContent += `## Response Received (Full JSON)

`;
  fileContent += `\`\`\`json
${responseJson}
\`\`\``;
  fileContent += `
${usageString}

`;
  fileContent += `${outcomeSection}`;
  try {
    try {
      await vault.createFolder(logFolder);
    } catch (e) {
      if (e instanceof Error && e.message && !e.message.includes("already exists")) {
        throw e;
      } else if (!(e instanceof Error)) {
      }
    }
    await vault.create(filePath, fileContent.trim());
  } catch (error) {
    console.error(`[BeatsCommands] Error logging API interaction to file ${filePath}:`, error);
    new import_obsidian17.Notice(`Failed to write AI log to ${filePath}. Check console.`);
  }
}
async function retryWithBackoff(fn, maxRetries = 3, baseDelayMs = 5e3) {
  for (let attempt = 0; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const isRateLimitError = errorMessage.toLowerCase().includes("rate limit") || errorMessage.toLowerCase().includes("overloaded") || errorMessage.toLowerCase().includes("too many requests");
      if (isRateLimitError && attempt < maxRetries) {
        const delayMs = baseDelayMs * Math.pow(2, attempt);
        new import_obsidian17.Notice(`Rate limit reached. Waiting ${delayMs / 1e3}s before retry (${attempt + 1}/${maxRetries})...`, 3e3);
        await new Promise((resolve) => window.setTimeout(resolve, delayMs));
        continue;
      }
      throw error;
    }
  }
  throw new Error("Retry logic exhausted without success");
}
async function callAiProvider(plugin, vault, userPrompt, subplotName, commandContext, sceneName, tripletInfo) {
  const provider = plugin.settings.defaultAiProvider || "openai";
  let apiKey;
  let modelId;
  let requestBodyForLog = null;
  let responseDataForLog;
  let result = null;
  let apiErrorMsg;
  try {
    const normalizeModelId = (prov, id) => {
      if (!id) return id;
      switch (prov) {
        case "anthropic":
          if (id === "claude-opus-4-1" || id === "claude-4.1-opus" || id === "claude-opus-4-1@20250805") return "claude-opus-4-1-20250805";
          if (id === "claude-sonnet-4-1" || id === "claude-4-sonnet" || id === "claude-sonnet-4-1@20250805") return "claude-sonnet-4-5-20250929";
          if (id === "claude-opus-4-0" || id === "claude-3-opus-20240229") return "claude-opus-4-1-20250805";
          if (id === "claude-sonnet-4-0" || id === "claude-3-7-sonnet-20250219" || id === "claude-sonnet-4-20250514") return "claude-sonnet-4-5-20250929";
          return id;
        case "openai":
          if (id === "gpt-5" || id === "o3" || id === "gpt-4o") return "gpt-4.1";
          if (id === "gpt-4.1") return "gpt-4.1";
          return id;
        case "gemini":
          if (id === "gemini-2.5-pro") return "gemini-2.5-pro";
          if (id === "gemini-ultra" || id === "gemini-creative" || id === "gemini-1.0-pro" || id === "gemini-1.5-pro") return "gemini-2.5-pro";
          return id;
        default:
          return id;
      }
    };
    if (provider === "anthropic") {
      apiKey = plugin.settings.anthropicApiKey;
      modelId = normalizeModelId("anthropic", plugin.settings.anthropicModelId) || "claude-sonnet-4-5-20250929";
      if (!apiKey || !modelId) {
        apiErrorMsg = "Anthropic API key or Model ID not configured in settings.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      requestBodyForLog = {
        model: modelId,
        messages: [{ role: "user", content: userPrompt }],
        max_tokens: 4e3
      };
      const apiResponse = await retryWithBackoff(
        () => callAnthropicApi(apiKey, modelId, null, userPrompt, 4e3)
      );
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success) {
        apiErrorMsg = apiResponse.error;
        throw new Error(apiErrorMsg || `Anthropic API call failed with unknown error.`);
      }
      result = apiResponse.content;
    } else if (provider === "gemini") {
      apiKey = plugin.settings.geminiApiKey;
      modelId = normalizeModelId("gemini", plugin.settings.geminiModelId) || "gemini-1.5-pro";
      if (!apiKey || !modelId) {
        apiErrorMsg = "Gemini API key or Model ID not configured.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      const jsonSchema = getSceneAnalysisJsonSchema();
      const safetySystem = "Follow policy: respond with purely editorial, non-explicit analysis. Avoid sexual detail, graphic violence, or instructions for harm. Output must be valid JSON only.";
      requestBodyForLog = {
        model: modelId,
        contents: [{ role: "user", parts: [{ text: userPrompt }] }],
        generationConfig: {
          temperature: 0.7,
          maxOutputTokens: 4e3,
          responseMimeType: "application/json",
          responseSchema: jsonSchema
        },
        systemInstruction: { parts: [{ text: safetySystem }] }
      };
      let apiResponse = await retryWithBackoff(
        () => callGeminiApi(apiKey, modelId, safetySystem, userPrompt, 4e3, 0.7, jsonSchema)
      );
      if (!apiResponse.success && typeof apiResponse.error === "string" && apiResponse.error.toLowerCase().includes("safety")) {
        const oaiKey = plugin.settings.openaiApiKey;
        const oaiModel = plugin.settings.openaiModelId || "gpt-4.1";
        if (oaiKey) {
          const openAiRequestForLog = {
            model: oaiModel,
            messages: [
              { role: "user", content: userPrompt }
            ],
            temperature: 0.7,
            max_tokens: 4e3,
            response_format: { type: "json_object" }
          };
          const oaiResp = await retryWithBackoff(
            () => callOpenAiApi(oaiKey, oaiModel, null, userPrompt, 4e3, 0.7, true)
          );
          responseDataForLog = oaiResp.responseData;
          if (!oaiResp.success) {
            apiErrorMsg = oaiResp.error || "Fallback (OpenAI) failed after Gemini safety block.";
            throw new Error(apiErrorMsg);
          }
          result = oaiResp.content;
          modelId = oaiModel;
          requestBodyForLog = openAiRequestForLog;
          await logApiInteractionToFile(plugin, vault, "openai", modelId, requestBodyForLog, responseDataForLog, subplotName, commandContext, sceneName, tripletInfo);
          return { result, modelIdUsed: modelId };
        }
      }
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success) {
        apiErrorMsg = apiResponse.error;
        throw new Error(apiErrorMsg || `Gemini API call failed.`);
      }
      result = apiResponse.content;
    } else {
      apiKey = plugin.settings.openaiApiKey;
      modelId = normalizeModelId("openai", plugin.settings.openaiModelId) || "gpt-4o";
      if (!apiKey || !modelId) {
        apiErrorMsg = "OpenAI API key or Model ID not configured.";
        responseDataForLog = { error: { message: apiErrorMsg, type: "plugin_config_error" } };
        throw new Error(apiErrorMsg);
      }
      requestBodyForLog = {
        model: modelId,
        messages: [
          { role: "user", content: userPrompt }
        ],
        temperature: 0.7,
        max_tokens: 4e3,
        response_format: { type: "json_object" }
      };
      const apiResponse = await retryWithBackoff(
        () => callOpenAiApi(apiKey, modelId, null, userPrompt, 4e3, 0.7, true)
      );
      responseDataForLog = apiResponse.responseData;
      if (!apiResponse.success) {
        apiErrorMsg = apiResponse.error;
        throw new Error(apiErrorMsg || `OpenAI API call failed.`);
      }
      result = apiResponse.content;
    }
    await logApiInteractionToFile(plugin, vault, provider, modelId || "unknown", requestBodyForLog, responseDataForLog, subplotName, commandContext, sceneName, tripletInfo);
    return { result, modelIdUsed: modelId || "unknown" };
  } catch (error) {
    const errorMessage = apiErrorMsg || (error instanceof Error ? error.message : String(error));
    console.error(`[API][BeatsCommands][callAiProvider] Error during ${provider} API call:`, errorMessage, error);
    const currentProvider = provider || plugin.settings.defaultAiProvider || "unknown";
    if (!modelId) {
      if (currentProvider === "anthropic") modelId = plugin.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
      else if (currentProvider === "openai") modelId = "gpt-4o";
      else if (currentProvider === "gemini") modelId = plugin.settings.geminiModelId || "gemini-1.5-pro";
      else modelId = "unknown";
    }
    if (!requestBodyForLog) requestBodyForLog = { note: "Request body not constructed due to early error." };
    if (!responseDataForLog) {
      responseDataForLog = { error: { message: errorMessage, type: errorMessage.includes("configured") ? "plugin_config_error" : "plugin_execution_error" } };
    }
    await logApiInteractionToFile(plugin, vault, currentProvider, modelId || "unknown", requestBodyForLog, responseDataForLog, subplotName, commandContext, sceneName, tripletInfo);
    new import_obsidian17.Notice(`Error: ${errorMessage}`);
    return { result: null, modelIdUsed: null };
  }
}
function parseJsonBeatsResponse(jsonResult, plugin) {
  try {
    let cleanedJson = jsonResult.trim();
    if (cleanedJson.startsWith("```json")) {
      cleanedJson = cleanedJson.replace(/^```json\s*\n?/, "").replace(/\n?```\s*$/, "");
    } else if (cleanedJson.startsWith("```")) {
      cleanedJson = cleanedJson.replace(/^```\s*\n?/, "").replace(/\n?```\s*$/, "");
    }
    const parsed = JSON.parse(cleanedJson);
    const formatAnalysisArray = (analysis, isCurrentAnalysis = false) => {
      if (!analysis || analysis.length === 0) return "";
      return analysis.map((beat, index) => {
        if (index === 0) {
          const isOverallGrade = isCurrentAnalysis && ["A", "B", "C"].includes(beat.grade);
          if (isOverallGrade) {
            return ` - ${beat.scene} ${beat.grade} / ${beat.comment}`;
          }
          const parts2 = [beat.scene];
          if (beat.title) parts2.push(beat.title);
          parts2.push(beat.grade);
          return ` - ${parts2.join(" ")} / ${beat.comment}`;
        }
        const parts = [];
        if (beat.title) parts.push(beat.title);
        parts.push(beat.grade);
        return ` - ${parts.join(" ")} / ${beat.comment}`;
      }).join("\n");
    };
    const result = {
      "previousSceneAnalysis": formatAnalysisArray(parsed["previousSceneAnalysis"], false),
      "currentSceneAnalysis": formatAnalysisArray(parsed["currentSceneAnalysis"], true),
      // Special handling for overall grade
      "nextSceneAnalysis": formatAnalysisArray(parsed["nextSceneAnalysis"], false)
    };
    if (!result["currentSceneAnalysis"].trim()) {
      new import_obsidian17.Notice("LLM response is missing required currentSceneAnalysis.");
      return null;
    }
    return result;
  } catch (error) {
    console.error("[parseJsonBeatsResponse] Error parsing JSON beats response:", error);
    new import_obsidian17.Notice("Failed to parse LLM JSON response. Check console for details.");
    return null;
  }
}
function parseGptResult(gptResult, plugin) {
  const jsonResult = parseJsonBeatsResponse(gptResult, plugin);
  if (jsonResult) {
    return jsonResult;
  }
  try {
    let text = (gptResult || "").replace(/\r\n?/g, "\n");
    text = text.replace(/^\s*[]\s+/gm, "- ");
    const normalizeHeader = (key) => {
      const headerRegex = new RegExp(
        `^\\s*(?:[#>*_'-]{0,5}\\s*)*` + key + `\\s*:?\\s*(?:[#>*_'-]{0,5})?\\s*$`,
        "gmi"
      );
      text = text.replace(headerRegex, `${key}:`);
    };
    normalizeHeader("previousSceneAnalysis");
    normalizeHeader("currentSceneAnalysis");
    normalizeHeader("nextSceneAnalysis");
    const section1Pattern = /^previousSceneAnalysis:\s*([\s\S]*?)(?=^\s*(?:currentSceneAnalysis:|nextSceneAnalysis:|$))/m;
    const section2Pattern = /^currentSceneAnalysis:\s*([\s\S]*?)(?=^\s*(?:nextSceneAnalysis:|$))/m;
    const section3Pattern = /^nextSceneAnalysis:\s*([\s\S]*)$/m;
    const section1Match = text.match(section1Pattern);
    const section2Match = text.match(section2Pattern);
    const section3Match = text.match(section3Pattern);
    const processSection = (content) => {
      if (!content) return "";
      const normalized = content.replace(/\\n/g, "\n").replace(/(\\n)+\s*$/, "");
      const trimmedContent = normalized.trim();
      if (!trimmedContent) return "";
      const lines = trimmedContent.split("\n").map((l) => l.trim());
      const normalizedBullets = lines.map((l) => l.replace(/^([])\s+/, "- "));
      const bulletLines = normalizedBullets.filter((l) => /^-\s+/.test(l));
      if (bulletLines.length > 0) {
        return bulletLines.map((l) => ` ${l}`).join("\n");
      }
      const nonEmpty = normalizedBullets.filter((l) => l.length > 0);
      if (nonEmpty.length > 0) {
        return nonEmpty.map((l) => ` - ${l}`).join("\n");
      }
      return "";
    };
    const analysis = {
      "previousSceneAnalysis": processSection(section1Match == null ? void 0 : section1Match[1]),
      "currentSceneAnalysis": processSection(section2Match == null ? void 0 : section2Match[1]),
      "nextSceneAnalysis": processSection(section3Match == null ? void 0 : section3Match[1])
    };
    if (!analysis["previousSceneAnalysis"].trim() && !analysis["currentSceneAnalysis"].trim() && !analysis["nextSceneAnalysis"].trim()) {
      new import_obsidian17.Notice("Failed to parse scene analysis from LLM response.");
      return null;
    }
    return analysis;
  } catch (error) {
    console.error("[parseGptResult] Error parsing beats response:", error);
    return null;
  }
}
async function updateSceneFile(vault, scene, parsedAnalysis, plugin, modelIdUsed) {
  try {
    const toArray = (block) => {
      return block.split("\n").map((s) => s.replace(/^\s*-\s*/, "").trim()).filter(Boolean);
    };
    await plugin.app.fileManager.processFrontMatter(scene.file, (fm) => {
      var _a, _b, _c;
      const fmObj = fm;
      delete fmObj["1beats"];
      delete fmObj["2beats"];
      delete fmObj["3beats"];
      const now = /* @__PURE__ */ new Date();
      const timestamp = now.toLocaleString(void 0, {
        year: "numeric",
        month: "short",
        day: "numeric",
        hour: "numeric",
        minute: "2-digit",
        hour12: true
      });
      const updatedValue = `${timestamp}${modelIdUsed ? ` by ${modelIdUsed}` : " by Unknown Model"}`;
      fmObj["Beats Last Updated"] = updatedValue;
      if (Object.prototype.hasOwnProperty.call(fmObj, "beatsupdate")) {
        fmObj["beatsupdate"] = false;
      } else {
        fmObj["Beats Update"] = false;
      }
      const b1 = (_a = parsedAnalysis["previousSceneAnalysis"]) == null ? void 0 : _a.trim();
      const b2 = (_b = parsedAnalysis["currentSceneAnalysis"]) == null ? void 0 : _b.trim();
      const b3 = (_c = parsedAnalysis["nextSceneAnalysis"]) == null ? void 0 : _c.trim();
      if (b1) fmObj["previousSceneAnalysis"] = toArray(b1);
      if (b2) fmObj["currentSceneAnalysis"] = toArray(b2);
      if (b3) fmObj["nextSceneAnalysis"] = toArray(b3);
    });
    return true;
  } catch (error) {
    console.error(`[updateSceneFile] Error updating file:`, error);
    new import_obsidian17.Notice(`Error saving updates to ${scene.file.basename}`);
    return false;
  }
}
async function processByManuscriptOrder(plugin, vault) {
  const modal = new SceneAnalysisProcessingModal(
    plugin.app,
    plugin,
    (mode) => calculateSceneCount(plugin, vault, mode),
    async (mode) => {
      await processWithModal(plugin, vault, mode, modal);
    },
    "radial-timeline:update-beats-manuscript-order"
    // pass command ID for resume functionality
  );
  modal.open();
}
async function processWithModal(plugin, vault, mode, modal) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q;
  const isResuming = plugin.settings._isResuming || false;
  if (isResuming) {
    plugin.settings._isResuming = false;
    await plugin.saveSettings();
  }
  const allScenes = await getAllSceneData(plugin, vault);
  allScenes.sort(compareScenesByOrder);
  if (allScenes.length < 1) {
    throw new Error("No valid scenes found in the specified source path.");
  }
  const processableScenes = allScenes.filter((scene) => {
    var _a2, _b2, _c2, _d2, _e2;
    if (mode === "flagged") {
      const beatsUpdateFlag = (_e2 = (_c2 = (_a2 = scene.frontmatter) == null ? void 0 : _a2.beatsupdate) != null ? _c2 : (_b2 = scene.frontmatter) == null ? void 0 : _b2.BeatsUpdate) != null ? _e2 : (_d2 = scene.frontmatter) == null ? void 0 : _d2["Beats Update"];
      return normalizeBooleanValue2(beatsUpdateFlag);
    }
    return hasProcessableContent(scene.frontmatter);
  });
  const processableContentScenes = allScenes.filter((scene) => hasProcessableContent(scene.frontmatter));
  const triplets = buildTripletsByIndex(processableContentScenes, processableScenes, (s) => s.file.path);
  let processedCount = 0;
  let totalToProcess = 0;
  for (const triplet of triplets) {
    const beatsUpdateFlag = (_e = (_c = (_a = triplet.current.frontmatter) == null ? void 0 : _a.beatsupdate) != null ? _c : (_b = triplet.current.frontmatter) == null ? void 0 : _b.BeatsUpdate) != null ? _e : (_d = triplet.current.frontmatter) == null ? void 0 : _d["Beats Update"];
    const isFlagged = normalizeBooleanValue2(beatsUpdateFlag);
    if (mode === "flagged") {
      if (isFlagged) totalToProcess++;
    } else if (mode === "force-all") {
      if (isResuming) {
        if (!hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true })) {
          totalToProcess++;
        }
      } else {
        totalToProcess++;
      }
    } else if (mode === "unprocessed") {
      if (isResuming) {
        if (!hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true })) {
          totalToProcess++;
        }
      } else {
        if (!hasBeenProcessedForBeats(triplet.current.frontmatter)) {
          totalToProcess++;
        }
      }
    }
  }
  for (const triplet of triplets) {
    if (modal.isAborted()) {
      await plugin.saveSettings();
      throw new Error("Processing aborted by user");
    }
    const currentScenePath = triplet.current.file.path;
    const tripletIdentifier = `${(_g = (_f = triplet.prev) == null ? void 0 : _f.sceneNumber) != null ? _g : "Start"}-${triplet.current.sceneNumber}-${(_i = (_h = triplet.next) == null ? void 0 : _h.sceneNumber) != null ? _i : "End"}`;
    const beatsUpdateFlag = (_n = (_l = (_j = triplet.current.frontmatter) == null ? void 0 : _j.beatsupdate) != null ? _l : (_k = triplet.current.frontmatter) == null ? void 0 : _k.BeatsUpdate) != null ? _n : (_m = triplet.current.frontmatter) == null ? void 0 : _m["Beats Update"];
    const isFlagged = normalizeBooleanValue2(beatsUpdateFlag);
    let shouldProcess = false;
    if (mode === "flagged") {
      shouldProcess = isFlagged;
    } else if (mode === "force-all") {
      if (isResuming) {
        shouldProcess = !hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true });
      } else {
        shouldProcess = true;
      }
    } else if (mode === "unprocessed") {
      if (isResuming) {
        shouldProcess = !hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true });
      } else {
        shouldProcess = !hasBeenProcessedForBeats(triplet.current.frontmatter);
      }
    }
    if (!shouldProcess) {
      continue;
    }
    const sceneName = triplet.current.file.basename;
    modal.updateProgress(processedCount + 1, totalToProcess, sceneName);
    const sceneNameForLog = sceneName;
    try {
      const prevBody = triplet.prev ? triplet.prev.body : null;
      const currentBody = triplet.current.body;
      const nextBody = triplet.next ? triplet.next.body : null;
      const prevNum = triplet.prev ? String((_o = triplet.prev.sceneNumber) != null ? _o : "N/A") : "N/A";
      const currentNum = String((_p = triplet.current.sceneNumber) != null ? _p : "N/A");
      const nextNum = triplet.next ? String((_q = triplet.next.sceneNumber) != null ? _q : "N/A") : "N/A";
      if (plugin.activeBeatsModal && typeof plugin.activeBeatsModal.setTripletInfo === "function") {
        plugin.activeBeatsModal.setTripletInfo(prevNum, currentNum, nextNum);
      }
      const contextPrompt = getActiveContextPrompt(plugin);
      const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt);
      const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
      const runAi = createAiRunner(plugin, vault, callAiProvider);
      const aiResult = await runAi(userPrompt, null, "processByManuscriptOrder", sceneNameForLog, tripletForLog);
      if (aiResult.result) {
        const parsedAnalysis = parseGptResult(aiResult.result, plugin);
        if (parsedAnalysis) {
          if (!triplet.prev) {
            parsedAnalysis["previousSceneAnalysis"] = "";
          }
          if (!triplet.next) {
            parsedAnalysis["nextSceneAnalysis"] = "";
          }
          const updated = await updateSceneAnalysis(vault, triplet.current.file, parsedAnalysis, plugin, aiResult.modelIdUsed);
          if (updated) {
            await plugin.saveSettings();
            modal.updateProgress(processedCount + 1, totalToProcess, sceneName);
          } else {
            modal.addError(`Failed to update file: ${currentScenePath}`);
          }
        } else {
          modal.addError(`Failed to parse AI result for: ${sceneName}`);
        }
      } else {
        modal.addError(`No result from AI for: ${sceneName}`);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      const isRateLimitError = errorMessage.toLowerCase().includes("rate limit") || errorMessage.toLowerCase().includes("overloaded") || errorMessage.toLowerCase().includes("too many requests");
      if (isRateLimitError) {
        modal.addError(`API RATE LIMIT EXCEEDED - Processing stopped`);
        modal.addError(`Details: ${errorMessage}`);
        modal.addError(`System retried 3 times with delays (5s, 10s, 20s) but rate limit persists. Anthropic limits: 50 requests/min for Sonnet 4.x. The plugin now waits 1.5s between scenes (40 req/min). Use Resume to continue after the rate limit window resets (~1 minute).`);
        modal.abort();
        await plugin.saveSettings();
        throw new Error(`Processing aborted due to rate limit: ${errorMessage}`);
      }
      modal.addError(`Error processing ${sceneName}: ${errorMessage}`);
    }
    processedCount++;
    if (!modal.isAborted()) {
      await new Promise((resolve) => window.setTimeout(resolve, 1500));
    }
  }
  await plugin.saveSettings();
  plugin.refreshTimelineIfNeeded(null);
}
async function processBySubplotOrder(plugin, vault) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  const notice = new import_obsidian17.Notice("Processing Subplot: Getting scene data...", 0);
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    if (allScenes.length < 1) {
      new import_obsidian17.Notice("No valid scenes found in the specified source path.");
      notice.hide();
      return;
    }
    const scenesBySubplot = {};
    allScenes.forEach((scene) => {
      const subplotList = getSubplotNamesFromFM(scene.frontmatter);
      subplotList.forEach((subplotKey) => {
        if (subplotKey) {
          if (!scenesBySubplot[subplotKey]) {
            scenesBySubplot[subplotKey] = [];
          }
          if (!scenesBySubplot[subplotKey].some((s) => s.file.path === scene.file.path)) {
            scenesBySubplot[subplotKey].push(scene);
          }
        }
      });
    });
    const subplotNames = Object.keys(scenesBySubplot);
    if (subplotNames.length === 0) {
      new import_obsidian17.Notice("No scenes with subplots found.");
      notice.hide();
      return;
    }
    let totalProcessedCount = 0;
    let totalTripletsAcrossSubplots = 0;
    subplotNames.forEach((subplotName) => {
      const scenes = scenesBySubplot[subplotName];
      scenes.sort(compareScenesByOrder);
      const validScenes = scenes.filter((scene) => {
        var _a2, _b2, _c2, _d2;
        const beatsUpdate = ((_a2 = scene.frontmatter) == null ? void 0 : _a2.beatsupdate) || ((_b2 = scene.frontmatter) == null ? void 0 : _b2.BeatsUpdate) || ((_c2 = scene.frontmatter) == null ? void 0 : _c2["Beats Update"]);
        if (normalizeBooleanValue2(beatsUpdate) && !hasProcessableContent(scene.frontmatter)) {
          const msg = `Scene ${(_d2 = scene.sceneNumber) != null ? _d2 : scene.file.basename} (subplot ${subplotName}) has Beats Update: Yes/True but Status is not working/complete. Skipping.`;
          new import_obsidian17.Notice(msg, 6e3);
        }
        return hasProcessableContent(scene.frontmatter) && normalizeBooleanValue2(beatsUpdate);
      });
      totalTripletsAcrossSubplots += validScenes.length;
    });
    notice.setMessage(`Analyzing ${totalTripletsAcrossSubplots} scenes for subplot order...`);
    for (const subplotName of subplotNames) {
      const scenes = scenesBySubplot[subplotName];
      scenes.sort(compareScenesByOrder);
      const orderedScenes = scenes.slice().sort(compareScenesByOrder);
      const processableContentScenes = orderedScenes.filter((scene) => hasProcessableContent(scene.frontmatter));
      const flaggedInOrder = orderedScenes.filter((s) => {
        var _a2, _b2, _c2;
        return hasProcessableContent(s.frontmatter) && normalizeBooleanValue2(((_a2 = s.frontmatter) == null ? void 0 : _a2.beatsupdate) || ((_b2 = s.frontmatter) == null ? void 0 : _b2.BeatsUpdate) || ((_c2 = s.frontmatter) == null ? void 0 : _c2["Beats Update"]));
      });
      const triplets = buildTripletsByIndex(processableContentScenes, flaggedInOrder, (s) => s.file.path);
      for (const triplet of triplets) {
        const currentScenePath = triplet.current.file.path;
        const tripletIdentifier = `subplot-${subplotName}-${(_b = (_a = triplet.prev) == null ? void 0 : _a.sceneNumber) != null ? _b : "Start"}-${triplet.current.sceneNumber}-${(_d = (_c = triplet.next) == null ? void 0 : _c.sceneNumber) != null ? _d : "End"}`;
        const beatsUpdateFlag = (_g = (_e = triplet.current.frontmatter) == null ? void 0 : _e.beatsupdate) != null ? _g : (_f = triplet.current.frontmatter) == null ? void 0 : _f["Beats Update"];
        if (!normalizeBooleanValue2(beatsUpdateFlag)) {
          continue;
        }
        notice.setMessage(`Processing scene ${triplet.current.sceneNumber} (${totalProcessedCount + 1}/${totalTripletsAcrossSubplots}) - Subplot: '${subplotName}'...`);
        const prevBody = triplet.prev ? triplet.prev.body : null;
        const currentBody = triplet.current.body;
        const nextBody = triplet.next ? triplet.next.body : null;
        const prevNum = triplet.prev ? String((_h = triplet.prev.sceneNumber) != null ? _h : "N/A") : "N/A";
        const currentNum = String((_i = triplet.current.sceneNumber) != null ? _i : "N/A");
        const nextNum = triplet.next ? String((_j = triplet.next.sceneNumber) != null ? _j : "N/A") : "N/A";
        const contextPrompt = getActiveContextPrompt(plugin);
        const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt);
        const sceneNameForLog = triplet.current.file.basename;
        const runAi = createAiRunner(plugin, vault, callAiProvider);
        const aiResult = await runAi(userPrompt, subplotName, "processBySubplotOrder", sceneNameForLog);
        if (aiResult.result) {
          const parsedAnalysis = parseGptResult(aiResult.result, plugin);
          if (parsedAnalysis) {
            if (!triplet.prev) {
              parsedAnalysis["previousSceneAnalysis"] = "";
            }
            if (!triplet.next) {
              parsedAnalysis["nextSceneAnalysis"] = "";
            }
            const updated = await updateSceneAnalysis(vault, triplet.current.file, parsedAnalysis, plugin, aiResult.modelIdUsed);
            if (updated) {
              await plugin.saveSettings();
            } else {
            }
          } else {
          }
        } else {
        }
        totalProcessedCount++;
        notice.setMessage(`Progress: ${totalProcessedCount}/${totalTripletsAcrossSubplots} scenes processed...`);
        await new Promise((resolve) => window.setTimeout(resolve, 200));
      }
    }
    await plugin.saveSettings();
    notice.hide();
    new import_obsidian17.Notice(`Subplot order processing complete: ${totalProcessedCount}/${totalTripletsAcrossSubplots} triplets processed.`);
    plugin.refreshTimelineIfNeeded(null);
  } catch (error) {
    console.error("[API Beats][processBySubplotOrder] Error during processing:", error);
    notice.hide();
    new import_obsidian17.Notice("Error processing subplots. Check console for details.");
  }
}
async function processSubplotWithModal(plugin, vault, subplotName, modal) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    if (allScenes.length < 1) {
      throw new Error("No valid scenes found in the specified source path.");
    }
    const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
    if (filtered.length === 0) {
      throw new Error(`No scenes found for subplot "${subplotName}".`);
    }
    filtered.sort(compareScenesByOrder);
    const validScenes = filtered.filter((scene) => {
      var _a2, _b2, _c2;
      const beatsUpdate = ((_a2 = scene.frontmatter) == null ? void 0 : _a2.beatsupdate) || ((_b2 = scene.frontmatter) == null ? void 0 : _b2.BeatsUpdate) || ((_c2 = scene.frontmatter) == null ? void 0 : _c2["Beats Update"]);
      return hasProcessableContent(scene.frontmatter) && normalizeBooleanValue2(beatsUpdate);
    });
    if (validScenes.length === 0) {
      throw new Error(`No flagged scenes (Beats Update: Yes/True/1) with content found for "${subplotName}".`);
    }
    const triplets = [];
    const processableContentScenes = filtered.filter((scene) => hasProcessableContent(scene.frontmatter));
    const flaggedScenes = validScenes;
    for (const flaggedScene of flaggedScenes) {
      const idx = processableContentScenes.findIndex((s) => s.file.path === flaggedScene.file.path);
      const prev = idx > 0 ? processableContentScenes[idx - 1] : null;
      const next = idx >= 0 && idx < processableContentScenes.length - 1 ? processableContentScenes[idx + 1] : null;
      triplets.push({ prev, current: flaggedScene, next });
    }
    let processedCount = 0;
    const total = triplets.length;
    for (const triplet of triplets) {
      if (modal.isAborted()) {
        await plugin.saveSettings();
        throw new Error("Processing aborted by user");
      }
      const flag = ((_a = triplet.current.frontmatter) == null ? void 0 : _a.beatsupdate) || ((_b = triplet.current.frontmatter) == null ? void 0 : _b.BeatsUpdate) || ((_c = triplet.current.frontmatter) == null ? void 0 : _c["Beats Update"]);
      if (!normalizeBooleanValue2(flag)) continue;
      const currentPath = triplet.current.file.path;
      const tripletIdentifier = `subplot-${subplotName}-${(_e = (_d = triplet.prev) == null ? void 0 : _d.sceneNumber) != null ? _e : "Start"}-${triplet.current.sceneNumber}-${(_g = (_f = triplet.next) == null ? void 0 : _f.sceneNumber) != null ? _g : "End"}`;
      const sceneName = triplet.current.file.basename;
      modal.updateProgress(processedCount + 1, total, sceneName);
      const prevBody = triplet.prev ? triplet.prev.body : null;
      const currentBody = triplet.current.body;
      const nextBody = triplet.next ? triplet.next.body : null;
      const prevNum = triplet.prev ? String((_h = triplet.prev.sceneNumber) != null ? _h : "N/A") : "N/A";
      const currentNum = String((_i = triplet.current.sceneNumber) != null ? _i : "N/A");
      const nextNum = triplet.next ? String((_j = triplet.next.sceneNumber) != null ? _j : "N/A") : "N/A";
      if (modal && typeof modal.setTripletInfo === "function") {
        modal.setTripletInfo(prevNum, currentNum, nextNum);
      } else {
      }
      const contextPrompt = getActiveContextPrompt(plugin);
      const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt);
      const sceneNameForLog = triplet.current.file.basename;
      const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
      const runAi = createAiRunner(plugin, vault, callAiProvider);
      const aiResult = await runAi(userPrompt, subplotName, "processBySubplotOrder", sceneNameForLog, tripletForLog);
      if (aiResult.result) {
        const parsedAnalysis = parseGptResult(aiResult.result, plugin);
        if (parsedAnalysis) {
          if (!triplet.prev) {
            parsedAnalysis["previousSceneAnalysis"] = "";
          }
          if (!triplet.next) {
            parsedAnalysis["nextSceneAnalysis"] = "";
          }
          const success = await updateSceneFile(vault, triplet.current, parsedAnalysis, plugin, aiResult.modelIdUsed);
          if (success) {
            processedCount++;
          } else {
            modal.addError(`Failed to update file for scene ${triplet.current.sceneNumber}: ${currentPath}`);
          }
        } else {
          modal.addError(`Failed to parse AI response for scene ${triplet.current.sceneNumber}: ${currentPath}`);
        }
      } else {
        modal.addError(`AI processing failed for scene ${triplet.current.sceneNumber}: ${currentPath}`);
      }
    }
    await plugin.saveSettings();
  } catch (error) {
    throw error;
  }
}
async function processEntireSubplotWithModal(plugin, vault, subplotName, isResuming = false) {
  if (plugin.activeBeatsModal && plugin.activeBeatsModal.isProcessing) {
    plugin.activeBeatsModal.open();
    new import_obsidian17.Notice("Reopening active processing session...");
    return;
  }
  const getSceneCount = async () => {
    try {
      const allScenes = await getAllSceneData(plugin, vault);
      const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
      const validScenes = filtered.filter((scene) => hasProcessableContent(scene.frontmatter));
      if (isResuming) {
        const unprocessedToday = validScenes.filter(
          (scene) => !hasBeenProcessedForBeats(scene.frontmatter, { todayOnly: true })
        );
        return unprocessedToday.length;
      } else {
        return validScenes.length;
      }
    } catch (error) {
      return 0;
    }
  };
  const modal = new SceneAnalysisProcessingModal(
    plugin.app,
    plugin,
    getSceneCount,
    async () => {
      await processEntireSubplotWithModalInternal(plugin, vault, subplotName, modal, isResuming);
    },
    void 0,
    // no resumeCommandId for subplot processing
    subplotName,
    // pass subplot name for resume functionality
    true
    // isEntireSubplot = true
  );
  const originalOnOpen = modal.onOpen.bind(modal);
  modal.onOpen = function() {
    const { contentEl, titleEl } = this;
    titleEl.setText(`Processing entire subplot: ${subplotName}`);
    this.showProgressView();
    this.isProcessing = true;
    this.abortController = new AbortController();
    plugin.activeBeatsModal = this;
    plugin.showBeatsStatusBar(0, 0);
    (async () => {
      try {
        await processEntireSubplotWithModalInternal(plugin, vault, subplotName, modal, isResuming);
        if (this.abortController && this.abortController.signal.aborted) {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        } else {
          this.showCompletionSummary("Processing completed successfully!");
        }
      } catch (error) {
        if (!this.abortController.signal.aborted) {
          this.addError(`Fatal error: ${error instanceof Error ? error.message : String(error)}`);
          this.showCompletionSummary("Processing stopped due to error");
        } else {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        }
      } finally {
        this.isProcessing = false;
        this.abortController = null;
        plugin.activeBeatsModal = null;
        plugin.hideBeatsStatusBar();
      }
    })();
  };
  modal.open();
}
async function processEntireSubplotWithModalInternal(plugin, vault, subplotName, modal, isResuming = false) {
  var _a, _b, _c, _d, _e, _f, _g;
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    if (allScenes.length < 1) {
      throw new Error("No valid scenes found in the specified source path.");
    }
    const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
    if (filtered.length === 0) {
      throw new Error(`No scenes found for subplot "${subplotName}".`);
    }
    filtered.sort(compareScenesByOrder);
    const validScenes = filtered.filter((scene) => hasProcessableContent(scene.frontmatter));
    if (validScenes.length === 0) {
      throw new Error(`No scenes with processable content found for "${subplotName}".`);
    }
    const triplets = [];
    for (const currentScene of validScenes) {
      const currentIndex = validScenes.indexOf(currentScene);
      const prevScene = currentIndex > 0 ? validScenes[currentIndex - 1] : null;
      const nextScene = currentIndex < validScenes.length - 1 ? validScenes[currentIndex + 1] : null;
      triplets.push({
        prev: prevScene,
        current: currentScene,
        next: nextScene
      });
    }
    let total;
    if (isResuming) {
      total = triplets.filter((t) => !hasBeenProcessedForBeats(t.current.frontmatter, { todayOnly: true })).length;
    } else {
      total = triplets.length;
    }
    let processedCount = 0;
    for (const triplet of triplets) {
      if (modal.isAborted()) {
        await plugin.saveSettings();
        throw new Error("Processing aborted by user");
      }
      const currentPath = triplet.current.file.path;
      const tripletIdentifier = `entire-subplot-${subplotName}-${(_b = (_a = triplet.prev) == null ? void 0 : _a.sceneNumber) != null ? _b : "Start"}-${triplet.current.sceneNumber}-${(_d = (_c = triplet.next) == null ? void 0 : _c.sceneNumber) != null ? _d : "End"}`;
      if (isResuming) {
        if (hasBeenProcessedForBeats(triplet.current.frontmatter, { todayOnly: true })) {
          continue;
        }
      }
      const sceneName = triplet.current.file.basename;
      modal.updateProgress(processedCount + 1, total, sceneName);
      const prevBody = triplet.prev ? triplet.prev.body : null;
      const currentBody = triplet.current.body;
      const nextBody = triplet.next ? triplet.next.body : null;
      const prevNum = triplet.prev ? String((_e = triplet.prev.sceneNumber) != null ? _e : "N/A") : "N/A";
      const currentNum = String((_f = triplet.current.sceneNumber) != null ? _f : "N/A");
      const nextNum = triplet.next ? String((_g = triplet.next.sceneNumber) != null ? _g : "N/A") : "N/A";
      if (modal && typeof modal.setTripletInfo === "function") {
        modal.setTripletInfo(prevNum, currentNum, nextNum);
      } else {
      }
      const contextPrompt = getActiveContextPrompt(plugin);
      const userPrompt = buildSceneAnalysisPrompt(prevBody, currentBody, nextBody, prevNum, currentNum, nextNum, contextPrompt);
      const sceneNameForLog = triplet.current.file.basename;
      const tripletForLog = { prev: prevNum, current: currentNum, next: nextNum };
      const runAi = createAiRunner(plugin, vault, callAiProvider);
      const aiResult = await runAi(userPrompt, subplotName, "processEntireSubplot", sceneNameForLog, tripletForLog);
      if (aiResult.result) {
        const parsedAnalysis = parseGptResult(aiResult.result, plugin);
        if (parsedAnalysis) {
          if (!triplet.prev) {
            parsedAnalysis["previousSceneAnalysis"] = "";
          }
          if (!triplet.next) {
            parsedAnalysis["nextSceneAnalysis"] = "";
          }
          const success = await updateSceneFile(vault, triplet.current, parsedAnalysis, plugin, aiResult.modelIdUsed);
          if (success) {
            processedCount++;
          } else {
            modal.addError(`Failed to update file for scene ${triplet.current.sceneNumber}: ${currentPath}`);
          }
        } else {
          modal.addError(`Failed to parse AI response for scene ${triplet.current.sceneNumber}: ${currentPath}`);
        }
      } else {
        modal.addError(`AI processing failed for scene ${triplet.current.sceneNumber}: ${currentPath}`);
      }
    }
    await plugin.saveSettings();
  } catch (error) {
    throw error;
  }
}
async function processBySubplotNameWithModal(plugin, vault, subplotName) {
  if (plugin.activeBeatsModal && plugin.activeBeatsModal.isProcessing) {
    plugin.activeBeatsModal.open();
    new import_obsidian17.Notice("Reopening active processing session...");
    return;
  }
  const getSceneCount = async () => {
    try {
      const allScenes = await getAllSceneData(plugin, vault);
      const filtered = allScenes.filter((scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName));
      const validScenes = filtered.filter((scene) => {
        var _a, _b, _c;
        const beatsUpdate = ((_a = scene.frontmatter) == null ? void 0 : _a.beatsupdate) || ((_b = scene.frontmatter) == null ? void 0 : _b.BeatsUpdate) || ((_c = scene.frontmatter) == null ? void 0 : _c["Beats Update"]);
        return hasProcessableContent(scene.frontmatter) && normalizeBooleanValue2(beatsUpdate);
      });
      return validScenes.length;
    } catch (error) {
      return 0;
    }
  };
  const modal = new SceneAnalysisProcessingModal(
    plugin.app,
    plugin,
    getSceneCount,
    async () => {
      await processSubplotWithModal(plugin, vault, subplotName, modal);
    },
    void 0,
    // no resumeCommandId for subplot processing
    subplotName,
    // pass subplot name for resume functionality
    false
    // isEntireSubplot = false (flagged scenes only)
  );
  const originalOnOpen = modal.onOpen.bind(modal);
  modal.onOpen = function() {
    const { contentEl, titleEl } = this;
    titleEl.setText(`Processing subplot: ${subplotName}`);
    this.showProgressView();
    this.isProcessing = true;
    this.abortController = new AbortController();
    plugin.activeBeatsModal = this;
    plugin.showBeatsStatusBar(0, 0);
    (async () => {
      try {
        await processSubplotWithModal(plugin, vault, subplotName, modal);
        if (this.abortController && this.abortController.signal.aborted) {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        } else {
          this.showCompletionSummary("Processing completed successfully!");
        }
      } catch (error) {
        if (!this.abortController.signal.aborted) {
          this.addError(`Fatal error: ${error instanceof Error ? error.message : String(error)}`);
          this.showCompletionSummary("Processing stopped due to error");
        } else {
          this.showCompletionSummary("Processing aborted by user or rate limit");
        }
      } finally {
        this.isProcessing = false;
        this.abortController = null;
        plugin.activeBeatsModal = null;
        plugin.hideBeatsStatusBar();
      }
    })();
  };
  modal.open();
}
async function getDistinctSubplotNames(plugin, vault) {
  const scenes = await getAllSceneData(plugin, vault);
  const subplotCounts = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    const subplotList = getSubplotNamesFromFM(scene.frontmatter);
    subplotList.forEach((subplot) => {
      if (subplot) {
        subplotCounts.set(subplot, (subplotCounts.get(subplot) || 0) + 1);
      }
    });
  });
  const subplotArray = Array.from(subplotCounts.entries()).map(([subplot, count]) => ({
    subplot,
    count
  }));
  subplotArray.sort((a, b) => {
    if (a.subplot === "Main Plot" || !a.subplot) return -1;
    if (b.subplot === "Main Plot" || !b.subplot) return 1;
    if (a.count !== b.count) return b.count - a.count;
    return a.subplot.localeCompare(b.subplot);
  });
  return subplotArray.map((item) => item.subplot);
}
async function testYamlUpdateFormatting(plugin, vault) {
  var _a, _b, _c;
  const dummyFilePath = "AITestDummyScene.md";
  const dummyBody = "This is the body text of the dummy scene.\nIt has multiple lines.";
  const dummyInitialFrontmatter = {
    Class: "Scene",
    Synopsis: "Dummy synopsis for testing YAML update.",
    Subplot: ["Test Arc"],
    When: "2024-01-01",
    Words: 10,
    "Beats Update": "Yes"
  };
  new import_obsidian17.Notice(`Starting YAML update test on ${dummyFilePath}...`);
  try {
    let file = vault.getAbstractFileByPath(dummyFilePath);
    if (!(file instanceof import_obsidian17.TFile)) {
      new import_obsidian17.Notice(`Creating dummy file: ${dummyFilePath}`);
      const initialContent = `---
${(0, import_obsidian17.stringifyYaml)(dummyInitialFrontmatter)}---
${dummyBody}`;
      await vault.create(dummyFilePath, initialContent);
      file = vault.getAbstractFileByPath(dummyFilePath);
    }
    if (!(file instanceof import_obsidian17.TFile)) {
      new import_obsidian17.Notice(`Error: Could not get TFile for ${dummyFilePath}`);
      return;
    }
    const currentContent = await vault.read(file);
    const fmInfo = (0, import_obsidian17.getFrontMatterInfo)(currentContent);
    if (!fmInfo || !fmInfo.exists) {
      new import_obsidian17.Notice(`Error: Dummy file ${dummyFilePath} is missing frontmatter.`);
      return;
    }
    const fmText = (_a = fmInfo.frontmatter) != null ? _a : "";
    const currentFrontmatter = fmText ? (0, import_obsidian17.parseYaml)(fmText) || {} : {};
    let currentBody = currentContent;
    const endOffset = (_c = (_b = fmInfo.position) == null ? void 0 : _b.end) == null ? void 0 : _c.offset;
    if (typeof endOffset === "number" && endOffset >= 0 && endOffset <= currentContent.length) {
      currentBody = currentContent.slice(endOffset).trim();
    } else {
      currentBody = currentContent.replace(/^---[\s\S]*?\n---/, "").trim();
    }
    const dummySceneData = {
      file,
      frontmatter: currentFrontmatter,
      sceneNumber: 999,
      body: currentBody
    };
    const parsedAnalysis = parseGptResult(DUMMY_API_RESPONSE, plugin);
    if (!parsedAnalysis) {
      new import_obsidian17.Notice("Error: Failed to parse dummy API response data.");
      return;
    }
    const success = await updateSceneFile(vault, dummySceneData, parsedAnalysis, plugin, null);
    if (success) {
      new import_obsidian17.Notice(`Successfully updated YAML in ${dummyFilePath}. Please check the file formatting.`);
    } else {
      new import_obsidian17.Notice(`Failed to update YAML in ${dummyFilePath}. Check console for errors.`);
    }
  } catch (error) {
    console.error("Error during YAML update test:", error);
    new import_obsidian17.Notice("Error during YAML update test. Check console.");
  }
}
async function createTemplateScene(plugin, vault) {
  try {
    const today = /* @__PURE__ */ new Date();
    const isoDate = today.toISOString().slice(0, 10);
    const folderPath = sanitizeSourcePath(plugin.settings.sourcePath);
    if (folderPath) {
      const f = vault.getAbstractFileByPath(folderPath);
      if (!f) {
        await vault.createFolder(folderPath);
      }
    }
    let sceneNumber = 1;
    let targetPath = buildInitialSceneFilename(folderPath, `${sceneNumber} Template Scene.md`);
    while (vault.getAbstractFileByPath(targetPath)) {
      sceneNumber++;
      targetPath = buildInitialSceneFilename(folderPath, `${sceneNumber} Template Scene.md`);
    }
    const frontmatter = {
      Class: "Scene",
      Act: 1,
      When: isoDate,
      Duration: "2 hours",
      Synopsis: "Write a one-sentence summary of this scene.",
      Status: "Todo",
      Subplot: ["Main Plot", "Romance Arc"],
      Character: ["Protagonist", "Mentor"],
      Place: "",
      Due: isoDate,
      "Publish Stage": "Zero",
      Revision: 0,
      "Pending Edits": "",
      Words: 0,
      Book: "",
      "Beats Update": ""
    };
    const body = "\nWrite your scene here. Fill in Character and Subplot fields as needed. Use array format for multiple items.";
    const content = `---
${(0, import_obsidian17.stringifyYaml)(frontmatter)}---
${body}
`;
    await vault.create(targetPath, content);
    new import_obsidian17.Notice(`Created template scene: ${targetPath}`);
    await openOrRevealFileByPath(plugin.app, targetPath, false);
  } catch (e) {
    console.error("[createTemplateScene] Failed:", e);
    new import_obsidian17.Notice("Failed to create template scene. Check console for details.");
  }
}
async function purgeScenesBeats(plugin, vault, scenes) {
  let purgedCount = 0;
  for (const scene of scenes) {
    try {
      await plugin.app.fileManager.processFrontMatter(scene.file, (fm) => {
        const fmObj = fm;
        const hadPreviousAnalysis = fmObj["previousSceneAnalysis"] !== void 0;
        const hadCurrentAnalysis = fmObj["currentSceneAnalysis"] !== void 0;
        const hadNextAnalysis = fmObj["nextSceneAnalysis"] !== void 0;
        const hadBeatsLastUpdated = fmObj["Beats Last Updated"] !== void 0;
        delete fmObj["previousSceneAnalysis"];
        delete fmObj["currentSceneAnalysis"];
        delete fmObj["nextSceneAnalysis"];
        delete fmObj["Beats Last Updated"];
        if (hadPreviousAnalysis || hadCurrentAnalysis || hadNextAnalysis || hadBeatsLastUpdated) {
          purgedCount++;
        }
      });
    } catch (error) {
      console.error(`[purgeScenesBeats] Error purging beats from ${scene.file.path}:`, error);
    }
  }
  return purgedCount;
}
async function purgeBeatsByManuscriptOrder(plugin, vault) {
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    if (allScenes.length === 0) {
      new import_obsidian17.Notice("No scenes found in manuscript.");
      return;
    }
    const modal = new PurgeConfirmationModal(
      plugin.app,
      `Purge ALL beats from ${allScenes.length} scene${allScenes.length !== 1 ? "s" : ""} in your manuscript?`,
      [
        "previousSceneAnalysis, currentSceneAnalysis, nextSceneAnalysis fields",
        "Beats Last Updated timestamps"
      ],
      async () => {
        const notice = new import_obsidian17.Notice("Purging beats from all scenes...", 0);
        const purgedCount = await purgeScenesBeats(plugin, vault, allScenes);
        notice.hide();
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        new import_obsidian17.Notice(`Purged beats from ${purgedCount} of ${allScenes.length} scene${allScenes.length !== 1 ? "s" : ""}.`);
      }
    );
    modal.open();
  } catch (error) {
    console.error("[purgeBeatsByManuscriptOrder] Error:", error);
    new import_obsidian17.Notice("Error purging beats. Check console for details.");
  }
}
async function purgeBeatsBySubplotName(plugin, vault, subplotName) {
  try {
    const allScenes = await getAllSceneData(plugin, vault);
    const filtered = allScenes.filter(
      (scene) => getSubplotNamesFromFM(scene.frontmatter).includes(subplotName)
    );
    if (filtered.length === 0) {
      new import_obsidian17.Notice(`No scenes found for subplot "${subplotName}".`);
      return;
    }
    const modal = new PurgeConfirmationModal(
      plugin.app,
      `Purge beats from ${filtered.length} scene${filtered.length !== 1 ? "s" : ""} in subplot "${subplotName}"?`,
      [
        "previousSceneAnalysis, currentSceneAnalysis, nextSceneAnalysis fields",
        "Beats Last Updated timestamps"
      ],
      async () => {
        const notice = new import_obsidian17.Notice(`Purging beats from "${subplotName}"...`, 0);
        const purgedCount = await purgeScenesBeats(plugin, vault, filtered);
        notice.hide();
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        new import_obsidian17.Notice(`Purged beats from ${purgedCount} of ${filtered.length} scene${filtered.length !== 1 ? "s" : ""} in subplot "${subplotName}".`);
      }
    );
    modal.open();
  } catch (error) {
    console.error(`[purgeBeatsBySubplotName] Error purging subplot "${subplotName}":`, error);
    new import_obsidian17.Notice(`Error purging beats from "${subplotName}". Check console for details.`);
  }
}
var import_obsidian17, DUMMY_API_RESPONSE, PurgeConfirmationModal;
var init_SceneAnalysisCommands = __esm({
  "src/SceneAnalysisCommands.ts"() {
    import_obsidian17 = require("obsidian");
    init_sceneCreation();
    init_anthropicApi();
    init_openaiApi();
    init_SceneAnalysisProcessingModal();
    init_geminiApi();
    init_sceneAnalysis();
    init_text();
    init_frontmatter();
    init_fileUtils();
    init_TripletBuilder();
    init_FileUpdater();
    init_RequestRunner();
    DUMMY_API_RESPONSE = `previousSceneAnalysis:
 - 33.2 Trisan Inner Turmoil - / Lacks clarity
 - Chae Ban Hesitation ? / Uncertain decision
 - Entiat Reflection ? / Needs clearer link: should explore motive
 - Chae Ban Plan + / Strengthens connection to currentSceneAnalysis choices
 - Meeting Entiat + / Sets up tension
currentSceneAnalysis:
 - 33.5 B / Scene will be stronger by making Entiat motivations clearer. Clarify: imminent threat
 - Entiat Adoption Reflections ? / Lacks tension link to events in previousSceneAnalysis
 - Chae Ban Escape News + / Advances plot
 - Entiat Internal Conflict + / Highlights dilemma: how to handle the situation from previousSceneAnalysis
 - Connection to nextSceneAnalysis + / Sets up the coming conflict
nextSceneAnalysis:
 - 34 Teco Routine Disruption - / Needs purpose
 - Entiat Unexpected Visit ? / Confusing motivation: clarify intention here
 - Sasha Defense and Defeat + / Builds on tension from currentSceneAnalysis
 - Teco Escape Decision + / Strong transition
 - Final Choice + / Resolves arc started in previousSceneAnalysis`;
    PurgeConfirmationModal = class extends import_obsidian17.Modal {
      constructor(app, message, details, onConfirm) {
        super(app);
        this.message = message;
        this.details = details;
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl, titleEl } = this;
        titleEl.setText("Confirm purge beats");
        const messageEl = contentEl.createDiv({ cls: "rt-purge-message" });
        messageEl.setText(this.message);
        const detailsEl = contentEl.createDiv({ cls: "rt-purge-details" });
        detailsEl.createEl("strong", { text: "This will permanently delete:" });
        const listEl = detailsEl.createEl("ul");
        this.details.forEach((detail) => {
          listEl.createEl("li", { text: detail });
        });
        const warningEl = contentEl.createDiv({ cls: "rt-purge-warning" });
        warningEl.createEl("strong", { text: "This cannot be undone. Continue?" });
        const buttonRow = contentEl.createDiv({ cls: "rt-beats-actions" });
        new import_obsidian17.ButtonComponent(buttonRow).setButtonText("Purge beats").setWarning().onClick(() => {
          this.close();
          this.onConfirm();
        });
        new import_obsidian17.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
      }
    };
  }
});

// src/services/SearchService.ts
var SearchService_exports = {};
__export(SearchService_exports, {
  SearchService: () => SearchService
});
var import_obsidian42, SearchService;
var init_SearchService = __esm({
  "src/services/SearchService.ts"() {
    import_obsidian42 = require("obsidian");
    SearchService = class {
      constructor(app, plugin) {
        this.app = app;
        this.plugin = plugin;
      }
      openSearchPrompt() {
        const modal = new import_obsidian42.Modal(this.app);
        modal.titleEl.setText("Search timeline");
        const contentEl = modal.contentEl;
        contentEl.empty();
        const searchContainer = contentEl.createDiv("search-container");
        searchContainer.classList.add("flex-container");
        searchContainer.classList.add("radial-timeline-search");
        const searchInput = new import_obsidian42.TextComponent(searchContainer);
        searchInput.setPlaceholder("Enter search term (min 3 letters)");
        searchInput.inputEl.classList.add("search-input");
        if (this.plugin.searchActive && this.plugin.searchTerm) searchInput.setValue(this.plugin.searchTerm);
        const buttonContainer = contentEl.createDiv("rt-button-container");
        new import_obsidian42.ButtonComponent(buttonContainer).setButtonText("Search").onClick(() => {
          const term = searchInput.getValue().trim();
          if (term.length >= 3) {
            this.performSearch(term);
            modal.close();
          } else {
            new import_obsidian42.Notice("Please enter at least 3 letters to search");
          }
        });
        new import_obsidian42.ButtonComponent(buttonContainer).setButtonText("Reset").onClick(() => {
          searchInput.setValue("");
          this.clearSearch();
          modal.close();
        });
        this.plugin.registerDomEvent(searchInput.inputEl, "keydown", (e) => {
          if (e.key === "Enter") {
            const term = searchInput.getValue().trim();
            if (term.length >= 3) {
              this.performSearch(term);
              modal.close();
            } else {
              new import_obsidian42.Notice("Please enter at least 3 letters to search");
            }
          }
        });
        modal.open();
      }
      performSearch(term) {
        if (!term || term.trim().length === 0) {
          this.clearSearch();
          return;
        }
        this.plugin.searchTerm = term;
        this.plugin.searchActive = true;
        this.plugin.searchResults.clear();
        const containsWholePhrase = (haystack, phrase, isDate = false) => {
          if (!haystack || !phrase || typeof haystack !== "string") return false;
          const h = haystack.toLowerCase();
          const p = phrase.toLowerCase();
          if (isDate && h.includes("/")) {
            const datePattern = new RegExp(p.replace(/\//g, "\\/") + "(?:\\/|$)", "i");
            return datePattern.test(h);
          }
          return h.includes(p);
        };
        const formatDateForDisplay = (when) => {
          if (!when || !(when instanceof Date)) return "";
          try {
            const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
            const month = months[when.getMonth()];
            const day = when.getDate();
            const year = when.getFullYear();
            const hours = when.getHours();
            const minutes = when.getMinutes();
            let dateStr = `${month} ${day}, ${year}`;
            if (hours === 0 && minutes === 0) {
              dateStr += ` @ Midnight`;
            } else if (hours === 12 && minutes === 0) {
              dateStr += ` @ Noon`;
            } else {
              const period = hours >= 12 ? "PM" : "AM";
              const displayHours = hours % 12 === 0 ? 12 : hours % 12;
              if (minutes === 0) {
                dateStr += ` @ ${displayHours}${period}`;
              } else {
                dateStr += ` @ ${displayHours}:${String(minutes).padStart(2, "0")}${period}`;
              }
            }
            return dateStr;
          } catch (e) {
            return "";
          }
        };
        this.plugin.getSceneData().then((scenes) => {
          scenes.forEach((scene) => {
            var _a;
            const povText = scene.pov ? String(scene.pov) : "";
            const textFields = [
              scene.title,
              scene.synopsis,
              ...scene.Character || [],
              scene.subplot,
              scene.location,
              povText,
              scene.Duration
            ];
            const textMatched = textFields.some((f) => containsWholePhrase(f, term, false));
            const dateFieldNumeric = (_a = scene.when) == null ? void 0 : _a.toLocaleDateString();
            const dateFieldDisplay = formatDateForDisplay(scene.when);
            const dateMatched = containsWholePhrase(dateFieldNumeric, term, true) || containsWholePhrase(dateFieldDisplay, term, false);
            if (textMatched || dateMatched) {
              if (scene.path) this.plugin.searchResults.add(scene.path);
            }
          });
          const timelineViews = this.plugin.getTimelineViews();
          timelineViews.forEach((view) => view.refreshTimeline());
        });
      }
      clearSearch() {
        this.plugin.searchActive = false;
        this.plugin.searchTerm = "";
        this.plugin.searchResults.clear();
        const timelineViews = this.plugin.getTimelineViews();
        timelineViews.forEach((view) => view.refreshTimeline());
      }
    };
  }
});

// src/services/FileTrackingService.ts
var FileTrackingService_exports = {};
__export(FileTrackingService_exports, {
  FileTrackingService: () => FileTrackingService
});
var import_obsidian43, FileTrackingService;
var init_FileTrackingService = __esm({
  "src/services/FileTrackingService.ts"() {
    import_obsidian43 = require("obsidian");
    FileTrackingService = class {
      constructor(plugin) {
        this.plugin = plugin;
      }
      updateOpenFilesTracking() {
        const previousOpenFiles = new Set(this.plugin.openScenePaths);
        const openFilePaths = /* @__PURE__ */ new Set();
        const openFilesList = [];
        const leaves = this.plugin.app.workspace.getLeavesOfType("markdown");
        leaves.forEach((leaf) => {
          const view = leaf.view;
          if (view instanceof import_obsidian43.MarkdownView && view.file) {
            openFilePaths.add(view.file.path);
            openFilesList.push(view.file.path);
          }
        });
        const activeFile = this.plugin.app.workspace.getActiveFile();
        if (activeFile && !openFilesList.includes(activeFile.path)) {
          openFilePaths.add(activeFile.path);
          openFilesList.push(activeFile.path);
        }
        try {
          const layout = this.plugin.app.workspace.getLayout();
          if (layout && layout.leaves) {
            const leafIds = Object.keys(layout.leaves);
            leafIds.forEach((id) => {
              const leafData = layout.leaves[id];
              if (leafData && leafData.type === "markdown" && leafData.state && leafData.state.file) {
                const filePath = leafData.state.file;
                if (!openFilesList.includes(filePath)) {
                  openFilePaths.add(filePath);
                  openFilesList.push(filePath);
                }
              }
            });
          }
        } catch (error) {
          console.error("[Radial Timeline] Error accessing workspace layout:", error);
        }
        let hasChanged = previousOpenFiles.size !== openFilePaths.size;
        if (!hasChanged) {
          for (const path of openFilePaths) {
            if (!previousOpenFiles.has(path)) {
              hasChanged = true;
              break;
            }
          }
        }
        if (!hasChanged) return;
        this.plugin.openScenePaths = openFilePaths;
        this.plugin.getTimelineViews().forEach((v) => v.refreshTimeline());
      }
      registerWorkspaceListeners() {
        this.plugin.app.workspace.onLayoutReady(() => {
          this.plugin.setCSSColorVariables();
          this.updateOpenFilesTracking();
        });
        this.plugin.registerEvent(this.plugin.app.workspace.on("layout-change", () => {
          this.updateOpenFilesTracking();
          this.plugin.refreshTimelineIfNeeded(null);
        }));
        this.plugin.registerEvent(this.plugin.app.vault.on("delete", (file) => this.plugin.refreshTimelineIfNeeded(file)));
        this.plugin.registerEvent(this.plugin.app.vault.on("rename", (file, oldPath) => this.handleFileRename(file, oldPath)));
        this.plugin.registerEvent(this.plugin.app.workspace.on("css-change", () => {
          this.plugin.setCSSColorVariables();
          try {
            const views = this.plugin.getTimelineViews();
            views.forEach((v) => {
              var _a, _b;
              const svg = (_b = (_a = v == null ? void 0 : v.containerEl) == null ? void 0 : _a.querySelector) == null ? void 0 : _b.call(_a, ".radial-timeline-svg");
              if (svg) {
                this.plugin.getRendererService().updateProgressAndTicks(v);
                if (v.currentMode === "gossamer") {
                  this.plugin.getRendererService().updateGossamerLayer(v);
                }
              }
            });
          } catch (e) {
            this.plugin.refreshTimelineIfNeeded(null);
          }
        }));
      }
      handleFileRename(file, oldPath) {
        if (this.plugin.openScenePaths.has(oldPath)) {
          this.plugin.openScenePaths.delete(oldPath);
          if (file instanceof import_obsidian43.TFile && this.plugin.isSceneFile(file.path)) {
            this.plugin.openScenePaths.add(file.path);
          }
        }
        this.plugin.refreshTimelineIfNeeded(file);
      }
    };
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  DEFAULT_SETTINGS: () => DEFAULT_SETTINGS,
  TIMELINE_VIEW_TYPE: () => TIMELINE_VIEW_TYPE2,
  default: () => RadialTimelinePlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian44 = require("obsidian");

// src/services/TimelineService.ts
var import_obsidian19 = require("obsidian");

// src/view/TimeLineView.ts
var import_obsidian18 = require("obsidian");

// src/utils/svgDom.ts
function renderSvgFromString(svgContent, container, registerCleanup = () => {
}) {
  try {
    const svgElement = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const parser = new DOMParser();
    const svgDoc = parser.parseFromString(svgContent, "image/svg+xml");
    const parserError = svgDoc.querySelector("parsererror");
    if (parserError) {
      console.error("Error parsing SVG content:", parserError.textContent);
      const fallbackDoc = new DOMParser().parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${svgContent}</svg>`, "image/svg+xml");
      if (!fallbackDoc.querySelector("parsererror")) {
        const fallbackSvg = fallbackDoc.documentElement;
        while (fallbackSvg.firstChild) {
          svgElement.appendChild(fallbackSvg.firstChild);
        }
        setCriticalAttributes(svgElement, fallbackSvg.getAttribute("viewBox"));
        container.appendChild(wrapInFragment(svgElement));
        return svgElement;
      }
      return null;
    }
    const sourceSvg = svgDoc.documentElement;
    copyAttributes(sourceSvg, svgElement);
    setCriticalAttributes(svgElement, sourceSvg.getAttribute("viewBox"));
    while (sourceSvg.firstChild) {
      svgElement.appendChild(sourceSvg.firstChild);
    }
    container.appendChild(wrapInFragment(svgElement));
    return svgElement;
  } catch (error) {
    console.error("Error creating SVG element:", error);
    return buildFallbackSvg(svgContent, container, registerCleanup);
  }
}
function wrapInFragment(node) {
  const fragment = document.createDocumentFragment();
  fragment.appendChild(node);
  return fragment;
}
function copyAttributes(source, target) {
  Array.from(source.attributes).forEach((attr) => {
    if (attr.name !== "xmlns" && attr.name !== "class") {
      target.setAttribute(attr.name, attr.value);
    }
  });
  target.classList.add(...Array.from(source.classList));
}
function setCriticalAttributes(svgElement, viewBox) {
  svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  svgElement.setAttribute("width", "100%");
  svgElement.setAttribute("height", "100%");
  svgElement.setAttribute("viewBox", viewBox || "-800 -800 1600 1600");
  svgElement.setAttribute("preserveAspectRatio", "xMidYMid meet");
  svgElement.setAttribute("class", "radial-timeline-svg");
}
function buildFallbackSvg(svgContent, container, registerCleanup) {
  try {
    const fallbackSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    setCriticalAttributes(fallbackSvg, null);
    const svgBodyMatch = svgContent.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    if (svgBodyMatch && svgBodyMatch[1]) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${svgBodyMatch[1]}</svg>`, "image/svg+xml");
      if (!doc.querySelector("parsererror")) {
        const svgDoc = doc.documentElement;
        const elementNodes = Array.from(svgDoc.querySelectorAll("*"));
        let pendingRaf = null;
        const processNodes = (nodes, startIdx, callback) => {
          const CHUNK_SIZE = 100;
          const endIdx = Math.min(startIdx + CHUNK_SIZE, nodes.length);
          for (let i = startIdx; i < endIdx; i++) {
            const element = nodes[i];
            const newElement = document.createElementNS("http://www.w3.org/2000/svg", element.tagName.toLowerCase());
            Array.from(element.attributes).forEach((attr) => newElement.setAttribute(attr.name, attr.value));
            newElement.textContent = element.textContent;
            fallbackSvg.appendChild(newElement);
          }
          if (endIdx < nodes.length) {
            pendingRaf = window.requestAnimationFrame(() => {
              pendingRaf = null;
              processNodes(nodes, endIdx, callback);
            });
          } else {
            callback();
          }
        };
        if (elementNodes.length > 100) {
          const loadingText = document.createElementNS("http://www.w3.org/2000/svg", "text");
          loadingText.setAttribute("x", "0");
          loadingText.setAttribute("y", "0");
          loadingText.setAttribute("class", "loading-message");
          loadingText.setAttribute("font-size", "24");
          loadingText.setAttribute("text-anchor", "middle");
          loadingText.textContent = "Loading timeline...";
          fallbackSvg.appendChild(loadingText);
          container.appendChild(wrapInFragment(fallbackSvg));
          registerCleanup(() => {
            if (pendingRaf !== null) {
              cancelAnimationFrame(pendingRaf);
              pendingRaf = null;
            }
          });
          processNodes(elementNodes, 0, () => {
            loadingText.remove();
          });
        } else {
          elementNodes.forEach((element) => {
            const newElement = document.createElementNS("http://www.w3.org/2000/svg", element.tagName.toLowerCase());
            Array.from(element.attributes).forEach((attr) => newElement.setAttribute(attr.name, attr.value));
            newElement.textContent = element.textContent;
            fallbackSvg.appendChild(newElement);
          });
          container.appendChild(wrapInFragment(fallbackSvg));
        }
        return fallbackSvg;
      }
    }
    container.appendChild(wrapInFragment(fallbackSvg));
    return fallbackSvg;
  } catch (innerError) {
    console.error("All SVG parsing approaches failed:", innerError);
    return null;
  }
}

// src/view/interactions/RotationController.ts
function setupRotationController(view, svg) {
  const rotatable = svg.querySelector("#timeline-rotatable");
  const toggle = svg.querySelector("#rotation-toggle");
  const arrowUp = svg.querySelector("#rotation-arrow-up");
  const arrowDown = svg.querySelector("#rotation-arrow-down");
  if (!rotatable || !toggle || !arrowUp || !arrowDown) {
    return;
  }
  let rotated = view.getRotationState();
  const applyRotation = () => {
    if (rotated) {
      rotatable.setAttribute("transform", "rotate(-120)");
      arrowUp.classList.add("is-hidden");
      arrowDown.classList.remove("is-hidden");
    } else {
      rotatable.removeAttribute("transform");
      arrowUp.classList.remove("is-hidden");
      arrowDown.classList.add("is-hidden");
    }
    svg.setAttribute("data-rotated", rotated ? "true" : "false");
    view.applyRotationToNumberSquares(svg, rotated);
    const counterSelectors = [
      ".color-key-center",
      ".estimated-date-tick",
      ".estimated-date-dot",
      ".target-date-tick",
      ".target-date-marker",
      ".estimation-date-label",
      ".target-date-tick",
      ".target-date-marker"
    ];
    counterSelectors.forEach((sel) => {
      const nodes = svg.querySelectorAll(sel);
      nodes.forEach((node) => {
        const el = node;
        if (!el.closest("#timeline-rotatable")) return;
        const t = el.getAttribute("transform") || "";
        const base = t.replace(/\s*rotate\([^)]*\)/g, "").trim();
        if (rotated) {
          el.setAttribute("transform", `${base} rotate(120)`.trim());
        } else {
          el.setAttribute("transform", base);
        }
      });
    });
  };
  applyRotation();
  const clickHandler = (e) => {
    e.stopPropagation();
    if (view.currentMode === "gossamer") {
      return;
    }
    rotated = !rotated;
    view.setRotationState(rotated);
    applyRotation();
  };
  view.registerDomEvent(toggle, "click", clickHandler);
}

// src/view/interactions/SearchInteractions.ts
init_regex();
function setupSearchControls(view) {
  const clearSearchBtn = view.contentEl.querySelector(".rt-clear-search-btn");
  if (clearSearchBtn) {
    view.registerDomEvent(clearSearchBtn, "click", () => {
      view.plugin.clearSearch();
    });
  }
}
function addHighlightRectangles(view) {
  if (!view.plugin.searchActive) return;
  const searchTerm = view.plugin.searchTerm;
  const escapedPattern = escapeRegExp(searchTerm);
  const svg = view.contentEl.querySelector(".radial-timeline-svg");
  const highlightTspan = (tspan, originalText, fillColor) => {
    while (tspan.firstChild) tspan.removeChild(tspan.firstChild);
    const regex = new RegExp(`(${escapedPattern})`, "gi");
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(originalText)) !== null) {
      if (match.index > lastIndex) {
        tspan.appendChild(document.createTextNode(originalText.substring(lastIndex, match.index)));
      }
      const highlightSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      highlightSpan.setAttribute("class", "rt-search-term");
      if (fillColor) highlightSpan.setAttribute("fill", fillColor);
      highlightSpan.textContent = match[0];
      tspan.appendChild(highlightSpan);
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < originalText.length) {
      tspan.appendChild(document.createTextNode(originalText.substring(lastIndex)));
    }
  };
  view.contentEl.querySelectorAll('tspan[data-item-type="subplot"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="character"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="title"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.style.getPropertyValue("--rt-dynamic-color") || null;
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="date"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll('tspan[data-item-type="duration"]').forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  view.contentEl.querySelectorAll("svg .rt-synopsis-text text").forEach((textEl) => {
    if (textEl.querySelector("tspan")) return;
    const originalText = textEl.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = textEl.getAttribute("fill");
    while (textEl.firstChild) textEl.removeChild(textEl.firstChild);
    const regex = new RegExp(`(${escapedPattern})`, "gi");
    let lastIndex = 0;
    let match;
    while ((match = regex.exec(originalText)) !== null) {
      if (match.index > lastIndex) {
        textEl.appendChild(document.createTextNode(originalText.substring(lastIndex, match.index)));
      }
      const highlightSpan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      highlightSpan.setAttribute("class", "rt-search-term");
      if (fillColor) highlightSpan.setAttribute("fill", fillColor);
      highlightSpan.textContent = match[0];
      textEl.appendChild(highlightSpan);
      lastIndex = match.index + match[0].length;
    }
    if (lastIndex < originalText.length) {
      textEl.appendChild(document.createTextNode(originalText.substring(lastIndex)));
    }
  });
  view.contentEl.querySelectorAll("svg .rt-synopsis-text text tspan:not([data-item-type])").forEach((tspan) => {
    const originalText = tspan.textContent || "";
    if (!originalText || !originalText.match(new RegExp(escapedPattern, "i"))) return;
    const fillColor = tspan.getAttribute("fill");
    highlightTspan(tspan, originalText, fillColor);
  });
  if (!svg) {
    return;
  }
  const allSceneGroups = svg.querySelectorAll(".rt-scene-group");
  allSceneGroups.forEach((group) => {
    const pathAttr = group.getAttribute("data-path");
    if (!pathAttr) return;
    if (!view.plugin.searchResults.has(decodeURIComponent(pathAttr))) return;
    const scenePath = group.querySelector(".rt-scene-path");
    const sceneId = scenePath == null ? void 0 : scenePath.id;
    if (!sceneId) return;
    const numberSquare = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
    const numberText = svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
    if (numberSquare) numberSquare.classList.add("rt-search-result");
    if (numberText) numberText.classList.add("rt-search-result");
  });
}

// src/view/interactions/ModeToggleController.ts
init_GossamerCommands();
init_ModeRegistry();
init_LayoutConstants();
function buildModeOptions() {
  return getToggleableModes().map((mode) => ({
    id: mode.id,
    label: mode.name,
    acronym: mode.ui.acronym || mode.name.substring(0, 4).toUpperCase(),
    order: mode.ui.order
  }));
}
var MODE_OPTIONS = buildModeOptions();
var ICON_BASE_WIDTH = 92;
var ICON_BASE_HEIGHT = 126;
var INACTIVE_VISUAL_WIDTH = 46;
var ACTIVE_VISUAL_WIDTH = 55;
var INACTIVE_SCALE = INACTIVE_VISUAL_WIDTH / ICON_BASE_WIDTH;
var ACTIVE_SCALE = ACTIVE_VISUAL_WIDTH / ICON_BASE_WIDTH;
var INACTIVE_VISUAL_HEIGHT = ICON_BASE_HEIGHT * INACTIVE_SCALE;
var ACTIVE_VISUAL_HEIGHT = ICON_BASE_HEIGHT * ACTIVE_SCALE;
var ICON_VISUAL_GAP_INACTIVE = 4;
var ICON_VISUAL_GAP_ACTIVE = 15;
function scalePath(pathData, scale) {
  return pathData.replace(/([-\d.]+)/g, (match) => {
    const num = parseFloat(match);
    return isNaN(num) ? match : String(num * scale);
  });
}
var ORIGINAL_DOCUMENT_PATH = "M0.0740741 108.5C0.0740711 118 3.35321 126 18.8532 126H74.3532C85.9532 126 91.0013 112.5 91.0741 105C91.2407 87.8333 91.0741 55.2111 91.0741 48C91.0741 43 87.8224 33.4634 74.3532 17.5C60.8532 1.5 49.8532 0 46.0741 0H17.0741C4.85322 0 0.12237 9 0.0740749 17.5C-0.0925918 46.8333 0.0740765 100.49 0.0740741 108.5Z";
function createInactiveDocumentShape() {
  return scalePath(ORIGINAL_DOCUMENT_PATH, INACTIVE_SCALE);
}
function createActiveDocumentShape() {
  return scalePath(ORIGINAL_DOCUMENT_PATH, ACTIVE_SCALE);
}
function createModeSelectorGrid(view) {
  const grid = document.createElementNS("http://www.w3.org/2000/svg", "g");
  grid.setAttribute("class", "rt-mode-selector-grid");
  grid.setAttribute("id", "mode-selector");
  const spacePerIcon = INACTIVE_VISUAL_WIDTH + ICON_VISUAL_GAP_INACTIVE;
  const totalWidth = MODE_OPTIONS.length * INACTIVE_VISUAL_WIDTH + (MODE_OPTIONS.length - 1) * ICON_VISUAL_GAP_INACTIVE;
  const startX = MODE_SELECTOR_POS_X - totalWidth / 2 + INACTIVE_VISUAL_WIDTH / 2;
  MODE_OPTIONS.forEach((mode, index) => {
    const x = startX + index * spacePerIcon;
    const optionGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    optionGroup.setAttribute("class", "rt-mode-option");
    optionGroup.setAttribute("data-mode", mode.id);
    optionGroup.setAttribute("transform", `translate(${x}, ${MODE_SELECTOR_POS_Y})`);
    const innerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
    innerGroup.setAttribute("class", "rt-mode-option-content");
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("class", "rt-document-bg");
    path.setAttribute("d", createInactiveDocumentShape());
    const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
    text.setAttribute("class", "rt-mode-acronym-text");
    text.setAttribute("x", String(ICON_BASE_WIDTH / 2 * INACTIVE_SCALE));
    text.setAttribute("y", String((ICON_BASE_HEIGHT - 16) * INACTIVE_SCALE));
    text.setAttribute("text-anchor", "middle");
    text.setAttribute("dominant-baseline", "middle");
    text.textContent = mode.acronym;
    const numberLabel = document.createElementNS("http://www.w3.org/2000/svg", "text");
    numberLabel.setAttribute("class", "rt-mode-number-label");
    numberLabel.setAttribute("x", String(12 * INACTIVE_SCALE));
    numberLabel.setAttribute("y", String(20 * INACTIVE_SCALE));
    numberLabel.setAttribute("text-anchor", "start");
    numberLabel.setAttribute("dominant-baseline", "middle");
    numberLabel.textContent = String(index + 1);
    innerGroup.appendChild(path);
    innerGroup.appendChild(text);
    innerGroup.appendChild(numberLabel);
    optionGroup.appendChild(innerGroup);
    grid.appendChild(optionGroup);
  });
  const sourcePath = view.plugin.settings.sourcePath || "";
  let bookTitle = "";
  if (sourcePath) {
    const parts = sourcePath.split("/").filter((p) => p.length > 0);
    bookTitle = parts.length > 0 ? parts[parts.length - 1] : "";
  }
  if (bookTitle) {
    const bookTitleText = document.createElementNS("http://www.w3.org/2000/svg", "text");
    bookTitleText.setAttribute("class", "rt-book-title-text");
    bookTitleText.setAttribute("x", String(BOOK_TITLE_POS_X));
    bookTitleText.setAttribute("y", String(BOOK_TITLE_POS_Y));
    bookTitleText.setAttribute("text-anchor", "start");
    bookTitleText.setAttribute("dominant-baseline", "baseline");
    bookTitleText.setAttribute("id", "book-title");
    bookTitleText.textContent = bookTitle;
    grid.appendChild(bookTitleText);
  }
  const titleText = document.createElementNS("http://www.w3.org/2000/svg", "text");
  titleText.setAttribute("class", "rt-mode-title-text");
  titleText.setAttribute("x", String(MODE_TITLE_POS_X));
  titleText.setAttribute("y", String(MODE_TITLE_POS_Y));
  titleText.setAttribute("text-anchor", "start");
  titleText.setAttribute("dominant-baseline", "baseline");
  titleText.setAttribute("id", "mode-title");
  if (MODE_OPTIONS.length > 0) {
    titleText.textContent = MODE_OPTIONS[0].label;
  }
  grid.appendChild(titleText);
  return grid;
}
async function switchToMode(view, modeId, modeSelector) {
  var _a;
  updateModeSelectorState(modeSelector, modeId);
  const modeManager = (_a = view.getModeManager) == null ? void 0 : _a.call(view);
  if (modeManager) {
    await modeManager.switchMode(modeId);
  } else {
    view.plugin.settings.currentMode = modeId;
    await view.plugin.saveSettings();
    resetGossamerModeState();
    if (typeof view.refreshTimeline === "function") {
      view.refreshTimeline();
    } else {
      view.plugin.refreshTimelineIfNeeded(null);
    }
  }
}
function updateModeSelectorState(modeSelector, currentMode) {
  const activeIndex = MODE_OPTIONS.findIndex((m) => m.id === currentMode);
  let x = MODE_SELECTOR_POS_X;
  const positions = [];
  for (let i = 0; i < MODE_OPTIONS.length; i++) {
    positions.push(x);
    if (i === activeIndex) {
      x += ACTIVE_VISUAL_WIDTH + ICON_VISUAL_GAP_ACTIVE;
    } else if (i + 1 === activeIndex) {
      x += INACTIVE_VISUAL_WIDTH + ICON_VISUAL_GAP_ACTIVE;
    } else {
      x += INACTIVE_VISUAL_WIDTH + ICON_VISUAL_GAP_INACTIVE;
    }
  }
  const totalWidth = positions[positions.length - 1] + INACTIVE_VISUAL_WIDTH - positions[0];
  const offset = MODE_SELECTOR_POS_X - (positions[0] + positions[positions.length - 1]) / 2;
  MODE_OPTIONS.forEach((mode, index) => {
    const modeElement = modeSelector.querySelector(`[data-mode="${mode.id}"]`);
    if (!modeElement) return;
    const bg = modeElement.querySelector(".rt-document-bg");
    const text = modeElement.querySelector(".rt-mode-acronym-text");
    const numberLabel = modeElement.querySelector(".rt-mode-number-label");
    const finalX = positions[index] + offset;
    if (mode.id === currentMode) {
      modeElement.setAttribute("transform", `translate(${finalX}, ${MODE_SELECTOR_POS_Y})`);
      modeElement.classList.add("rt-mode-current");
      bg.classList.add("rt-active");
      text.classList.add("rt-active");
      if (numberLabel) numberLabel.classList.add("rt-active");
      bg.setAttribute("d", createActiveDocumentShape());
      text.setAttribute("x", String(ICON_BASE_WIDTH / 2 * ACTIVE_SCALE));
      text.setAttribute("y", String((ICON_BASE_HEIGHT - 16) * ACTIVE_SCALE));
      if (numberLabel) {
        numberLabel.setAttribute("x", String(12 * ACTIVE_SCALE));
        numberLabel.setAttribute("y", String(20 * ACTIVE_SCALE));
      }
    } else {
      modeElement.setAttribute("transform", `translate(${finalX}, ${MODE_SELECTOR_POS_Y})`);
      modeElement.classList.remove("rt-mode-current");
      bg.classList.remove("rt-active");
      text.classList.remove("rt-active");
      if (numberLabel) numberLabel.classList.remove("rt-active");
      bg.setAttribute("d", createInactiveDocumentShape());
      text.setAttribute("x", String(ICON_BASE_WIDTH / 2 * INACTIVE_SCALE));
      text.setAttribute("y", String((ICON_BASE_HEIGHT - 16) * INACTIVE_SCALE));
      if (numberLabel) {
        numberLabel.setAttribute("x", String(12 * INACTIVE_SCALE));
        numberLabel.setAttribute("y", String(20 * INACTIVE_SCALE));
      }
    }
  });
  const titleText = modeSelector.querySelector("#mode-title");
  if (titleText && activeIndex >= 0) {
    titleText.textContent = MODE_OPTIONS[activeIndex].label;
  }
}
function setupModeToggleController(view, svg) {
  const modeSelector = createModeSelectorGrid(view);
  svg.appendChild(modeSelector);
  updateModeSelectorState(modeSelector, view.currentMode || "narrative");
  MODE_OPTIONS.forEach((mode) => {
    const modeElement = modeSelector.querySelector(`[data-mode="${mode.id}"]`);
    if (modeElement) {
      view.registerDomEvent(modeElement, "click", async (e) => {
        e.stopPropagation();
        await switchToMode(view, mode.id, modeSelector);
      });
    }
  });
  const handleKeyPress = async (e) => {
    var _a, _b, _c;
    const activeView = (_c = (_b = (_a = view.app) == null ? void 0 : _a.workspace) == null ? void 0 : _b.activeLeaf) == null ? void 0 : _c.view;
    if (activeView !== view) {
      return;
    }
    const activeEl = document.activeElement;
    if (activeEl) {
      const tag = activeEl.tagName.toUpperCase();
      if (tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || activeEl.isContentEditable) {
        return;
      }
    }
    const key = parseInt(e.key);
    if (key >= 1 && key <= 4 && key <= MODE_OPTIONS.length) {
      e.preventDefault();
      const modeId = MODE_OPTIONS[key - 1].id;
      await switchToMode(view, modeId, modeSelector);
    }
  };
  document.addEventListener("keydown", handleKeyPress);
  view._modeToggleCleanup = () => {
    document.removeEventListener("keydown", handleKeyPress);
  };
  MODE_OPTIONS.forEach((mode) => {
    const modeElement = modeSelector.querySelector(`[data-mode="${mode.id}"]`);
    if (modeElement) {
      view.registerDomEvent(modeElement, "mouseenter", (e) => {
        modeElement.classList.add("rt-mode-hover");
      });
      view.registerDomEvent(modeElement, "mouseleave", (e) => {
        modeElement.classList.remove("rt-mode-hover");
      });
    }
  });
}

// src/view/interactions/index.ts
init_ChronologueShiftController();

// src/view/TimeLineView.ts
init_ChronologueShiftController();

// src/modes/ModeManager.ts
init_ModeDefinition();
init_ModeRegistry();
var ModeManager = class {
  // SAFE: Per-view-instance, managed by view lifecycle
  constructor(plugin, view) {
    this.plugin = plugin;
    this.view = view;
  }
  /**
   * Get the current mode from the view
   */
  getCurrentMode() {
    const currentModeString = this.view.currentMode;
    if (isTimelineMode(currentModeString)) {
      return currentModeString;
    }
    return "narrative" /* NARRATIVE */;
  }
  /**
   * Switch to a new mode
   * Handles lifecycle: exit current  update state  enter new  refresh
   * If the new mode's onEnter hook throws an error, the mode switch is cancelled and reverted.
   */
  async switchMode(newMode) {
    const currentMode = this.getCurrentMode();
    if (currentMode === newMode) {
      return;
    }
    const currentModeDefinition = getModeDefinition(currentMode);
    const newModeDefinition = getModeDefinition(newMode);
    if (currentModeDefinition.onExit) {
      await currentModeDefinition.onExit(this.view);
    }
    this.view.currentMode = newMode;
    this.plugin.settings.currentMode = newMode;
    await this.plugin.saveSettings();
    if (newModeDefinition.onEnter) {
      try {
        await newModeDefinition.onEnter(this.view);
      } catch (error) {
        console.error(`[ModeManager] Failed to enter ${newMode}:`, error);
        this.view.currentMode = currentMode;
        this.plugin.settings.currentMode = currentMode;
        await this.plugin.saveSettings();
        return;
      }
    }
    await this.refreshTimeline();
  }
  /**
   * Toggle to the next mode in the toggle cycle
   * Only cycles through modes that have showInToggleButton = true
   */
  async toggleToNextMode() {
    const currentMode = this.getCurrentMode();
    const { getToggleableModes: getToggleableModes2 } = await Promise.resolve().then(() => (init_ModeRegistry(), ModeRegistry_exports));
    const toggleableModes = getToggleableModes2();
    if (toggleableModes.length === 0) {
      await this.switchMode("narrative" /* NARRATIVE */);
      return;
    }
    const currentIndex = toggleableModes.findIndex((mode) => mode.id === currentMode);
    if (currentIndex === -1) {
      await this.switchMode(toggleableModes[0].id);
      return;
    }
    const nextIndex = (currentIndex + 1) % toggleableModes.length;
    await this.switchMode(toggleableModes[nextIndex].id);
  }
  /**
   * Check if a mode is currently active
   */
  isMode(mode) {
    return this.getCurrentMode() === mode;
  }
  /**
   * Refresh the timeline view
   * Uses the view's refresh method if available, otherwise triggers plugin refresh
   */
  async refreshTimeline() {
    if (typeof this.view.refreshTimeline === "function") {
      await this.view.refreshTimeline();
    } else {
      this.plugin.refreshTimelineIfNeeded(null);
    }
  }
};
function createModeManager(plugin, view) {
  return new ModeManager(plugin, view);
}

// src/modes/ModeInteractionController.ts
init_ModeDefinition();
var ModeInteractionController = class {
  constructor(view) {
    // SAFE: Per-view-instance, managed by view lifecycle
    this.handlers = [];
    this.currentMode = null;
    this.view = view;
  }
  /**
   * Setup interaction handlers for a mode
   * Cleans up previous mode handlers first
   * @param mode - The mode definition to setup
   * @param svg - The SVG element to attach handlers to
   */
  async setupMode(mode, svg) {
    this.cleanup();
    this.currentMode = mode.id;
    switch (mode.id) {
      case "narrative" /* NARRATIVE */:
        await this.setupAllScenesHandlers(svg);
        break;
      case "subplot" /* SUBPLOT */:
        await this.setupMainPlotHandlers(svg);
        break;
      case "gossamer" /* GOSSAMER */:
        await this.setupGossamerHandlers(svg);
        break;
      case "chronologue" /* CHRONOLOGUE */:
        await this.setupChronologueHandlers(svg);
        break;
    }
  }
  /**
   * Clean up all registered handlers
   */
  cleanup() {
    this.handlers.forEach((handler) => {
      try {
        handler.removeFunction();
      } catch (e) {
      }
    });
    this.handlers = [];
    this.currentMode = null;
  }
  /**
   * Register a handler for tracking and cleanup
   */
  registerHandler(element, event, handler, removeFunction) {
    this.handlers.push({
      element,
      event,
      handler,
      removeFunction
    });
  }
  /**
   * Setup handlers for All Scenes mode
   */
  async setupAllScenesHandlers(svg) {
    const { setupAllScenesDelegatedHover: setupAllScenesDelegatedHover2, setupSceneInteractions: setupSceneInteractions2 } = await Promise.resolve().then(() => (init_AllScenesMode2(), AllScenesMode_exports));
    const container = this.view.containerEl;
    if (container) {
      setupAllScenesDelegatedHover2(this.view, container, this.view.sceneData || []);
    }
    const sceneGroups = svg.querySelectorAll(".rt-scene-group");
    sceneGroups.forEach((group) => {
      setupSceneInteractions2(this.view, group, svg, this.view.sceneData || []);
    });
  }
  /**
   * Setup handlers for Main Plot mode
   */
  async setupMainPlotHandlers(svg) {
    const { setupMainPlotMode: setupMainPlotMode2 } = await Promise.resolve().then(() => (init_MainPlotMode2(), MainPlotMode_exports));
    setupMainPlotMode2(this.view, svg);
  }
  /**
   * Setup handlers for Gossamer mode
   */
  async setupGossamerHandlers(svg) {
    const { setupGossamerMode: setupGossamerMode2 } = await Promise.resolve().then(() => (init_GossamerMode2(), GossamerMode_exports));
    setupGossamerMode2(this.view, svg);
  }
  /**
   * Setup handlers for Chronologue mode
   */
  async setupChronologueHandlers(svg) {
    const { setupChronologueMode: setupChronologueMode2 } = await Promise.resolve().then(() => (init_ChronologueMode2(), ChronologueMode_exports));
    const viewBox = svg.getAttribute("viewBox");
    let outerRadius = 300;
    if (viewBox) {
      const [, , width, height] = viewBox.split(" ").map(parseFloat);
      const size = Math.min(width, height);
      const margin = 50;
      outerRadius = size / 2 - margin;
    }
    const view = this.view;
    view.scenes = this.view.sceneData || [];
    view.outerRadius = outerRadius;
    setupChronologueMode2(view, svg);
  }
  /**
   * Get the current mode this controller is managing
   */
  getCurrentMode() {
    return this.currentMode;
  }
};
function createInteractionController(view) {
  return new ModeInteractionController(view);
}

// src/renderer/ChangeDetection.ts
function createSnapshot(scenes, openFilePaths, searchActive, searchResults, currentMode, settings, gossamerRun) {
  var _a, _b, _c, _d;
  const sceneHash = scenes.map((s) => {
    const parts = [
      s.path || s.title || "",
      s.status || "",
      s.actNumber || "",
      s.subplot || "",
      s.number || "",
      s.when instanceof Date ? s.when.getTime() : s.when || "",
      s.Duration || "",
      s.due || "",
      s["Publish Stage"] || "",
      s.synopsis || "",
      // Pending Edits affects number square color (gray)
      s.pendingEdits || "",
      s.Description || "",
      stringifyPovForHash(s.pov),
      // Range field (rendered in Gossamer mode)
      s.Range || "",
      (s.Character || []).length,
      s.location || ""
    ];
    for (let i = 1; i <= 30; i++) {
      const gossamerKey = `Gossamer${i}`;
      parts.push(s[gossamerKey] || "");
      const justificationKey = `Gossamer${i} Justification`;
      parts.push(s[justificationKey] || "");
    }
    return parts.join(":");
  }).join("|");
  const publishStageColorsHash = settings.publishStageColors ? JSON.stringify(settings.publishStageColors) : "";
  const subplotColorsHash = settings.subplotColors ? JSON.stringify(settings.subplotColors) : "";
  const dominantSubplotsHash = settings.dominantSubplots ? JSON.stringify(settings.dominantSubplots) : "";
  const now = /* @__PURE__ */ new Date();
  const gossamerRunHash = (() => {
    var _a2, _b2, _c2, _d2, _e, _f;
    if (!gossamerRun) return "";
    try {
      const beats = Array.isArray(gossamerRun.beats) ? gossamerRun.beats.map((beat) => {
        var _a3, _b3, _c3, _d3;
        return {
          beat: (_a3 = beat == null ? void 0 : beat.beat) != null ? _a3 : "",
          score: typeof (beat == null ? void 0 : beat.score) === "number" ? beat.score : "",
          status: (_b3 = beat == null ? void 0 : beat.status) != null ? _b3 : "",
          range: (beat == null ? void 0 : beat.range) ? `${(_c3 = beat.range.min) != null ? _c3 : ""}-${(_d3 = beat.range.max) != null ? _d3 : ""}` : "",
          out: (beat == null ? void 0 : beat.isOutOfRange) ? "1" : "0"
        };
      }) : [];
      return JSON.stringify({
        beats,
        label: (_b2 = (_a2 = gossamerRun.meta) == null ? void 0 : _a2.label) != null ? _b2 : "",
        model: (_d2 = (_c2 = gossamerRun.meta) == null ? void 0 : _c2.model) != null ? _d2 : "",
        summary: (_f = (_e = gossamerRun.overall) == null ? void 0 : _e.summary) != null ? _f : ""
      });
    } catch (e) {
      return String(Date.now());
    }
  })();
  return {
    sceneCount: scenes.length,
    sceneHash,
    openFilePaths: new Set(openFilePaths),
    searchActive,
    searchResults: new Set(searchResults),
    currentMode,
    currentMonth: now.getMonth(),
    currentDate: now.toISOString().split("T")[0],
    sortByWhen: (_a = settings.sortByWhenDate) != null ? _a : false,
    showEstimate: (_b = settings.showEstimate) != null ? _b : true,
    aiEnabled: (_c = settings.enableAiSceneAnalysis) != null ? _c : false,
    targetDate: settings.targetCompletionDate,
    chronologueDurationCap: settings.chronologueDurationCapSelection,
    discontinuityThreshold: settings.discontinuityThreshold,
    publishStageColorsHash,
    subplotColorsHash,
    dominantSubplotsHash,
    povMode: (_d = settings.globalPovMode) != null ? _d : "off",
    gossamerRunExists: !!gossamerRun,
    gossamerRunHash,
    timestamp: Date.now()
  };
}
function detectChanges(prev, current) {
  const changeTypes = /* @__PURE__ */ new Set();
  if (!prev) {
    return {
      hasChanges: true,
      changeTypes: /* @__PURE__ */ new Set(["scene_data" /* SCENE_DATA */]),
      canUseSelectiveUpdate: false,
      updateStrategy: "full"
    };
  }
  if (prev.sceneHash !== current.sceneHash || prev.sceneCount !== current.sceneCount) {
    changeTypes.add("scene_data" /* SCENE_DATA */);
  }
  if (!setsEqual(prev.openFilePaths, current.openFilePaths)) {
    changeTypes.add("open_files" /* OPEN_FILES */);
  }
  if (prev.searchActive !== current.searchActive || !setsEqual(prev.searchResults, current.searchResults)) {
    changeTypes.add("search" /* SEARCH */);
  }
  if (prev.currentMode !== current.currentMode) {
    changeTypes.add("mode" /* MODE */);
  }
  if (prev.sortByWhen !== current.sortByWhen || prev.showEstimate !== current.showEstimate || prev.aiEnabled !== current.aiEnabled || prev.targetDate !== current.targetDate || prev.chronologueDurationCap !== current.chronologueDurationCap || prev.discontinuityThreshold !== current.discontinuityThreshold || prev.publishStageColorsHash !== current.publishStageColorsHash || prev.subplotColorsHash !== current.subplotColorsHash || prev.povMode !== current.povMode) {
    changeTypes.add("settings" /* SETTINGS */);
  }
  if (prev.dominantSubplotsHash !== current.dominantSubplotsHash) {
    changeTypes.add("dominant_subplot" /* DOMINANT_SUBPLOT */);
  }
  if (prev.currentMonth !== current.currentMonth || prev.currentDate !== current.currentDate) {
    changeTypes.add("time" /* TIME */);
  }
  if (prev.gossamerRunExists !== current.gossamerRunExists || prev.gossamerRunHash !== current.gossamerRunHash) {
    changeTypes.add("gossamer" /* GOSSAMER */);
  }
  const hasChanges = changeTypes.size > 0;
  const selectiveChangeTypes = [
    "open_files" /* OPEN_FILES */,
    "search" /* SEARCH */,
    "time" /* TIME */,
    "dominant_subplot" /* DOMINANT_SUBPLOT */,
    // DOM update for scene colors
    "synopsis" /* SYNOPSIS */,
    // DOM update for synopsis text
    "gossamer" /* GOSSAMER */
  ];
  const canUseSelectiveUpdate = hasChanges && Array.from(changeTypes).every((type) => selectiveChangeTypes.includes(type));
  let updateStrategy = "none";
  if (hasChanges) {
    updateStrategy = canUseSelectiveUpdate ? "selective" : "full";
  }
  return {
    hasChanges,
    changeTypes,
    canUseSelectiveUpdate,
    updateStrategy
  };
}
function setsEqual(a, b) {
  if (a.size !== b.size) return false;
  for (const item of a) {
    if (!b.has(item)) return false;
  }
  return true;
}
function stringifyPovForHash(pov) {
  return typeof pov === "string" ? pov : "";
}

// src/view/TimeLineView.ts
var TIMELINE_VIEW_TYPE = "radial-timeline";
var TIMELINE_VIEW_DISPLAY_TEXT = "Radial timeline";
var _RadialTimelineView = class _RadialTimelineView extends import_obsidian18.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    // Frontmatter values to track to reduce unnecessary SVG View refreshes
    this.lastFrontmatterValues = {};
    this.timelineRefreshTimeout = null;
    // Change detection snapshot for optimizing renders
    this.lastSnapshot = null;
    // Scene data (scenes)
    this.sceneData = [];
    // Set of open scene paths (for tracking open files)
    this.openScenePaths = /* @__PURE__ */ new Set();
    // Store rotation state to persist across timeline refreshes
    this.rotationState = false;
    // Cache book title for display in tab
    this.cachedBookTitle = void 0;
    // Mode system
    this._currentMode = "narrative";
    // Interaction handler management
    // Store event handler references for clean removal
    this.normalEventHandlers = /* @__PURE__ */ new Map();
    this.gossamerEventHandlers = /* @__PURE__ */ new Map();
    // Property to track tab highlight timeout
    this._tabHighlightTimeout = null;
    this.plugin = plugin;
    this.openScenePaths = plugin.openScenePaths;
    this.rendererService = plugin.getRendererService();
    this._currentMode = plugin.settings.currentMode || "narrative";
    try {
      this.modeManager = createModeManager(plugin, this);
      this.interactionController = createInteractionController(this);
    } catch (e) {
    }
  }
  // Expose a safe registrar for Gossamer handlers so external modules can record svg-level listeners
  registerGossamerHandler(key, handler) {
    this.gossamerEventHandlers.set(key, handler);
  }
  /**
   * Get the current timeline mode
   */
  get currentMode() {
    return this._currentMode;
  }
  /**
   * Set the current timeline mode
   */
  set currentMode(mode) {
    this._currentMode = mode;
  }
  /**
   * Get the ModeManager instance
   * Provides centralized mode switching with lifecycle management
   */
  getModeManager() {
    return this.modeManager;
  }
  /**
   * Get the InteractionController instance
   * Manages event handler registration and cleanup
   */
  getInteractionController() {
    return this.interactionController;
  }
  getViewType() {
    return TIMELINE_VIEW_TYPE;
  }
  getDisplayText() {
    if (this.cachedBookTitle && this.cachedBookTitle.trim()) {
      return `Radial Timeline: ${this.cachedBookTitle.trim()}`;
    }
    return TIMELINE_VIEW_DISPLAY_TEXT;
  }
  getIcon() {
    return "shell";
  }
  // --- Helpers for number-square orientation/position (shared across modes) ---
  applyRotationToNumberSquares(svg, rotated) {
    const angle = 120;
    const orients = svg.querySelectorAll(".number-square-orient");
    orients.forEach((el) => {
      const base = (el.getAttribute("transform") || "").replace(/\s*rotate\([^)]*\)/g, "").trim();
      if (rotated) {
        el.setAttribute("transform", `${base} rotate(${angle})`.trim());
      } else {
        if (base) el.setAttribute("transform", base);
        else el.removeAttribute("transform");
      }
    });
  }
  getRotationState() {
    return this.rotationState;
  }
  setRotationState(rotated) {
    this.rotationState = rotated;
  }
  getSquareGroupForSceneId(svg, sceneId) {
    const rect = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
    if (!rect) return null;
    const group = rect.closest(".number-square-group");
    return group;
  }
  setNumberSquareGroupPosition(svg, sceneId, x, y) {
    const group = this.getSquareGroupForSceneId(svg, sceneId);
    if (group) {
      group.setAttribute("transform", `translate(${x}, ${y})`);
    }
  }
  // Add this method to handle search indicator clicks
  setupSearchControls() {
    setupSearchControls(this);
  }
  /**
   * Setup interactions based on the current mode
   */
  setupInteractionsForMode(svg) {
    if (this.interactionController) {
      const { getModeDefinition: getModeDefinition2 } = (init_ModeRegistry(), __toCommonJS(ModeRegistry_exports));
      const modeDef = getModeDefinition2(this.currentMode);
      this.interactionController.setupMode(modeDef, svg);
    }
  }
  updateOpenFilesTracking() {
    var _a;
    const previousOpenFiles = new Set(this.openScenePaths);
    this.openScenePaths = /* @__PURE__ */ new Set();
    const leaves = this.app.workspace.getLeavesOfType("markdown");
    const openFilesList = [];
    leaves.forEach((leaf) => {
      const view = leaf.view;
      if (view instanceof import_obsidian18.MarkdownView && view.file) {
        this.openScenePaths.add(view.file.path);
        openFilesList.push(view.file.path);
      }
    });
    const activeFile = this.app.workspace.getActiveFile();
    if (activeFile && !openFilesList.includes(activeFile.path)) {
      this.openScenePaths.add(activeFile.path);
      openFilesList.push(activeFile.path);
    }
    try {
      const layout = this.app.workspace.getLayout();
      if (layout && layout.leaves) {
        const leafIds = Object.keys(layout.leaves);
        leafIds.forEach((id) => {
          const leafs = layout.leaves;
          const leafData = leafs[id];
          if (leafData && leafData.type === "markdown" && leafData.state && leafData.state.file) {
            const filePath = leafData.state.file;
            if (!openFilesList.includes(filePath)) {
              this.openScenePaths.add(filePath);
              openFilesList.push(filePath);
            }
          }
        });
      }
    } catch (e) {
      console.error("Error accessing workspace layout:", e);
    }
    let hasChanged = false;
    if (previousOpenFiles.size !== this.openScenePaths.size) {
      hasChanged = true;
    } else {
      for (const path of previousOpenFiles) {
        if (!this.openScenePaths.has(path)) {
          hasChanged = true;
          break;
        }
      }
      if (!hasChanged) {
        for (const path of this.openScenePaths) {
          if (!previousOpenFiles.has(path)) {
            hasChanged = true;
            break;
          }
        }
      }
    }
    this.plugin.openScenePaths = new Set(this.openScenePaths);
    if (hasChanged) {
      const container = this.containerEl.children[1];
      const updated = (_a = this.rendererService) == null ? void 0 : _a.updateOpenClasses(container, this.openScenePaths);
      if (!updated) this.refreshTimeline();
    }
  }
  refreshTimeline() {
    if (!this.plugin) return;
    const perfStart = performance.now();
    const container = this.containerEl.children[1];
    this.updateOpenFilesTracking();
    this.plugin.getSceneData().then(async (sceneData) => {
      var _a, _b, _c;
      const dataLoadTime = performance.now() - perfStart;
      if (this._currentMode === "gossamer") {
        const { buildAllGossamerRuns: buildAllGossamerRuns2 } = await Promise.resolve().then(() => (init_gossamer(), gossamer_exports));
        const selectedBeatModel = ((_a = this.plugin.settings.beatSystem) == null ? void 0 : _a.trim()) || void 0;
        const allRuns = buildAllGossamerRuns2(sceneData, selectedBeatModel);
        this.plugin._gossamerLastRun = allRuns.current;
        this.plugin._gossamerHistoricalRuns = allRuns.historical;
        this.plugin._gossamerMinMax = allRuns.minMax;
        this.plugin._gossamerHasAnyScores = allRuns.hasAnyScores;
      }
      this.sceneData = sceneData;
      this.plugin.lastSceneData = sceneData;
      const bookTitle = (_b = sceneData.find((scene) => scene.Book)) == null ? void 0 : _b.Book;
      if (bookTitle) {
        this.cachedBookTitle = bookTitle;
      }
      const currentSnapshot = createSnapshot(
        sceneData,
        this.plugin.openScenePaths,
        this.plugin.searchActive,
        this.plugin.searchResults,
        this._currentMode,
        this.plugin.settings,
        this.plugin._gossamerLastRun
      );
      const changeResult = detectChanges(this.lastSnapshot, currentSnapshot);
      if (changeResult.updateStrategy === "none") {
        return;
      } else if (changeResult.updateStrategy === "selective" && this.rendererService) {
        let updated = false;
        if (changeResult.changeTypes.has("open_files" /* OPEN_FILES */)) {
          updated = this.rendererService.updateOpenClasses(container, this.plugin.openScenePaths) || updated;
        }
        if (changeResult.changeTypes.has("search" /* SEARCH */)) {
          updated = this.rendererService.updateNumberSquaresDOM(container, this.plugin, sceneData) || updated;
          updated = this.rendererService.updateSearchHighlights(this) || updated;
        }
        if (changeResult.changeTypes.has("time" /* TIME */)) {
          updated = this.rendererService.updateProgressAndTicks(this) || updated;
        }
        if (changeResult.changeTypes.has("synopsis" /* SYNOPSIS */)) {
          updated = this.rendererService.updateSynopsisDOM(container, sceneData) || updated;
        }
        if (changeResult.changeTypes.has("gossamer" /* GOSSAMER */)) {
          updated = this.rendererService.updateGossamerLayer(this) || updated;
        }
        if (updated) {
          this.lastSnapshot = currentSnapshot;
          return;
        }
      }
      const loadingEl = container.createEl("div", {
        cls: "rt-loading-message",
        text: "Loading timeline data..."
      });
      container.empty();
      container.appendChild(loadingEl);
      const renderStart = performance.now();
      this.renderTimeline(container, this.sceneData);
      const renderTime = performance.now() - renderStart;
      loadingEl.remove();
      this.lastSnapshot = currentSnapshot;
      this.setupSearchControls();
      if (this.plugin.searchActive) {
        if (!((_c = this.rendererService) == null ? void 0 : _c.updateSearchHighlights(this))) {
          window.setTimeout(() => this.addHighlightRectangles(), 100);
        }
      }
    }).catch((error) => {
      const errorEl = container.createEl("div", {
        cls: "rt-error-message",
        text: `Error: ${error.message}`
      });
      console.error("Failed to load timeline data", error);
    });
  }
  setupMouseCoordinateTracking(container) {
  }
  /**
   * Called whenever the view is shown/revealed (e.g., when switching tabs back to this view)
   * Unlike onOpen which is called only once when the view is created
   */
  onload() {
  }
  async onOpen() {
    await this.plugin.maybeShowReleaseNotesModal();
    this.registerEvent(
      this.app.workspace.on("file-open", () => {
        this.updateOpenFilesTracking();
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.updateOpenFilesTracking();
      })
    );
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        const isThisViewActive = (leaf == null ? void 0 : leaf.view) === this;
        if (isThisViewActive) {
        }
        this.updateOpenFilesTracking();
      })
    );
    this.registerEvent(
      this.app.workspace.on("quick-preview", () => {
        this.updateOpenFilesTracking();
      })
    );
    this.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        var _a;
        if (!(file instanceof import_obsidian18.TFile) || file.extension !== "md") return;
        const cache = this.app.metadataCache.getFileCache(file);
        if (!cache || !cache.frontmatter) return;
        const fm = cache.frontmatter;
        const isScene = fm.Class === "Scene" || fm.class === "Scene";
        const isBeatOrPlot = fm.Class === "Plot" || fm.class === "Plot" || fm.Class === "Beat" || fm.class === "Beat";
        if (!isScene && !isBeatOrPlot) return;
        const isGossamerMode = this._currentMode === "gossamer";
        if (isGossamerMode && !isBeatOrPlot) {
          return;
        }
        if (!isGossamerMode && isBeatOrPlot && !isScene) {
          return;
        }
        const fileId = file.path;
        const currentFrontmatter = JSON.stringify(cache.frontmatter);
        const previousFrontmatter = this.lastFrontmatterValues[fileId];
        this.lastFrontmatterValues[fileId] = currentFrontmatter;
        if (previousFrontmatter === currentFrontmatter) return;
        if (this.timelineRefreshTimeout) window.clearTimeout(this.timelineRefreshTimeout);
        this.timelineRefreshTimeout = window.setTimeout(() => {
          this.refreshTimeline();
        }, Math.max(0, Number((_a = this.plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4)));
      })
    );
    this.updateOpenFilesTracking();
    if (this._currentMode === "gossamer" && this.modeManager) {
      const { TimelineMode: TimelineMode2 } = await Promise.resolve().then(() => (init_ModeDefinition(), ModeDefinition_exports));
      const { getModeDefinition: getModeDefinition2 } = await Promise.resolve().then(() => (init_ModeRegistry(), ModeRegistry_exports));
      const gossamerDef = getModeDefinition2(TimelineMode2.GOSSAMER);
      if (gossamerDef.onEnter) {
        try {
          await gossamerDef.onEnter(this);
        } catch (e) {
          console.error("[Gossamer] Failed to initialize on load:", e);
          this._currentMode = "narrative";
        }
      }
    }
    this.refreshTimeline();
  }
  async onClose() {
    this.plugin.clearSearch();
    if (this._modeToggleCleanup) {
      this._modeToggleCleanup();
    }
    if (this._chronologueShiftCleanup) {
      this._chronologueShiftCleanup();
    }
  }
  // Add missing addHighlightRectangles method
  addHighlightRectangles() {
    addHighlightRectangles(this);
  }
  renderTimeline(container, scenes) {
    var _a;
    container.empty();
    if (!scenes || scenes.length === 0) {
      let sourcePath = (this.plugin.settings.sourcePath || "").trim();
      if (sourcePath) {
        sourcePath = (0, import_obsidian18.normalizePath)(sourcePath);
      }
      let messageText;
      if (sourcePath === "") {
        messageText = "No source folder has been configured in the Radial timeline plugin settings. Please choose a folder that will hold your scene notes or leave blank to use the root of your vault.";
      } else {
        const folderExists = !!this.plugin.app.vault.getAbstractFileByPath(sourcePath);
        if (folderExists) {
          messageText = `No scene files were found in "${sourcePath}".`;
        } else {
          messageText = `The folder "${sourcePath}" does not exist in your vault yet.`;
        }
        messageText += " Would you like to create a template scene note with example YAML frontmatter?";
      }
      container.createEl("div", { text: messageText });
      const demoButton = container.createEl("button", {
        text: "Create template scene note",
        cls: "rt-action-button"
      });
      this.registerDomEvent(demoButton, "click", async () => {
        const { createTemplateScene: createTemplateScene2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
        await createTemplateScene2(this.plugin, this.plugin.app.vault);
        window.setTimeout(() => {
          this.refreshTimeline();
        }, 500);
      });
      return;
    }
    this.sceneData = scenes;
    const fragment = document.createDocumentFragment();
    const timelineContainer = document.createElement("div");
    timelineContainer.className = "radial-timeline-container";
    fragment.appendChild(timelineContainer);
    try {
      const startTime = performance.now();
      const renderer = (_a = this.rendererService) != null ? _a : this.plugin.getRendererService();
      const { svgString, maxStageColor: calculatedMaxStageColor } = renderer.generateTimeline(this.plugin, scenes);
      if (calculatedMaxStageColor) {
        document.documentElement.style.setProperty("--rt-max-publish-stage-color", calculatedMaxStageColor);
      }
      const svgElement = renderSvgFromString(svgString, timelineContainer, (cleanup) => this.register(cleanup));
      if (svgElement) {
        svgElement.setAttribute("data-mode", this.currentMode);
        if (this.currentMode === "chronologue" && isShiftModeActive()) {
          svgElement.setAttribute("data-shift-mode", "active");
        }
        if (this.currentMode === "gossamer") {
          svgElement.setAttribute("data-gossamer-mode", "true");
          const allElements = svgElement.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
          allElements.forEach((el) => {
            const group = el.closest(".rt-scene-group");
            const itemType = group == null ? void 0 : group.getAttribute("data-item-type");
            if (itemType !== "Beat") {
              el.classList.add("rt-non-selected");
            }
          });
        } else {
          svgElement.removeAttribute("data-gossamer-mode");
        }
        this.setupInteractionsForMode(svgElement);
        const subplotLabelGroups = svgElement.querySelectorAll(".subplot-label-group[data-font-size]");
        subplotLabelGroups.forEach((group) => {
          const fontSize = group.getAttribute("data-font-size");
          if (fontSize) {
            group.style.setProperty("--rt-subplot-font-size", `${fontSize}px`);
          }
        });
        setupRotationController(this, svgElement);
        setupModeToggleController(this, svgElement);
        const adjustLabels = () => {
          var _a2;
          return (_a2 = this.rendererService) == null ? void 0 : _a2.adjustBeatLabelsAfterRender(timelineContainer);
        };
        const rafId1 = requestAnimationFrame(adjustLabels);
        const leafChangeHandler = () => {
          if (this.app.workspace.getActiveViewOfType(_RadialTimelineView) === this) {
            const timeoutId = window.setTimeout(() => {
              const rafId2 = requestAnimationFrame(adjustLabels);
              this.register(() => cancelAnimationFrame(rafId2));
            }, 50);
            this.register(() => window.clearTimeout(timeoutId));
          }
        };
        this.register(() => cancelAnimationFrame(rafId1));
        this.registerEvent(this.app.workspace.on("active-leaf-change", leafChangeHandler));
        const allSynopses = Array.from(svgElement.querySelectorAll(".rt-scene-info"));
        const sceneGroups = Array.from(svgElement.querySelectorAll(".rt-scene-group"));
        const sceneGroupRafIds = [];
        const CHUNK_SIZE = 20;
        const processSceneGroups = (startIdx) => {
          const endIdx = Math.min(startIdx + CHUNK_SIZE, sceneGroups.length);
          for (let i = startIdx; i < endIdx; i++) {
            const group = sceneGroups[i];
            const encodedPath = group.getAttribute("data-path");
            if (encodedPath && encodedPath !== "") {
              const filePath = decodeURIComponent(encodedPath);
              if (this.openScenePaths.has(filePath)) {
                group.classList.add("rt-scene-is-open");
                const scenePath = group.querySelector(".rt-scene-path");
                if (scenePath) {
                  scenePath.classList.add("rt-scene-is-open");
                }
                const sceneTitle = group.querySelector(".rt-scene-title");
                if (sceneTitle) {
                  sceneTitle.classList.add("rt-scene-is-open");
                }
                const sceneId = scenePath == null ? void 0 : scenePath.id;
                if (sceneId) {
                  const numberSquare = svgElement.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
                  if (numberSquare) {
                    numberSquare.classList.add("rt-scene-is-open");
                  }
                  const numberText = svgElement.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
                  if (numberText) {
                    numberText.classList.add("rt-scene-is-open");
                  }
                }
              }
            }
          }
          if (endIdx < sceneGroups.length) {
            const rafId = window.requestAnimationFrame(() => processSceneGroups(endIdx));
            sceneGroupRafIds.push(rafId);
          }
        };
        this.register(() => {
          sceneGroupRafIds.forEach((id) => cancelAnimationFrame(id));
        });
        processSceneGroups(0);
        allSynopses.forEach((synopsis) => {
          synopsis.classList.remove("rt-visible");
        });
        this.setupSearchControls();
        const subplotLabels = svgElement.querySelectorAll(".rt-subplot-ring-label-text");
        if (subplotLabels.length > 0) {
          const onEnterLeave = (hovering, targetGroup) => {
            if (!targetGroup) return;
            subplotLabels.forEach((label) => {
              if (hovering) label.classList.add("rt-non-selected");
              else label.classList.remove("rt-non-selected");
            });
          };
          const svg = container.querySelector(".radial-timeline-svg");
          if (svg) {
            let lastHoverGroup = null;
            this.registerDomEvent(svg, "pointerover", (e) => {
              const g = e.target.closest(".rt-scene-group");
              if (g && g !== lastHoverGroup) {
                onEnterLeave(true, g);
                lastHoverGroup = g;
              }
            });
            this.registerDomEvent(svg, "pointerout", (e) => {
              const g = e.target.closest(".rt-scene-group");
              if (g && g === lastHoverGroup) {
                onEnterLeave(false, g);
                lastHoverGroup = null;
              }
            });
          }
        }
      }
      container.appendChild(fragment);
      if (this.currentMode === "gossamer") {
        const svg = container.querySelector(".radial-timeline-svg");
        if (svg) {
          let gossamerOuterRafId = null;
          let gossamerInnerRafId = null;
          gossamerOuterRafId = requestAnimationFrame(() => {
            gossamerInnerRafId = requestAnimationFrame(() => {
              this.setupGossamerEventListeners(svg);
              gossamerOuterRafId = null;
              gossamerInnerRafId = null;
            });
          });
          this.register(() => {
            if (gossamerOuterRafId !== null) cancelAnimationFrame(gossamerOuterRafId);
            if (gossamerInnerRafId !== null) cancelAnimationFrame(gossamerInnerRafId);
          });
        }
      }
    } catch (error) {
      console.error("Error rendering timeline:", error);
      container.createEl("div", {
        text: "Error rendering timeline. Check console for details."
      });
    }
  }
  // New helper removed; interactions moved to modes/AllScenesMode
  // Helper method to highlight files in the navigator and tab bar
  highlightFileInExplorer(filePath, isHighlighting) {
    if (!filePath) return;
    try {
      const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian18.TFile) {
        if (isHighlighting) {
          const fileExplorer = this.plugin.app.workspace.getLeavesOfType("file-explorer")[0];
          if (fileExplorer && fileExplorer.view) {
            const explorerView = fileExplorer.view;
            if (explorerView.revealInFolder) {
              explorerView.revealInFolder(file);
            }
          }
        } else {
          this.plugin.app.workspace.trigger("active-leaf-change", this.leaf);
        }
      }
    } catch (error) {
    }
  }
  /**
   * Remove all Gossamer-specific event listeners and restore normal mode
   */
  removeGossamerEventListeners(svg) {
    this.gossamerEventHandlers.forEach((handler, key) => {
      const [eventType] = key.split("::");
      svg.removeEventListener(eventType, handler);
    });
    this.gossamerEventHandlers.clear();
  }
  /**
   * Setup Gossamer-specific event listeners
   * These are simpler and don't have conditionals - just Plot slice and dot interactions
   */
  setupGossamerEventListeners(svg) {
    this.removeGossamerEventListeners(svg);
    if (this.interactionController) {
      const { getModeDefinition: getModeDefinition2 } = (init_ModeRegistry(), __toCommonJS(ModeRegistry_exports));
      const { TimelineMode: TimelineMode2 } = (init_ModeDefinition(), __toCommonJS(ModeDefinition_exports));
      const modeDef = getModeDefinition2(TimelineMode2.GOSSAMER);
      this.interactionController.setupMode(modeDef, svg);
    }
  }
};
_RadialTimelineView.viewType = TIMELINE_VIEW_TYPE;
var RadialTimelineView = _RadialTimelineView;

// src/services/TimelineService.ts
var TimelineService = class {
  constructor(app, plugin) {
    this.refreshTimeout = null;
    this.pendingRequest = null;
    this.app = app;
    this.plugin = plugin;
  }
  getTimelineViews() {
    return this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE).map((leaf) => leaf.view).filter((v) => v instanceof RadialTimelineView);
  }
  /**
   * Schedule a render with change type tracking and batching
   * Multiple rapid calls will batch change types together
   */
  scheduleRender(changeTypes, delayMs = 100) {
    if (this.pendingRequest) {
      changeTypes.forEach((type) => this.pendingRequest.changeTypes.add(type));
    } else {
      this.pendingRequest = {
        changeTypes: new Set(changeTypes),
        requestedAt: Date.now(),
        priority: this.calculatePriority(changeTypes)
      };
    }
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
    }
    const effectiveDelay = this.pendingRequest.priority === 0 ? 0 : delayMs;
    this.refreshTimeout = window.setTimeout(() => {
      this.executeScheduledRender();
    }, effectiveDelay);
  }
  /**
   * Calculate priority for change types
   * Lower number = higher priority = shorter delay
   */
  calculatePriority(changeTypes) {
    if (changeTypes.includes("scene_data" /* SCENE_DATA */) || changeTypes.includes("mode" /* MODE */) || changeTypes.includes("settings" /* SETTINGS */)) {
      return 0;
    }
    if (changeTypes.includes("gossamer" /* GOSSAMER */)) {
      return 1;
    }
    return 2;
  }
  /**
   * Execute the scheduled render
   */
  executeScheduledRender() {
    if (!this.pendingRequest) return;
    const views = this.getTimelineViews();
    const activeLeaf = this.app.workspace.getActiveViewOfType(RadialTimelineView);
    if (activeLeaf) {
      activeLeaf.refreshTimeline();
    } else {
      const firstView = views[0];
      if (firstView) {
        firstView.refreshTimeline();
      }
    }
    this.pendingRequest = null;
    this.refreshTimeout = null;
  }
  /**
   * Legacy method for compatibility
   * @param file - File that triggered the refresh (null = settings change or manual refresh)
   */
  refreshTimelineIfNeeded(file, delayMs) {
    var _a;
    if (file && (!(file instanceof import_obsidian19.TFile) || file.extension !== "md")) return;
    const effectiveDelay = (_a = delayMs != null ? delayMs : this.plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4;
    if (!file) {
      this.scheduleRender(["settings" /* SETTINGS */], effectiveDelay);
      return;
    }
    this.scheduleRender(["scene_data" /* SCENE_DATA */], effectiveDelay);
  }
  /**
   * Cancel any pending render
   */
  cancelPendingRender() {
    if (this.refreshTimeout) {
      window.clearTimeout(this.refreshTimeout);
      this.refreshTimeout = null;
    }
    this.pendingRequest = null;
  }
};

// src/services/SceneDataService.ts
var import_obsidian20 = require("obsidian");
init_frontmatter();
init_date();
init_sceneHelpers();
init_text();
init_gossamer();
var SceneDataService = class {
  constructor(app, settings) {
    this.app = app;
    this.settings = settings;
  }
  /**
   * Update settings (called when settings change)
   */
  updateSettings(settings) {
    this.settings = settings;
  }
  /**
   * Get all scene data from the vault
   */
  async getSceneData(options) {
    var _a, _b, _c, _d;
    const filterBeats = (_a = options == null ? void 0 : options.filterBeatsBySystem) != null ? _a : true;
    const files = this.app.vault.getMarkdownFiles().filter((file) => {
      if (this.settings.sourcePath) {
        return file.path.startsWith(this.settings.sourcePath);
      }
      return true;
    });
    const scenes = [];
    const plotsToProcess = [];
    for (const file of files) {
      try {
        const rawMetadata = (_b = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _b.frontmatter;
        const metadata = rawMetadata ? normalizeFrontmatterKeys(rawMetadata) : void 0;
        if (metadata && metadata.Class === "Scene") {
          const whenStr = metadata.When;
          let when;
          if (typeof whenStr === "string") {
            const parsed = parseWhenField(whenStr);
            if (parsed) {
              when = parsed;
            }
          } else if (whenStr instanceof Date) {
            when = whenStr;
          }
          const hasValidWhen = when instanceof Date && !isNaN(when.getTime());
          const normalizedWhen = hasValidWhen ? when : void 0;
          const missingWhen = !hasValidWhen;
          const isoDate = hasValidWhen && normalizedWhen ? normalizedWhen.toISOString().split("T")[0] : "";
          const subplots = metadata.Subplot ? Array.isArray(metadata.Subplot) ? metadata.Subplot : [metadata.Subplot] : ["Main Plot"];
          const actValue = metadata.Act;
          const actNumber = actValue !== void 0 && actValue !== null && actValue !== "" ? Number(actValue) : 1;
          const validActNumber = actNumber >= 1 && actNumber <= 3 ? actNumber : 1;
          for (const subplot of subplots) {
            const durationValue = metadata.Duration;
            const duration = durationValue !== void 0 && durationValue !== null ? String(durationValue) : void 0;
            const beatsUpdate = metadata["Beats Update"];
            const rawCharacter = metadata.Character;
            const characterList = Array.isArray(rawCharacter) ? rawCharacter.map((c) => stripWikiLinks(c)) : rawCharacter ? [stripWikiLinks(rawCharacter)] : void 0;
            const rawPov = metadata.POV;
            let povField;
            if (Array.isArray(rawPov)) {
              for (const entry of rawPov) {
                const candidate = typeof entry === "string" ? entry : entry !== void 0 && entry !== null ? String(entry) : "";
                const trimmed = candidate.trim();
                if (trimmed.length > 0) {
                  povField = trimmed;
                  break;
                }
              }
            } else if (typeof rawPov === "string") {
              const trimmed = rawPov.trim();
              if (trimmed.length > 0) {
                povField = trimmed;
              }
            } else if (rawPov !== void 0 && rawPov !== null) {
              const converted = String(rawPov).trim();
              if (converted.length > 0) {
                povField = converted;
              }
            }
            scenes.push({
              date: isoDate,
              when: normalizedWhen,
              missingWhen,
              path: file.path,
              title: (_c = metadata.Title) != null ? _c : file.basename,
              subplot,
              act: String(validActNumber),
              actNumber: validActNumber,
              pov: povField,
              location: metadata.Place,
              Character: characterList,
              synopsis: metadata.Synopsis,
              status: metadata.Status,
              "Publish Stage": metadata["Publish Stage"],
              due: metadata.Due,
              pendingEdits: metadata["Pending Edits"],
              Duration: duration,
              Book: metadata.Book,
              // AI Scene Analysis fields - handle both string and array formats from YAML
              "previousSceneAnalysis": Array.isArray(metadata["previousSceneAnalysis"]) ? metadata["previousSceneAnalysis"].join("\n") : metadata["previousSceneAnalysis"],
              "currentSceneAnalysis": Array.isArray(metadata["currentSceneAnalysis"]) ? metadata["currentSceneAnalysis"].join("\n") : metadata["currentSceneAnalysis"],
              "nextSceneAnalysis": Array.isArray(metadata["nextSceneAnalysis"]) ? metadata["nextSceneAnalysis"].join("\n") : metadata["nextSceneAnalysis"],
              itemType: "Scene",
              "Beats Update": normalizeBooleanValue(beatsUpdate)
            });
          }
        } else if (metadata && isStoryBeat(metadata.Class)) {
          const actValue = metadata.Act;
          const actNumber = actValue !== void 0 && actValue !== null && actValue !== "" ? Number(actValue) : 1;
          const validActNumber = actNumber >= 1 && actNumber <= 3 ? actNumber : 1;
          plotsToProcess.push({ file, metadata, validActNumber });
        }
      } catch (error) {
        console.error(`Error processing file ${file.path}:`, error);
      }
    }
    this.applyDominantSubplotPreferences(scenes);
    const filteredScenes = this.filterScenesByDominantSubplot(scenes);
    const scenesByDate = /* @__PURE__ */ new Map();
    const processedPaths = /* @__PURE__ */ new Set();
    for (const scene of filteredScenes) {
      const dateKey = scene.date;
      const pathDateKey = `${scene.path}-${dateKey}`;
      if (processedPaths.has(pathDateKey)) {
        continue;
      }
      processedPaths.add(pathDateKey);
      if (!scenesByDate.has(dateKey)) {
        scenesByDate.set(dateKey, []);
      }
      scenesByDate.get(dateKey).push(scene);
    }
    let beatsToProcess = plotsToProcess;
    if (filterBeats && this.settings.beatSystem) {
      const beatsWithModel = beatsToProcess.map((p) => ({
        original: p,
        "Beat Model": p.metadata["Beat Model"]
      }));
      const filtered = filterBeatsBySystem(beatsWithModel, this.settings.beatSystem);
      beatsToProcess = filtered.map((f) => f.original);
    }
    for (const { file, metadata, validActNumber } of beatsToProcess) {
      const whenStr = metadata.When;
      let when;
      if (typeof whenStr === "string") {
        const parsed = parseWhenField(whenStr);
        if (parsed) {
          when = parsed;
        }
      } else if (whenStr instanceof Date) {
        when = whenStr;
      }
      const dateKey = when && !isNaN(when.getTime()) ? when.toISOString().split("T")[0] : "";
      const beatModel = metadata["Beat Model"] || this.settings.beatSystem || "";
      filteredScenes.push({
        date: dateKey,
        when,
        path: file.path,
        title: (_d = metadata.Title) != null ? _d : file.basename,
        subplot: "Main Plot",
        // Beats always use Main Plot for outermost ring
        act: String(validActNumber),
        actNumber: validActNumber,
        synopsis: metadata.Synopsis,
        Description: metadata.Description,
        "Beat Model": beatModel,
        Range: metadata.Range,
        "Suggest Placement": metadata["Suggest Placement"],
        itemType: "Beat",
        // Modern standard - renderer should use isBeatNote() helper
        // Include all Gossamer score fields (Gossamer1-30)
        Gossamer1: metadata.Gossamer1,
        Gossamer2: metadata.Gossamer2,
        Gossamer3: metadata.Gossamer3,
        Gossamer4: metadata.Gossamer4,
        Gossamer5: metadata.Gossamer5,
        "Publish Stage": metadata["Publish Stage"]
      });
    }
    return filteredScenes;
  }
  /**
   * Apply dominant subplot preferences from settings
   */
  applyDominantSubplotPreferences(scenes) {
    if (!this.settings.dominantSubplots) return;
    const scenesByPath = /* @__PURE__ */ new Map();
    scenes.forEach((scene) => {
      if (!scene.path) return;
      if (!scenesByPath.has(scene.path)) {
        scenesByPath.set(scene.path, []);
      }
      scenesByPath.get(scene.path).push(scene);
    });
    Object.entries(this.settings.dominantSubplots).forEach(([path, dominantSubplot]) => {
      const scenesForPath = scenesByPath.get(path);
      if (!scenesForPath || scenesForPath.length <= 1) return;
      scenesForPath.forEach((scene) => {
        scene._isDominantSubplot = scene.subplot === dominantSubplot;
      });
    });
  }
  /**
   * Keep all scenes but mark the dominant subplot for visual coloring
   * (this does NOT filter - all subplot versions are kept for rendering in their respective rings)
   */
  filterScenesByDominantSubplot(scenes) {
    return scenes;
  }
  /**
   * Check if a file path is a scene file
   */
  isSceneFile(filePath) {
    var _a;
    const file = this.app.vault.getAbstractFileByPath(filePath);
    if (!(file instanceof import_obsidian20.TFile)) return false;
    const metadata = (_a = this.app.metadataCache.getFileCache(file)) == null ? void 0 : _a.frontmatter;
    if (!metadata) return false;
    return metadata.Class === "Scene";
  }
};

// src/utils/constants.ts
var NUM_ACTS = 3;
var GRID_CELL_BASE = 22;
var STATUS_COLORS = {
  Working: "var(--rt-color-working)",
  Todo: "var(--rt-color-todo)",
  Empty: "var(--rt-color-empty)",
  Due: "var(--rt-color-due)",
  Complete: "var(--rt-color-complete)"
};
var GRID_CELL_WIDTH_EXTRA = 9;
var GRID_CELL_GAP_X = 2;
var GRID_CELL_GAP_Y = 4;
var GRID_HEADER_OFFSET_Y = 12;
var GRID_LINE_HEIGHT = 26;
var STAGE_ORDER = ["Zero", "Author", "House", "Press"];
var STAGES_FOR_GRID = ["Zero", "Author", "House", "Press"];
var STATUSES_FOR_GRID = ["Todo", "Working", "Due", "Completed"];

// src/utils/colour.ts
function getMostAdvancedStageColor(scenes, publishStageColors) {
  const stageOrder = [...STAGE_ORDER];
  let maxStageIndex = 0;
  scenes.forEach((scene) => {
    const rawStage = scene["Publish Stage"];
    const stage = STAGE_ORDER.includes(rawStage) ? rawStage : "Zero";
    const currentIndex = stageOrder.indexOf(stage);
    if (currentIndex > maxStageIndex) {
      maxStageIndex = currentIndex;
    }
  });
  const maxStageName = stageOrder[maxStageIndex];
  return publishStageColors[maxStageName] || publishStageColors.Zero;
}
function hexToRgb(hex) {
  const match = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  if (!match) return null;
  return {
    r: parseInt(match[1], 16),
    g: parseInt(match[2], 16),
    b: parseInt(match[3], 16)
  };
}
function rgbToHsl(r, g, b) {
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h = 0, s = 0, l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;
      case g:
        h = (b - r) / d + 2;
        break;
      case b:
        h = (r - g) / d + 4;
        break;
    }
    h /= 6;
  }
  return { h, s, l };
}
function hslToRgb(h, s, l) {
  let r, g, b;
  if (s === 0) {
    r = g = b = l;
  } else {
    const hue2rgb = (p2, q2, t) => {
      if (t < 0) t += 1;
      if (t > 1) t -= 1;
      if (t < 1 / 6) return p2 + (q2 - p2) * 6 * t;
      if (t < 1 / 2) return q2;
      if (t < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t) * 6;
      return p2;
    };
    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
    const p = 2 * l - q;
    r = hue2rgb(p, q, h + 1 / 3);
    g = hue2rgb(p, q, h);
    b = hue2rgb(p, q, h - 1 / 3);
  }
  return { r: Math.round(r * 255), g: Math.round(g * 255), b: Math.round(b * 255) };
}
function rgbToHex(r, g, b) {
  return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}
function lightenColor(hex, percent) {
  const num = parseInt(hex.replace("#", ""), 16);
  const r = num >> 16;
  const g = num >> 8 & 255;
  const b = num & 255;
  const mixRatio = Math.min(1, percent / 100);
  const newR = Math.min(255, Math.round(r + (255 - r) * mixRatio));
  const newG = Math.min(255, Math.round(g + (255 - g) * mixRatio));
  const newB = Math.min(255, Math.round(b + (255 - b) * mixRatio));
  return `#${(1 << 24 | newR << 16 | newG << 8 | newB).toString(16).slice(1)}`;
}

// src/SynopsisManager.ts
init_text();

// src/synopsis/SynopsisData.ts
init_text();
function getPublishStageStyle(stageInput, publishStageColors) {
  const stage = stageInput || "Zero";
  const stageClass = `rt-title-stage-${String(stage).toLowerCase()}`;
  const titleColor = publishStageColors[stage] || "#808080";
  return { stageClass, titleColor };
}
function splitSynopsisLines(contentLines) {
  let synopsisEndIndex = contentLines.findIndex((line) => line === "\xA0" || line === "");
  if (synopsisEndIndex === -1) synopsisEndIndex = Math.max(0, contentLines.length - 2);
  const metadataItems = contentLines.slice(synopsisEndIndex + 1);
  return { synopsisEndIndex, metadataItems };
}
function decodeContentLines(lines) {
  return lines.map((line) => decodeHtmlEntities(line));
}
function isOverdueAndIncomplete(scene, today = /* @__PURE__ */ new Date()) {
  const dueString = scene.due;
  if (!dueString || typeof dueString !== "string") return false;
  const parts = dueString.split("-").map(Number);
  if (parts.length !== 3 || parts.some(isNaN)) return false;
  const [dueYear, dueMonth1, dueDay] = parts;
  const dueMonth = dueMonth1 - 1;
  const todayY = today.getFullYear();
  const todayM = today.getMonth();
  const todayD = today.getDate();
  let isOverdue = false;
  if (dueYear < todayY) isOverdue = true;
  else if (dueYear === todayY) {
    if (dueMonth < todayM) isOverdue = true;
    else if (dueMonth === todayM) {
      if (dueDay < todayD) isOverdue = true;
    }
  }
  let normalizedStatus = "";
  if (scene.status) {
    if (Array.isArray(scene.status) && scene.status.length > 0) normalizedStatus = String(scene.status[0]).trim().toLowerCase();
    else if (typeof scene.status === "string") normalizedStatus = scene.status.trim().toLowerCase();
  }
  const isComplete = normalizedStatus === "complete" || normalizedStatus === "done";
  return isOverdue && !isComplete;
}

// src/synopsis/SynopsisView.ts
function createSynopsisContainer(sceneId, scenePath) {
  const containerGroup = document.createElementNS("http://www.w3.org/2000/svg", "g");
  containerGroup.setAttribute("class", "rt-scene-info rt-info-container");
  containerGroup.setAttribute("data-for-scene", sceneId);
  if (scenePath) {
    containerGroup.setAttribute("data-scene-path", encodeURIComponent(scenePath));
  }
  return containerGroup;
}
function createTextGroup() {
  const group = document.createElementNS("http://www.w3.org/2000/svg", "g");
  group.setAttribute("class", "rt-synopsis-text");
  return group;
}
function createText(x, y, cls, text) {
  const el = document.createElementNS("http://www.w3.org/2000/svg", "text");
  el.setAttribute("class", cls);
  el.setAttribute("x", String(x));
  el.setAttribute("y", String(y));
  el.setAttribute("text-anchor", "start");
  el.textContent = text;
  return el;
}

// src/SynopsisManager.ts
init_LayoutConstants();
init_sceneHelpers();
var _SynopsisManager = class _SynopsisManager {
  constructor(plugin) {
    this.plugin = plugin;
  }
  parseHtmlSafely(html) {
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<div>${html}</div>`, "text/html");
    const container = doc.querySelector("div");
    const fragment = document.createDocumentFragment();
    if (container) {
      while (container.firstChild) {
        fragment.appendChild(container.firstChild);
      }
    }
    return fragment;
  }
  /**
   * Format date from When field to friendly format for display
   * @param when Date object from scene.when
   * @returns Formatted date string (e.g., "Aug 1, 1812 @ 8AM" or "Apr 6, 1812 @ Noon" or "Apr 6, 1812 @ Midnight")
   */
  formatDateForDisplay(when) {
    if (!when) {
      return "";
    }
    if (!(when instanceof Date) || Number.isNaN(when.getTime())) {
      throw new Error("formatDateForDisplay requires a valid Date object");
    }
    const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
    const month = months[when.getMonth()];
    const day = when.getDate();
    const year = when.getFullYear();
    const hours = when.getHours();
    const minutes = when.getMinutes();
    let dateStr = `${month} ${day}, ${year}`;
    if (hours === 0 && minutes === 0) {
      dateStr += " @ Midnight";
    } else if (hours === 12 && minutes === 0) {
      dateStr += " @ Noon";
    } else {
      const period = hours >= 12 ? "PM" : "AM";
      const displayHours = hours % 12 === 0 ? 12 : hours % 12;
      if (minutes === 0) {
        dateStr += ` @ ${displayHours}${period}`;
      } else {
        dateStr += ` @ ${displayHours}:${String(minutes).padStart(2, "0")}${period}`;
      }
    }
    return dateStr;
  }
  /**
   * Add title content to a text element safely
   * @param titleContent The title content to add
   * @param titleTextElement The text element to add to
   * @param titleColor The color for the title
   * @param sceneNumber Optional scene number from frontmatter
   * @param sceneDate Optional scene date from frontmatter (should be pre-formatted)
   * @param sceneDuration Optional scene duration from frontmatter
   */
  /**
   * Add title content to the title text element
   * Returns a metadata text element if date/duration exist, otherwise null
   */
  addTitleContent(titleContent, titleTextElement, titleColor, sceneNumber, sceneDate, sceneDuration) {
    if (titleContent.includes("<tspan")) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg><text>${titleContent}</text></svg>`, "image/svg+xml");
      const textNode = doc.querySelector("text");
      if (!textNode) {
        const fallbackTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        fallbackTspan.setAttribute("fill", titleColor);
        fallbackTspan.appendChild(document.createTextNode(titleContent));
        titleTextElement.appendChild(fallbackTspan);
        return null;
      }
      Array.from(textNode.childNodes).forEach((node) => {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName.toLowerCase() === "tspan") {
          const tspan = node;
          const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          Array.from(tspan.attributes).forEach((attr) => {
            svgTspan.setAttribute(attr.name, attr.value);
          });
          if (tspan instanceof HTMLElement || tspan instanceof SVGElement) {
            const style = tspan.getAttribute("style");
            if (style) {
              svgTspan.setAttribute("style", style);
            }
          }
          svgTspan.textContent = tspan.textContent;
          titleTextElement.appendChild(svgTspan);
        } else if (node.nodeType === Node.TEXT_NODE) {
          if (node.textContent) {
            titleTextElement.appendChild(document.createTextNode(node.textContent));
          }
        }
      });
      return null;
    } else {
      const titleParts = parseSceneTitleComponents(titleContent, sceneNumber, sceneDate, sceneDuration);
      if (titleParts.sceneNumber) {
        const numTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        numTspan.classList.add("rt-scene-title-bold");
        numTspan.setAttribute("data-item-type", "title");
        numTspan.style.setProperty("--rt-dynamic-color", titleColor);
        numTspan.textContent = `${titleParts.sceneNumber} `;
        titleTextElement.appendChild(numTspan);
      }
      const mainTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      mainTspan.classList.add("rt-scene-title-bold");
      mainTspan.setAttribute("data-item-type", "title");
      mainTspan.style.setProperty("--rt-dynamic-color", titleColor);
      mainTspan.textContent = titleParts.title;
      titleTextElement.appendChild(mainTspan);
      if (titleParts.date || titleParts.duration) {
        const metadataElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        metadataElement.setAttribute("class", "rt-info-text rt-title-text-main rt-title-date-time");
        metadataElement.setAttribute("x", "0");
        metadataElement.setAttribute("y", "0");
        metadataElement.setAttribute("text-anchor", "start");
        metadataElement.setAttribute("data-metadata-block", "true");
        metadataElement.setAttribute("data-column-gap", "8px");
        if (titleParts.date) {
          const dateTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          dateTspan.setAttribute("class", "rt-date-text");
          dateTspan.setAttribute("data-item-type", "date");
          dateTspan.setAttribute("data-column-role", "date");
          dateTspan.setAttribute("dy", "-16px");
          dateTspan.textContent = titleParts.date;
          metadataElement.appendChild(dateTspan);
        }
        if (titleParts.duration) {
          const durationTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          durationTspan.setAttribute("class", "rt-duration-text");
          durationTspan.setAttribute("data-item-type", "duration");
          durationTspan.setAttribute("data-column-role", "duration");
          durationTspan.setAttribute("x", "0");
          durationTspan.setAttribute("dy", titleParts.date ? "16px" : "0");
          durationTspan.textContent = titleParts.duration;
          metadataElement.appendChild(durationTspan);
        }
        return metadataElement;
      }
    }
    return null;
  }
  /**
   * Create a metadata text element with date and duration (two-row layout)
   * DEPRECATED - No longer used
   */
  createMetadataElement(sceneDate, sceneDuration) {
    return null;
  }
  /**
   * Create a DOM element for a scene synopsis with consistent formatting
   * @returns An SVG group element containing the formatted synopsis
   */
  generateElement(scene, contentLines, sceneId, subplotIndexResolver) {
    const { stageClass, titleColor } = getPublishStageStyle(scene["Publish Stage"], this.plugin.settings.publishStageColors);
    const { synopsisEndIndex, metadataItems } = splitSynopsisLines(contentLines);
    const decodedContentLines = decodeContentLines(contentLines);
    const getSubplotColor = (subplot, sceneIdentifier) => {
      const resolveCssVariable = (index2) => {
        const normalizedIndex = Math.max(0, index2) % 15;
        const varName = `--rt-subplot-colors-${normalizedIndex}`;
        const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
        if (!value) {
          throw new Error(`CSS variable ${varName} is not defined for subplot coloring.`);
        }
        return value;
      };
      const resolveIndex = () => {
        var _a;
        if (subplotIndexResolver) {
          const resolved = subplotIndexResolver(subplot);
          if (!Number.isFinite(resolved)) {
            throw new Error(`Subplot index resolver returned an invalid value for "${subplot}".`);
          }
          return resolved;
        }
        const sceneGroup = (_a = document.getElementById(sceneIdentifier)) == null ? void 0 : _a.closest(".scene-group");
        if (!sceneGroup) {
          throw new Error(`Scene group not found for synopsis ${sceneIdentifier}.`);
        }
        const idxAttr = sceneGroup.getAttribute("data-subplot-index");
        if (!idxAttr) {
          throw new Error(`Scene group for ${sceneIdentifier} is missing data-subplot-index.`);
        }
        const parsed = parseInt(idxAttr, 10);
        if (Number.isNaN(parsed)) {
          throw new Error(`Invalid subplot index "${idxAttr}" for scene ${sceneIdentifier}.`);
        }
        return parsed;
      };
      const index = resolveIndex();
      return resolveCssVariable(index);
    };
    const lineHeight = 24;
    const containerGroup = createSynopsisContainer(sceneId, scene.path);
    containerGroup.setAttribute("data-stage-color", titleColor);
    const synopsisTextGroup = createTextGroup();
    containerGroup.appendChild(synopsisTextGroup);
    const titleContent = decodedContentLines[0];
    const titleTextElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
    titleTextElement.setAttribute("class", `rt-info-text rt-title-text-main`);
    titleTextElement.setAttribute("x", "0");
    titleTextElement.setAttribute("y", "0");
    const currentMode = this.plugin.settings.currentMode || "narrative";
    const isGossamerMode = currentMode === "gossamer";
    const shouldShowDate = scene.when && !(scene.itemType === "Plot" && isGossamerMode);
    const formattedDate = shouldShowDate ? this.formatDateForDisplay(scene.when) : void 0;
    const duration = scene.Duration ? scene.Duration : void 0;
    const metadataElement = this.addTitleContent(titleContent, titleTextElement, titleColor, scene.number, formattedDate, duration);
    synopsisTextGroup.appendChild(titleTextElement);
    if (metadataElement) {
      synopsisTextGroup.appendChild(metadataElement);
    }
    let extraLineCount = 0;
    const appendInfoLine = (className, text) => {
      const y = (1 + extraLineCount) * lineHeight;
      synopsisTextGroup.appendChild(createText(0, y, className, text));
      extraLineCount += 1;
    };
    const missingWhenMessage = this.buildMissingWhenMessage(scene);
    if (missingWhenMessage) {
      appendInfoLine("rt-info-text rt-title-text-secondary rt-missing-when-text", missingWhenMessage);
    }
    const dueString = scene.due;
    if (dueString && isOverdueAndIncomplete(scene)) {
      appendInfoLine("rt-info-text rt-title-text-secondary rt-overdue-text", `Overdue: ${dueString}`);
    }
    const pendingEdits = scene.pendingEdits && typeof scene.pendingEdits === "string" ? scene.pendingEdits.trim() : "";
    if (pendingEdits) {
      const maxWidth = 500;
      const lines = splitIntoBalancedLines(pendingEdits, maxWidth);
      for (let i = 0; i < lines.length; i++) {
        const y = (1 + extraLineCount) * lineHeight + i * lineHeight;
        const text = `${i === 0 ? "Revisions: " : ""}${lines[i]}`;
        synopsisTextGroup.appendChild(createText(0, y, "rt-info-text rt-title-text-secondary rt-revisions-text", text));
      }
      extraLineCount += lines.length;
    }
    for (let i = 1; i < synopsisEndIndex; i++) {
      const lineContent = decodedContentLines[i];
      const isGossamerLine = contentLines[i].includes("<gossamer>") && contentLines[i].includes("</gossamer>");
      const lineY = (i + extraLineCount) * lineHeight;
      const synopsisLineElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
      if (isGossamerLine) {
        synopsisLineElement.setAttribute("class", "rt-info-text rt-title-text-main rt-gossamer-score-line");
        synopsisLineElement.setAttribute("x", "0");
        synopsisLineElement.setAttribute("y", String(lineY));
        const gossamerContent = contentLines[i].replace(/<gossamer>/g, "").replace(/<\/gossamer>/g, "");
        const gossamerTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        gossamerTspan.classList.add("rt-scene-title-bold");
        gossamerTspan.setAttribute("data-item-type", "title");
        gossamerTspan.style.setProperty("--rt-dynamic-color", titleColor);
        gossamerTspan.textContent = gossamerContent;
        synopsisLineElement.appendChild(gossamerTspan);
      } else {
        synopsisLineElement.setAttribute("class", "rt-info-text rt-title-text-secondary");
        synopsisLineElement.setAttribute("x", "0");
        synopsisLineElement.setAttribute("y", String(lineY));
        if (lineContent.includes("<tspan")) {
          this.processContentWithTspans(lineContent, synopsisLineElement);
        } else {
          synopsisLineElement.textContent = lineContent;
        }
      }
      synopsisTextGroup.appendChild(synopsisLineElement);
    }
    if (metadataItems.length > 0) {
      const addSpacer = (yPosition, height) => {
        const spacerElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
        spacerElement.setAttribute("class", "synopsis-spacer");
        spacerElement.setAttribute("x", "0");
        spacerElement.setAttribute("y", String(yPosition));
        spacerElement.setAttribute("font-size", "2px");
        spacerElement.textContent = "\xA0";
        spacerElement.classList.add("rt-invisible-spacer");
        synopsisTextGroup.appendChild(spacerElement);
        return yPosition;
      };
      const synopsisBottomY = synopsisEndIndex * lineHeight;
      let currentMetadataY = addSpacer(synopsisBottomY, 0);
      if (this.plugin.settings.enableAiSceneAnalysis && scene["previousSceneAnalysis"]) {
        const beatsY = currentMetadataY;
        const beatsText = scene["previousSceneAnalysis"] || "";
        const linesAdded = this.formatBeatsText(beatsText, "previousSceneAnalysis", synopsisTextGroup, beatsY, lineHeight, 0);
        currentMetadataY = beatsY + linesAdded * lineHeight;
        if (linesAdded > 0) {
          currentMetadataY = addSpacer(currentMetadataY, 0);
        }
      }
      if (this.plugin.settings.enableAiSceneAnalysis && scene["currentSceneAnalysis"]) {
        const beatsY = currentMetadataY;
        const beatsText = scene["currentSceneAnalysis"] || "";
        const linesAdded = this.formatBeatsText(beatsText, "currentSceneAnalysis", synopsisTextGroup, beatsY, lineHeight, 0);
        currentMetadataY = beatsY + linesAdded * lineHeight;
        if (linesAdded > 0) {
          currentMetadataY = addSpacer(currentMetadataY, 0);
        }
      }
      if (this.plugin.settings.enableAiSceneAnalysis && scene["nextSceneAnalysis"]) {
        const beatsY = currentMetadataY;
        const beatsText = scene["nextSceneAnalysis"] || "";
        const linesAdded = this.formatBeatsText(beatsText, "nextSceneAnalysis", synopsisTextGroup, beatsY, lineHeight, 0);
        currentMetadataY = beatsY + linesAdded * lineHeight;
        if (linesAdded > 0) {
          currentMetadataY = addSpacer(currentMetadataY, 0);
        }
      }
      const subplotStartY = currentMetadataY;
      const decodedMetadataItems = metadataItems.map((item) => decodeHtmlEntities(item));
      if (decodedMetadataItems.length > 0 && decodedMetadataItems[0] && decodedMetadataItems[0].trim().length > 0) {
        const subplots = decodedMetadataItems[0].split(", ").filter((s) => s.trim().length > 0);
        if (subplots.length > 0) {
          const subplotTextElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
          subplotTextElement.setAttribute("class", "rt-info-text rt-metadata-text");
          subplotTextElement.setAttribute("x", "0");
          subplotTextElement.setAttribute("y", String(subplotStartY));
          subplots.forEach((subplot, j) => {
            const color = getSubplotColor(subplot.trim(), sceneId);
            const subplotText = subplot.trim();
            const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
            tspan.setAttribute("data-item-type", "subplot");
            tspan.style.setProperty("--rt-dynamic-color", color);
            tspan.textContent = subplotText;
            subplotTextElement.appendChild(tspan);
            if (j < subplots.length - 1) {
              const comma = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              comma.setAttribute("fill", "var(--text-muted)");
              comma.textContent = ", ";
              subplotTextElement.appendChild(comma);
            }
          });
          synopsisTextGroup.appendChild(subplotTextElement);
        }
      }
      if (decodedMetadataItems.length > 1 && decodedMetadataItems[1] && decodedMetadataItems[1].trim().length > 0) {
        const characterY = subplotStartY + lineHeight;
        const characterList = decodedMetadataItems[1].split(", ").filter((c) => c.trim().length > 0);
        if (characterList.length > 0) {
          const characterTextElement = document.createElementNS("http://www.w3.org/2000/svg", "text");
          characterTextElement.setAttribute("class", "rt-info-text rt-metadata-text");
          characterTextElement.setAttribute("x", "0");
          characterTextElement.setAttribute("y", String(characterY));
          characterList.forEach((character, j) => {
            var _a;
            const trimmedChar = character.trim();
            const color = "#666666";
            let baselineRaised = false;
            const markerMatch = trimmedChar.match(/>pov(?:=([^<]+))<$/i);
            const povLabel = markerMatch ? ((_a = markerMatch[1]) == null ? void 0 : _a.trim()) || "POV" : void 0;
            const cleanedText = markerMatch ? trimmedChar.replace(/\s*>pov(?:=[^<]+)?<\s*/i, "").trim() : trimmedChar;
            if (cleanedText) {
              const tspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              tspan.setAttribute("data-item-type", "character");
              tspan.style.setProperty("--rt-dynamic-color", color);
              tspan.textContent = cleanedText;
              characterTextElement.appendChild(tspan);
            }
            if (povLabel) {
              const povTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              povTspan.setAttribute("class", "rt-pov-marker");
              povTspan.setAttribute("dy", "-8px");
              povTspan.style.setProperty("--rt-dynamic-color", color);
              povTspan.textContent = povLabel;
              characterTextElement.appendChild(povTspan);
              baselineRaised = true;
            }
            if (j < characterList.length - 1) {
              const comma = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              comma.setAttribute("fill", "var(--text-muted)");
              if (baselineRaised) {
                comma.setAttribute("dy", "8px");
              }
              comma.textContent = ", ";
              characterTextElement.appendChild(comma);
            } else if (baselineRaised) {
              const resetTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
              resetTspan.setAttribute("dy", "8px");
              resetTspan.textContent = "";
              characterTextElement.appendChild(resetTspan);
            }
          });
          synopsisTextGroup.appendChild(characterTextElement);
        }
      }
    }
    return containerGroup;
  }
  /**
   * Generate SVG string from DOM element (temporary compatibility method)
   */
  generateHTML(scene, contentLines, sceneId) {
    const element = this.generateElement(scene, contentLines, sceneId);
    const serializer = new XMLSerializer();
    return serializer.serializeToString(element);
  }
  /**
   * Update the position of a synopsis based on mouse position
   */
  updatePosition(synopsis, event, svg, sceneId) {
    if (!(synopsis instanceof SVGElement)) {
      throw new Error("Synopsis element must be an SVGElement.");
    }
    if (!svg) {
      throw new Error("SVG root is required to position synopsis content.");
    }
    const pt = svg.createSVGPoint();
    pt.x = event.clientX;
    pt.y = event.clientY;
    const ctm = svg.getScreenCTM();
    if (!ctm) {
      throw new Error("Unable to compute screen CTM for timeline SVG.");
    }
    const svgP = pt.matrixTransform(ctm.inverse());
    const quadrant = this.getQuadrant(svgP.x, svgP.y);
    const currentMode = this.plugin.settings.currentMode || "narrative";
    const isChronologueMode = currentMode === "chronologue";
    const isSubplotMode = currentMode === "subplot";
    const subplotOuterRadius = isChronologueMode ? SUBPLOT_OUTER_RADIUS_CHRONOLOGUE : isSubplotMode ? SUBPLOT_OUTER_RADIUS_MAINPLOT : SUBPLOT_OUTER_RADIUS_STANDARD;
    const adjustedRadius = subplotOuterRadius - SYNOPSIS_INSET;
    synopsis.removeAttribute("style");
    synopsis.classList.remove("rt-synopsis-q1", "rt-synopsis-q2", "rt-synopsis-q3", "rt-synopsis-q4");
    const position = this.getPositionForQuadrant(quadrant, adjustedRadius);
    synopsis.classList.add(`rt-synopsis-${position.quadrantClass}`);
    const y = position.y;
    if (Math.abs(y) >= adjustedRadius) {
      throw new Error(`Synopsis y-position ${y} exceeds radius ${adjustedRadius}`);
    }
    const diff = adjustedRadius * adjustedRadius - y * y;
    if (diff < 0) {
      throw new Error("Cannot compute synopsis x-position due to invalid radius difference.");
    }
    const baseX = Math.sqrt(diff);
    const x = position.isRightAligned ? baseX : -baseX;
    synopsis.setAttribute("transform", `translate(${x}, ${y})`);
    synopsis.classList.add("rt-visible");
    synopsis.setAttribute("opacity", "1");
    synopsis.setAttribute("pointer-events", "all");
    this.positionTextElements(synopsis, position.isRightAligned, position.isTopHalf, adjustedRadius, sceneId);
  }
  /**
   * Determine which quadrant a point is in
   * SVG coordinate system: (0,0) is at center
   * Q1: Bottom-Right (+x, +y)
   * Q2: Bottom-Left (-x, +y)
   * Q3: Top-Left (-x, -y)
   * Q4: Top-Right (+x, -y)
   */
  getQuadrant(x, y) {
    if (x >= 0 && y >= 0) return "Q1";
    else if (x < 0 && y >= 0) return "Q2";
    else if (x < 0 && y < 0) return "Q3";
    else return "Q4";
  }
  /**
   * Get position configuration for a specific quadrant
   */
  getPositionForQuadrant(quadrant, outerRadius) {
    let result = {
      x: 0,
      y: 0,
      quadrantClass: "",
      isRightAligned: false,
      isTopHalf: false
    };
    const topHalfOffset = -550;
    const bottomHalfOffset = 120;
    switch (quadrant) {
      case "Q1":
        result.x = 0;
        result.y = bottomHalfOffset;
        result.quadrantClass = "q2";
        result.isRightAligned = false;
        result.isTopHalf = false;
        break;
      case "Q2":
        result.x = 0;
        result.y = bottomHalfOffset;
        result.quadrantClass = "q1";
        result.isRightAligned = true;
        result.isTopHalf = false;
        break;
      case "Q3":
        result.x = 0;
        result.y = topHalfOffset;
        result.quadrantClass = "q4";
        result.isRightAligned = true;
        result.isTopHalf = true;
        break;
      case "Q4":
        result.x = 0;
        result.y = topHalfOffset;
        result.quadrantClass = "q3";
        result.isRightAligned = false;
        result.isTopHalf = true;
        break;
    }
    return result;
  }
  positionTextElements(synopsis, isRightAligned, isTopHalf, radius, sceneId) {
    const textElements = Array.from(synopsis.querySelectorAll("text"));
    if (textElements.length === 0) return;
    const textAnchor = isRightAligned ? "end" : "start";
    textElements.forEach((textEl) => {
      if (textEl.getAttribute("data-metadata-block") === "true") {
        textEl.setAttribute("text-anchor", "start");
      } else {
        textEl.setAttribute("text-anchor", textAnchor);
      }
    });
    const synopsisTextGroup = synopsis.querySelector(".rt-synopsis-text");
    if (!synopsisTextGroup) {
      return;
    }
    synopsisTextGroup.removeAttribute("transform");
    const titleLineHeight = 32;
    const synopsisLineHeight = 22;
    const scorePreGap = 46;
    const metadataSpacing = 14;
    const synopsisTransform = synopsis.getAttribute("transform") || "";
    const translateMatch = synopsisTransform.match(/translate\(([^,]+),\s*([^)]+)\)/);
    if (!translateMatch || translateMatch.length < 3) {
      return;
    }
    const baseX = parseFloat(translateMatch[1]);
    const baseY = parseFloat(translateMatch[2]);
    const textRows = [];
    textElements.forEach((textEl) => {
      if (textEl.getAttribute("data-metadata-block") === "true" && textRows.length > 0) {
        textRows[textRows.length - 1].push(textEl);
      } else {
        textRows.push([textEl]);
      }
    });
    let yOffset = 0;
    textRows.forEach((rowElements, rowIndex) => {
      var _a;
      const primaryEl = (_a = rowElements[0]) != null ? _a : null;
      if (rowIndex > 0) {
        const currentEl = rowElements[0];
        const isGossamerLine = currentEl.classList.contains("rt-gossamer-score-line");
        const prevEl = textRows[rowIndex - 1][0];
        const isPrevLineSynopsis = prevEl.classList.contains("rt-title-text-secondary");
        if (rowIndex === 1) {
          yOffset += titleLineHeight;
        } else if (isGossamerLine && isPrevLineSynopsis) {
          yOffset += scorePreGap;
        } else {
          yOffset += synopsisLineHeight;
        }
      }
      let anchorY = baseY + yOffset;
      if (Math.abs(anchorY) >= radius) {
        anchorY = Math.sign(anchorY) * (radius - 1);
      }
      const radiusDiff = radius * radius - anchorY * anchorY;
      if (radiusDiff < 0) {
        throw new Error(`Cannot resolve anchor for row ${rowIndex}; negative radius difference computed.`);
      }
      const circleX = Math.sqrt(radiusDiff);
      const direction = isRightAligned ? 1 : -1;
      let anchorAbsoluteX = circleX * direction;
      if (isTopHalf) {
        const inset = this.computeTopHalfInset(primaryEl, rowIndex);
        const magnitude = Math.abs(anchorAbsoluteX) - inset;
        if (magnitude < 0) {
          throw new Error(`Inset ${inset} for row ${rowIndex} exceeds available radius.`);
        }
        anchorAbsoluteX = magnitude * direction;
      }
      const anchorX = anchorAbsoluteX - baseX;
      const { primaryWidth, metadataWidth, gap } = this.measureRowLayout(rowElements, metadataSpacing);
      const roundedAnchorX = Math.round(anchorX);
      const rowY = rowIndex === 0 ? 0 : yOffset;
      this.positionRowColumns(
        rowElements,
        roundedAnchorX,
        rowY,
        primaryWidth,
        metadataWidth,
        gap,
        isRightAligned
      );
    });
  }
  computeTopHalfInset(textElement, rowIndex) {
    if (!textElement) {
      return _SynopsisManager.TOP_HALF_BASE_INSET;
    }
    const style = window.getComputedStyle(textElement);
    const fontSize = (style == null ? void 0 : style.fontSize) ? parseFloat(style.fontSize) : Number.NaN;
    let referenceSize = Number.isFinite(fontSize) && fontSize > 0 ? fontSize : Number.NaN;
    if (!Number.isFinite(referenceSize) || referenceSize <= 0) {
      try {
        const box = textElement.getBBox();
        if (box && Number.isFinite(box.height) && box.height > 0) {
          referenceSize = box.height;
        }
      } catch (error) {
        console.warn("[Synopsis] Failed to read bbox height for inset calculation:", error);
      }
    }
    if (!Number.isFinite(referenceSize) || referenceSize <= 0) {
      console.warn(
        `[Synopsis] Falling back to base inset for row ${rowIndex}; element has no measurable font size or height.`,
        textElement
      );
      return _SynopsisManager.TOP_HALF_BASE_INSET;
    }
    const ratio = rowIndex === 0 ? 0.9 : 0.6;
    const scaled = referenceSize * ratio;
    return Math.max(
      _SynopsisManager.TOP_HALF_MIN_INSET,
      Math.min(_SynopsisManager.TOP_HALF_MAX_INSET, scaled)
    );
  }
  measureRowLayout(rowElements, defaultGap) {
    if (rowElements.length === 0) {
      return { primaryWidth: 0, metadataWidth: 0, gap: defaultGap };
    }
    const primaryWidth = this.measureTextWidth(rowElements[0]);
    let metadataWidth = 0;
    let gap = defaultGap;
    if (rowElements.length > 1) {
      const metadataEl = rowElements[1];
      metadataWidth = this.measureTextWidth(metadataEl);
      const gapAttr = metadataEl.getAttribute("data-column-gap");
      if (gapAttr) {
        const parsedGap = parseFloat(gapAttr);
        if (!Number.isNaN(parsedGap)) {
          gap = parsedGap;
        }
      }
    }
    return { primaryWidth, metadataWidth, gap };
  }
  positionRowColumns(rowElements, anchorX, yPosition, primaryWidth, metadataWidth, gap, isRightAligned) {
    if (rowElements.length === 0) {
      return;
    }
    const hasMetadata = rowElements.length > 1;
    if (isRightAligned) {
      const metadataRightEdge = anchorX - SYNOPSIS_INSET;
      const metadataLeftEdge = hasMetadata ? metadataRightEdge - metadataWidth : metadataRightEdge;
      const titleRightEdge = hasMetadata ? metadataLeftEdge - gap : metadataRightEdge;
      rowElements.forEach((textEl, index) => {
        if (index === 0) {
          textEl.setAttribute("x", String(titleRightEdge));
          textEl.setAttribute("y", String(yPosition));
        } else {
          textEl.setAttribute("x", String(metadataLeftEdge));
          textEl.setAttribute("y", String(yPosition));
          textEl.setAttribute("text-anchor", "start");
          this.alignMetadataTspans(textEl, metadataLeftEdge);
        }
      });
    } else {
      const rowLeftEdge = anchorX + SYNOPSIS_INSET;
      const metadataLeftEdge = hasMetadata ? rowLeftEdge + primaryWidth + gap : rowLeftEdge;
      rowElements.forEach((textEl, index) => {
        if (index === 0) {
          textEl.setAttribute("x", String(rowLeftEdge));
          textEl.setAttribute("y", String(yPosition));
        } else {
          textEl.setAttribute("x", String(metadataLeftEdge));
          textEl.setAttribute("y", String(yPosition));
          this.alignMetadataTspans(textEl, metadataLeftEdge);
        }
      });
    }
  }
  alignMetadataTspans(metadataText, columnX) {
    const tspans = Array.from(metadataText.querySelectorAll("tspan"));
    tspans.forEach((tspan) => {
      const role = tspan.getAttribute("data-column-role");
      if (role === "date" || role === "duration") {
        tspan.setAttribute("x", String(columnX));
      }
    });
  }
  measureTextWidth(element) {
    const box = element.getBBox();
    if (box && Number.isFinite(box.width)) {
      return Math.max(0, box.width);
    }
    const length = element.getComputedTextLength();
    if (Number.isFinite(length)) {
      return Math.max(0, length);
    }
    throw new Error("Unable to measure text width for synopsis element.");
  }
  /**
   * Process content with tspan elements and add to an SVG element
   * @param content The HTML content to process
   * @param parentElement The SVG element to append processed nodes to
   */
  processContentWithTspans(content, parentElement) {
    let processedContent = content;
    if (content.includes("&lt;tspan") && !content.includes("<tspan")) {
      processedContent = content.replace(/&lt;/g, "<").replace(/&gt;/g, ">").replace(/&quot;/g, '"').replace(/&apos;/g, "'").replace(/&amp;/g, "&");
    }
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<div>${processedContent}</div>`, "text/html");
    const container = doc.querySelector("div");
    if (!container) {
      throw new Error("Unable to create container for synopsis content.");
    }
    const nodes = Array.from(container.childNodes);
    if (nodes.length === 0) {
      throw new Error("Synopsis content produced no nodes to render.");
    }
    const appendTextSpan = (textValue) => {
      if (!textValue.trim()) {
        return;
      }
      const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
      svgTspan.textContent = textValue;
      parentElement.appendChild(svgTspan);
    };
    nodes.forEach((node) => {
      var _a, _b;
      if (node.nodeType === Node.TEXT_NODE) {
        appendTextSpan((_a = node.textContent) != null ? _a : "");
        return;
      }
      if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        const tag = element.tagName.toLowerCase();
        if (tag !== "tspan" && tag !== "span") {
          throw new Error(`Unsupported element <${element.tagName}> in synopsis content.`);
        }
        const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
        Array.from(element.attributes).forEach((attr) => {
          svgTspan.setAttribute(attr.name, attr.value);
        });
        svgTspan.textContent = (_b = element.textContent) != null ? _b : "";
        parentElement.appendChild(svgTspan);
        return;
      }
      throw new Error("Unsupported node type found in synopsis content.");
    });
    if (!parentElement.hasChildNodes()) {
      throw new Error("Synopsis conversion produced no SVG tspans.");
    }
  }
  // Add this new method for splitting text into lines
  splitTextIntoLines(text, maxWidth) {
    if (!text || typeof text !== "string") {
      return [""];
    }
    const trimmedText = text.trim();
    if (!trimmedText) {
      return [""];
    }
    const words = trimmedText.split(/\s+/);
    const lines = [];
    let currentLine = "";
    const maxCharsPerLine = 50;
    for (let i = 0; i < words.length; i++) {
      const word = words[i];
      const wordWidth = word.length;
      if (currentLine.length + wordWidth + 1 > maxCharsPerLine && currentLine !== "") {
        lines.push(currentLine.trim());
        currentLine = word;
      } else {
        currentLine += (currentLine ? " " : "") + word;
      }
    }
    if (currentLine) {
      lines.push(currentLine.trim());
    }
    if (lines.length === 0) {
      return [trimmedText];
    }
    return lines;
  }
  /**
   * Formats and adds beat text lines to an SVG group.
   * @param beatsText The multi-line string containing beats for one section.
   * @param beatKey The key identifying the section ('previousSceneAnalysis', 'currentSceneAnalysis', 'nextSceneAnalysis').
   * @param parentGroup The SVG group element to append the text elements to.
   * @param baseY The starting Y coordinate for the first line.
   * @param lineHeight The vertical distance between lines.
   * @param spacerSize Size of the spacer to add after this beats section.
   */
  formatBeatsText(beatsText, beatKey, parentGroup, baseY, lineHeight, spacerSize = 0) {
    var _a, _b;
    if (!beatsText || typeof beatsText !== "string" || beatsText === "undefined" || beatsText === "null") {
      return 0;
    }
    beatsText = beatsText.replace(/undefined|null/gi, "").trim();
    if (!beatsText) {
      return 0;
    }
    let lines = [];
    const hasNewlines = beatsText.includes("\n");
    if (hasNewlines) {
      lines = beatsText.split("\n").map((line) => line.trim()).filter((line) => line.length > 0);
    } else {
      const trimmedText = beatsText.trim();
      if (trimmedText.startsWith("-")) {
        if (trimmedText.length > 1) {
          lines = [trimmedText];
        }
      } else {
        const beatSeparatorPattern = /,\s*(?=[^,]*[\+\-\?]\s*\/)/g;
        const parts = trimmedText.split(beatSeparatorPattern);
        if (parts.length > 1) {
          lines = parts.map((item) => `- ${item.trim()}`).filter((line) => line.length > 2);
        } else {
          lines = trimmedText.split(",").map((item) => `- ${item.trim()}`).filter((line) => line.length > 2);
        }
        if (lines.length === 0 && trimmedText.length > 0) {
          lines = [`- ${trimmedText}`];
        }
      }
    }
    if (lines.length > 0) {
      const processedLines = [];
      for (const originalLine of lines) {
        if (!originalLine || !originalLine.trim()) continue;
        const line = originalLine.trim();
        let wasSplit = false;
        let isGradeLine = false;
        const prefixMatch = line.match(/^\s*(\[[A-Z][+-]?\]\s*)/);
        const numericGradeRegex = /^\s*-?\s*(\d+(\.\d+)?\s+[ABC])/i;
        if (prefixMatch || line.match(numericGradeRegex)) {
          isGradeLine = true;
        }
        let splitChar = "";
        const hasSlashSeparator = /\s\/\s/.test(line);
        if (!hasSlashSeparator) {
          if (isGradeLine) {
            if (line.match(/\.\s/)) {
              splitChar = ".";
            } else if (line.includes(",")) {
              splitChar = ",";
            }
          } else {
            if (line.includes(",")) {
              splitChar = ",";
            }
          }
        }
        if (splitChar) {
          const parts = line.split(splitChar);
          if (parts.length > 1) {
            wasSplit = true;
            const wrapTag = isGradeLine ? "[GRADE]" : "[BODY]";
            processedLines.push(parts[0] + splitChar);
            for (let i = 1; i < parts.length; i++) {
              const part = parts[i].trim();
              if (part) {
                const text = i < parts.length - 1 ? part + splitChar : part;
                processedLines.push(`${wrapTag} ${text}`);
              }
            }
          }
        }
        if (!wasSplit) {
          processedLines.push(originalLine);
        }
      }
      lines.splice(0, lines.length, ...processedLines);
    }
    let currentY = baseY;
    let lineCount = 0;
    for (let i = 0; i < lines.length; i++) {
      let line = lines[i].trim();
      if (!line.startsWith("-")) {
        line = `- ${line}`;
      }
      let rawContent = line.substring(1).trim();
      if (!rawContent) continue;
      let titleText = rawContent;
      let commentText = "";
      let titleClass = "beats-text-neutral";
      let commentClass = "beats-text";
      let signDetected = null;
      let useSlashSeparator = false;
      let detectedGrade = null;
      const bodyWrapMatch = rawContent.match(/^\[BODY\]\s*(.*)$/);
      const gradeWrapMatch = rawContent.match(/^\[GRADE\]\s*(.*)$/);
      if (gradeWrapMatch) {
        titleText = gradeWrapMatch[1];
        rawContent = titleText;
        titleClass = "beats-text-grade";
        commentClass = "beats-text-grade";
        if (lines.length > 0) {
          const firstLineContent = lines[0].replace(/^-\s*/, "");
          const firstLineGradeMatch = firstLineContent.match(/^\s*\d+(\.\d+)?\s+([ABC])(?![A-Za-z0-9])/i);
          if (firstLineGradeMatch) {
            detectedGrade = firstLineGradeMatch[2].toUpperCase();
          }
        }
      } else if (bodyWrapMatch) {
        titleText = bodyWrapMatch[1];
        rawContent = titleText;
        titleClass = "rt-info-text rt-title-text-secondary";
        commentClass = "rt-info-text rt-title-text-secondary";
      } else {
        if (!bodyWrapMatch && !gradeWrapMatch) {
          const signSlashPattern = /^(.*?)\s*([-+?])\s*\/\s*(.*)$/;
          const match = rawContent.match(signSlashPattern);
          if (match) {
            titleText = match[1].trim();
            signDetected = match[2];
            commentText = match[3].trim();
            useSlashSeparator = true;
          } else {
            const endSignMatch = rawContent.match(/\s*([-+?])$/);
            if (endSignMatch) {
              signDetected = endSignMatch[1];
              titleText = rawContent.substring(0, endSignMatch.index).trim();
            }
          }
          if (signDetected === "+") {
            titleClass = "beats-text-positive";
          } else if (signDetected === "-") {
            titleClass = "beats-text-negative";
          }
        }
      }
      if (beatKey === "currentSceneAnalysis" && !bodyWrapMatch && !gradeWrapMatch) {
        const gradeMatch = titleText.match(/^\s*-?\s*(\d+(\.\d+)?\s+[ABC])/i);
        if (gradeMatch) {
          const gradeLetterMatch = titleText.match(/\s+([ABC])/i);
          if (gradeLetterMatch && gradeLetterMatch[1]) {
            detectedGrade = gradeLetterMatch[1].toUpperCase();
          }
          titleClass = "beats-text-grade";
          commentClass = "beats-text-grade";
        }
      }
      const brRe = /\s*\[br\]\s*/i;
      const titleSegments = (titleText || "").split(brRe);
      const commentSegments = useSlashSeparator && commentText ? (commentText || "").split(brRe) : [];
      const makeLine = (titlePart, commentPart) => {
        const lineText = document.createElementNS("http://www.w3.org/2000/svg", "text");
        lineText.setAttribute("class", "beats-text");
        lineText.setAttribute("x", "0");
        lineText.setAttribute("y", String(currentY));
        lineText.setAttribute("text-anchor", "start");
        if (titlePart !== null) {
          const tt = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          tt.setAttribute("class", titleClass);
          tt.textContent = titlePart;
          lineText.appendChild(tt);
        }
        if (commentPart !== null) {
          const ct = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          ct.setAttribute("class", commentClass);
          ct.textContent = (titlePart ? " / " : "") + commentPart;
          lineText.appendChild(ct);
        }
        parentGroup.appendChild(lineText);
        currentY += lineHeight;
        lineCount += 1;
      };
      makeLine((_a = titleSegments[0]) != null ? _a : "", commentSegments.length > 0 ? (_b = commentSegments[0]) != null ? _b : "" : null);
      for (let i2 = 1; i2 < titleSegments.length; i2++) {
        makeLine(titleSegments[i2], null);
      }
      for (let i2 = 1; i2 < commentSegments.length; i2++) {
        makeLine(commentSegments[i2], null);
      }
    }
    if (spacerSize > 0) {
      const addSpacer = (yPosition, height) => {
        const spacer = document.createElementNS("http://www.w3.org/2000/svg", "rect");
        spacer.setAttribute("class", "synopsis-spacer");
        spacer.setAttribute("x", "0");
        spacer.setAttribute("y", String(yPosition));
        spacer.setAttribute("width", "20");
        spacer.setAttribute("height", String(height));
        parentGroup.appendChild(spacer);
      };
      addSpacer(currentY, spacerSize);
      currentY += spacerSize;
    }
    return lineCount;
  }
  buildMissingWhenMessage(scene) {
    if (!shouldDisplayMissingWhenWarning(scene)) return null;
    const neighbors = this.getNarrativeNeighbors(scene);
    const previousDate = this.getValidWhen(neighbors == null ? void 0 : neighbors.previous);
    const nextDate = this.getValidWhen(neighbors == null ? void 0 : neighbors.next);
    const suggestions = [];
    if (previousDate) {
      suggestions.push(`Prev ${this.formatDateForDisplay(previousDate)}`);
    }
    if (nextDate) {
      suggestions.push(`Next ${this.formatDateForDisplay(nextDate)}`);
    }
    if (suggestions.length === 0) {
      return "Missing When date";
    }
    const suggestionText = suggestions.length === 1 ? suggestions[0] : `${suggestions[0]} or ${suggestions[1]}`;
    return `Missing When date \u2014 Try ${suggestionText}`;
  }
  getNarrativeNeighbors(scene) {
    const dataset = this.plugin.lastSceneData;
    if (!Array.isArray(dataset) || dataset.length === 0) return null;
    const sceneEntries = dataset.filter((item) => !isBeatNote(item));
    if (sceneEntries.length === 0) return null;
    const seenKeys = /* @__PURE__ */ new Set();
    const deduped = [];
    sceneEntries.forEach((item) => {
      const key = this.getSceneKey(item);
      if (!seenKeys.has(key)) {
        seenKeys.add(key);
        deduped.push(item);
      }
    });
    const ordered = sortScenes(deduped, false);
    const targetKey = this.getSceneKey(scene);
    const index = ordered.findIndex((item) => this.getSceneKey(item) === targetKey);
    if (index === -1) return null;
    return {
      previous: index > 0 ? ordered[index - 1] : void 0,
      next: index < ordered.length - 1 ? ordered[index + 1] : void 0
    };
  }
  getSceneKey(item) {
    var _a;
    return item.path || `${item.title || ""}::${String((_a = item.when) != null ? _a : "")}`;
  }
  getValidWhen(item) {
    if (!item) return null;
    if (!(item.when instanceof Date)) return null;
    return Number.isNaN(item.when.getTime()) ? null : item.when;
  }
};
/**
 * Position text elements along an arc
 */
_SynopsisManager.TOP_HALF_BASE_INSET = 18;
_SynopsisManager.TOP_HALF_MIN_INSET = 10;
_SynopsisManager.TOP_HALF_MAX_INSET = 48;
var SynopsisManager = _SynopsisManager;

// src/renderer/gossamerLayer.ts
init_gossamer();
function getCSSVar(varName, fallback) {
  return getComputedStyle(document.documentElement).getPropertyValue(varName).trim() || fallback;
}
function mapScoreToRadius(score, inner, outer) {
  const clamped = Math.max(0, Math.min(100, score));
  return inner + clamped / 100 * (outer - inner);
}
function renderGossamerLayer(scenes, run, polar, anglesByBeat, beatPathByName, overlayRuns, minBand, spokeEndRadius, publishStageColorByBeat, beatSlicesByName, publishStageColors, hasAnyScores = false) {
  var _a;
  if (!run) return "";
  const beatStatusMap = new Map(run.beats.map((b) => [b.beat, b.status]));
  const outOfRangeBeats = new Set(run.beats.filter((b) => b.isOutOfRange).map((b) => b.beat));
  const defaultColor = getCSSVar("--rt-gossamer-default-color", "#7a7a7a");
  const mostAdvancedColor = publishStageColors ? getMostAdvancedStageColor(scenes, publishStageColors) : Array.from((publishStageColorByBeat == null ? void 0 : publishStageColorByBeat.values()) || [])[0] || defaultColor;
  const selectedBeatModel = (_a = run == null ? void 0 : run.meta) == null ? void 0 : _a.model;
  const beatOrder = extractBeatOrder(scenes, selectedBeatModel);
  if (!beatOrder.length) {
    return "";
  }
  const localAngles = (() => {
    const m = /* @__PURE__ */ new Map();
    const fallbackAngles = beatOrder.map((_, i) => -Math.PI / 2 + i / beatOrder.length * 2 * Math.PI);
    beatOrder.forEach((name, idx) => m.set(name, fallbackAngles[idx]));
    if (anglesByBeat) {
      anglesByBeat.forEach((val, key) => {
        m.set(key, val);
      });
    }
    return m;
  })();
  const present = extractPresentBeatScores(run);
  const { innerRadius, outerRadius } = polar;
  const nameToScore = new Map(present.map((p) => [p.beat, p.score]));
  const segments = [];
  let current = [];
  const scoreTexts = [];
  const spokes = [];
  const beatOutlines = [];
  const rangeSquares = [];
  beatOrder.forEach((name) => {
    var _a2;
    const angle = localAngles.get(name);
    if (typeof angle !== "number") return;
    const beatColor = (publishStageColorByBeat == null ? void 0 : publishStageColorByBeat.get(name)) || mostAdvancedColor;
    const score = nameToScore.get(name);
    const beatData = run.beats.find((b) => b.beat === name);
    const beatStatus = beatStatusMap.get(name);
    const spokeEnd = spokeEndRadius != null ? spokeEndRadius : outerRadius;
    const sx1 = innerRadius * Math.cos(angle);
    const sy1 = innerRadius * Math.sin(angle);
    const sx2 = spokeEnd * Math.cos(angle);
    const sy2 = spokeEnd * Math.sin(angle);
    spokes.push(`<line class="rt-gossamer-spoke" data-beat="${escapeAttr(name)}" x1="${fmt(sx1)}" y1="${fmt(sy1)}" x2="${fmt(sx2)}" y2="${fmt(sy2)}" stroke="${beatColor}"/>`);
    if (beatSlicesByName) {
      const sliceInfo = beatSlicesByName.get(name);
      if (sliceInfo) {
        const arcPath2 = buildCellArcPath(sliceInfo.innerR, sliceInfo.outerR, sliceInfo.startAngle, sliceInfo.endAngle);
        beatOutlines.push(`<path class="rt-gossamer-beat-outline" d="${arcPath2}" stroke="${beatColor}" data-beat="${escapeAttr(name)}"/>`);
      }
    }
    if (beatData == null ? void 0 : beatData.range) {
      const range = beatData.range;
      const minRadius = mapScoreToRadius(range.min, innerRadius, outerRadius);
      const maxRadius = mapScoreToRadius(range.max, innerRadius, outerRadius);
      const rangeMinX = minRadius * Math.cos(angle);
      const rangeMinY = minRadius * Math.sin(angle);
      const rangeMaxX = maxRadius * Math.cos(angle);
      const rangeMaxY = maxRadius * Math.sin(angle);
      const idealRangeWidth = getCSSVar("--rt-gossamer-ideal-range-width", "6px");
      spokes.push(`<line class="rt-gossamer-ideal-range" data-beat="${escapeAttr(name)}" x1="${fmt(rangeMinX)}" y1="${fmt(rangeMinY)}" x2="${fmt(rangeMaxX)}" y2="${fmt(rangeMaxY)}" stroke="${beatColor}" stroke-width="${idealRangeWidth}"/>`);
      rangeSquares.push(`<text class="rt-gossamer-range-value" data-beat="${escapeAttr(name)}" x="${fmt(rangeMinX)}" y="${fmt(rangeMinY + 1)}">${range.min}</text>`);
      rangeSquares.push(`<text class="rt-gossamer-range-value" data-beat="${escapeAttr(name)}" x="${fmt(rangeMaxX)}" y="${fmt(rangeMaxY + 1)}">${range.max}</text>`);
    }
    const isMissingInSequence = beatStatus === "outlineOnly";
    const displayScore = typeof score === "number" ? score : isMissingInSequence && hasAnyScores ? 0 : null;
    if (displayScore !== null) {
      const r = mapScoreToRadius(displayScore, innerRadius, outerRadius);
      const x = r * Math.cos(angle);
      const y = r * Math.sin(angle);
      current.push({ x, y });
      const path = (beatPathByName == null ? void 0 : beatPathByName.get(name)) || "";
      const encodedPath = path ? encodeURIComponent(path) : "";
      const data = `data-beat="${escapeAttr(name)}" data-score="${String(displayScore)}"${encodedPath ? ` data-path="${escapeAttr(encodedPath)}"` : ""}${((_a2 = run == null ? void 0 : run.meta) == null ? void 0 : _a2.label) ? ` data-label="${escapeAttr(run.meta.label)}"` : ""}`;
      scoreTexts.push(`<text class="rt-gossamer-score-text${isMissingInSequence ? " rt-gossamer-missing-data" : ""}" x="${fmt(x)}" y="${fmt(y + 1)}" ${data}>${displayScore}</text>`);
      if ((beatData == null ? void 0 : beatData.range) && typeof score === "number") {
        const range = beatData.range;
        const scoreRadius = mapScoreToRadius(score, innerRadius, outerRadius);
        const isInRange = score >= range.min && score <= range.max;
        const isBelowRange = score < range.min;
        const isAboveRange = score > range.max;
        let segmentStart;
        let segmentEnd;
        if (isInRange) {
          const distToMin = Math.abs(score - range.min);
          const distToMax = Math.abs(score - range.max);
          const targetBoundary = distToMin < distToMax ? range.min : range.max;
          segmentStart = scoreRadius;
          segmentEnd = mapScoreToRadius(targetBoundary, innerRadius, outerRadius);
        } else {
          if (isBelowRange) {
            segmentStart = scoreRadius;
            segmentEnd = mapScoreToRadius(range.min, innerRadius, outerRadius);
          } else {
            segmentStart = scoreRadius;
            segmentEnd = mapScoreToRadius(range.max, innerRadius, outerRadius);
          }
        }
        const segX1 = segmentStart * Math.cos(angle);
        const segY1 = segmentStart * Math.sin(angle);
        const segX2 = segmentEnd * Math.cos(angle);
        const segY2 = segmentEnd * Math.sin(angle);
        let segmentClass;
        if (isInRange) {
          segmentClass = "rt-gossamer-range-segment rt-in-range";
        } else if (isAboveRange) {
          segmentClass = "rt-gossamer-range-segment rt-above-range";
        } else {
          segmentClass = "rt-gossamer-range-segment rt-below-range";
        }
        spokes.push(`<line class="${segmentClass}" data-beat="${escapeAttr(name)}" x1="${fmt(segX1)}" y1="${fmt(segY1)}" x2="${fmt(segX2)}" y2="${fmt(segY2)}"/>`);
      }
    }
  });
  if (current.length > 1) segments.push(buildPath(current));
  if (segments.length === 0 && scoreTexts.length === 0 && spokes.length === 0 && beatOutlines.length === 0) return "";
  let bandSvg = "";
  if (minBand && minBand.min && minBand.max) {
    const minPts = toPoints(minBand.min, localAngles, innerRadius, outerRadius);
    const maxPts = toPoints(minBand.max, localAngles, innerRadius, outerRadius);
    if (minPts.length >= 2 && maxPts.length >= 2) {
      const maxPath = buildBezierPath(maxPts, true);
      const minPathForward = buildBezierPath(minPts, true);
      const minPathReversed = reverseSvgPath(minPathForward);
      const bandPath = `${maxPath} ${minPathReversed} Z`;
      const bandOpacity = getCSSVar("--rt-gossamer-band-opacity", "0.5");
      const lightColor = lightenColor(mostAdvancedColor, 70);
      bandSvg = `<path class="rt-gossamer-band" d="${bandPath}" fill="${lightColor}" fill-opacity="${bandOpacity}"/>`;
    }
  }
  const overlayPathsWithColors = [];
  const overlayDots = [];
  if (overlayRuns && overlayRuns.length > 0) {
    [...overlayRuns].reverse().forEach((ov) => {
      const path = buildOverlayPath(ov.points, localAngles, innerRadius, outerRadius);
      if (path) {
        const historicalColor = getCSSVar("--rt-gossamer-historical-color", "#c0c0c0");
        overlayPathsWithColors.push({
          path,
          color: ov.color || historicalColor
        });
      }
      const historicalDotRadius = getCSSVar("--rt-gossamer-dot-historical", "5");
      ov.points.forEach((point) => {
        const angle = localAngles.get(point.beat);
        if (typeof angle === "number") {
          const r = mapScoreToRadius(point.score, innerRadius, outerRadius);
          const x = r * Math.cos(angle);
          const y = r * Math.sin(angle);
          const errorColor = getCSSVar("--rt-gossamer-error-color", "#ff4444");
          const historicalColor = getCSSVar("--rt-gossamer-historical-color", "#c0c0c0");
          const dotColor = point.score === 0 ? errorColor : ov.color || historicalColor;
          overlayDots.push(`<circle class="rt-gossamer-dot-historical" cx="${fmt(x)}" cy="${fmt(y)}" r="${historicalDotRadius}" fill="${dotColor}" data-beat="${escapeAttr(point.beat)}" pointer-events="none"/>`);
        }
      });
    });
  }
  const overlaySvg = overlayPathsWithColors.map(({ path, color }) => `<path class="rt-gossamer-line rt-gossamer-overlay" d="${path}" stroke="${color}"/>`).join("");
  const overlayDotsSvg = overlayDots.join("");
  const mainPaths = segments.map((d) => `<path class="rt-gossamer-line" d="${d}"/>`).join("");
  const scoreTextsSvg = scoreTexts.join("");
  const spokesSvg = spokes.join("");
  const beatOutlinesSvg = beatOutlines.join("");
  const rangeMarkersSvg = rangeSquares.join("");
  return `<g class="rt-gossamer-layer">${bandSvg}${overlaySvg}${mainPaths}${spokesSvg}${beatOutlinesSvg}${overlayDotsSvg}${rangeMarkersSvg}${scoreTextsSvg}</g>`;
}
function buildBezierPath(points, startWithMove = true) {
  if (!points.length) return "";
  if (points.length === 1) {
    return startWithMove ? `M ${fmt(points[0].x)} ${fmt(points[0].y)}` : `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
  }
  if (points.length === 2) {
    const start = startWithMove ? `M ${fmt(points[0].x)} ${fmt(points[0].y)}` : `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
    return `${start} L ${fmt(points[1].x)} ${fmt(points[1].y)}`;
  }
  let path = startWithMove ? `M ${fmt(points[0].x)} ${fmt(points[0].y)}` : `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
  for (let i = 0; i < points.length - 1; i++) {
    const current = points[i];
    const next = points[i + 1];
    const prev = i > 0 ? points[i - 1] : current;
    const afterNext = i < points.length - 2 ? points[i + 2] : next;
    const distCurrNext = Math.sqrt((next.x - current.x) ** 2 + (next.y - current.y) ** 2);
    const distPrevCurr = Math.sqrt((current.x - prev.x) ** 2 + (current.y - prev.y) ** 2);
    const distNextAfter = Math.sqrt((afterNext.x - next.x) ** 2 + (afterNext.y - next.y) ** 2);
    let tension = 0.25;
    const avgDist = (distPrevCurr + distCurrNext + distNextAfter) / 3;
    if (avgDist < 50) {
      tension = 0.1;
    } else if (avgDist < 100) {
      tension = 0.15;
    }
    if (i > 0 && i < points.length - 1) {
      const v1x = current.x - prev.x;
      const v1y = current.y - prev.y;
      const v2x = next.x - current.x;
      const v2y = next.y - current.y;
      const dot = v1x * v2x + v1y * v2y;
      const mag1 = Math.sqrt(v1x * v1x + v1y * v1y);
      const mag2 = Math.sqrt(v2x * v2x + v2y * v2y);
      if (mag1 > 0 && mag2 > 0) {
        const cosAngle = dot / (mag1 * mag2);
        if (cosAngle < 0.5) {
          tension *= 0.5;
        }
      }
    }
    const maxControlDist = distCurrNext * 0.4;
    let cp1x = current.x + (next.x - prev.x) * tension;
    let cp1y = current.y + (next.y - prev.y) * tension;
    const cp1dist = Math.sqrt((cp1x - current.x) ** 2 + (cp1y - current.y) ** 2);
    if (cp1dist > maxControlDist && cp1dist > 0) {
      const scale = maxControlDist / cp1dist;
      cp1x = current.x + (cp1x - current.x) * scale;
      cp1y = current.y + (cp1y - current.y) * scale;
    }
    let cp2x = next.x - (afterNext.x - current.x) * tension;
    let cp2y = next.y - (afterNext.y - current.y) * tension;
    const cp2dist = Math.sqrt((cp2x - next.x) ** 2 + (cp2y - next.y) ** 2);
    if (cp2dist > maxControlDist && cp2dist > 0) {
      const scale = maxControlDist / cp2dist;
      cp2x = next.x + (cp2x - next.x) * scale;
      cp2y = next.y + (cp2y - next.y) * scale;
    }
    path += ` C ${fmt(cp1x)} ${fmt(cp1y)}, ${fmt(cp2x)} ${fmt(cp2y)}, ${fmt(next.x)} ${fmt(next.y)}`;
  }
  return path;
}
function buildPath(points) {
  return buildBezierPath(points, true);
}
function reverseSvgPath(path) {
  const segments = [];
  const regex = /([MLC])\s*([\d.\s,-]+)/g;
  let match;
  while ((match = regex.exec(path)) !== null) {
    const cmd = match[1];
    const coords = match[2].trim().split(/[\s,]+/).map(parseFloat);
    segments.push({ cmd, coords });
  }
  if (segments.length === 0) return "";
  const points = [];
  segments.forEach((seg, idx) => {
    if (seg.cmd === "M" || seg.cmd === "L") {
      points.push({ x: seg.coords[0], y: seg.coords[1] });
    } else if (seg.cmd === "C") {
      const prevPoint = points[points.length - 1];
      if (prevPoint) {
        prevPoint.cp2 = { x: seg.coords[0], y: seg.coords[1] };
      }
      points.push({
        x: seg.coords[4],
        y: seg.coords[5],
        cp1: { x: seg.coords[2], y: seg.coords[3] }
        // Control point entering this point
      });
    }
  });
  if (points.length < 2) return `L ${fmt(points[0].x)} ${fmt(points[0].y)}`;
  let reversedPath = `L ${fmt(points[points.length - 1].x)} ${fmt(points[points.length - 1].y)}`;
  for (let i = points.length - 1; i > 0; i--) {
    const current = points[i];
    const prev = points[i - 1];
    if (current.cp1 && prev.cp2) {
      reversedPath += ` C ${fmt(current.cp1.x)} ${fmt(current.cp1.y)}, ${fmt(prev.cp2.x)} ${fmt(prev.cp2.y)}, ${fmt(prev.x)} ${fmt(prev.y)}`;
    } else {
      reversedPath += ` L ${fmt(prev.x)} ${fmt(prev.y)}`;
    }
  }
  return reversedPath;
}
function fmt(n) {
  return n.toFixed(6).replace(/\.0+$/, "");
}
function toPoints(series, angles, inner, outer) {
  const pts = [];
  series.forEach((p) => {
    const a = angles.get(p.beat);
    if (typeof a !== "number") return;
    const r = mapScoreToRadius(p.score, inner, outer);
    pts.push({ x: r * Math.cos(a), y: r * Math.sin(a) });
  });
  return pts;
}
function buildOverlayPath(points, angles, inner, outer) {
  const pts = toPoints(points, angles, inner, outer);
  if (pts.length < 2) return null;
  return buildBezierPath(pts, true);
}
function escapeAttr(s) {
  return (s || "").replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function buildCellArcPath(innerR, outerR, startAngle, endAngle) {
  const x1 = innerR * Math.cos(startAngle);
  const y1 = innerR * Math.sin(startAngle);
  const x2 = outerR * Math.cos(startAngle);
  const y2 = outerR * Math.sin(startAngle);
  const x3 = outerR * Math.cos(endAngle);
  const y3 = outerR * Math.sin(endAngle);
  const x4 = innerR * Math.cos(endAngle);
  const y4 = innerR * Math.sin(endAngle);
  const largeArc = endAngle - startAngle > Math.PI ? 1 : 0;
  return `M ${fmt(x1)} ${fmt(y1)} L ${fmt(x2)} ${fmt(y2)} A ${fmt(outerR)} ${fmt(outerR)} 0 ${largeArc} 1 ${fmt(x3)} ${fmt(y3)} L ${fmt(x4)} ${fmt(y4)} A ${fmt(innerR)} ${fmt(innerR)} 0 ${largeArc} 0 ${fmt(x1)} ${fmt(y1)} Z`;
}

// src/renderer/components/MonthSpokes.ts
init_svg();
var normalizeAngle2 = (angle) => {
  const twoPi = Math.PI * 2;
  let normalized = angle % twoPi;
  if (normalized > Math.PI) {
    normalized -= twoPi;
  } else if (normalized <= -Math.PI) {
    normalized += twoPi;
  }
  return normalized;
};
function renderMonthSpokesAndInnerLabels(params) {
  const { months, lineInnerRadius, lineOuterRadius, currentMonthIndex, includeIntermediateSpokes = false, outerSpokeInnerRadius } = params;
  const innerSpokeStart = lineInnerRadius - 5;
  const innerSpokeEnd = lineInnerRadius + 30;
  let svg = '<g class="month-spokes">';
  months.forEach(({ name, angle }, monthIndex) => {
    const isActBoundary = [0, 4, 8].includes(monthIndex);
    const isPastMonth = monthIndex < currentMonthIndex;
    const innerX1 = formatNumber(innerSpokeStart * Math.cos(angle));
    const innerY1 = formatNumber(innerSpokeStart * Math.sin(angle));
    const innerX2 = formatNumber(innerSpokeEnd * Math.cos(angle));
    const innerY2 = formatNumber(innerSpokeEnd * Math.sin(angle));
    svg += `
      <line  
        x1="${innerX1}"
        y1="${innerY1}"
        x2="${innerX2}"
        y2="${innerY2}"
        class="rt-month-spoke-line rt-inner-calendar-spoke${isActBoundary ? " rt-act-boundary" : ""}${isPastMonth ? " rt-past-month" : ""}"
      />`;
    if (outerSpokeInnerRadius !== void 0) {
      const outerX1 = formatNumber(outerSpokeInnerRadius * Math.cos(angle));
      const outerY1 = formatNumber(outerSpokeInnerRadius * Math.sin(angle));
      const outerX2 = formatNumber(lineOuterRadius * Math.cos(angle));
      const outerY2 = formatNumber(lineOuterRadius * Math.sin(angle));
      const dashOffset = isActBoundary ? "" : ' stroke-dashoffset="2"';
      svg += `
      <line  
        x1="${outerX1}"
        y1="${outerY1}"
        x2="${outerX2}"
        y2="${outerY2}"
        class="rt-month-spoke-line${isActBoundary ? " rt-act-boundary" : ""}${isPastMonth ? " rt-past-month" : ""}"${dashOffset}
      />`;
    }
    const innerLabelRadius = lineInnerRadius;
    const pixelToRadian = 5 * 2 * Math.PI / (2 * Math.PI * innerLabelRadius);
    const startAngle = angle + pixelToRadian;
    const endAngle = angle + Math.PI / 6;
    const innerPathId = `innerMonthPath-${name}`;
    svg += `
      <path id="${innerPathId}"
        d="
          M ${formatNumber(innerLabelRadius * Math.cos(startAngle))} ${formatNumber(innerLabelRadius * Math.sin(startAngle))}
          A ${formatNumber(innerLabelRadius)} ${formatNumber(innerLabelRadius)} 0 0 1 ${formatNumber(innerLabelRadius * Math.cos(endAngle))} ${formatNumber(innerLabelRadius * Math.sin(endAngle))}
        "
        fill="none"
      />
      <text class="rt-month-label" ${isPastMonth ? 'opacity="0.5"' : ""}>
        <textPath href="#${innerPathId}" startOffset="0" text-anchor="start">
          ${months[monthIndex].shortName}
        </textPath>
      </text>
    `;
  });
  if (includeIntermediateSpokes && months.length > 0 && outerSpokeInnerRadius !== void 0) {
    const multiplier = 3;
    const majorStep = 2 * Math.PI / months.length;
    for (let monthIndex = 0; monthIndex < months.length; monthIndex++) {
      for (let step = 1; step < multiplier; step++) {
        const rawAngle = months[monthIndex].angle + majorStep * step / multiplier;
        const angle = normalizeAngle2(rawAngle);
        const x1 = formatNumber(outerSpokeInnerRadius * Math.cos(angle));
        const y1 = formatNumber(outerSpokeInnerRadius * Math.sin(angle));
        const x2 = formatNumber(lineOuterRadius * Math.cos(angle));
        const y2 = formatNumber(lineOuterRadius * Math.sin(angle));
        svg += `
      <line
        x1="${x1}"
        y1="${y1}"
        x2="${x2}"
        y2="${y2}"
        class="rt-month-spoke-line rt-month-spoke-intermediate"
        stroke-dashoffset="2"
      />`;
      }
    }
  }
  svg += "</g>";
  return svg;
}
function renderGossamerMonthSpokes(params) {
  const { innerRadius, outerRadius } = params;
  let spokesHtml = "";
  for (let i = 0; i < 12; i++) {
    const angle = i / 12 * 2 * Math.PI - Math.PI / 2;
    const x1 = formatNumber(innerRadius * Math.cos(angle));
    const y1 = formatNumber(innerRadius * Math.sin(angle));
    const x2 = formatNumber(outerRadius * Math.cos(angle));
    const y2 = formatNumber(outerRadius * Math.sin(angle));
    const isActBoundary = [0, 4, 8].includes(i);
    spokesHtml += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" class="rt-month-spoke-line rt-gossamer-grid-spoke${isActBoundary ? " rt-act-boundary" : ""}"/>`;
  }
  return `<g class="rt-gossamer-spokes">${spokesHtml}</g>`;
}

// src/renderer/components/ProgressRing.ts
function renderProgressRing(params) {
  const { progressRadius, yearProgress, currentYearStartAngle, segmentCount = 6 } = params;
  const fullCircleAngle = 2 * Math.PI;
  const segmentAngle = fullCircleAngle / segmentCount;
  const completeSegments = Math.floor(yearProgress * segmentCount);
  const partialSegmentAngle = (yearProgress * segmentCount - completeSegments) * segmentAngle;
  let svg = "";
  for (let i = 0; i < segmentCount; i++) {
    const segStart = currentYearStartAngle + i * segmentAngle;
    let segEnd = segStart + segmentAngle;
    if (i > completeSegments) continue;
    if (i === completeSegments && partialSegmentAngle > 0) {
      segEnd = segStart + partialSegmentAngle;
    }
    svg += `
            <path
                d="
                    M ${progressRadius * Math.cos(segStart)} ${progressRadius * Math.sin(segStart)}
                    A ${progressRadius} ${progressRadius} 0 ${segEnd - segStart > Math.PI ? 1 : 0} 1 
                    ${progressRadius * Math.cos(segEnd)} ${progressRadius * Math.sin(segEnd)}
                "
                class="progress-ring-fill"
                stroke="url(#linearColors${i + 1})"
            />
        `;
  }
  return svg;
}

// src/renderer/components/ProgressTicks.ts
init_svg();
function renderTargetDateTick(params) {
  const { plugin, progressRadius, dateToAngle: dateToAngle2 } = params;
  let targetDateAngle = -Math.PI / 2;
  if (plugin.settings.targetCompletionDate) {
    try {
      const targetDate = /* @__PURE__ */ new Date(plugin.settings.targetCompletionDate + "T00:00:00");
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      if (!isNaN(targetDate.getTime()) && targetDate > today) {
        targetDateAngle = dateToAngle2(targetDate);
      }
    } catch (e) {
    }
  }
  const targetTickOuterRadius = progressRadius + 5;
  const targetTickInnerRadius = progressRadius - 35;
  const targetMarkerSize = 8;
  const line = `
        <line
            x1="${formatNumber(targetTickOuterRadius * Math.cos(targetDateAngle))}"
            y1="${formatNumber(targetTickOuterRadius * Math.sin(targetDateAngle))}"
            x2="${formatNumber((targetTickInnerRadius + 3) * Math.cos(targetDateAngle))}"
            y2="${formatNumber((targetTickInnerRadius + 3) * Math.sin(targetDateAngle))}"
            class="target-date-tick"
        />`;
  const markerX = formatNumber(targetTickInnerRadius * Math.cos(targetDateAngle) - targetMarkerSize / 2);
  const markerY = formatNumber(targetTickInnerRadius * Math.sin(targetDateAngle) - targetMarkerSize / 2);
  const marker = `
        <rect x="${markerX}" y="${markerY}" width="${targetMarkerSize}" height="${targetMarkerSize}" class="target-date-marker" />`;
  return `${line}
${marker}`;
}

// src/renderer/components/Progress.ts
init_svg();
init_date();
function renderEstimatedDateElements(params) {
  const { estimateDate, progressRadius } = params;
  let absoluteDatePos;
  if (estimateDate === null) {
    absoluteDatePos = -Math.PI / 2;
  } else {
    absoluteDatePos = dateToAngle(estimateDate);
  }
  const tickOuterRadius = progressRadius + 5;
  const tickInnerRadius = progressRadius - 35;
  const tickOuterX = tickOuterRadius * Math.cos(absoluteDatePos);
  const tickOuterY = tickOuterRadius * Math.sin(absoluteDatePos);
  const tickInnerX = tickInnerRadius * Math.cos(absoluteDatePos);
  const tickInnerY = tickInnerRadius * Math.sin(absoluteDatePos);
  let svg = "";
  if ([tickOuterX, tickOuterY, tickInnerX, tickInnerY].every((v) => Number.isFinite(v))) {
    svg += `
      <line x1="${formatNumber(tickOuterX)}" y1="${formatNumber(tickOuterY)}" x2="${formatNumber(tickInnerX)}" y2="${formatNumber(tickInnerY)}" class="estimated-date-tick" />
      <circle cx="${formatNumber(tickInnerX)}" cy="${formatNumber(tickInnerY)}" r="4" class="estimated-date-dot" />
    `;
  }
  const displayDate = estimateDate === null ? new Date((/* @__PURE__ */ new Date()).getFullYear(), 0, 1) : estimateDate;
  const dateFormatter = new Intl.DateTimeFormat("en-US", { month: "short", day: "numeric" });
  const dateDisplay = dateFormatter.format(displayDate);
  const labelRadius = progressRadius - 45;
  const maxOffset = -18;
  const offsetX = maxOffset * Math.cos(absoluteDatePos);
  const maxYOffset = 5;
  const offsetY = -maxYOffset * Math.sin(absoluteDatePos);
  const labelXNum = labelRadius * Math.cos(absoluteDatePos) + offsetX;
  const labelYNum = labelRadius * Math.sin(absoluteDatePos) + offsetY;
  if (Number.isFinite(labelXNum) && Number.isFinite(labelYNum)) {
    const labelX = formatNumber(labelXNum);
    const labelY = formatNumber(labelYNum);
    svg += `
      <text x="${labelX}" y="${labelY}" text-anchor="middle" dominant-baseline="middle" class="estimation-date-label">${dateDisplay}</text>
    `;
  }
  return svg;
}
function renderEstimationArc(params) {
  const { estimateDate, progressRadius } = params;
  if (estimateDate === null) {
    return "";
  }
  const startAngle = -Math.PI / 2;
  const estimatedDateAngle = dateToAngle(estimateDate);
  let arcAngleSpan = estimatedDateAngle - startAngle;
  if (arcAngleSpan < 0) arcAngleSpan += 2 * Math.PI;
  const x0 = progressRadius * Math.cos(startAngle);
  const y0 = progressRadius * Math.sin(startAngle);
  const x1 = progressRadius * Math.cos(estimatedDateAngle);
  const y1 = progressRadius * Math.sin(estimatedDateAngle);
  if (![x0, y0, x1, y1].every(Number.isFinite)) return "";
  return `
    <path d="M ${x0} ${y0} A ${progressRadius} ${progressRadius} 0 ${arcAngleSpan > Math.PI ? 1 : 0} 1 ${x1} ${y1}" class="progress-ring-base" />
  `;
}

// src/services/RendererService.ts
init_date();

// src/renderer/dom/SceneDOMUpdater.ts
function updateSceneColors(svg, plugin, changedScenes) {
  try {
    const subplotColors = plugin.settings.subplotColors || [];
    const masterSubplotOrder = getMasterSubplotOrder(svg);
    let updated = false;
    changedScenes.forEach((scene) => {
      if (!scene.path) return;
      const encodedPath = encodeURIComponent(scene.path);
      const sceneGroups = svg.querySelectorAll(`[data-path="${encodedPath}"]`);
      sceneGroups.forEach((group) => {
        const subplot = scene.subplot || "Main Plot";
        const subplotIndex = masterSubplotOrder.indexOf(subplot);
        if (subplotIndex === -1) return;
        const arc = group.querySelector(".rt-scene-arc");
        if (arc) {
          const color = subplotColors[subplotIndex % subplotColors.length] || "#cccccc";
          arc.setAttribute("fill", color);
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[SceneDOMUpdater] Failed to update scene colors:", error);
    return false;
  }
}
function getMasterSubplotOrder(svg) {
  const labels = svg.querySelectorAll(".rt-subplot-ring-label-text");
  return Array.from(labels).map((label) => label.getAttribute("data-subplot-name")).filter((name) => name !== null);
}

// src/renderer/dom/NumberSquareDOMUpdater.ts
init_sceneHelpers();
function updateNumberSquareStates(svg, plugin, scenes) {
  try {
    let updated = false;
    scenes.forEach((scene) => {
      if (!scene.path) return;
      const encodedPath = encodeURIComponent(scene.path);
      const sceneGroups = svg.querySelectorAll(`.rt-scene-group[data-path="${encodedPath}"]`);
      sceneGroups.forEach((group) => {
        const scenePath = group.querySelector(".rt-scene-path");
        const sceneId = scenePath == null ? void 0 : scenePath.id;
        const numberSquare = sceneId ? svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`) : null;
        const numberText = sceneId ? svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`) : null;
        if (!numberSquare || !numberText) return;
        const { isSceneOpen, isSearchMatch, hasEdits } = getSceneState(scene, plugin);
        let newSquareClasses = buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits);
        let newTextClasses = buildTextClasses(isSceneOpen, isSearchMatch, hasEdits);
        if (shouldDisplayMissingWhenWarning(scene)) {
          newSquareClasses += " rt-missing-when";
          newTextClasses += " rt-missing-when";
        }
        if (plugin.settings.enableAiSceneAnalysis) {
          const existingClasses = numberText.getAttribute("class") || "";
          const gradeMatch = existingClasses.match(/rt-grade-([A-F])/);
          if (gradeMatch) {
            newTextClasses += ` rt-grade-${gradeMatch[1]}`;
          }
        }
        const currentSquareClasses = numberSquare.getAttribute("class");
        if (currentSquareClasses !== newSquareClasses) {
          numberSquare.setAttribute("class", newSquareClasses);
          updated = true;
        }
        const currentTextClasses = numberText.getAttribute("class");
        if (currentTextClasses !== newTextClasses) {
          numberText.setAttribute("class", newTextClasses);
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[NumberSquareDOMUpdater] Failed to update number squares:", error);
    return false;
  }
}

// src/renderer/dom/SynopsisDOMUpdater.ts
function updateSynopsisText(svg, changedScenes) {
  try {
    let updated = false;
    changedScenes.forEach((scene) => {
      if (!scene.path || !scene.synopsis) return;
      const encodedPath = encodeURIComponent(scene.path);
      const synopsisElements = svg.querySelectorAll(`[data-scene-path="${encodedPath}"] .rt-synopsis-text`);
      synopsisElements.forEach((element) => {
        const currentText = element.textContent || "";
        const newText = scene.synopsis || "";
        if (currentText !== newText) {
          element.textContent = newText;
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[SynopsisDOMUpdater] Failed to update synopsis:", error);
    return false;
  }
}

// src/renderer/dom/SubplotLabelDOMUpdater.ts
function updateSubplotLabels(svg, newLabels) {
  try {
    let updated = false;
    newLabels.forEach((newText, subplotName) => {
      const labelElements = svg.querySelectorAll(`[data-subplot-name="${subplotName}"] textPath`);
      labelElements.forEach((element) => {
        const currentText = element.textContent || "";
        if (currentText !== newText) {
          element.textContent = newText;
          updated = true;
        }
      });
    });
    return updated;
  } catch (error) {
    console.error("[SubplotLabelDOMUpdater] Failed to update subplot labels:", error);
    return false;
  }
}

// src/renderer/TimelineRenderer.ts
init_svg();
init_date();
init_text();
init_sceneHelpers();

// src/utils/numberSquareHelpers.ts
init_svg();
function makeSceneId(actIndex, ring, idx, isOuterAllScenes, isOuter) {
  return isOuterAllScenes && isOuter ? `scene-path-${actIndex}-${ring}-outer-${idx}` : `scene-path-${actIndex}-${ring}-${idx}`;
}
function generateNumberSquareGroup(squareX, squareY, squareSize, squareClasses, sceneId, number, textClasses, grade, options) {
  var _a;
  const cornerRadius = (_a = options == null ? void 0 : options.cornerRadius) != null ? _a : 0;
  const radiusAttr = cornerRadius > 0 ? ` rx="${cornerRadius}" ry="${cornerRadius}"` : "";
  const subplotAttr = (options == null ? void 0 : options.subplotIndex) !== void 0 ? ` data-subplot-idx="${options.subplotIndex}"` : "";
  return `
        <g class="number-square-group" transform="translate(${squareX}, ${squareY})">
            <g class="number-square-orient">
                <rect 
                    x="-${squareSize.width / 2}" 
                    y="-${squareSize.height / 2}" 
                    width="${squareSize.width}" 
                    height="${squareSize.height}" 
                    class="${squareClasses}" 
                    data-scene-id="${escapeXml(sceneId)}"
                    ${radiusAttr}${subplotAttr}
                />
                <text 
                    x="0" 
                    y="0" 
                    text-anchor="middle" 
                    dominant-baseline="middle" 
                    class="${textClasses}"
                    data-scene-id="${escapeXml(sceneId)}"
                    dy="0.1em"
                >${number}</text>
            </g>
        </g>
    `;
}

// src/renderer/layout/Rings.ts
function computeRingGeometry(params) {
  const { size, innerRadius, subplotOuterRadius, outerRadius, numRings, monthTickTerminal, monthTextInset } = params;
  if (!Number.isFinite(numRings) || numRings <= 0) {
    const lineInnerRadius2 = innerRadius;
    const lineOuterRadius2 = outerRadius;
    const monthLabelRadius2 = lineOuterRadius2 - monthTextInset;
    return { ringWidths: [], ringStartRadii: [], lineInnerRadius: lineInnerRadius2, lineOuterRadius: lineOuterRadius2, monthLabelRadius: monthLabelRadius2 };
  }
  const availableSpace = subplotOuterRadius - innerRadius;
  const reductionFactor = 1;
  const sumOfSeries = reductionFactor === 1 ? numRings : (1 - Math.pow(reductionFactor, numRings)) / (1 - reductionFactor);
  const initialRingWidth = availableSpace / sumOfSeries;
  const ringWidths = Array.from({ length: numRings }, (_, i) => initialRingWidth * Math.pow(reductionFactor, i));
  const ringStartRadii = ringWidths.reduce((acc, width, i) => {
    const previousRadius = i === 0 ? innerRadius : acc[i - 1] + ringWidths[i - 1];
    acc.push(previousRadius);
    return acc;
  }, []);
  const lineInnerRadius = ringStartRadii[0] - 20;
  const lineOuterRadius = outerRadius;
  const monthLabelRadius = lineOuterRadius - monthTextInset;
  return { ringWidths, ringStartRadii, lineInnerRadius, lineOuterRadius, monthLabelRadius };
}

// src/renderer/TimelineRenderer.ts
init_LayoutConstants();

// src/renderer/utils/SceneLayout.ts
init_LayoutConstants();
init_sceneHelpers();
function computePositions(innerR, outerR, startAngle, endAngle, items) {
  const middleRadius = (innerR + outerR) / 2;
  const plotAngularWidth = PLOT_PIXEL_WIDTH / middleRadius;
  const totalAngularSpace = endAngle - startAngle;
  const plotCount = items.filter((it) => isBeatNote(it)).length;
  const plotTotalAngularSpace = plotCount * plotAngularWidth;
  const sceneCount = items.filter((it) => !isBeatNote(it)).length;
  const sceneAngularSize = sceneCount > 0 ? (totalAngularSpace - plotTotalAngularSpace) / sceneCount : 0;
  let current = startAngle;
  const positions = /* @__PURE__ */ new Map();
  items.forEach((it, idx) => {
    if (isBeatNote(it)) {
      positions.set(idx, { startAngle: current, endAngle: current + plotAngularWidth, angularSize: plotAngularWidth });
      current += plotAngularWidth;
    } else {
      positions.set(idx, { startAngle: current, endAngle: current + sceneAngularSize, angularSize: sceneAngularSize });
      current += sceneAngularSize;
    }
  });
  return positions;
}

// src/renderer/utils/Performance.ts
function pushPerfRecord(plugin, record) {
  const host = plugin;
  if (!host._perfMeasurements) {
    host._perfMeasurements = [];
  }
  host._perfMeasurements.push(record);
  if (host._perfMeasurements.length > 200) {
    host._perfMeasurements.shift();
  }
}
function startPerfSegment(plugin, label) {
  const canMeasure = typeof performance !== "undefined" && typeof performance.now === "function";
  const start = canMeasure ? performance.now() : Date.now();
  return () => {
    const end = canMeasure ? performance.now() : Date.now();
    const duration = end - start;
    const record = { label, duration, timestamp: Date.now() };
    pushPerfRecord(plugin, record);
  };
}

// src/renderer/utils/SceneFill.ts
init_sceneHelpers();
init_text();
init_date();
function getFillForScene(scene, publishStageColors, subplotColorResolver, isOuterAllScenes) {
  if (isBeatNote(scene)) {
    return "#FFFFFF";
  }
  const statusList = Array.isArray(scene.status) ? scene.status : [scene.status];
  const norm = normalizeStatus(statusList[0]);
  const publishStage = scene["Publish Stage"] || "Zero";
  if (!norm) return `url(#plaidTodo${publishStage})`;
  if (norm === "Completed") {
    if (isOuterAllScenes && subplotColorResolver) {
      const subplotName = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
      return subplotColorResolver(subplotName);
    }
    const stageColor = publishStageColors[publishStage] || publishStageColors.Zero;
    return stageColor;
  }
  if (scene.due && isOverdueDateString(scene.due)) return STATUS_COLORS.Due;
  if (norm === "Working") return `url(#plaidWorking${publishStage})`;
  if (norm === "Todo") return `url(#plaidTodo${publishStage})`;
  return STATUS_COLORS[statusList[0]] || STATUS_COLORS.Todo;
}

// src/renderer/utils/LabelMetrics.ts
init_LayoutConstants();
function estimatePixelsFromTitle(title, fontPx, fudge, paddingPx) {
  const approxPerChar = fontPx * (CHAR_WIDTH_EM + LETTER_SPACING_EM) * fudge;
  return Math.max(0, title.length * approxPerChar + paddingPx);
}

// src/renderer/components/Grid.ts
function renderCenterGrid(params) {
  const {
    statusesForGrid,
    stagesForGrid,
    gridCounts,
    PUBLISH_STAGE_COLORS,
    currentYearLabel,
    estimatedTotalScenes,
    startXGrid,
    startYGrid,
    cellWidth,
    cellHeight,
    cellGapX,
    cellGapY,
    headerY
  } = params;
  const gridWidth = statusesForGrid.length * cellWidth + (statusesForGrid.length - 1) * cellGapX;
  const gridHeight = stagesForGrid.length * cellHeight + (stagesForGrid.length - 1) * cellGapY;
  const isStageCompleteForGridRow = (rowIndex, gridCountsIn, stages) => {
    const stage = stages[rowIndex];
    const rc = gridCountsIn[stage];
    const rowTotal = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0) + (rc.Completed || 0);
    const maxStageIdxForGrid = stages.reduce((acc, s, idx) => {
      const counts = gridCountsIn[s];
      const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
      return total > 0 ? Math.max(acc, idx) : acc;
    }, -1);
    if (rowTotal === 0 && maxStageIdxForGrid > rowIndex) {
      return true;
    }
    if (rowIndex === maxStageIdxForGrid) {
      const completed = rc.Completed || 0;
      const incomplete = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0);
      const thisStageComplete = completed > 0 && incomplete === 0;
      if (!thisStageComplete) return false;
      for (let i = 0; i < rowIndex; i++) {
        const prevStage = stages[i];
        const prevCounts = gridCountsIn[prevStage];
        const prevTotal = (prevCounts.Todo || 0) + (prevCounts.Working || 0) + (prevCounts.Due || 0) + (prevCounts.Completed || 0);
        const prevIncomplete = (prevCounts.Todo || 0) + (prevCounts.Working || 0) + (prevCounts.Due || 0);
        if (prevTotal > 0 && prevIncomplete > 0) {
          return false;
        }
      }
      return true;
    }
    return false;
  };
  const renderGridCell = (stage, status, x, y, count) => {
    let fillAttr = "";
    if (status === "Completed") {
      const solid = PUBLISH_STAGE_COLORS[stage] || "#888888";
      fillAttr = `fill="${solid}"`;
    } else if (status === "Working") {
      fillAttr = `fill="url(#plaidWorking${stage})"`;
    } else if (status === "Todo") {
      fillAttr = `fill="url(#plaidTodo${stage})"`;
    } else if (status === "Due") {
      fillAttr = `fill="var(--rt-color-due)"`;
    } else {
      fillAttr = `fill="#888888"`;
    }
    const cellOpacity = count <= 0 ? 0.1 : 1;
    return `
      <g transform="translate(${x}, ${y})">
        <rect x="0" y="0" width="${cellWidth}" height="${cellHeight}" ${fillAttr} fill-opacity="${cellOpacity}">
          ${count > 0 ? `<title>${stage} \u2022 ${status}: ${count}</title>` : ""}
        </rect>
        ${status === "Completed" && count > 0 ? `<text x="2" y="${cellHeight - 3}" text-anchor="start" dominant-baseline="alphabetic" class="grid-completed-count">${count}</text>` : ""}
      </g>
    `;
  };
  const header = `
    <g class="color-key-center">
      ${statusesForGrid.map((status, c) => {
    const label = status === "Todo" ? "Tdo" : status === "Working" ? "Wrk" : status === "Completed" ? "Cmt" : "Due";
    const x = startXGrid + c * (cellWidth + cellGapX) + cellWidth / 2;
    const y = headerY;
    const tip = params.statusTooltips[status] || status;
    return `
          <g class="status-header">
            <text x="${x}" y="${y}" text-anchor="middle" dominant-baseline="alphabetic" class="center-key-text status-header-letter">${label}</text>
            <rect x="${x - 18}" y="${y - 18}" width="36" height="24" fill="transparent" pointer-events="all">
              <title>${tip}</title>
            </rect>
          </g>
        `;
  }).join("")}
      <text x="${startXGrid + gridWidth}" y="${startYGrid + gridHeight + (cellGapY + 16)}" text-anchor="end" dominant-baseline="alphabetic" class="center-key-text">${currentYearLabel}//${estimatedTotalScenes}</text>
    `;
  const isBookComplete = (() => {
    const mostAdvancedStageIdx = stagesForGrid.reduce((acc, s, idx) => {
      const counts = gridCounts[s];
      const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
      return total > 0 ? Math.max(acc, idx) : acc;
    }, -1);
    if (mostAdvancedStageIdx === -1) return false;
    const finalStage = stagesForGrid[mostAdvancedStageIdx];
    if (finalStage !== "Press") return false;
    const pressCounts = gridCounts["Press"];
    const pressCompleted = pressCounts.Completed || 0;
    const pressIncomplete = (pressCounts.Todo || 0) + (pressCounts.Working || 0) + (pressCounts.Due || 0);
    return pressCompleted > 0 && pressIncomplete === 0;
  })();
  const rows = stagesForGrid.map((stage, r) => {
    const xh = startXGrid - 12;
    const yh = startYGrid + r * (cellHeight + cellGapY) + (cellHeight / 2 + 1);
    const stageTip = params.stageTooltips[stage] || stage;
    const stageHeader = `
      <g class="stage-header">
        <text x="${xh}" y="${yh}" text-anchor="end" dominant-baseline="middle" class="center-key-text stage-header-letter">${stage === "Zero" ? "Z" : stage === "Author" ? "A" : stage === "House" ? "H" : "P"}</text>
        <rect x="${xh - 14}" y="${yh - 14}" width="28" height="28" fill="transparent" pointer-events="all">
          <title>${stageTip}</title>
        </rect>
      </g>
    `;
    const cells = statusesForGrid.map((status, c) => {
      const count = gridCounts[stage][status] || 0;
      const x = startXGrid + c * (cellWidth + cellGapX);
      const y = startYGrid + r * (cellHeight + cellGapY);
      const completeRow = isStageCompleteForGridRow(r, gridCounts, stagesForGrid);
      if (completeRow) {
        const mostAdvancedStageIdx = stagesForGrid.reduce((acc, s, idx) => {
          const counts = gridCounts[s];
          const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
          return total > 0 ? Math.max(acc, idx) : acc;
        }, -1);
        const mostStage = stagesForGrid[Math.max(0, mostAdvancedStageIdx)];
        const solid = PUBLISH_STAGE_COLORS[mostStage] || "#888888";
        const iconId = isBookComplete ? "icon-smile" : "icon-bookmark-check";
        return `
          <g transform="translate(${x}, ${y})">
            <rect x="0" y="0" width="${cellWidth}" height="${cellHeight}" fill="${solid}">
              ${count > 0 ? `<title>${stage} \u2022 ${status}: ${count}</title>` : ""}
            </rect>
            <use href="#${iconId}" x="${(cellWidth - 18) / 2}" y="${(cellHeight - 18) / 2}" width="18" height="18" class="completed-icon" />
          </g>
        `;
      }
      return renderGridCell(stage, status, x, y, count);
    }).join("");
    return `${stageHeader}${cells}`;
  }).join("");
  const arrows = (() => {
    const maxStageIdxForGrid = stagesForGrid.reduce((acc, s, idx) => {
      const counts = gridCounts[s];
      const total = (counts.Todo || 0) + (counts.Working || 0) + (counts.Due || 0) + (counts.Completed || 0);
      return total > 0 ? Math.max(acc, idx) : acc;
    }, -1);
    if (maxStageIdxForGrid === -1) return "";
    return stagesForGrid.map((stage, r) => {
      let arrowId = "";
      if (r === maxStageIdxForGrid) arrowId = "icon-arrow-right-dash";
      else if (r < maxStageIdxForGrid) arrowId = "icon-arrow-down";
      else return "";
      const ax = startXGrid + gridWidth + 4;
      const ay = startYGrid + r * (cellHeight + cellGapY) + cellHeight / 2;
      return `<use href="#${arrowId}" x="${ax}" y="${ay - 12}" width="24" height="24" class="rt-grid-arrow" />`;
    }).join("");
  })();
  return `${header}${rows}${arrows}</g>`;
}

// src/renderer/layout/Paths.ts
init_svg();
function arcPath(radius, startAngle, endAngle) {
  return `
    M ${formatNumber(radius * Math.cos(startAngle))} ${formatNumber(radius * Math.sin(startAngle))}
    A ${formatNumber(radius)} ${formatNumber(radius)} 0 0 1 ${formatNumber(radius * Math.cos(endAngle))} ${formatNumber(radius * Math.sin(endAngle))}
  `;
}

// src/renderer/components/Months.ts
function renderMonthLabelDefs(params) {
  const { months, monthLabelRadius, chronologueDateRadius } = params;
  return months.map(({ angle, isFirst, isLast }, index) => {
    const angleOffset = 0.01;
    const startAngle = angle + angleOffset;
    const arcLength = isFirst || isLast ? Math.PI / 12 : Math.PI / 24;
    const endAngle = startAngle + arcLength;
    const pathId = `monthLabelPath-${index}`;
    let radius = isFirst || isLast ? chronologueDateRadius : monthLabelRadius;
    return `
      <path id="${pathId}" d="${arcPath(radius, startAngle, endAngle)}" fill="none" />
    `;
  }).join("");
}

// src/renderer/components/SubplotLabels.ts
init_svg();

// src/renderer/modules/ModeRenderingHelpers.ts
init_ModeDefinition();
init_ModeRegistry();
function shouldRenderStoryBeats(plugin) {
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  return modeDef.rendering.beatDisplay !== "none";
}
function shouldShowAllScenesInOuterRing(plugin) {
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  return modeDef.rendering.outerRingContent === "narrative" || modeDef.rendering.outerRingContent === "chronologue";
}
function getSubplotLabelText(plugin, subplot, isOuterRing) {
  if (!isOuterRing) {
    return subplot.toUpperCase();
  }
  const currentMode = plugin.settings.currentMode || "narrative" /* NARRATIVE */;
  const modeDef = getModeDefinition(currentMode);
  if (modeDef.rendering.outerRingContent === "narrative") {
    return "ALL SCENES";
  } else if (modeDef.rendering.outerRingContent === "subplot-only") {
    return "MAIN PLOT";
  } else if (modeDef.rendering.outerRingContent === "chronologue") {
    return "CHRONOLOGUE";
  }
  return subplot.toUpperCase();
}

// src/renderer/components/SubplotLabels.ts
function renderSubplotLabels(params) {
  const { NUM_RINGS, ringStartRadii, ringWidths, masterSubplotOrder, plugin } = params;
  const totalRings = NUM_RINGS;
  const subplotCount = masterSubplotOrder.length;
  const ringsToUse = Math.min(subplotCount, totalRings);
  let svg = "";
  const act = 3;
  for (let ringOffset = 0; ringOffset < ringsToUse; ringOffset++) {
    const ring = totalRings - ringOffset - 1;
    const subplot = masterSubplotOrder[ringOffset];
    if (!subplot) continue;
    const innerR = ringStartRadii[ring];
    const outerR = innerR + ringWidths[ring];
    const labelPathId = `subplot-label-path-${ring}`;
    const labelRadius = (innerR + outerR) / 2;
    const availableHeight = ringWidths[ring];
    const fontSize = Math.floor(availableHeight * 0.95);
    const arcLength = Math.PI / 2;
    const endAngle = -Math.PI / 2;
    const startAngle = endAngle - arcLength;
    const arcPixelLength = labelRadius * arcLength;
    const d = `M ${formatNumber(labelRadius * Math.cos(startAngle))} ${formatNumber(labelRadius * Math.sin(startAngle))} A ${formatNumber(labelRadius)} ${formatNumber(labelRadius)} 0 0 1 ${formatNumber(labelRadius * Math.cos(endAngle))} ${formatNumber(labelRadius * Math.sin(endAngle))}`;
    const isOuterRing = ringOffset === 0;
    const labelRaw = getSubplotLabelText(plugin, subplot, isOuterRing);
    svg += `
      <path id="${labelPathId}" d="${d}" fill="none" />
      <g class="subplot-label-group" data-font-size="${fontSize}">
        <text class="rt-subplot-ring-label-text" data-subplot-index="${ringOffset}" data-subplot-name="${escapeXml(subplot)}" text-anchor="end">
          <textPath href="#${labelPathId}" startOffset="100%" textLength="${formatNumber(arcPixelLength)}" lengthAdjust="spacingAndGlyphs">${escapeXml(labelRaw)}</textPath>
        </text>
      </g>
    `;
  }
  return svg;
}

// src/renderer/components/Defs.ts
function renderDefs(PUBLISH_STAGE_COLORS) {
  const plaid = Object.entries(PUBLISH_STAGE_COLORS).map(([stage, color]) => {
    return `
      <pattern id="plaidWorking${stage}" patternUnits="userSpaceOnUse" width="80" height="20" patternTransform="rotate(-20)">
        <rect width="80" height="20" fill="var(--rt-color-working)" opacity="var(--rt-color-plaid-opacity)"/>
        <path d="M 0 10 Q 2.5 -5, 5 10 Q 7.5 25, 10 10 Q 12.5 5, 15 10 Q 17.5 25, 20 10 Q 22.5 -5, 25 10 Q 27.5 25, 30 10 Q 32.5 5, 35 10 Q 37.5 25, 40 10 Q 42.5 -5, 45 10 Q 47.5 25, 50 10 Q 52.5 5, 55 10 Q 57.5 25, 60 10 Q 62.5 -5, 65 10 Q 67.5 25, 70 10 Q 72.5 5, 75 10 Q 77.5 25, 80 10" 
          stroke="${color}" stroke-opacity="var(--rt-color-plaid-stroke-opacity)" stroke-width="1.5" fill="none" />
      </pattern>

      <pattern id="plaidTodo${stage}" patternUnits="userSpaceOnUse" width="10" height="10" patternTransform="rotate(45)">
        <rect width="10" height="10" fill="var(--rt-color-todo)" opacity="var(--rt-color-plaid-opacity)"/>
        <line x1="0" y1="0" x2="0" y2="10" stroke="${color}" stroke-width="1.5" stroke-opacity="0.5"/>
        <line x1="0" y1="0" x2="10" y2="0" stroke="${color}" stroke-width="1.5" stroke-opacity="0.5"/>
      </pattern>
    `;
  }).join("");
  const icons = `
    <symbol id="icon-circle-slash" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <line x1="9" x2="15" y1="15" y2="9" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-smile" viewBox="0 0 24 24">
      <circle cx="12" cy="12" r="10" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M8 14s1.5 2 4 2 4-2 4-2" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
      <line x1="9" x2="9.01" y1="9" y2="9" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
      <line x1="15" x2="15.01" y1="9" y2="9" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-house" viewBox="0 0 24 24">
      <path d="M15 21v-8a1 1 0 0 0-1-1h-4a1 1 0 0 0-1 1v8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M3 10a2 2 0 0 1 .709-1.528l7-5.999a2 2 0 0 1 2.582 0l7 5.999A2 2 0 0 1 21 10v9a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-printer" viewBox="0 0 24 24">
      <path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M6 9V3a1 1 0 0 1 1-1h10a1 1 0 0 1 1 1v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <rect x="6" y="14" width="12" height="8" rx="1" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-arrow-right-dash" viewBox="0 0 24 24">
      <path d="M11 9a1 1 0 0 0 1-1V5.061a1 1 0 0 1 1.811-.75l6.836 6.836a1.207 1.207 0 0 1 0 1.707l-6.836 6.835a1 1 0 0 1-1.811-.75V16a1 1 0 0 0-1-1H9a1 1 0 0 1-1-1v-4a1 1 0 0 1 1-1z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="M4 9v6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </symbol>
    <symbol id="icon-arrow-down" viewBox="0 0 24 24">
      <path d="M15 11a1 1 0 0 0 1 1h2.939a1 1 0 0 1 .75 1.811l-6.835 6.836a1.207 1.207 0 0 1-1.707 0L4.31 13.81a1 1 0 0 1 .75-1.811H8a1 1 0 0 0 1-1V5a1 1 0 0 1 1-1h4a1 1 0 0 1 1 1z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </symbol>
    <symbol id="icon-bookmark-check" viewBox="0 0 24 24">
      <path d="m19 21-7-4-7 4V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2Z" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
      <path d="m9 10 2 2 4-4" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
    </symbol>
    <!-- Arrow Up/Down From Line (toggle rotation) -->
    <symbol id="icon-arrow-up-from-line" viewBox="0 0 24 24">
      <path d="m18 9-6-6-6 6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M12 3v14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M5 21h14" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
    <symbol id="icon-arrow-down-from-line" viewBox="0 0 24 24">
      <path d="M19 3H5" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="M12 21V7" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
      <path d="m6 15 6 6 6-6" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
    </symbol>
  `;
  const filters = `
    <filter id="beatTextBg" x="-25%" y="-25%" width="150%" height="150%">
      <feMorphology in="SourceAlpha" operator="dilate" radius="1.8" result="DILATE"/>
      <feFlood flood-color="#000000" result="BLACK"/>
      <feComposite in="BLACK" in2="DILATE" operator="in" result="BG"/>
      <feMerge>
        <feMergeNode in="BG"/>
        <feMergeNode in="SourceGraphic"/>
      </feMerge>
    </filter>
  `;
  return plaid + icons + filters;
}
function renderProgressRingGradients() {
  return `
    <defs>
      <linearGradient id="linearColors1" x1="0" y1="0" x2="1" y2="1">
        <stop offset="0%" stop-color="#FF0000"></stop>
        <stop offset="100%" stop-color="#FF7F00"></stop>
      </linearGradient>
      <linearGradient id="linearColors2" x1="0.5" y1="0" x2="0.5" y2="1">
        <stop offset="0%" stop-color="#FF7F00"></stop>
        <stop offset="100%" stop-color="#FFFF00"></stop>
      </linearGradient>
      <linearGradient id="linearColors3" x1="1" y1="0" x2="0" y2="1">
        <stop offset="0%" stop-color="#FFFF00"></stop>
        <stop offset="100%" stop-color="#00FF00"></stop>
      </linearGradient>
      <linearGradient id="linearColors4" x1="1" y1="1" x2="0" y2="0">
        <stop offset="0%" stop-color="#00FF00"></stop>
        <stop offset="100%" stop-color="#0000FF"></stop>
      </linearGradient>
      <linearGradient id="linearColors5" x1="0.5" y1="1" x2="0.5" y2="0">
        <stop offset="0%" stop-color="#0000FF"></stop>
        <stop offset="100%" stop-color="#4B0082"></stop>
      </linearGradient>
      <linearGradient id="linearColors6" x1="0" y1="1" x2="1" y2="0">
        <stop offset="0%" stop-color="#4B0082"></stop>
        <stop offset="100%" stop-color="#8F00FF"></stop>
      </linearGradient>
    </defs>`;
}

// src/renderer/components/SceneArcs.ts
init_svg();
function sceneArcPath(innerR, outerR, startAngle, endAngle) {
  return `
    M ${formatNumber(innerR * Math.cos(startAngle))} ${formatNumber(innerR * Math.sin(startAngle))}
    L ${formatNumber(outerR * Math.cos(startAngle))} ${formatNumber(outerR * Math.sin(startAngle))}
    A ${formatNumber(outerR)} ${formatNumber(outerR)} 0 0 1 ${formatNumber(outerR * Math.cos(endAngle))} ${formatNumber(outerR * Math.sin(endAngle))}
    L ${formatNumber(innerR * Math.cos(endAngle))} ${formatNumber(innerR * Math.sin(endAngle))}
    A ${formatNumber(innerR)} ${formatNumber(innerR)} 0 0 0 ${formatNumber(innerR * Math.cos(startAngle))} ${formatNumber(innerR * Math.sin(startAngle))}
  `;
}
function renderVoidCellPath(innerR, outerR, startAngle, endAngle) {
  const path = sceneArcPath(innerR, outerR, startAngle, endAngle);
  return `<path d="${path}" class="rt-void-cell"/>`;
}

// src/renderer/components/Beats.ts
init_svg();
function renderBeatGroup(params) {
  const { beat, act, ring, idx, innerR, outerR, startAngle, endAngle } = params;
  const groupId = `scene-group-${act}-${ring}-${idx}`;
  return `
    <g class="rt-scene-group beats" data-item-type="Beat" data-act="${act}" data-ring="${ring}" data-idx="${idx}" data-start-angle="${formatNumber(startAngle)}" data-end-angle="${formatNumber(endAngle)}" data-inner-r="${formatNumber(innerR)}" data-outer-r="${formatNumber(outerR)}" data-path="${beat.path ? encodeURIComponent(beat.path) : ""}" id="${groupId}">
  `;
}

// src/renderer/components/BeatSlices.ts
init_svg();
function renderBeatSlice(params) {
  const { act, ring, idx, innerR, outerR, startAngle, endAngle, sceneId, beat } = params;
  const pathD = sceneArcPath(innerR, outerR + 2, startAngle, endAngle);
  return `
    ${renderBeatGroup({ beat, act, ring, idx, innerR, outerR: outerR + 2, startAngle, endAngle })}
      <path id="${sceneId}" d="${pathD}" fill="#E6E6E6" class="rt-scene-path"/>
      <line x1="${formatNumber(innerR * Math.cos(endAngle))}" y1="${formatNumber(innerR * Math.sin(endAngle))}" x2="${formatNumber((outerR + 2) * Math.cos(endAngle))}" y2="${formatNumber((outerR + 2) * Math.sin(endAngle))}" stroke="#000000" stroke-width="1" shape-rendering="crispEdges" />
    </g>
  `;
}

// src/renderer/components/Acts.ts
init_svg();
function renderActBorders(params) {
  const { NUM_ACTS: NUM_ACTS2, innerRadius, outerRadius } = params;
  let svg = "";
  for (let act = 0; act < NUM_ACTS2; act++) {
    const angle = act * 2 * Math.PI / NUM_ACTS2 - Math.PI / 2;
    svg += `
      <line x1="${formatNumber(innerRadius * Math.cos(angle))}" y1="${formatNumber(innerRadius * Math.sin(angle))}"
            x2="${formatNumber(outerRadius * Math.cos(angle))}" y2="${formatNumber(outerRadius * Math.sin(angle))}"
            class="act-border" />
    `;
  }
  return svg;
}

// src/renderer/components/ActLabels.ts
init_svg();
function renderActLabels(params) {
  const { NUM_ACTS: NUM_ACTS2, outerMostOuterRadius, actLabelOffset, maxStageColor } = params;
  let svg = "";
  const actLabelRadius = outerMostOuterRadius + actLabelOffset;
  for (let act = 0; act < NUM_ACTS2; act++) {
    const angle = act * 2 * Math.PI / NUM_ACTS2 - Math.PI / 2;
    const angleOffset = -0.085;
    const startAngleAct = angle + angleOffset;
    const endAngleAct = startAngleAct + Math.PI / 12;
    const actPathId = `actPath-${act}`;
    svg += `
      <path id="${actPathId}" d="
        M ${formatNumber(actLabelRadius * Math.cos(startAngleAct))} ${formatNumber(actLabelRadius * Math.sin(startAngleAct))}
        A ${formatNumber(actLabelRadius)} ${formatNumber(actLabelRadius)} 0 0 1 ${formatNumber(actLabelRadius * Math.cos(endAngleAct))} ${formatNumber(actLabelRadius * Math.sin(endAngleAct))}
      " fill="none" />
      <text class="rt-act-label" fill="${maxStageColor}">
        <textPath href="#${actPathId}" startOffset="0" text-anchor="start">ACT ${act + 1}</textPath>
      </text>
    `;
  }
  return svg;
}

// src/renderer/components/Synopses.ts
function serializeSynopsesToString(synopsesElements) {
  const synopsesContainer = document.createElementNS("http://www.w3.org/2000/svg", "g");
  synopsesContainer.setAttribute("class", "synopses-container");
  synopsesElements.forEach((element) => {
    synopsesContainer.appendChild(element);
  });
  const serializer = new XMLSerializer();
  return serializer.serializeToString(synopsesContainer);
}

// src/renderer/components/Scenes.ts
init_svg();
init_sceneHelpers();
function renderSceneGroup(params) {
  const { scene, act, ring, idx, innerR, outerR, startAngle, endAngle, subplotIdxAttr } = params;
  const groupId = `scene-group-${act}-${ring}-${idx}`;
  return `
    <g class="rt-scene-group${isBeatNote(scene) ? " beats" : ""}" data-item-type="${isBeatNote(scene) ? "Beat" : "Scene"}" data-act="${act}" data-ring="${ring}" data-idx="${idx}" data-start-angle="${formatNumber(startAngle)}" data-end-angle="${formatNumber(endAngle)}" data-inner-r="${formatNumber(innerR)}" data-outer-r="${formatNumber(outerR)}" data-subplot-index="${String(subplotIdxAttr)}" data-path="${scene.path ? encodeURIComponent(scene.path) : ""}" id="${groupId}">
  `;
}

// src/renderer/components/NumberSquares.ts
init_sceneHelpers();
init_text();
function renderNumberSquaresUnified(params) {
  const {
    plugin,
    scenes,
    sceneGrades,
    positions,
    squareRadius,
    act,
    ringOuter,
    NUM_RINGS,
    masterSubplotOrder,
    ringStartRadii,
    ringWidths,
    scenesByActAndSubplot,
    sceneNumbersMap,
    enableSubplotColors = false,
    resolveSubplotVisual
  } = params;
  let svg = '<g class="rt-number-squares">';
  scenes.forEach((scene, idx) => {
    var _a;
    if (isBeatNote(scene)) return;
    const number = getScenePrefixNumber(scene.title, scene.number);
    if (!number) return;
    let sceneStartAngle;
    let textPathRadius;
    let sceneId;
    if (positions && squareRadius !== void 0 && act !== void 0 && ringOuter !== void 0) {
      const pos = positions.get(idx);
      if (!pos) return;
      sceneStartAngle = pos.startAngle;
      textPathRadius = squareRadius;
      sceneId = makeSceneId(act, ringOuter, idx, true, true);
    } else if (NUM_RINGS && masterSubplotOrder && ringStartRadii && ringWidths && scenesByActAndSubplot) {
      const subplot = scene.subplot || "Main Plot";
      const subplotIndex = masterSubplotOrder.indexOf(subplot);
      const ring = NUM_RINGS - 1 - subplotIndex;
      const currentMode = plugin.settings.currentMode || "narrative";
      const isChronologueMode = currentMode === "chronologue";
      const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
      const sceneActNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
      const actIndex = sortByWhen ? 0 : sceneActNumber - 1;
      const scenesInActAndSubplot = scenesByActAndSubplot[actIndex] && scenesByActAndSubplot[actIndex][subplot] || [];
      const filteredScenes = scenesInActAndSubplot.filter((s) => !isBeatNote(s));
      const sceneIndex = filteredScenes.indexOf(scene);
      let startAngle;
      let endAngle;
      if (sortByWhen) {
        startAngle = -Math.PI / 2;
        endAngle = 3 * Math.PI / 2;
      } else {
        startAngle = actIndex * 2 * Math.PI / 3 - Math.PI / 2;
        endAngle = (actIndex + 1) * 2 * Math.PI / 3 - Math.PI / 2;
      }
      const innerR = ringStartRadii[ring];
      const outerR = innerR + ringWidths[ring];
      const totalAngularSpace = endAngle - startAngle;
      const sceneAngularSize = filteredScenes.length > 0 ? totalAngularSpace / filteredScenes.length : 0;
      let currentAngle = startAngle;
      for (let i = 0; i < sceneIndex; i++) currentAngle += sceneAngularSize;
      sceneStartAngle = currentAngle;
      textPathRadius = (ringStartRadii[ring] + (ringStartRadii[ring] + ringWidths[ring])) / 2;
      sceneId = `scene-path-${actIndex}-${ring}-${sceneIndex}`;
    } else {
      return;
    }
    const squareSize = getNumberSquareSize(number);
    const squareX = textPathRadius * Math.cos(sceneStartAngle);
    const squareY = textPathRadius * Math.sin(sceneStartAngle);
    const { isSceneOpen, isSearchMatch, hasEdits } = getSceneState(scene, plugin);
    let squareClasses = buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits);
    let textClasses = buildTextClasses(isSceneOpen, isSearchMatch, hasEdits);
    const grade = sceneGrades.get(sceneId);
    if (plugin.settings.enableAiSceneAnalysis && grade) {
      textClasses += ` rt-grade-${grade}`;
    }
    if (shouldDisplayMissingWhenWarning(scene)) {
      squareClasses += " rt-missing-when";
      textClasses += " rt-missing-when";
    }
    if (sceneNumbersMap) {
      sceneNumbersMap.set(sceneId, { number, x: squareX, y: squareY, width: squareSize.width, height: squareSize.height });
    }
    const subplotVisual = enableSubplotColors && resolveSubplotVisual ? resolveSubplotVisual(scene) : null;
    svg += generateNumberSquareGroup(
      squareX,
      squareY,
      squareSize,
      squareClasses,
      sceneId,
      number,
      textClasses,
      grade,
      {
        cornerRadius: 4,
        subplotIndex: subplotVisual == null ? void 0 : subplotVisual.subplotIndex
      }
    );
  });
  svg += "</g>";
  return svg;
}
function renderOuterRingNumberSquares(params) {
  return renderNumberSquaresUnified({
    plugin: params.plugin,
    scenes: params.combined,
    sceneGrades: params.sceneGrades,
    positions: params.positions,
    squareRadius: params.squareRadiusOuter,
    act: params.act,
    ringOuter: params.ringOuter,
    enableSubplotColors: params.enableSubplotColors,
    resolveSubplotVisual: params.resolveSubplotVisual
  });
}
function renderInnerRingsNumberSquaresAllScenes(params) {
  var _a;
  const { plugin, NUM_RINGS, masterSubplotOrder, ringStartRadii, ringWidths, scenesByActAndSubplot, scenes, sceneGrades, enableSubplotColors = false, resolveSubplotVisual } = params;
  const currentMode = plugin.settings.currentMode || "narrative";
  const isChronologueMode = currentMode === "chronologue";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  let svg = "";
  scenes.forEach((scene) => {
    if (isBeatNote(scene)) return;
    const number = getScenePrefixNumber(scene.title, scene.number);
    if (!number) return;
    const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    if (subplot === "Main Plot") return;
    const subplotIndex = masterSubplotOrder.indexOf(subplot);
    if (subplotIndex === -1) return;
    const ring = NUM_RINGS - 1 - subplotIndex;
    if (ring < 0 || ring >= NUM_RINGS) return;
    const sceneActNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
    const actIndex = sortByWhen ? 0 : sceneActNumber - 1;
    const scenesInActAndSubplot = scenesByActAndSubplot[actIndex] && scenesByActAndSubplot[actIndex][subplot] || [];
    const filteredScenesForIndex = scenesInActAndSubplot.filter((s) => !isBeatNote(s));
    const sceneKey = scene.path || scene.title || "";
    const sceneIndex = filteredScenesForIndex.findIndex((s) => (s.path || s.title || "") === sceneKey);
    if (sceneIndex === -1) return;
    let startAngle;
    let endAngle;
    if (sortByWhen) {
      startAngle = -Math.PI / 2;
      endAngle = 3 * Math.PI / 2;
    } else {
      startAngle = actIndex * 2 * Math.PI / 3 - Math.PI / 2;
      endAngle = (actIndex + 1) * 2 * Math.PI / 3 - Math.PI / 2;
    }
    const innerR = ringStartRadii[ring];
    const outerR = innerR + ringWidths[ring];
    const middleRadius = (innerR + outerR) / 2;
    const totalAngularSpace = endAngle - startAngle;
    const sceneAngularSize = filteredScenesForIndex.length > 0 ? totalAngularSpace / filteredScenesForIndex.length : 0;
    let currentAngle = startAngle;
    for (let i = 0; i < sceneIndex; i++) currentAngle += sceneAngularSize;
    const sceneStartAngle = currentAngle;
    const textPathRadius = (innerR + outerR) / 2;
    const squareSize = getNumberSquareSize(number);
    const squareX = textPathRadius * Math.cos(sceneStartAngle);
    const squareY = textPathRadius * Math.sin(sceneStartAngle);
    const { isSceneOpen, isSearchMatch, hasEdits } = getSceneState(scene, plugin);
    let squareClasses = buildSquareClasses(isSceneOpen, isSearchMatch, hasEdits);
    let textClasses = buildTextClasses(isSceneOpen, isSearchMatch, hasEdits);
    if (shouldDisplayMissingWhenWarning(scene)) {
      squareClasses += " rt-missing-when";
      textClasses += " rt-missing-when";
    }
    const sceneId = `scene-path-${actIndex}-${ring}-${sceneIndex}`;
    extractGradeFromScene(scene, sceneId, sceneGrades, plugin);
    const grade = sceneGrades.get(sceneId);
    if (plugin.settings.enableAiSceneAnalysis && grade) textClasses += ` rt-grade-${grade}`;
    const subplotVisual = enableSubplotColors && resolveSubplotVisual ? resolveSubplotVisual(scene) : null;
    svg += generateNumberSquareGroup(
      squareX,
      squareY,
      squareSize,
      squareClasses,
      sceneId,
      number,
      textClasses,
      grade,
      {
        cornerRadius: 4,
        subplotIndex: subplotVisual == null ? void 0 : subplotVisual.subplotIndex
      }
    );
  });
  return svg;
}
function renderNumberSquaresStandard(params) {
  return renderNumberSquaresUnified({
    plugin: params.plugin,
    scenes: params.scenes,
    sceneGrades: params.sceneGrades,
    NUM_RINGS: params.NUM_RINGS,
    masterSubplotOrder: params.masterSubplotOrder,
    ringStartRadii: params.ringStartRadii,
    ringWidths: params.ringWidths,
    scenesByActAndSubplot: params.scenesByActAndSubplot,
    sceneNumbersMap: params.sceneNumbersMap,
    enableSubplotColors: params.enableSubplotColors,
    resolveSubplotVisual: params.resolveSubplotVisual
  });
}

// src/renderer/TimelineRenderer.ts
init_ChronologueTimeline();

// src/renderer/utils/SynopsisBuilder.ts
init_sceneHelpers();
init_text();

// src/utils/pov.ts
var MODE_KEYWORDS = {
  first: "first",
  "1st": "first",
  second: "second",
  "2nd": "second",
  you: "second",
  third: "third",
  "3rd": "third",
  limited: "third",
  omni: "omni",
  omniscient: "omni",
  objective: "objective",
  narrator: "objective",
  legacy: "legacy",
  pov: "legacy"
};
var COUNT_WORDS = {
  one: 1,
  two: 2,
  three: 3,
  four: 4,
  five: 5,
  six: 6,
  seven: 7,
  eight: 8,
  nine: 9,
  ten: 10,
  dozen: 12
};
var MODE_CONFIG = {
  first: { label: "1", usesCharacters: true },
  third: { label: "3", usesCharacters: true },
  legacy: { label: "1", usesCharacters: true },
  second: { label: "2", usesCharacters: false, syntheticText: "You" },
  omni: { label: "3", usesCharacters: false, syntheticText: "Omni" },
  objective: { label: "0", usesCharacters: false, syntheticText: "Narrator" }
};
function interpretKeyword(raw) {
  if (typeof raw !== "string") return {};
  const trimmed = raw.trim().toLowerCase();
  if (!trimmed) return {};
  const firstToken = trimmed.split(/\s+/)[0];
  const mappedMode = MODE_KEYWORDS[firstToken];
  if (mappedMode) {
    return { modeOverride: mappedMode };
  }
  if (trimmed === "count" || trimmed === "all") {
    return { countOverride: Number.POSITIVE_INFINITY };
  }
  const wordCount = COUNT_WORDS[trimmed];
  if (wordCount) {
    return { countOverride: wordCount };
  }
  const numeric = Number(trimmed);
  if (!Number.isNaN(numeric) && numeric > 0) {
    return { countOverride: numeric };
  }
  return {};
}
function normalizeGlobalMode(mode) {
  if (!mode || mode === "off") return "legacy";
  if (mode === "first" || mode === "second" || mode === "third" || mode === "omni" || mode === "objective") {
    return mode;
  }
  return "legacy";
}
function determineHighlightCount(countOverride, characterCount) {
  if (characterCount <= 0) return 0;
  if (countOverride === void 0) {
    return 1;
  }
  if (!Number.isFinite(countOverride)) {
    return characterCount;
  }
  return Math.max(1, Math.min(characterCount, Math.floor(countOverride)));
}
function resolveScenePov(scene, options) {
  const characters = scene.Character || [];
  const { modeOverride, countOverride } = interpretKeyword(scene.pov);
  const effectiveMode = modeOverride != null ? modeOverride : normalizeGlobalMode(options.globalMode);
  const config = MODE_CONFIG[effectiveMode];
  const syntheticEntries = [];
  const characterMarkers = [];
  if (!config.usesCharacters) {
    if (config.syntheticText) {
      syntheticEntries.push({ text: config.syntheticText, label: config.label });
    }
    return { syntheticEntries, characterMarkers };
  }
  const highlightCount = determineHighlightCount(countOverride, characters.length);
  for (let i = 0; i < highlightCount; i++) {
    if (i >= characters.length) break;
    characterMarkers.push({ index: i, label: config.label });
  }
  return { syntheticEntries, characterMarkers };
}

// src/renderer/utils/SynopsisBuilder.ts
function buildSynopsisElement(plugin, scene, sceneId, maxTextWidth, orderedSubplots, subplotIndexResolver) {
  const contentLines = [
    scene.title || "",
    ...isBeatNote(scene) && scene.Description ? splitIntoBalancedLines(scene.Description, maxTextWidth) : scene.synopsis ? splitIntoBalancedLines(scene.synopsis, maxTextWidth) : []
  ];
  if (isBeatNote(scene)) {
    const gossamer1 = scene.Gossamer1;
    if (gossamer1 !== void 0 && gossamer1 !== null) {
      contentLines.push(`<gossamer>${gossamer1}/100</gossamer>`);
    }
  }
  contentLines.push("\xA0");
  if (!isBeatNote(scene)) {
    contentLines.push(orderedSubplots.join(", "));
    const characters = scene.Character || [];
    const povInfo = resolveScenePov(scene, {
      globalMode: plugin.settings.globalPovMode
    });
    const formattedEntries = [];
    povInfo.syntheticEntries.forEach((entry) => {
      formattedEntries.push(`${entry.text} >pov=${entry.label}<`);
    });
    const markerMap = /* @__PURE__ */ new Map();
    povInfo.characterMarkers.forEach((marker) => {
      markerMap.set(marker.index, marker.label);
    });
    characters.forEach((char, index) => {
      const label = markerMap.get(index);
      if (label) {
        formattedEntries.push(`${char} >pov=${label}<`);
      } else {
        formattedEntries.push(char);
      }
    });
    const rawCharacters = formattedEntries.filter((str) => !!str && str.trim().length > 0).join(", ");
    if (rawCharacters) {
      contentLines.push(rawCharacters);
    }
  }
  const filtered = contentLines.filter((line) => line && line.trim() !== "\xA0");
  return plugin.synopsisManager.generateElement(scene, filtered, sceneId, subplotIndexResolver);
}

// src/renderer/TimelineRenderer.ts
var STAGE_HEADER_TOOLTIPS = {
  Zero: "Zero stage \u2014 The raw first draft. Unpolished ideas on the page, no revisions yet.",
  Author: "Author stage \u2014 The author revises and refines the draft after letting it rest.",
  House: "House stage \u2014 Alpha and beta readers give feedback. Publisher or editor reviews the manuscript. Copy-edited and proofed.",
  Press: "Press stage \u2014 Final version is ready for publication."
};
var STATUS_HEADER_TOOLTIPS = {
  Todo: "Todo \u2014 tasks or scenes not yet started",
  Working: "Working \u2014 tasks or scenes currently in progress",
  Due: "Due \u2014 tasks or scenes with a past-due date",
  Completed: "Completed \u2014 tasks or scenes finished"
};
var beatLabelAdjustState = /* @__PURE__ */ new WeakMap();
function getLabelSignature(container) {
  const ids = Array.from(container.querySelectorAll(".rt-storybeat-title textPath")).map((tp) => tp.getAttribute("href") || "").join("|");
  return ids;
}
function computeCacheableValues(plugin, scenes) {
  var _a;
  const stopPrecompute = startPerfSegment(plugin, "timeline.precompute");
  const currentMode = plugin.settings.currentMode || "narrative";
  const isChronologueMode = currentMode === "chronologue";
  const isSubplotMode = currentMode === "subplot";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  const forceChronological = isChronologueMode;
  const allSubplotsSet = /* @__PURE__ */ new Set();
  scenes.forEach((scene) => {
    const key = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    allSubplotsSet.add(key);
  });
  const allSubplots = Array.from(allSubplotsSet);
  const NUM_RINGS = allSubplots.length;
  const shouldShowBeats = shouldRenderStoryBeats(plugin);
  const allScenesPlotNotes = shouldShowBeats ? scenes.filter((s) => isBeatNote(s)) : [];
  const totalPlotNotes = allScenesPlotNotes.length;
  const plotIndexByKey = /* @__PURE__ */ new Map();
  allScenesPlotNotes.forEach((p, i) => {
    var _a2;
    return plotIndexByKey.set(`${String(p.title || "")}::${String((_a2 = p.actNumber) != null ? _a2 : "")}`, i);
  });
  const plotsBySubplot = /* @__PURE__ */ new Map();
  allScenesPlotNotes.forEach((p) => {
    const key = String(p.subplot || "");
    const arr = plotsBySubplot.get(key) || [];
    arr.push(p);
    plotsBySubplot.set(key, arr);
  });
  const scenesByActAndSubplot = {};
  if (sortByWhen) {
    scenesByActAndSubplot[0] = {};
    scenes.forEach((scene) => {
      const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
      if (!scenesByActAndSubplot[0][subplot]) {
        scenesByActAndSubplot[0][subplot] = [];
      }
      scenesByActAndSubplot[0][subplot].push(scene);
    });
    Object.keys(scenesByActAndSubplot[0]).forEach((subplot) => {
      scenesByActAndSubplot[0][subplot] = sortScenes(scenesByActAndSubplot[0][subplot], true, forceChronological);
    });
  } else {
    for (let act = 0; act < NUM_ACTS; act++) {
      scenesByActAndSubplot[act] = {};
    }
    scenes.forEach((scene) => {
      const act = scene.actNumber !== void 0 ? scene.actNumber - 1 : 0;
      const validAct = act >= 0 && act < NUM_ACTS ? act : 0;
      const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
      if (!scenesByActAndSubplot[validAct][subplot]) {
        scenesByActAndSubplot[validAct][subplot] = [];
      }
      scenesByActAndSubplot[validAct][subplot].push(scene);
    });
    for (let act = 0; act < NUM_ACTS; act++) {
      Object.keys(scenesByActAndSubplot[act] || {}).forEach((subplot) => {
        scenesByActAndSubplot[act][subplot] = sortScenes(scenesByActAndSubplot[act][subplot], false, false);
      });
    }
  }
  const allSubplotsMap = /* @__PURE__ */ new Map();
  const actsToCheck = sortByWhen ? 1 : NUM_ACTS;
  for (let actIndex = 0; actIndex < actsToCheck; actIndex++) {
    Object.entries(scenesByActAndSubplot[actIndex] || {}).forEach(([subplot, scenes2]) => {
      allSubplotsMap.set(subplot, (allSubplotsMap.get(subplot) || 0) + scenes2.length);
    });
  }
  const subplotCounts = Array.from(allSubplotsMap.entries()).map(([subplot, count]) => ({
    subplot,
    count
  }));
  subplotCounts.sort((a, b) => {
    if (a.subplot === "Main Plot" || !a.subplot) return -1;
    if (b.subplot === "Main Plot" || !b.subplot) return 1;
    return b.count - a.count;
  });
  const masterSubplotOrder = subplotCounts.map((item) => item.subplot);
  const subplotOuterRadius = isChronologueMode ? SUBPLOT_OUTER_RADIUS_CHRONOLOGUE : isSubplotMode ? SUBPLOT_OUTER_RADIUS_MAINPLOT : SUBPLOT_OUTER_RADIUS_STANDARD;
  const ringGeo = computeRingGeometry({
    size: SVG_SIZE,
    innerRadius: INNER_RADIUS,
    subplotOuterRadius,
    outerRadius: MONTH_LABEL_RADIUS,
    numRings: NUM_RINGS,
    monthTickTerminal: 0,
    monthTextInset: 0
  });
  const maxStageColor = getMostAdvancedStageColor(scenes, plugin.settings.publishStageColors);
  stopPrecompute();
  return {
    scenesByActAndSubplot,
    masterSubplotOrder,
    totalPlotNotes,
    plotIndexByKey,
    plotsBySubplot,
    ringWidths: ringGeo.ringWidths,
    ringStartRadii: ringGeo.ringStartRadii,
    lineInnerRadius: ringGeo.lineInnerRadius,
    maxStageColor
  };
}
function adjustBeatLabelsAfterRender(container, attempt = 0) {
  const state = beatLabelAdjustState.get(container) || {};
  if (!container.isConnected) return;
  const labels = container.querySelectorAll(".rt-storybeat-title");
  if (labels.length === 0) return;
  const SPACE_BEFORE_DASH = 6;
  const SPACE_AFTER_DASH = 4;
  const TEXT_START_OFFSET = 2;
  const EXTRA_BREATHING_ROOM = 16;
  const svgRoot = container.querySelector("svg.radial-timeline-svg");
  const isHidden = !svgRoot || svgRoot.getBoundingClientRect().width === 0 || document.visibilityState === "hidden";
  const MAX_ATTEMPTS = 10;
  const signature = getLabelSignature(container);
  if (state.signature !== signature) {
    state.signature = signature;
    state.success = false;
    if (state.retryId) cancelAnimationFrame(state.retryId);
    beatLabelAdjustState.set(container, state);
  }
  if (state.signature === signature && state.success) {
    return;
  }
  if (isHidden && attempt < MAX_ATTEMPTS) {
    const rafId = requestAnimationFrame(() => adjustBeatLabelsAfterRender(container, attempt + 1));
    state.retryId = rafId;
    beatLabelAdjustState.set(container, state);
    return;
  }
  const labelData = [];
  let measurableCount = 0;
  labels.forEach((label) => {
    var _a;
    const textElement = label;
    const textPath = textElement.querySelector("textPath");
    if (!textPath) return;
    const pathId = (_a = textPath.getAttribute("href")) == null ? void 0 : _a.substring(1);
    if (!pathId) return;
    const pathElement = container.querySelector(`#${pathId}`);
    if (!pathElement) return;
    const textLength = textPath.getComputedTextLength();
    if (textLength === 0) {
      return;
    }
    measurableCount++;
    const d = pathElement.getAttribute("d");
    if (!d) return;
    const arcMatch = d.match(/M\s+([-\d.]+)\s+([-\d.]+)\s+A\s+([-\d.]+)/);
    if (!arcMatch) return;
    const x = parseFloat(arcMatch[1]);
    const y = parseFloat(arcMatch[2]);
    const radius = parseFloat(arcMatch[3]);
    const originalStartAngle = Math.atan2(y, x);
    labelData.push({
      element: textElement,
      textPath,
      pathElement,
      pathId,
      originalStartAngle,
      textLength,
      radius
    });
  });
  if (measurableCount < labels.length && attempt < MAX_ATTEMPTS) {
    state.signature = signature;
    state.success = false;
    beatLabelAdjustState.set(container, state);
    window.setTimeout(() => adjustBeatLabelsAfterRender(container, attempt + 1), 50);
    return;
  }
  if (measurableCount === 0 && attempt >= MAX_ATTEMPTS) {
    state.lastAbortSignature = signature;
    beatLabelAdjustState.set(container, state);
    return;
  }
  labelData.sort((a, b) => {
    if (a.originalStartAngle === b.originalStartAngle) return a.pathId.localeCompare(b.pathId);
    return a.originalStartAngle - b.originalStartAngle;
  });
  let lastEnd = Number.NEGATIVE_INFINITY;
  const adjustments = [];
  labelData.forEach((data) => {
    const pathWidth = TEXT_START_OFFSET + data.textLength + EXTRA_BREATHING_ROOM;
    const pathAngleSpan = pathWidth / Math.max(1, data.radius);
    const textOnlyWidth = TEXT_START_OFFSET + data.textLength;
    const textAngleSpan = textOnlyWidth / Math.max(1, data.radius);
    let startAngle = data.originalStartAngle;
    let needsDash = false;
    let dashAngle;
    const epsilon = 2 / Math.max(1, data.radius);
    if (startAngle <= lastEnd + epsilon) {
      const spaceBeforeDash = SPACE_BEFORE_DASH / Math.max(1, data.radius);
      const spaceAfterDash = SPACE_AFTER_DASH / Math.max(1, data.radius);
      dashAngle = lastEnd + spaceBeforeDash;
      startAngle = lastEnd + spaceBeforeDash + spaceAfterDash;
      needsDash = true;
    }
    const endAngle = startAngle + textAngleSpan;
    lastEnd = endAngle;
    adjustments.push({
      data,
      newStartAngle: startAngle,
      needsDash,
      dashAngle,
      pathAngleSpan
    });
  });
  adjustments.forEach(({ data, newStartAngle, needsDash, dashAngle, pathAngleSpan }) => {
    var _a;
    const endAngle = newStartAngle + pathAngleSpan;
    const x1 = data.radius * Math.cos(newStartAngle);
    const y1 = data.radius * Math.sin(newStartAngle);
    const x2 = data.radius * Math.cos(endAngle);
    const y2 = data.radius * Math.sin(endAngle);
    const largeArc = pathAngleSpan > Math.PI ? 1 : 0;
    const newPath = `M ${formatNumber(x1)} ${formatNumber(y1)} A ${formatNumber(data.radius)} ${formatNumber(data.radius)} 0 ${largeArc} 1 ${formatNumber(x2)} ${formatNumber(y2)}`;
    data.pathElement.setAttribute("d", newPath);
    if (needsDash && dashAngle !== void 0) {
      let separator = container.querySelector(`#plot-separator-${data.pathId}`);
      if (!separator) {
        separator = document.createElementNS("http://www.w3.org/2000/svg", "text");
        separator.setAttribute("id", `plot-separator-${data.pathId}`);
        separator.setAttribute("class", "rt-storybeat-title rt-plot-dash-separator");
        separator.setAttribute("text-anchor", "middle");
        separator.setAttribute("dy", "-3");
        separator.textContent = "\u2014";
        (_a = data.pathElement.parentElement) == null ? void 0 : _a.appendChild(separator);
      }
      const dashRadius = data.radius + 1;
      const dx = dashRadius * Math.cos(dashAngle);
      const dy = dashRadius * Math.sin(dashAngle);
      const deg = (dashAngle + Math.PI / 2) * 180 / Math.PI;
      separator.setAttribute("transform", `translate(${formatNumber(dx)}, ${formatNumber(dy)}) rotate(${formatNumber(deg)})`);
    } else {
      const separator = container.querySelector(`#plot-separator-${data.pathId}`);
      separator == null ? void 0 : separator.remove();
    }
  });
  state.success = true;
  beatLabelAdjustState.set(container, state);
}
function createTimelineSVG(plugin, scenes) {
  var _a, _b, _c;
  const stopTotalPerf = startPerfSegment(plugin, "timeline.total");
  const sceneCount = scenes.length;
  const size = SVG_SIZE;
  const innerRadius = INNER_RADIUS;
  const monthLabelRadius = MONTH_LABEL_RADIUS;
  const chronologueDateRadius = CHRONOLOGUE_DATE_RADIUS;
  const monthTickStart = MONTH_TICK_START;
  const monthTickEnd = MONTH_TICK_END;
  const maxTextWidth = MAX_TEXT_WIDTH;
  const stopPrepPerf = startPerfSegment(plugin, "timeline.scene-prep");
  const precomputed = computeCacheableValues(plugin, scenes);
  stopPrepPerf();
  const {
    scenesByActAndSubplot,
    masterSubplotOrder,
    totalPlotNotes,
    plotIndexByKey,
    plotsBySubplot,
    ringWidths,
    ringStartRadii,
    lineInnerRadius,
    maxStageColor
  } = precomputed;
  const NUM_RINGS = masterSubplotOrder.length;
  const currentMode = plugin.settings.currentMode || "narrative";
  const shouldApplyNumberSquareColors = currentMode !== "gossamer";
  const numberSquareVisualResolver = shouldApplyNumberSquareColors ? (scene) => {
    const subplotName = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    const idx = masterSubplotOrder.indexOf(subplotName);
    const normalized = idx >= 0 ? idx % 16 : 0;
    return {
      subplotIndex: normalized
    };
  } : null;
  const subplotColorFor = (subplotName) => {
    const idx = masterSubplotOrder.indexOf(subplotName);
    const normalized = idx >= 0 ? idx % 16 : 0;
    const varName = `--rt-subplot-colors-${normalized}`;
    const computed = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
    return computed || "#EFBDEB";
  };
  let svg = `<svg width="${size}" height="${size}" viewBox="-${size / 2} -${size / 2} ${size} ${size}" 
                       xmlns="http://www.w3.org/2000/svg" class="radial-timeline-svg" 
                       preserveAspectRatio="xMidYMid meet">`;
  svg += `<g id="timeline-config-data" data-max-stage-color="${maxStageColor}"></g>`;
  svg += `<defs>`;
  const sceneNumbersMap = /* @__PURE__ */ new Map();
  const isChronologueMode = currentMode === "chronologue";
  const isSubplotMode = currentMode === "subplot";
  const sortByWhen = isChronologueMode ? true : (_a = plugin.settings.sortByWhenDate) != null ? _a : false;
  const forceChronological = isChronologueMode;
  const chronologueSceneEntries = isChronologueMode ? collectChronologueSceneEntries(scenes) : void 0;
  const subplotOuterRadius = isChronologueMode ? SUBPLOT_OUTER_RADIUS_CHRONOLOGUE : isSubplotMode ? SUBPLOT_OUTER_RADIUS_MAINPLOT : SUBPLOT_OUTER_RADIUS_STANDARD;
  const standardMonths = Array.from({ length: 12 }, (_, i) => {
    const angle = i / 12 * 2 * Math.PI - Math.PI / 2;
    const name = new Date(2e3, i).toLocaleString("en-US", { month: "long" });
    const shortName = new Date(2e3, i).toLocaleString("en-US", { month: "short" }).slice(0, 3);
    return { name, shortName, angle };
  });
  const months = standardMonths;
  let outerLabels;
  if (isChronologueMode) {
    const stopChronoLabels = startPerfSegment(plugin, "timeline.chronologue-labels");
    const startAngle = -Math.PI / 2;
    const endAngle = 3 * Math.PI / 2;
    const seenPaths = /* @__PURE__ */ new Set();
    const combined = [];
    scenes.forEach((s) => {
      if (isBeatNote(s)) {
        return;
      }
      const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
      if (!seenPaths.has(key)) {
        seenPaths.add(key);
        combined.push(s);
      }
    });
    const sortByWhen2 = true;
    const forceChronological2 = true;
    const sortedCombined = sortScenes(combined, sortByWhen2, forceChronological2);
    const sortedScenes = sortedCombined;
    const validDates = sortedScenes.map((s) => s.when).filter((when) => when instanceof Date && !isNaN(when.getTime()));
    const timeSpan = validDates.length > 0 ? calculateTimeSpan(validDates) : void 0;
    const sceneStartAngles = [];
    let sceneAngularSize = 0;
    if (sortedScenes.length > 0) {
      const totalAngularSpace = endAngle - startAngle;
      sceneAngularSize = totalAngularSpace / sortedScenes.length;
      sortedScenes.forEach((_, idx) => {
        const sceneStartAngle = startAngle + idx * sceneAngularSize;
        sceneStartAngles.push(sceneStartAngle);
      });
    }
    const chronoTicks = generateChronologicalTicks(sortedScenes, sceneStartAngles, sceneAngularSize, timeSpan);
    outerLabels = chronoTicks.map((tick) => ({
      name: tick.name,
      shortName: tick.shortName,
      angle: tick.angle,
      isMajor: tick.isMajor,
      isFirst: tick.isFirst,
      isLast: tick.isLast,
      sceneIndex: tick.sceneIndex
    }));
    stopChronoLabels();
  } else {
    outerLabels = standardMonths;
  }
  svg = `<svg width="${size}" height="${size}" viewBox="-${size / 2} -${size / 2} ${size} ${size}" xmlns="http://www.w3.org/2000/svg" class="radial-timeline-svg" ${isChronologueMode ? 'data-chronologue-mode="true"' : ""} preserveAspectRatio="xMidYMid meet">`;
  if (shouldShowAllScenesInOuterRing(plugin)) {
  }
  const PUBLISH_STAGE_COLORS = plugin.settings.publishStageColors;
  svg += `<defs>`;
  svg += renderDefs(PUBLISH_STAGE_COLORS);
  svg += renderMonthLabelDefs({ months: outerLabels, monthLabelRadius, chronologueDateRadius });
  svg += `</defs>`;
  svg += `<g id="timeline-root">`;
  const buildCellArcPath2 = (innerR, outerR, startAngle, endAngle) => {
    return `
                                M ${formatNumber(innerR * Math.cos(startAngle))} ${formatNumber(innerR * Math.sin(startAngle))}
                                L ${formatNumber(outerR * Math.cos(startAngle))} ${formatNumber(outerR * Math.sin(startAngle))}
                                A ${formatNumber(outerR)} ${formatNumber(outerR)} 0 0 1 ${formatNumber(outerR * Math.cos(endAngle))} ${formatNumber(outerR * Math.sin(endAngle))}
                                L ${formatNumber(innerR * Math.cos(endAngle))} ${formatNumber(innerR * Math.sin(endAngle))}
                                A ${formatNumber(innerR)} ${formatNumber(innerR)} 0 0 0 ${formatNumber(innerR * Math.cos(startAngle))} ${formatNumber(innerR * Math.sin(startAngle))}
                            `;
  };
  const computeRainbowColor = (index, total) => {
    if (!Number.isFinite(index) || !Number.isFinite(total) || total <= 0) {
      return "#888888";
    }
    const hue = index / total * 360;
    const saturation = 85;
    const lightness = 55;
    return `hsl(${Math.round(hue)}, ${saturation}%, ${lightness}%)`;
  };
  const currentMonthIndex = (/* @__PURE__ */ new Date()).getMonth();
  let boundaryLabelsHtml = "";
  outerLabels.forEach(({ shortName, isFirst, isLast }, index) => {
    const pathId = `monthLabelPath-${index}`;
    const isPastMonth = !isChronologueMode && index < currentMonthIndex;
    let labelClass = "rt-month-label-outer";
    if (isFirst) {
      labelClass = "rt-month-label-outer rt-date-boundary rt-date-first";
    } else if (isLast) {
      labelClass = "rt-month-label-outer rt-date-boundary rt-date-last";
    }
    let labelContent = shortName;
    if ((isFirst || isLast) && shortName.includes("\n")) {
      const lines = shortName.split("\n");
      labelContent = lines.map(
        (line, i) => `<tspan x="0" dy="${i === 0 ? 0 : "0.9em"}">${line}</tspan>`
      ).join("");
    }
    const labelHtml = `
                <text class="${labelClass}" ${isPastMonth ? 'opacity="0.5"' : ""}>
                    <textPath href="#${pathId}" startOffset="0" text-anchor="start">
                        ${labelContent}
                    </textPath>
                </text>
            `;
    if (isChronologueMode && (isFirst || isLast)) {
      boundaryLabelsHtml += labelHtml;
    } else {
      svg += labelHtml;
    }
  });
  const now = /* @__PURE__ */ new Date();
  const startOfYear = new Date(now.getFullYear(), 0, 1);
  const yearProgress = (now.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24 * 365);
  const progressRadius = lineInnerRadius + 15;
  const circumference = 2 * Math.PI * progressRadius;
  const currentYearStartAngle = -Math.PI / 2;
  const currentYearEndAngle = currentYearStartAngle + 2 * Math.PI * yearProgress;
  svg += renderProgressRingGradients();
  svg += `
            <circle
                cx="0"
                cy="0"
                r="${progressRadius}"
                class="progress-ring-base"
            />
        `;
  const estimateResult = plugin.settings.showEstimate === false ? null : plugin.calculateCompletionEstimate(scenes);
  if (estimateResult) {
    const estimatedCompletionDate = estimateResult.date;
    if (estimatedCompletionDate) {
      const startAngle = -Math.PI / 2;
      const estimatedYear = estimatedCompletionDate.getFullYear();
      const estimatedMonth = estimatedCompletionDate.getMonth();
      const estimatedDay = estimatedCompletionDate.getDate();
      const estimatedDaysInMonth = new Date(estimatedYear, estimatedMonth + 1, 0).getDate();
      const now2 = /* @__PURE__ */ new Date();
      const yearsDiff = estimatedCompletionDate.getFullYear() - now2.getFullYear();
      if (yearsDiff <= 0) {
        svg += renderEstimationArc({ estimateDate: estimatedCompletionDate, progressRadius });
      }
    }
  }
  if (!isChronologueMode) {
    svg += renderMonthSpokesAndInnerLabels({
      months,
      lineInnerRadius,
      lineOuterRadius: monthTickEnd,
      currentMonthIndex,
      includeIntermediateSpokes: true,
      outerSpokeInnerRadius: subplotOuterRadius
      // Add outer spokes from edge of inner rings
    });
  } else {
    svg += renderMonthSpokesAndInnerLabels({
      months,
      lineInnerRadius,
      lineOuterRadius: monthTickEnd,
      // Not used since we don't render outer spokes
      currentMonthIndex,
      includeIntermediateSpokes: false
      // No outerSpokeInnerRadius - only inner calendar spokes
    });
  }
  if (isChronologueMode && outerLabels.length > 0) {
    svg += '<g class="rt-chronological-outer-ticks">';
    outerLabels.forEach(({ angle, isMajor, shortName, isFirst, isLast, sceneIndex }) => {
      const tickStart = monthTickStart;
      const dataAttrs = sceneIndex !== void 0 ? ` data-scene-index="${sceneIndex}"` : "";
      if (isMajor) {
        const tickEnd = monthTickEnd;
        const x1 = formatNumber(tickStart * Math.cos(angle));
        const y1 = formatNumber(tickStart * Math.sin(angle));
        const x2 = formatNumber(tickEnd * Math.cos(angle));
        const y2 = formatNumber(tickEnd * Math.sin(angle));
        const boundaryClass = isFirst ? " rt-date-first" : isLast ? " rt-date-last" : "";
        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                        class="rt-chronological-tick rt-chronological-tick-major${boundaryClass}"${dataAttrs}/>`;
      } else if (shortName === "") {
        const tickEnd = (monthTickStart + monthTickEnd) / 2;
        const x1 = formatNumber(tickStart * Math.cos(angle));
        const y1 = formatNumber(tickStart * Math.sin(angle));
        const x2 = formatNumber(tickEnd * Math.cos(angle));
        const y2 = formatNumber(tickEnd * Math.sin(angle));
        svg += `<line x1="${x1}" y1="${y1}" x2="${x2}" y2="${y2}" 
                        class="rt-chronological-tick rt-chronological-tick-minor"${dataAttrs}/>`;
      }
    });
    svg += "</g>";
  }
  svg += renderProgressRing({ progressRadius, yearProgress, currentYearStartAngle, segmentCount: 6 });
  svg += renderTargetDateTick({ plugin, progressRadius, dateToAngle });
  const subplotCssColor = (name) => {
    const idx = masterSubplotOrder.indexOf(name);
    if (idx < 0) return "#EFBDEB";
    const colorIdx = idx % 16;
    const varName = `--rt-subplot-colors-${colorIdx}`;
    const root = document.documentElement;
    const computed = getComputedStyle(root).getPropertyValue(varName).trim();
    return computed || "#EFBDEB";
  };
  const synopsesElements = [];
  const sceneGrades = /* @__PURE__ */ new Map();
  scenes.forEach((scene) => {
    var _a2;
    const subplot = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
    const subplotIndex = masterSubplotOrder.indexOf(subplot);
    const ring = NUM_RINGS - 1 - subplotIndex;
    const actNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
    const currentMode2 = plugin.settings.currentMode || "narrative";
    const isChronologueMode2 = currentMode2 === "chronologue";
    const sortByWhen2 = isChronologueMode2 ? true : (_a2 = plugin.settings.sortByWhenDate) != null ? _a2 : false;
    const sceneActNumber = scene.actNumber !== void 0 ? scene.actNumber : 1;
    const actIndex = sortByWhen2 ? 0 : sceneActNumber - 1;
    const scenesInActAndSubplot = scenesByActAndSubplot[actIndex] && scenesByActAndSubplot[actIndex][subplot] || [];
    if (isBeatNote(scene)) {
      return;
    }
    const filteredScenesForIndex = scenesInActAndSubplot.filter((s) => !isBeatNote(s));
    const sceneIndex = filteredScenesForIndex.indexOf(scene);
    const sceneId = makeSceneId(actIndex, ring, sceneIndex, false, false);
    extractGradeFromScene(scene, sceneId, sceneGrades, plugin);
    if (!scene.title) {
      return;
    }
    const allSceneSubplots = scenes.filter((s) => s.path === scene.path).map((s) => s.subplot).filter((s) => s !== void 0);
    const sceneSubplot = scene.subplot || "Main Plot";
    const orderedSubplots = [sceneSubplot, ...allSceneSubplots.filter((s) => s !== sceneSubplot)];
    const synopsisElement = buildSynopsisElement(
      plugin,
      scene,
      sceneId,
      maxTextWidth,
      orderedSubplots,
      (name) => {
        const idx = masterSubplotOrder.indexOf(name);
        if (idx < 0) return 0;
        return idx % 16;
      }
    );
    synopsesElements.push(synopsisElement);
  });
  svg += `<g id="timeline-rotatable">`;
  const lastBeatEndByAct = {};
  if (!sortByWhen) {
    svg += renderActLabels({ NUM_ACTS, outerMostOuterRadius: ACT_LABEL_RADIUS, actLabelOffset: 0, maxStageColor });
  }
  plugin._beatAngles = /* @__PURE__ */ new Map();
  let manuscriptOrderPositions;
  const actsToRender = sortByWhen ? 1 : NUM_ACTS;
  const stopRingRender = startPerfSegment(plugin, "timeline.render-rings");
  for (let act = 0; act < actsToRender; act++) {
    const totalRings = NUM_RINGS;
    const subplotCount = masterSubplotOrder.length;
    const ringsToUse = Math.min(subplotCount, totalRings);
    for (let ringOffset = 0; ringOffset < ringsToUse; ringOffset++) {
      const ring = totalRings - ringOffset - 1;
      const innerR = ringStartRadii[ring];
      const outerR = innerR + ringWidths[ring];
      let startAngle;
      let endAngle;
      if (sortByWhen) {
        startAngle = -Math.PI / 2;
        endAngle = 3 * Math.PI / 2;
      } else {
        startAngle = act * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
        endAngle = (act + 1) * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
      }
      const subplot = masterSubplotOrder[ringOffset];
      const isOuterRing = ringOffset === 0;
      if (isOuterRing && shouldShowAllScenesInOuterRing(plugin)) {
        const seenPaths = /* @__PURE__ */ new Set();
        const seenPlotKeys = /* @__PURE__ */ new Set();
        const combined = [];
        const selectSceneForOuterRing = (scenePath, candidateScenes) => {
          var _a2;
          const dominantSubplot = (_a2 = plugin.settings.dominantSubplots) == null ? void 0 : _a2[scenePath];
          if (dominantSubplot) {
            const preferredScene = candidateScenes.find((s) => s.subplot === dominantSubplot);
            if (preferredScene) {
              return preferredScene;
            }
            if (plugin.settings.dominantSubplots) {
              delete plugin.settings.dominantSubplots[scenePath];
            }
          }
          let outermostScene = candidateScenes[0];
          let outermostIndex = Infinity;
          for (const scene of candidateScenes) {
            const subplot2 = scene.subplot || "Main Plot";
            const index = masterSubplotOrder.indexOf(subplot2);
            if (index !== -1 && index < outermostIndex) {
              outermostIndex = index;
              outermostScene = scene;
            }
          }
          return outermostScene;
        };
        const scenesByPath = /* @__PURE__ */ new Map();
        scenes.forEach((s) => {
          var _a2;
          if (!sortByWhen) {
            const sAct = s.actNumber !== void 0 ? s.actNumber - 1 : 0;
            if (sAct !== act) return;
          }
          if (isBeatNote(s)) {
            if (isChronologueMode) return;
            const pKey = `${String(s.title || "")}::${String((_a2 = s.actNumber) != null ? _a2 : "")}`;
            if (!seenPlotKeys.has(pKey)) {
              seenPlotKeys.add(pKey);
              combined.push(s);
            }
          } else {
            const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
            if (!scenesByPath.has(key)) {
              scenesByPath.set(key, []);
            }
            scenesByPath.get(key).push(s);
          }
        });
        scenesByPath.forEach((scenesForPath, pathKey) => {
          if (seenPaths.has(pathKey)) return;
          seenPaths.add(pathKey);
          const selectedScene = selectSceneForOuterRing(
            scenesForPath[0].path || "",
            scenesForPath
          );
          combined.push(selectedScene);
          const sceneIndex = combined.length - 1;
          const allScenesSceneId = makeSceneId(act, NUM_RINGS - 1, sceneIndex, true, true);
          extractGradeFromScene(selectedScene, allScenesSceneId, sceneGrades, plugin);
        });
        const sortedCombined = sortScenes(combined, sortByWhen, forceChronological);
        const positions = computePositions(innerR, outerR, startAngle, endAngle, sortedCombined);
        if (isChronologueMode) {
          manuscriptOrderPositions = /* @__PURE__ */ new Map();
          sortedCombined.forEach((scene, idx) => {
            const position = positions.get(idx);
            if (position) {
              const key = scene.path || `title:${scene.title || ""}`;
              manuscriptOrderPositions.set(key, position);
            }
          });
        }
        const beatTextRadius = outerR - BEAT_TITLE_INSET;
        sortedCombined.forEach((scene, idx) => {
          const { number, text } = parseSceneTitle(scene.title || "", scene.number);
          const position = positions.get(idx);
          const sceneStartAngle = position.startAngle;
          const sceneEndAngle = position.endAngle;
          const effectiveOuterR = isBeatNote(scene) ? outerR + 2 : outerR;
          if (isBeatNote(scene) && scene.title) {
            const titleWithoutNumber = scene.title.replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
            const center = (sceneStartAngle + sceneEndAngle) / 2;
            plugin._beatAngles.set(titleWithoutNumber, center);
            if (!plugin._beatSlices) plugin._beatSlices = /* @__PURE__ */ new Map();
            plugin._beatSlices.set(titleWithoutNumber, {
              startAngle: sceneStartAngle,
              endAngle: sceneEndAngle,
              innerR,
              outerR: effectiveOuterR
            });
          }
          const textPathRadius = Math.max(innerR, outerR - SCENE_TITLE_INSET);
          const color = getFillForScene(scene, PUBLISH_STAGE_COLORS, subplotColorFor, true);
          const arcPath2 = sceneArcPath(innerR, effectiveOuterR, sceneStartAngle, sceneEndAngle);
          const sceneId = makeSceneId(act, ring, idx, true, true);
          try {
            const allSceneSubplots = scenes.filter((s) => s.path === scene.path).map((s) => s.subplot).filter((s) => s !== void 0);
            const sceneSubplot = scene.subplot || "Main Plot";
            const orderedSubplots = [sceneSubplot, ...allSceneSubplots.filter((s) => s !== sceneSubplot)];
            const synopsisElOuter = buildSynopsisElement(
              plugin,
              scene,
              sceneId,
              maxTextWidth,
              orderedSubplots,
              (name) => {
                const idx2 = masterSubplotOrder.indexOf(name);
                if (idx2 < 0) return 0;
                return idx2 % 16;
              }
            );
            synopsesElements.push(synopsisElOuter);
          } catch (error) {
            console.warn("Failed to build synopsis for scene:", scene.path, error);
          }
          let sceneClasses = "rt-scene-path";
          if (scene.path && plugin.openScenePaths.has(scene.path)) sceneClasses += " rt-scene-is-open";
          const dyOffset = 0;
          const beatTextRadius2 = outerR - BEAT_TITLE_INSET;
          const rawTitleFull = (() => {
            const full = scene.title || "";
            const m = full.match(/^(?:\s*\d+(?:\.\d+)?\s+)?(.+)/);
            return m ? m[1] : full;
          })();
          const estimatedWidth = estimatePixelsFromTitle(rawTitleFull, BEAT_FONT_PX, ESTIMATE_FUDGE_RENDER, PADDING_RENDER_PX);
          const labelStartAngle = sceneStartAngle;
          const labelEndAngle = sceneStartAngle + estimatedWidth / beatTextRadius2;
          const desiredAngleArc = labelEndAngle - labelStartAngle;
          const largeArcFlag = desiredAngleArc > Math.PI ? 1 : 0;
          const subplotIdxAttr = (() => {
            const name = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
            const i = Math.max(0, masterSubplotOrder.indexOf(name));
            return i;
          })();
          const plotStrokeAttr = (() => {
            if (isBeatNote(scene)) {
              const publishStage = scene["Publish Stage"] || "Zero";
              const stageColor = PUBLISH_STAGE_COLORS[publishStage] || PUBLISH_STAGE_COLORS.Zero;
              return `stroke="${stageColor}" stroke-width="2"`;
            }
            return "";
          })();
          svg += `
                        ${renderSceneGroup({ scene, act, ring, idx, innerR, outerR: effectiveOuterR, startAngle: sceneStartAngle, endAngle: sceneEndAngle, subplotIdxAttr })}
                            <path id="${sceneId}"
                                  d="${arcPath2}" 
                                  fill="${color}" 
                                  ${plotStrokeAttr}
                                  class="${sceneClasses}"/>
                            ${isBeatNote(scene) ? `` : ``}

                            ${!isBeatNote(scene) ? `
                            <path id="textPath-${act}-${ring}-outer-${idx}" 
                                  d="M ${formatNumber(textPathRadius * Math.cos(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} ${formatNumber(textPathRadius * Math.sin(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} 
                                     A ${formatNumber(textPathRadius)} ${formatNumber(textPathRadius)} 0 0 1 ${formatNumber(textPathRadius * Math.cos(sceneEndAngle))} ${formatNumber(textPathRadius * Math.sin(sceneEndAngle))}" 
                                  fill="none"/>
                            <text class="rt-scene-title${scene.path && plugin.openScenePaths.has(scene.path) ? " rt-scene-is-open" : ""}" dy="${dyOffset}" data-scene-id="${sceneId}">
                                <textPath href="#textPath-${act}-${ring}-outer-${idx}" startOffset="4">
                                    ${text}
                                </textPath>
                            </text>` : `
                            <path id="plot-label-arc-${act}-${ring}-outer-${idx}" 
                                  d="M ${formatNumber(beatTextRadius2 * Math.cos(labelStartAngle))} ${formatNumber(beatTextRadius2 * Math.sin(labelStartAngle))} 
                                     A ${formatNumber(beatTextRadius2)} ${formatNumber(beatTextRadius2)} 0 ${largeArcFlag} 1 ${formatNumber(beatTextRadius2 * Math.cos(labelEndAngle))} ${formatNumber(beatTextRadius2 * Math.sin(labelEndAngle))}" 
                                  data-slice-start="${formatNumber(sceneStartAngle)}" data-radius="${formatNumber(beatTextRadius2)}" fill="none"/>
                            <text class="rt-storybeat-title" dy="-3">
                                <textPath href="#plot-label-arc-${act}-${ring}-outer-${idx}" startOffset="2">
                                    ${escapeXml(rawTitleFull)}
                                </textPath>
                            </text>
                            `}
                        </g>`;
        });
        const totalUsedSpace = Array.from(positions.values()).reduce((sum, p) => sum + p.angularSize, 0);
        const totalAngularSpace = endAngle - startAngle;
        const remainingVoidSpace = totalAngularSpace - totalUsedSpace;
        if (remainingVoidSpace > 1e-3) {
          const voidStartAngle = startAngle + totalUsedSpace;
          const voidEndAngle = endAngle;
          svg += renderVoidCellPath(innerR, outerR, voidStartAngle, voidEndAngle);
        }
        continue;
      }
      const currentScenes = subplot ? scenesByActAndSubplot[act][subplot] || [] : [];
      if (currentScenes && currentScenes.length > 0) {
        if (currentScenes && currentScenes.length > 0) {
          const currentMode2 = plugin.settings.currentMode || "narrative";
          const isChronologueMode2 = currentMode2 === "chronologue";
          const sortByWhen2 = isChronologueMode2 ? true : (_b = plugin.settings.sortByWhenDate) != null ? _b : false;
          const forceChronological2 = isChronologueMode2;
          const beforeList = currentScenes.map((s, i) => {
            const pos = extractPosition(s);
            return `[${i}]pos:${pos}`;
          }).join(", ");
          const sortedCurrentScenes = sortScenes(currentScenes, sortByWhen2, forceChronological2);
          const afterList = sortedCurrentScenes.map((s, i) => {
            const pos = extractPosition(s);
            return `[${i}]pos:${pos}`;
          }).join(", ");
          const shouldShowBeats = shouldRenderStoryBeats(plugin);
          const isOuterRingAllScenes = isOuterRing && shouldShowAllScenesInOuterRing(plugin);
          const isAllScenesMode = shouldShowAllScenesInOuterRing(plugin);
          const effectiveScenes = sortedCurrentScenes.filter((scene) => !isBeatNote(scene));
          const scenePositions = computePositions(innerR, outerR, startAngle, endAngle, effectiveScenes);
          effectiveScenes.forEach((scene, idx) => {
            const { number, text } = parseSceneTitle(scene.title || "", scene.number);
            const position = scenePositions.get(idx);
            if (!position) return;
            const sceneStartAngle = position.startAngle;
            const sceneEndAngle = position.endAngle;
            const textPathRadius = Math.max(innerR, outerR - SCENE_TITLE_INSET);
            const color = (() => {
              const statusList = Array.isArray(scene.status) ? scene.status : [scene.status];
              const norm = normalizeStatus(statusList[0]);
              const publishStage = scene["Publish Stage"] || "Zero";
              if (!norm) {
                return `url(#plaidTodo${publishStage})`;
              }
              if (norm === "Completed") {
                if (isAllScenesMode) {
                  const subplotName = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
                  if (subplotName !== "Main Plot") {
                    return subplotCssColor(subplotName);
                  }
                }
                const stageColor = PUBLISH_STAGE_COLORS[publishStage] || PUBLISH_STAGE_COLORS.Zero;
                return stageColor;
              }
              if (scene.due && isOverdueDateString(scene.due)) {
                return STATUS_COLORS.Due;
              }
              if (norm === "Working") {
                return `url(#plaidWorking${publishStage})`;
              }
              if (norm === "Todo") {
                return `url(#plaidTodo${publishStage})`;
              }
              return STATUS_COLORS[statusList[0]] || STATUS_COLORS.Todo;
            })();
            const arcPath2 = sceneArcPath(innerR, outerR, sceneStartAngle, sceneEndAngle);
            const sceneId = `scene-path-${act}-${ring}-${idx}`;
            const subplotIdxAttr = (() => {
              const name = scene.subplot && scene.subplot.trim().length > 0 ? scene.subplot : "Main Plot";
              const i = Math.max(0, masterSubplotOrder.indexOf(name));
              return i;
            })();
            let sceneClasses = "rt-scene-path rt-scene-arc";
            if (scene.path && plugin.openScenePaths.has(scene.path)) sceneClasses += " rt-scene-is-open";
            const fontSize = 18;
            svg += `
                            ${renderSceneGroup({ scene, act, ring, idx, innerR, outerR, startAngle: sceneStartAngle, endAngle: sceneEndAngle, subplotIdxAttr })}
                                <path id="${sceneId}"
                                      d="${arcPath2}" 
                                      fill="${color}" 
                                      class="${sceneClasses}"/>

                                <!-- Scene title path (using only the text part) - Skip for Plot notes -->
                                ${!isBeatNote(scene) ? `
                                <path id="textPath-${act}-${ring}-${idx}" 
                                      d="M ${formatNumber(textPathRadius * Math.cos(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} ${formatNumber(textPathRadius * Math.sin(sceneStartAngle + TEXTPATH_START_NUDGE_RAD))} 
                                         A ${formatNumber(textPathRadius)} ${formatNumber(textPathRadius)} 0 0 1 ${formatNumber(textPathRadius * Math.cos(sceneEndAngle))} ${formatNumber(textPathRadius * Math.sin(sceneEndAngle))}" 
                                      fill="none"/>
                                <text class="rt-scene-title${scene.path && plugin.openScenePaths.has(scene.path) ? " rt-scene-is-open" : ""}" data-scene-id="${sceneId}">
                                    <textPath href="#textPath-${act}-${ring}-${idx}" startOffset="4">
                                        ${text}
                                    </textPath>
                                </text>` : `

                                `}
                            </g>`;
          });
          const totalUsedSpace = Array.from(scenePositions.values()).reduce((sum, p) => sum + p.angularSize, 0);
          const totalAngularSpace = endAngle - startAngle;
          const remainingVoidSpace = totalAngularSpace - totalUsedSpace;
          if (remainingVoidSpace > 1e-3) {
            const voidStartAngle = startAngle + totalUsedSpace;
            const voidEndAngle = endAngle;
            const voidArcPath = sceneArcPath(innerR, outerR, voidStartAngle, voidEndAngle);
            svg += `<path d="${voidArcPath}" class="rt-void-cell"/>`;
          }
        } else {
          if (!shouldShowAllScenesInOuterRing(plugin)) {
            const plotNotesInSubplot = plotsBySubplot.get(subplot) || [];
            if (plotNotesInSubplot.length > 0) {
              const middleRadius = (innerR + outerR) / 2;
              const plotAngularWidth = PLOT_PIXEL_WIDTH / middleRadius;
              const totalPlotSpace = plotNotesInSubplot.length * plotAngularWidth;
              const remainingSpace = endAngle - startAngle - totalPlotSpace;
              let currentAngle = startAngle;
              plotNotesInSubplot.forEach((plotNote, idx) => {
                var _a2;
                const plotStartAngle = currentAngle;
                const plotEndAngle = currentAngle + plotAngularWidth;
                const plotIndex = (_a2 = plotIndexByKey.get(`${plotNote.title}::${plotNote.actNumber}`)) != null ? _a2 : 0;
                const totalPlots = totalPlotNotes;
                const maxAdjustment = 40;
                const adjustmentRange = maxAdjustment * 2;
                const position = totalPlots > 1 ? plotIndex / (totalPlots - 1) : 0.5;
                const adjustment = position * adjustmentRange - maxAdjustment;
                const sceneId = `scene-path-${act}-${ring}-${idx}`;
                svg += renderBeatSlice({ act, ring, idx, innerR, outerR, startAngle: plotStartAngle, endAngle: plotEndAngle, sceneId, beat: plotNote });
                currentAngle += plotAngularWidth;
              });
              if (remainingSpace > 1e-3) {
                svg += renderVoidCellPath(innerR, outerR, currentAngle, endAngle);
              }
            } else {
              svg += renderVoidCellPath(innerR, outerR, startAngle, endAngle);
            }
          } else {
            svg += renderVoidCellPath(innerR, outerR, startAngle, endAngle);
          }
        }
      } else {
        svg += renderVoidCellPath(innerR, outerR, startAngle, endAngle);
      }
    }
  }
  stopRingRender();
  svg += renderActBorders({ NUM_ACTS, innerRadius, outerRadius: subplotOuterRadius });
  const actualOuterRadius = ringStartRadii[NUM_RINGS - 1] + ringWidths[NUM_RINGS - 1];
  const keyX = size / 2 - 200;
  const keyY = -size / 2 + 50;
  const swatchSize = 20;
  const textOffset = 30;
  const lineHeight = GRID_LINE_HEIGHT;
  const sceneNotesOnly = scenes.filter((scene) => !isBeatNote(scene));
  const processedScenes = /* @__PURE__ */ new Set();
  const statusCounts = sceneNotesOnly.reduce((acc, scene) => {
    var _a2;
    if (scene.path && processedScenes.has(scene.path)) {
      return acc;
    }
    if (scene.path) {
      processedScenes.add(scene.path);
    }
    const normalizedStatus = ((_a2 = scene.status) == null ? void 0 : _a2.toString().trim().toLowerCase()) || "";
    if (!normalizedStatus || normalizedStatus === "") {
      acc["Todo"] = (acc["Todo"] || 0) + 1;
      return acc;
    }
    if (normalizedStatus === "complete") {
      const publishStage = scene["Publish Stage"] || "Zero";
      const validStage = publishStage;
      acc[validStage] = (acc[validStage] || 0) + 1;
    } else if (scene.due) {
      const originalDueString = scene.due;
      const parts = originalDueString.split("-").map(Number);
      if (parts.length === 3 && !isNaN(parts[0]) && !isNaN(parts[1]) && !isNaN(parts[2])) {
        const dueYear = parts[0];
        const dueMonth = parts[1] - 1;
        const dueDay = parts[2];
        const today = /* @__PURE__ */ new Date();
        const todayYear = today.getFullYear();
        const todayMonth = today.getMonth();
        const todayDay = today.getDate();
        let isOverdue = false;
        if (dueYear < todayYear) {
          isOverdue = true;
        } else if (dueYear === todayYear) {
          if (dueMonth < todayMonth) {
            isOverdue = true;
          } else if (dueMonth === todayMonth) {
            if (dueDay < todayDay) {
              isOverdue = true;
            }
          }
        }
        if (isOverdue) {
          acc["Due"] = (acc["Due"] || 0) + 1;
        } else {
          let statusKey = "Todo";
          if (scene.status) {
            if (Array.isArray(scene.status) && scene.status.length > 0) {
              statusKey = String(scene.status[0]);
            } else if (typeof scene.status === "string") {
              statusKey = scene.status;
            }
          }
          acc[statusKey] = (acc[statusKey] || 0) + 1;
        }
      } else {
        let statusKey = "Todo";
        if (scene.status) {
          if (Array.isArray(scene.status) && scene.status.length > 0) {
            statusKey = String(scene.status[0]);
          } else if (typeof scene.status === "string") {
            statusKey = scene.status;
          }
        }
        acc[statusKey] = (acc[statusKey] || 0) + 1;
      }
    } else {
      let statusKey = "Todo";
      if (scene.status) {
        if (Array.isArray(scene.status) && scene.status.length > 0) {
          statusKey = String(scene.status[0]);
        } else if (typeof scene.status === "string") {
          statusKey = scene.status;
        }
      }
      acc[statusKey] = (acc[statusKey] || 0) + 1;
    }
    return acc;
  }, {});
  plugin.latestStatusCounts = statusCounts;
  const centerRadius = innerRadius * 0.7;
  const centerKeySize = 20;
  const centerLineHeight = 44;
  const stageColorEntries = Object.entries(PUBLISH_STAGE_COLORS);
  const ICON_ID_MAP = {
    Zero: "icon-circle-slash",
    Author: "icon-smile",
    House: "icon-house",
    Press: "icon-printer"
  };
  const statusColorEntries = Object.entries(STATUS_COLORS).filter(([status]) => status !== "Empty" && status !== "Complete");
  const maxEntries = Math.max(stageColorEntries.length, statusColorEntries.length);
  const totalHeight = maxEntries * centerLineHeight;
  const startY = -totalHeight / 2 + centerLineHeight / 2;
  const stagesForGrid = [...STAGES_FOR_GRID];
  const statusesForGrid = [...STATUSES_FOR_GRID];
  const processedPathsForGrid = /* @__PURE__ */ new Set();
  const gridCounts = {};
  stagesForGrid.forEach((s) => {
    gridCounts[s] = { Todo: 0, Working: 0, Due: 0, Completed: 0 };
  });
  scenes.forEach((scene) => {
    if (isBeatNote(scene)) return;
    if (!scene.path || processedPathsForGrid.has(scene.path)) return;
    processedPathsForGrid.add(scene.path);
    const rawStage = scene["Publish Stage"];
    const stageKey = STAGES_FOR_GRID.includes(rawStage) ? rawStage : "Zero";
    const normalized = normalizeStatus(scene.status);
    let bucket = "Todo";
    if (normalized === "Completed") {
      bucket = "Completed";
    } else if (scene.due && isOverdueDateString(scene.due)) {
      bucket = "Due";
    } else if (normalized) {
      bucket = normalized;
    }
    if (!(bucket in gridCounts[stageKey])) {
      bucket = "Todo";
    }
    gridCounts[stageKey][bucket] += 1;
  });
  const cellBase = GRID_CELL_BASE;
  const cellWidth = Math.round(cellBase * 1.5) + GRID_CELL_WIDTH_EXTRA;
  const cellHeight = cellBase;
  const cellGapY = GRID_CELL_GAP_Y;
  const cellGapX = GRID_CELL_GAP_X;
  const gridWidth = statusesForGrid.length * cellWidth + (statusesForGrid.length - 1) * cellGapX;
  const gridHeight = stagesForGrid.length * cellHeight + (stagesForGrid.length - 1) * cellGapY;
  const startXGrid = -gridWidth / 2;
  const startYGrid = -gridHeight / 2;
  const uniqueSceneCount = processedPathsForGrid.size;
  const seenTitlePaths = /* @__PURE__ */ new Set();
  let maxSceneNumber = 0;
  scenes.forEach((scene) => {
    if (isBeatNote(scene)) return;
    if (!scene.path || seenTitlePaths.has(scene.path)) return;
    seenTitlePaths.add(scene.path);
    const { number } = parseSceneTitle(scene.title || "", scene.number);
    if (number && typeof number === "string") {
      const asNum = Number(number.replace(/\D/g, ""));
      if (!isNaN(asNum)) maxSceneNumber = Math.max(maxSceneNumber, asNum);
    }
  });
  const baseTotalScenes = Math.max(uniqueSceneCount, maxSceneNumber);
  const currentYearLabel = String((/* @__PURE__ */ new Date()).getFullYear());
  const headerY = startYGrid - (cellGapY + GRID_HEADER_OFFSET_Y);
  const uniqueScenesCount = processedPathsForGrid.size;
  const seenForMax = /* @__PURE__ */ new Set();
  let highestPrefixNumber = 0;
  scenes.forEach((scene) => {
    if (isBeatNote(scene)) return;
    if (!scene.path || seenForMax.has(scene.path)) return;
    seenForMax.add(scene.path);
    const { number } = parseSceneTitle(scene.title || "", scene.number);
    if (number) {
      const n = parseFloat(String(number));
      if (!isNaN(n)) {
        highestPrefixNumber = Math.max(highestPrefixNumber, n);
      }
    }
  });
  const estimatedTotalScenes = Math.max(uniqueScenesCount, Math.floor(highestPrefixNumber));
  let maxStageIdxForGrid = -1;
  for (let i = 0; i < stagesForGrid.length; i++) {
    const rc = gridCounts[stagesForGrid[i]];
    const rowTotal = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0) + (rc.Completed || 0);
    if (rowTotal > 0) maxStageIdxForGrid = i;
  }
  const isStageCompleteForGridRow = (rowIndex, gridCounts2, stages, maxStageIdxForGrid2) => {
    const stage = stages[rowIndex];
    const rc = gridCounts2[stage];
    const rowTotal = (rc.Todo || 0) + (rc.Working || 0) + (rc.Due || 0) + (rc.Completed || 0);
    return rowTotal === 0 && maxStageIdxForGrid2 > rowIndex;
  };
  const renderGridCell = (stage, status, x, y, count, cellWidth2, cellHeight2) => {
    let fillAttr = "";
    if (status === "Completed") {
      const solid = PUBLISH_STAGE_COLORS[stage] || "#888888";
      fillAttr = `fill="${solid}"`;
    } else if (status === "Working") {
      fillAttr = `fill="url(#plaidWorking${stage})"`;
    } else if (status === "Todo") {
      fillAttr = `fill="url(#plaidTodo${stage})"`;
    } else if (status === "Due") {
      fillAttr = `fill="var(--rt-color-due)"`;
    } else {
      fillAttr = `fill="#888888"`;
    }
    const cellOpacity = count <= 0 ? 0.1 : 1;
    return `
                <g transform="translate(${x}, ${y})">
                    <rect x="0" y="0" width="${cellWidth2}" height="${cellHeight2}" ${fillAttr} fill-opacity="${cellOpacity}">
                        ${count > 0 ? `<title>${stage} \u2022 ${status}: ${count}</title>` : ""}
                    </rect>
                    ${status === "Completed" && count > 0 ? `<text x="2" y="${cellHeight2 - 3}" text-anchor="start" dominant-baseline="alphabetic" class="grid-completed-count">${count}</text>` : ""}
                </g>
            `;
  };
  svg += renderCenterGrid({
    statusesForGrid,
    stagesForGrid,
    gridCounts,
    PUBLISH_STAGE_COLORS,
    currentYearLabel,
    estimatedTotalScenes,
    startXGrid,
    startYGrid,
    cellWidth,
    cellHeight,
    cellGapX,
    cellGapY,
    headerY,
    stageTooltips: STAGE_HEADER_TOOLTIPS,
    statusTooltips: STATUS_HEADER_TOOLTIPS
  });
  if (estimateResult) {
    svg += renderEstimatedDateElements({ estimateDate: estimateResult.date, progressRadius });
  }
  svg += `<g class="background-layer">`;
  svg += renderSubplotLabels({ NUM_RINGS, ringStartRadii, ringWidths, masterSubplotOrder, plugin });
  svg += `</g>`;
  if (shouldShowAllScenesInOuterRing(plugin)) {
    svg += `<g class="rt-number-squares">`;
    const ringOuter = NUM_RINGS - 1;
    const innerROuter = ringStartRadii[ringOuter];
    const outerROuter = innerROuter + ringWidths[ringOuter];
    const squareRadiusOuter = (innerROuter + outerROuter) / 2;
    const currentMode2 = plugin.settings.currentMode || "narrative";
    const isChronologueMode2 = currentMode2 === "chronologue";
    const sortByWhen2 = isChronologueMode2 ? true : (_c = plugin.settings.sortByWhenDate) != null ? _c : false;
    const actsToRender2 = sortByWhen2 ? 1 : NUM_ACTS;
    for (let act = 0; act < actsToRender2; act++) {
      let startAngle;
      let endAngle;
      if (sortByWhen2) {
        startAngle = -Math.PI / 2;
        endAngle = 3 * Math.PI / 2;
      } else {
        startAngle = act * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
        endAngle = (act + 1) * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
      }
      const seenPaths = /* @__PURE__ */ new Set();
      const seenPlotKeys = /* @__PURE__ */ new Set();
      const combined = [];
      scenes.forEach((s) => {
        var _a2;
        if (!sortByWhen2) {
          const sAct = s.actNumber !== void 0 ? s.actNumber - 1 : 0;
          if (sAct !== act) return;
        }
        if (isBeatNote(s)) {
          if (isChronologueMode2) return;
          const pKey = `${String(s.title || "")}::${String((_a2 = s.actNumber) != null ? _a2 : "")}`;
          if (seenPlotKeys.has(pKey)) return;
          seenPlotKeys.add(pKey);
          combined.push(s);
        } else {
          const key = s.path || `${s.title || ""}::${String(s.when || "")}`;
          if (seenPaths.has(key)) return;
          seenPaths.add(key);
          combined.push(s);
        }
      });
      const forceChronological2 = isChronologueMode2;
      const sortedCombined = sortScenes(combined, sortByWhen2, forceChronological2);
      const positionsDetailed = computePositions(innerROuter, outerROuter, startAngle, endAngle, sortedCombined);
      const positions = /* @__PURE__ */ new Map();
      positionsDetailed.forEach((p, i) => positions.set(i, { startAngle: p.startAngle, endAngle: p.endAngle }));
      svg += renderOuterRingNumberSquares({
        plugin,
        act,
        ringOuter,
        squareRadiusOuter,
        positions,
        combined: sortedCombined,
        sceneGrades,
        enableSubplotColors: shouldApplyNumberSquareColors,
        resolveSubplotVisual: numberSquareVisualResolver || void 0
      });
    }
    svg += renderInnerRingsNumberSquaresAllScenes({
      plugin,
      NUM_RINGS,
      masterSubplotOrder,
      ringStartRadii,
      ringWidths,
      scenesByActAndSubplot,
      scenes,
      sceneGrades,
      enableSubplotColors: shouldApplyNumberSquareColors,
      resolveSubplotVisual: numberSquareVisualResolver || void 0
    });
    svg += `</g>`;
  } else if (!shouldShowAllScenesInOuterRing(plugin)) {
    svg += renderNumberSquaresStandard({
      plugin,
      NUM_RINGS,
      masterSubplotOrder,
      ringStartRadii,
      ringWidths,
      scenesByActAndSubplot,
      scenes,
      sceneGrades,
      sceneNumbersMap,
      enableSubplotColors: shouldApplyNumberSquareColors,
      resolveSubplotVisual: numberSquareVisualResolver || void 0
    });
  }
  svg += `</g>`;
  const synopsisHTML = serializeSynopsesToString(synopsesElements);
  {
    const views = plugin.app.workspace.getLeavesOfType("radial-timeline");
    const isGossamerMode = views.some((leaf) => {
      const view = leaf.view;
      const mode = view == null ? void 0 : view.currentMode;
      return mode === "gossamer";
    });
    if (isGossamerMode) {
      const polar = { innerRadius, outerRadius: actualOuterRadius };
      const outerRingInnerRadius = ringStartRadii[NUM_RINGS - 1];
      const run = plugin._gossamerLastRun || null;
      const anglesByBeat = plugin._beatAngles || /* @__PURE__ */ new Map();
      const beatPathByName = /* @__PURE__ */ new Map();
      scenes.forEach((s) => {
        if (!isBeatNote(s) || !s.title || !s.path) return;
        const titleWithoutNumber = s.title.replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
        beatPathByName.set(titleWithoutNumber, s.path);
      });
      const publishStageColorByBeat = /* @__PURE__ */ new Map();
      scenes.forEach((s) => {
        if (!isBeatNote(s) || !s.title) return;
        const titleWithoutNumber = s.title.replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
        const publishStage = s["Publish Stage"] || "Zero";
        const stageColor = PUBLISH_STAGE_COLORS[publishStage] || PUBLISH_STAGE_COLORS.Zero;
        publishStageColorByBeat.set(titleWithoutNumber, stageColor);
      });
      const beatSlicesByName = plugin._beatSlices || /* @__PURE__ */ new Map();
      svg += renderGossamerMonthSpokes({ innerRadius, outerRadius: actualOuterRadius });
      const historicalRuns = plugin._gossamerHistoricalRuns || [];
      const minMax = plugin._gossamerMinMax || null;
      const hasAnyScores = plugin._gossamerHasAnyScores || false;
      const layer = renderGossamerLayer(
        scenes,
        run,
        polar,
        anglesByBeat.size ? anglesByBeat : void 0,
        beatPathByName,
        historicalRuns,
        // Historical runs (Gossamer2-5)
        minMax,
        // Min/max band
        outerRingInnerRadius,
        publishStageColorByBeat,
        beatSlicesByName,
        plugin.settings.publishStageColors,
        hasAnyScores
        // Flag to control whether to show red zeros for missing scores
      );
      if (layer) svg += layer;
    }
  }
  svg += synopsisHTML;
  svg += `</g>`;
  const act2BaseAngle = 1 * 2 * Math.PI / NUM_ACTS - Math.PI / 2;
  const act2Angle = act2BaseAngle;
  const arrowRadius = actualOuterRadius + 46;
  const arrowAngleAdjust = -(0.6 * Math.PI) / 180;
  const arrowAngle = act2Angle + arrowAngleAdjust;
  const arrowX = formatNumber(arrowRadius * Math.cos(arrowAngle));
  const arrowY = formatNumber(arrowRadius * Math.sin(arrowAngle));
  const arrowRotateDeg = (act2BaseAngle + Math.PI / 2) * 180 / Math.PI - 90;
  svg += `
            <g id="rotation-toggle" class="rotation-toggle" transform="translate(${arrowX}, ${arrowY}) rotate(${formatNumber(arrowRotateDeg)})">
                <use id="rotation-arrow-up" class="arrow-icon" href="#icon-arrow-up-from-line" x="-14.4" y="-14.4" width="26" height="26" />
                <use id="rotation-arrow-down" class="arrow-icon is-hidden" href="#icon-arrow-down-from-line" x="-14.4" y="-14.4" width="26" height="26" />
                <rect x="-18" y="-18" width="36" height="36" fill="transparent" pointer-events="all">
                    <title>Rotate timeline</title>
                </rect>
            </g>
        `;
  if (isChronologueMode) {
    const stopChronoOverlays = startPerfSegment(plugin, "timeline.chronologue-overlays");
    const durationCapMs = durationSelectionToMs(plugin.settings.chronologueDurationCapSelection);
    const chronologueTimelineArc = renderChronologueTimelineArc(
      scenes,
      subplotOuterRadius,
      // Use subplot outer radius for arcs
      manuscriptOrderPositions,
      durationCapMs,
      CHRONOLOGUE_DURATION_ARC_RADIUS,
      // Pass the absolute radius constant
      chronologueSceneEntries
    );
    if (chronologueTimelineArc) {
      svg += chronologueTimelineArc;
    }
    const outerRingIndex = NUM_RINGS - 1;
    const outerRingInnerR = ringStartRadii[outerRingIndex];
    const outerRingOuterR = outerRingInnerR + ringWidths[outerRingIndex];
    let customThresholdMs = void 0;
    if (plugin.settings.discontinuityThreshold) {
      const parsed = parseDurationDetail(plugin.settings.discontinuityThreshold);
      if (parsed) {
        customThresholdMs = parsed.ms;
      }
    }
    svg += renderChronologicalBackboneArc(
      scenes,
      outerRingInnerR,
      outerRingOuterR,
      3,
      manuscriptOrderPositions,
      chronologueSceneEntries,
      customThresholdMs
    );
    if (boundaryLabelsHtml) {
      svg += boundaryLabelsHtml;
    }
    stopChronoOverlays();
  }
  const scriptSection = ``;
  svg += `${scriptSection}</svg>`;
  const generatedSvgString = svg;
  stopTotalPerf();
  return { svgString: generatedSvgString, maxStageColor };
}

// src/services/RendererService.ts
var RendererService = class {
  constructor(app) {
    this.app = app;
  }
  generateTimeline(plugin, scenes) {
    return createTimelineSVG(plugin, scenes);
  }
  adjustBeatLabelsAfterRender(container) {
    adjustBeatLabelsAfterRender(container);
  }
  /**
   * Update scene colors for dominant subplot changes (DOM update)
   */
  updateSceneColorsDOM(container, plugin, changedScenes) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateSceneColors(svg, plugin, changedScenes);
  }
  /**
   * Update number square states (status, AI grades) (DOM update)
   */
  updateNumberSquaresDOM(container, plugin, scenes) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateNumberSquareStates(svg, plugin, scenes);
  }
  /**
   * Update synopsis text content (DOM update)
   */
  updateSynopsisDOM(container, changedScenes) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateSynopsisText(svg, changedScenes);
  }
  /**
   * Update subplot labels for mode changes (DOM update)
   */
  updateSubplotLabelsDOM(container, newLabels) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    return updateSubplotLabels(svg, newLabels);
  }
  /**
   * Update open-file visual state without full re-render.
   * Adds/removes rt-scene-is-open classes on scene groups and associated number elements.
   */
  updateOpenClasses(container, openPaths) {
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const sceneGroups = Array.from(svg.querySelectorAll(".rt-scene-group"));
    sceneGroups.forEach((group) => {
      const encPath = group.getAttribute("data-path");
      const path = encPath ? decodeURIComponent(encPath) : "";
      const isOpen = path !== "" && openPaths.has(path);
      group.classList.toggle("rt-scene-is-open", isOpen);
      const scenePath = group.querySelector(".rt-scene-path");
      const sceneTitle = group.querySelector(".rt-scene-title");
      if (scenePath) scenePath.classList.toggle("rt-scene-is-open", isOpen);
      if (sceneTitle) sceneTitle.classList.toggle("rt-scene-is-open", isOpen);
      const sceneId = scenePath == null ? void 0 : scenePath.id;
      if (sceneId) {
        const numSquare = svg.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
        const numText = svg.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
        if (numSquare) numSquare.classList.toggle("rt-scene-is-open", isOpen);
        if (numText) numText.classList.toggle("rt-scene-is-open", isOpen);
      }
    });
    return true;
  }
  /**
   * Rebuild search highlights without full re-render.
   * Clears previous rt-search-term nodes and rt-search-result classes,
   * then re-applies highlights using existing logic.
   */
  updateSearchHighlights(view) {
    const container = view.containerEl.children[1];
    if (!container) return false;
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const existing = svg.querySelectorAll(".rt-search-term");
    existing.forEach((node) => {
      const parent = node.parentNode;
      if (!parent) return node.remove();
      const textNode = document.createTextNode(node.textContent || "");
      parent.replaceChild(textNode, node);
    });
    try {
      addHighlightRectangles(view);
    } catch (e) {
    }
    return true;
  }
  /**
   * Selectively rebuild or remove the Gossamer layer and spokes inside the existing SVG.
   * - If the view is in gossamer mode, (re)generates spokes + layer and inserts them before synopses.
   * - If not in gossamer mode, removes any existing gossamer elements.
   * Returns true on success, false if SVG or required data is missing (caller may fall back to full refresh).
   */
  updateGossamerLayer(view) {
    var _a, _b, _c;
    const container = view.containerEl.children[1];
    if (!container) return false;
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const applyGossamerMask = () => {
      if (view.currentMode === "gossamer") {
        svg.setAttribute("data-gossamer-mode", "true");
        const elements = svg.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
        elements.forEach((el) => {
          const group = el.closest(".rt-scene-group");
          const itemType = group == null ? void 0 : group.getAttribute("data-item-type");
          if (itemType !== "Beat") {
            el.classList.add("rt-non-selected");
          }
        });
      } else {
        svg.removeAttribute("data-gossamer-mode");
      }
    };
    const removeExisting = () => {
      svg.querySelectorAll(".rt-gossamer-layer, .rt-gossamer-spokes").forEach((node) => {
        var _a2;
        return (_a2 = node.parentNode) == null ? void 0 : _a2.removeChild(node);
      });
    };
    const captureGeometry = () => {
      let innerRadius2 = null;
      let outerRadius2 = null;
      const existingGossamerSpoke = svg.querySelector(".rt-gossamer-spokes line");
      if (existingGossamerSpoke) {
        const x1 = Number(existingGossamerSpoke.getAttribute("x1") || "0");
        const y1 = Number(existingGossamerSpoke.getAttribute("y1") || "0");
        const x2 = Number(existingGossamerSpoke.getAttribute("x2") || "0");
        const y2 = Number(existingGossamerSpoke.getAttribute("y2") || "0");
        innerRadius2 = Math.hypot(x1, y1);
        outerRadius2 = Math.hypot(x2, y2);
      }
      const beatGroups = Array.from(svg.querySelectorAll('.rt-scene-group[data-item-type="Beat"]'));
      if (beatGroups.length > 0) {
        if (innerRadius2 === null || !Number.isFinite(innerRadius2)) {
          const inners = beatGroups.map((g) => Number(g.getAttribute("data-inner-r") || "0")).filter((n) => Number.isFinite(n));
          if (inners.length > 0) innerRadius2 = Math.min(...inners);
        }
        if (outerRadius2 === null || !Number.isFinite(outerRadius2)) {
          const outers = beatGroups.map((g) => Number(g.getAttribute("data-outer-r") || "0")).filter((n) => Number.isFinite(n));
          if (outers.length > 0) outerRadius2 = Math.max(...outers);
        }
      }
      if (innerRadius2 === null || !Number.isFinite(innerRadius2)) innerRadius2 = 200;
      if (outerRadius2 === null || !Number.isFinite(outerRadius2)) outerRadius2 = innerRadius2 + 300;
      let outerRingInnerRadius2 = innerRadius2;
      if (beatGroups.length > 0) {
        const inners = beatGroups.map((g) => Number(g.getAttribute("data-inner-r") || "0")).filter((n) => Number.isFinite(n));
        if (inners.length > 0) outerRingInnerRadius2 = Math.min(...inners);
      }
      return { innerRadius: innerRadius2, outerRadius: outerRadius2, outerRingInnerRadius: outerRingInnerRadius2 };
    };
    const isGossamerMode = view.currentMode === "gossamer";
    if (!isGossamerMode) {
      removeExisting();
      applyGossamerMask();
      return true;
    }
    const pluginAny = view.plugin;
    const run = pluginAny._gossamerLastRun || null;
    if (!run) {
      removeExisting();
      applyGossamerMask();
      return false;
    }
    const scenes = Array.isArray(view.sceneData) && view.sceneData.length > 0 ? view.sceneData : view.plugin.lastSceneData || [];
    const anglesByBeat = pluginAny._beatAngles || /* @__PURE__ */ new Map();
    const beatSlicesByName = pluginAny._beatSlices || /* @__PURE__ */ new Map();
    const beatPathByName = /* @__PURE__ */ new Map();
    const publishStageColorByBeat = /* @__PURE__ */ new Map();
    if (scenes.length > 0) {
      scenes.forEach((s) => {
        if (s.itemType !== "Plot" || !s.title) return;
        const titleWithoutNumber = (s.title || "").replace(/^\s*\d+(?:\.\d+)?\s+/, "").trim();
        if (s.path) beatPathByName.set(titleWithoutNumber, s.path);
        const publishStage = s["Publish Stage"] || "Zero";
        const PUBLISH_STAGE_COLORS = view.plugin.PUBLISH_STAGE_COLORS;
        if (PUBLISH_STAGE_COLORS) {
          const stageColor = PUBLISH_STAGE_COLORS[publishStage] || PUBLISH_STAGE_COLORS.Zero;
          publishStageColorByBeat.set(titleWithoutNumber, stageColor);
        }
      });
    }
    const { innerRadius, outerRadius, outerRingInnerRadius } = captureGeometry();
    removeExisting();
    const historicalRuns = pluginAny._gossamerHistoricalRuns || [];
    const minMax = pluginAny._gossamerMinMax || null;
    const spokesHtml = renderGossamerMonthSpokes({ innerRadius, outerRadius });
    const layerHtml = renderGossamerLayer(
      scenes || [],
      run,
      { innerRadius, outerRadius },
      anglesByBeat.size ? anglesByBeat : void 0,
      beatPathByName.size ? beatPathByName : void 0,
      historicalRuns,
      minMax,
      outerRingInnerRadius,
      publishStageColorByBeat.size ? publishStageColorByBeat : void 0,
      beatSlicesByName,
      (_a = view.plugin.settings) == null ? void 0 : _a.publishStageColors
    );
    const toNode = (html) => {
      if (!html) return null;
      const parser = new DOMParser();
      const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${html}</svg>`, "image/svg+xml");
      return doc.documentElement.firstElementChild;
    };
    const spokesNode = toNode(spokesHtml);
    const layerNode = toNode(layerHtml);
    if (!spokesNode && !layerNode) {
      applyGossamerMask();
      return false;
    }
    const firstSynopsis = svg.querySelector(".rt-scene-info");
    if (firstSynopsis) {
      if (spokesNode) (_b = firstSynopsis.parentNode) == null ? void 0 : _b.insertBefore(spokesNode, firstSynopsis);
      if (layerNode) (_c = firstSynopsis.parentNode) == null ? void 0 : _c.insertBefore(layerNode, firstSynopsis);
    } else {
      if (spokesNode) svg.appendChild(spokesNode);
      if (layerNode) svg.appendChild(layerNode);
    }
    applyGossamerMask();
    return true;
  }
  /**
   * Selectively update the year progress ring, target-date tick/marker,
   * and estimated date elements without full re-render.
   */
  updateProgressAndTicks(view) {
    var _a;
    const container = view.containerEl.children[1];
    if (!container) return false;
    const svg = container.querySelector(".radial-timeline-svg");
    if (!svg) return false;
    const baseCircle = svg.querySelector("circle.progress-ring-base");
    if (!baseCircle) return false;
    const progressRadius = Number(baseCircle.getAttribute("r") || "0");
    if (!Number.isFinite(progressRadius) || progressRadius <= 0) return false;
    svg.querySelectorAll("path.progress-ring-fill").forEach((n) => {
      var _a2;
      return (_a2 = n.parentNode) == null ? void 0 : _a2.removeChild(n);
    });
    svg.querySelectorAll("line.target-date-tick, rect.target-date-marker").forEach((n) => {
      var _a2;
      return (_a2 = n.parentNode) == null ? void 0 : _a2.removeChild(n);
    });
    svg.querySelectorAll("line.estimated-date-tick, circle.estimated-date-dot, text.estimation-date-label").forEach((n) => {
      var _a2;
      return (_a2 = n.parentNode) == null ? void 0 : _a2.removeChild(n);
    });
    svg.querySelectorAll("path.progress-ring-base").forEach((n) => {
      var _a2;
      return (_a2 = n.parentNode) == null ? void 0 : _a2.removeChild(n);
    });
    const now = /* @__PURE__ */ new Date();
    const startOfYear = new Date(now.getFullYear(), 0, 1);
    const yearProgress = (now.getTime() - startOfYear.getTime()) / (1e3 * 60 * 60 * 24 * 365);
    const currentYearStartAngle = -Math.PI / 2;
    const segmentsHtml = renderProgressRing({ progressRadius, yearProgress, currentYearStartAngle, segmentCount: 6 });
    const tickHtml = renderTargetDateTick({ plugin: view.plugin, progressRadius, dateToAngle });
    let estimationHtml = "";
    try {
      if (((_a = view.plugin.settings.showEstimate) != null ? _a : true) && typeof view.plugin.calculateCompletionEstimate === "function") {
        const scenes = view.sceneData || view.plugin.lastSceneData || [];
        const estimateResult = view.plugin.calculateCompletionEstimate(scenes);
        if (estimateResult) {
          const yearsDiff = estimateResult.date.getFullYear() - now.getFullYear();
          if (yearsDiff <= 0) {
            estimationHtml += renderEstimationArc({ estimateDate: estimateResult.date, progressRadius });
          }
          estimationHtml += renderEstimatedDateElements({ estimateDate: estimateResult.date, progressRadius });
        }
      }
    } catch (e) {
    }
    const combined = `${estimationHtml}${segmentsHtml}${tickHtml}`;
    const parser = new DOMParser();
    const doc = parser.parseFromString(`<svg xmlns="http://www.w3.org/2000/svg">${combined}</svg>`, "image/svg+xml");
    const toInsert = Array.from(doc.documentElement.children);
    if (toInsert.length === 0) return true;
    const parent = baseCircle.parentNode;
    if (!parent) return false;
    const nextSibling = baseCircle.nextSibling;
    toInsert.forEach((el) => parent.insertBefore(svg.ownerDocument.importNode(el, true), nextSibling));
    return true;
  }
};

// src/settings/SettingsTab.ts
var import_obsidian35 = require("obsidian");

// src/settings/FolderSuggest.ts
var import_obsidian21 = require("obsidian");
var FolderSuggest = class extends import_obsidian21.AbstractInputSuggest {
  constructor(app, input, plugin, text) {
    super(app, input);
    this.plugin = plugin;
    this.text = text;
  }
  getSuggestions(query) {
    var _a, _b, _c, _d;
    const q = (_a = query == null ? void 0 : query.toLowerCase()) != null ? _a : "";
    const folders = (_d = (_c = (_b = this.app.vault).getAllFolders) == null ? void 0 : _c.call(_b)) != null ? _d : this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian21.TFolder);
    if (!q) return folders;
    return folders.filter((f) => f.path.toLowerCase().includes(q));
  }
  renderSuggestion(folder, el) {
    el.setText(folder.path);
  }
  selectSuggestion(folder, _evt) {
    const inputEl = this.text.inputEl;
    const normalized = (0, import_obsidian21.normalizePath)(folder.path);
    try {
      this.text.setValue(normalized);
    } catch (e) {
    }
    if (this.inputEl) {
      try {
        this.inputEl.value = normalized;
      } catch (e) {
      }
    }
    void this.plugin.validateAndRememberPath(normalized).then(async (ok) => {
      if (ok) {
        this.plugin.settings.sourcePath = normalized;
        await this.plugin.saveSettings();
        inputEl.removeClass("setting-input-error");
        inputEl.addClass("setting-input-success");
        window.setTimeout(() => inputEl.removeClass("setting-input-success"), 1e3);
      } else {
        inputEl.addClass("setting-input-error");
        window.setTimeout(() => inputEl.removeClass("setting-input-error"), 2e3);
      }
      try {
        this.close();
      } catch (e) {
      }
      try {
        inputEl.focus();
      } catch (e) {
      }
    });
  }
};

// src/settings/sections/GeneralSection.ts
var import_obsidian22 = require("obsidian");
function renderGeneralSection(params) {
  const { app, plugin, attachFolderSuggest, containerEl } = params;
  const sourcePathSetting = new import_obsidian22.Setting(containerEl).setName("Source path").setDesc("Specify the root folder containing your manuscript scene files.");
  let textInput;
  sourcePathSetting.addText((text) => {
    var _a;
    textInput = text;
    text.setPlaceholder("Example: Manuscript/Scenes").setValue(plugin.settings.sourcePath);
    attachFolderSuggest(text);
    if ((_a = plugin.settings.sourcePath) == null ? void 0 : _a.trim()) {
      window.setTimeout(async () => {
        const isValid = await plugin.validateAndRememberPath(plugin.settings.sourcePath);
        if (isValid) {
          text.inputEl.addClass("rt-setting-input-success");
          window.setTimeout(() => {
            text.inputEl.removeClass("rt-setting-input-success");
          }, 2e3);
        }
      }, 100);
    }
    text.onChange(async (value) => {
      var _a2;
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
      const trimmed = value.trim();
      const normalizedValue = trimmed ? (0, import_obsidian22.normalizePath)(trimmed) : "";
      if (trimmed) {
        const isValid = await plugin.validateAndRememberPath(normalizedValue);
        if (isValid) {
          plugin.settings.sourcePath = normalizedValue;
          await plugin.saveSettings();
          text.inputEl.addClass("rt-setting-input-success");
          window.setTimeout(() => {
            text.inputEl.removeClass("rt-setting-input-success");
          }, 1e3);
        } else {
          text.inputEl.addClass("rt-setting-input-error");
          window.setTimeout(() => {
            text.inputEl.removeClass("rt-setting-input-error");
          }, 2e3);
        }
      } else {
        plugin.settings.sourcePath = normalizedValue;
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        const suggestions = (_a2 = text.inputEl.closest(".setting-item")) == null ? void 0 : _a2.querySelector(".source-path-suggestions");
        suggestions == null ? void 0 : suggestions.classList.add("hidden");
        text.inputEl.addClass("rt-setting-input-success");
        window.setTimeout(() => {
          text.inputEl.removeClass("rt-setting-input-success");
        }, 1e3);
      }
    });
  });
}

// src/settings/sections/PublicationSection.ts
var import_obsidian23 = require("obsidian");
function renderPublicationSection(params) {
  const { app, plugin, containerEl } = params;
  new import_obsidian23.Setting(containerEl).setName("Publication and progress").setHeading();
  new import_obsidian23.Setting(containerEl).setName("Target completion date").setDesc("Optional: Set a target date for project completion (YYYY-MM-DD). This will be shown on the timeline.").addText((text) => {
    text.inputEl.type = "date";
    text.setValue(plugin.settings.targetCompletionDate || "").onChange(async (value) => {
      const today = /* @__PURE__ */ new Date();
      today.setHours(0, 0, 0, 0);
      if (!value) {
        plugin.settings.targetCompletionDate = void 0;
        text.inputEl.removeClass("rt-setting-input-error");
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        return;
      }
      const selectedDate = /* @__PURE__ */ new Date(value + "T00:00:00");
      if (selectedDate > today) {
        plugin.settings.targetCompletionDate = value;
        text.inputEl.removeClass("rt-setting-input-error");
      } else {
        new import_obsidian23.Notice("Target date must be in the future.");
        text.setValue(plugin.settings.targetCompletionDate || "");
        return;
      }
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
  });
  new import_obsidian23.Setting(containerEl).setName("Show estimated completion date").setDesc("Toggle the estimation date label near the progress ring.").addToggle((toggle) => {
    var _a;
    return toggle.setValue((_a = plugin.settings.showEstimate) != null ? _a : true).onChange(async (value) => {
      plugin.settings.showEstimate = value;
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
  });
  new import_obsidian23.Setting(containerEl).setName("Zero draft mode").setDesc("Intercept clicks on scenes with Publish Stage = Zero and Status = Complete to capture Pending Edits without opening the scene.").addToggle((toggle) => {
    var _a;
    return toggle.setValue((_a = plugin.settings.enableZeroDraftMode) != null ? _a : false).onChange(async (value) => {
      plugin.settings.enableZeroDraftMode = value;
      await plugin.saveSettings();
    });
  });
}

// src/settings/sections/ChronologueSection.ts
var import_obsidian24 = require("obsidian");
init_date();
async function collectDurationCapOptions(plugin) {
  let scenes = plugin.lastSceneData;
  if (!Array.isArray(scenes) || scenes.length === 0) {
    try {
      scenes = await plugin.getSceneData();
    } catch (e) {
      return [];
    }
  }
  const dedupeKeys = /* @__PURE__ */ new Set();
  const optionsMap = /* @__PURE__ */ new Map();
  (scenes != null ? scenes : []).forEach((scene) => {
    var _a;
    if (scene.itemType === "Beat" || scene.itemType === "Plot") return;
    const identifier = scene.path || `${(_a = scene.title) != null ? _a : ""}|${scene.date}`;
    if (!identifier || dedupeKeys.has(identifier)) return;
    dedupeKeys.add(identifier);
    const detail = parseDurationDetail(scene.Duration);
    if (!detail) return;
    const key = `${detail.value}|${detail.unitKey}`;
    const unitLabel = detail.value === 1 ? detail.unitSingular : detail.unitPlural;
    const label = `${detail.valueText} ${unitLabel}`;
    const existing = optionsMap.get(key);
    if (existing) {
      existing.count += 1;
    } else {
      optionsMap.set(key, { label, count: 1, ms: detail.ms });
    }
  });
  return Array.from(optionsMap.entries()).map(([key, data]) => ({
    key,
    label: data.label,
    count: data.count,
    ms: data.ms
  })).sort((a, b) => a.ms - b.ms);
}
function renderChronologueSection(params) {
  var _a;
  const { app, plugin, containerEl } = params;
  new import_obsidian24.Setting(containerEl).setName("Chronologue mode settings").setHeading();
  const baseDurationDesc = "Scenes with durations at or above the selected value fill the entire segment. All other durations below this are proportionally scaled.";
  const durationSetting = new import_obsidian24.Setting(containerEl).setName("Chronologue duration arc cap").setDesc(baseDurationDesc);
  const savedCapSelection = (_a = plugin.settings.chronologueDurationCapSelection) != null ? _a : "auto";
  let durationDropdown;
  durationSetting.addDropdown((dropdown) => {
    durationDropdown = dropdown;
    dropdown.addOption("auto", "Longest observed duration (auto)");
    dropdown.setValue(savedCapSelection);
    dropdown.onChange(async (value) => {
      plugin.settings.chronologueDurationCapSelection = value;
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
    });
    dropdown.selectEl.style.setProperty("width", "160px", "important");
    dropdown.selectEl.style.setProperty("min-width", "160px", "important");
    dropdown.selectEl.style.setProperty("max-width", "160px", "important");
  });
  collectDurationCapOptions(plugin).then((options) => {
    const dropdown = durationDropdown;
    if (!dropdown) return;
    if (options.length === 0) {
      durationSetting.setDesc(`${baseDurationDesc} No scene durations detected yet.`);
    } else {
      options.forEach((opt) => {
        if (!dropdown.selectEl.querySelector(`option[value="${opt.key}"]`)) {
          dropdown.addOption(opt.key, `${opt.label} (${opt.count})`);
        }
      });
    }
    if (savedCapSelection !== "auto" && dropdown.selectEl.querySelector(`option[value="${savedCapSelection}"]`) === null) {
      const fallbackLabel = formatDurationSelectionLabel(savedCapSelection);
      if (fallbackLabel) {
        dropdown.addOption(savedCapSelection, `${fallbackLabel} (0)`);
      }
    }
    dropdown.setValue(savedCapSelection);
  }).catch(() => {
    if (!durationDropdown) return;
    durationSetting.setDesc(`${baseDurationDesc} Unable to load duration data.`);
  });
  const getScenesForThreshold = async () => {
    if (Array.isArray(plugin.lastSceneData) && plugin.lastSceneData.length > 0) {
      return plugin.lastSceneData;
    }
    try {
      const fetched = await plugin.getSceneData();
      if (Array.isArray(fetched) && fetched.length > 0) {
        plugin.lastSceneData = fetched;
        return fetched;
      }
      return [];
    } catch (err) {
      console.error("[Settings] Failed to load scenes for discontinuity threshold:", err);
      return [];
    }
  };
  const calculateAutoThreshold = async () => {
    try {
      const scenes = await getScenesForThreshold();
      const thresholdMs = calculateAutoDiscontinuityThreshold(scenes);
      if (thresholdMs === null) {
        return { display: "not yet calculated", days: null };
      }
      const minutes = thresholdMs / (60 * 1e3);
      const hours = thresholdMs / (60 * 60 * 1e3);
      const days = thresholdMs / (24 * 60 * 60 * 1e3);
      let display;
      if (days >= 1) {
        display = `${Math.round(days)} ${Math.round(days) === 1 ? "day" : "days"}`;
      } else if (hours >= 1) {
        display = `${Math.round(hours)} ${Math.round(hours) === 1 ? "hour" : "hours"}`;
      } else {
        display = `${Math.round(minutes)} ${Math.round(minutes) === 1 ? "minute" : "minutes"}`;
      }
      return { display, days: Math.round(days * 100) / 100 };
    } catch (err) {
      console.error("[Settings] Error calculating threshold:", err);
      return { display: "not yet calculated", days: null };
    }
  };
  const discontinuitySetting = new import_obsidian24.Setting(containerEl).setName("Discontinuity gap threshold");
  let discontinuityText;
  const updateDescriptionAndPlaceholder = async () => {
    const autoThreshold = await calculateAutoThreshold();
    discontinuitySetting.setDesc(`In shift mode, the \u221E symbol marks large time gaps between scenes. By default, this is auto-calculated as 3\xD7 the median gap between scenes. Current auto value: ${autoThreshold.display}. You can override this with a custom gap threshold (e.g., "4 days", "1 week", "30 minutes").`);
    if (discontinuityText) {
      const currentValue = plugin.settings.discontinuityThreshold || "";
      discontinuityText.setPlaceholder(`${autoThreshold.display} (auto)`);
      if (!currentValue) {
        discontinuityText.setValue("");
      }
    }
  };
  void updateDescriptionAndPlaceholder();
  discontinuitySetting.addText((text) => {
    discontinuityText = text;
    const currentValue = plugin.settings.discontinuityThreshold || "";
    text.setPlaceholder("Calculating\u2026").setValue(currentValue);
    void calculateAutoThreshold().then((autoThreshold) => {
      text.setPlaceholder(`${autoThreshold.display} (auto)`);
      if (!currentValue) {
        text.setValue("");
      }
    });
    const handleBlur = async () => {
      const trimmed = text.getValue().trim();
      text.inputEl.removeClass("rt-setting-input-success");
      text.inputEl.removeClass("rt-setting-input-error");
      if (!trimmed) {
        plugin.settings.discontinuityThreshold = void 0;
        await plugin.saveSettings();
        plugin.refreshTimelineIfNeeded(null);
        return;
      }
      const parsed = parseDurationDetail(trimmed);
      if (!parsed) {
        text.inputEl.addClass("rt-setting-input-error");
        new import_obsidian24.Notice('Invalid gap threshold format. Examples: "4 days", "1 week", "2 months"');
        return;
      }
      plugin.settings.discontinuityThreshold = trimmed;
      text.inputEl.addClass("rt-setting-input-success");
      await plugin.saveSettings();
      plugin.refreshTimelineIfNeeded(null);
      window.setTimeout(() => {
        text.inputEl.removeClass("rt-setting-input-success");
      }, 1e3);
    };
    plugin.registerDomEvent(text.inputEl, "blur", () => {
      void handleBlur();
    });
  });
  discontinuitySetting.addExtraButton((button) => button.setIcon("reset").setTooltip("Reset to auto-calculated threshold").onClick(async () => {
    plugin.settings.discontinuityThreshold = void 0;
    await plugin.saveSettings();
    plugin.refreshTimelineIfNeeded(null);
    if (discontinuityText) {
      discontinuityText.setValue("");
      discontinuityText.inputEl.removeClass("rt-setting-input-error");
      discontinuityText.inputEl.removeClass("rt-setting-input-success");
    }
    new import_obsidian24.Notice("Discontinuity threshold reset to auto-calculated value");
  }));
}

// src/settings/sections/TemplatesSection.ts
var import_obsidian28 = require("obsidian");

// src/modals/CreateBeatsTemplatesModal.ts
var import_obsidian25 = require("obsidian");
var CreateBeatsTemplatesModal = class extends import_obsidian25.Modal {
  constructor(app, plugin, beatSystem, beatCount) {
    super(app);
    this.resolve = null;
    this.plugin = plugin;
    this.beatSystem = beatSystem;
    this.beatCount = beatCount;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("rt-create-plot-templates-modal");
    const titleEl = contentEl.createEl("h2", { text: "Create Plot Template Notes" });
    titleEl.style.marginBottom = "16px";
    const infoContainer = contentEl.createDiv("rt-plot-templates-info");
    infoContainer.style.backgroundColor = "var(--background-secondary)";
    infoContainer.style.padding = "16px";
    infoContainer.style.borderRadius = "6px";
    infoContainer.style.marginBottom = "20px";
    infoContainer.createEl("p", {
      text: `This will create ${this.beatCount} Beat notes for "${this.beatSystem}" with the following structure:`
    });
    const exampleCode = infoContainer.createEl("pre");
    exampleCode.style.backgroundColor = "var(--background-primary)";
    exampleCode.style.padding = "12px";
    exampleCode.style.borderRadius = "4px";
    exampleCode.style.fontSize = "12px";
    exampleCode.style.overflowX = "auto";
    exampleCode.textContent = `---
Class: Beat
Act: 1
Description: [Beat description]
Beat Model: ${this.beatSystem}
Range: [Ideal momentum range]
Gossamer1:
---`;
    const locationInfo = infoContainer.createEl("p");
    locationInfo.style.marginTop = "12px";
    locationInfo.style.marginBottom = "0";
    const sourcePath = this.plugin.settings.sourcePath.trim();
    const locationText = sourcePath ? `Notes will be created in: ${sourcePath}/` : "Notes will be created in the vault root (no source path set)";
    const locationLabel = locationInfo.createEl("strong");
    locationLabel.textContent = "Location:";
    locationInfo.appendText(` ${locationText}`);
    const buttonContainer = contentEl.createDiv("rt-plot-templates-buttons");
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "10px";
    buttonContainer.style.justifyContent = "flex-end";
    new import_obsidian25.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
      if (this.resolve) {
        this.resolve({ confirmed: false });
      }
      this.close();
    });
    new import_obsidian25.ButtonComponent(buttonContainer).setButtonText(`Create ${this.beatCount} notes`).setCta().onClick(() => {
      if (this.resolve) {
        this.resolve({ confirmed: true });
      }
      this.close();
    });
  }
  waitForConfirmation() {
    return new Promise((resolve) => {
      this.resolve = resolve;
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    if (this.resolve) {
      this.resolve({ confirmed: false });
    }
  }
};

// src/settings/sections/TemplatesSection.ts
init_beatsSystems();

// src/utils/beatsTemplates.ts
var import_obsidian26 = require("obsidian");
init_beatsSystems();
function getMomentumRange(beatInfo) {
  if (beatInfo.momentumRange) {
    return beatInfo.momentumRange;
  }
  return "";
}
function generatePlotNoteContent(beatInfo, act, beatSystem) {
  const rangeValue = getMomentumRange(beatInfo);
  const frontmatter = [
    "---",
    "Class: Beat",
    `Act: ${act}`,
    `Description: ${beatInfo.description}`,
    `Beat Model: ${beatSystem}`,
    rangeValue ? `Range: ${rangeValue}` : "Range:",
    "When:",
    "Gossamer1:",
    "---",
    ""
  ].join("\n");
  const bodyParts = [];
  if (beatInfo.description) {
    bodyParts.push(beatInfo.description);
  }
  if (beatInfo.percentageRange) {
    bodyParts.push("");
    bodyParts.push(`**Manuscript Position:** ${beatInfo.percentageRange}`);
  }
  const body = bodyParts.length > 0 ? "\n" + bodyParts.join("\n") + "\n" : "";
  return frontmatter + body;
}
function getBeatAct(beatIndex, totalBeats) {
  const position = beatIndex / totalBeats;
  if (position < 0.33) return 1;
  if (position < 0.67) return 2;
  return 3;
}
async function createBeatTemplateNotes(vault, beatSystemName, sourcePath) {
  const beatSystem = PLOT_SYSTEMS[beatSystemName];
  if (!beatSystem) {
    throw new Error(`Unknown beat system: ${beatSystemName}`);
  }
  let created = 0;
  let skipped = 0;
  const errors = [];
  const targetFolder = sourcePath.trim() ? (0, import_obsidian26.normalizePath)(sourcePath.trim()) : "";
  if (targetFolder) {
    const folder = vault.getAbstractFileByPath(targetFolder);
    if (!folder) {
      try {
        await vault.createFolder(targetFolder);
      } catch (e) {
      }
    }
  }
  for (let i = 0; i < beatSystem.beats.length; i++) {
    const beatName = beatSystem.beats[i];
    const beatInfo = beatSystem.beatDetails[i];
    const beatNumber = i + 1;
    const act = getBeatAct(i, beatSystem.beats.length);
    const filename = `${beatNumber} ${beatName}.md`;
    const filePath = targetFolder ? `${targetFolder}/${filename}` : filename;
    const normalizedPath = (0, import_obsidian26.normalizePath)(filePath);
    const existingFile = vault.getAbstractFileByPath(normalizedPath);
    if (existingFile) {
      skipped++;
      continue;
    }
    const content = generatePlotNoteContent(beatInfo, act, beatSystemName);
    try {
      await vault.create(normalizedPath, content);
      created++;
    } catch (error) {
      errors.push(`Failed to create "${filename}": ${error}`);
    }
  }
  return { created, skipped, errors };
}

// src/settings/AiContextModal.ts
var import_obsidian27 = require("obsidian");
var TextInputModal = class extends import_obsidian27.Modal {
  constructor(app, title, defaultValue, onSubmit) {
    super(app);
    this.result = null;
    this.title = title;
    this.defaultValue = defaultValue;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText(this.title);
    this.inputEl = contentEl.createEl("input", {
      type: "text",
      value: this.defaultValue,
      cls: "rt-text-input-modal-field"
    });
    window.setTimeout(() => {
      var _a, _b;
      (_a = this.inputEl) == null ? void 0 : _a.focus();
      (_b = this.inputEl) == null ? void 0 : _b.select();
    }, 10);
    const handleKeydown = (e) => {
      var _a;
      if (e.key === "Enter") {
        e.preventDefault();
        this.submit(((_a = this.inputEl) == null ? void 0 : _a.value) || "");
      } else if (e.key === "Escape") {
        this.close();
      }
    };
    this.inputEl.addEventListener("keydown", handleKeydown);
    this._keydownHandler = handleKeydown;
    const buttonRow = contentEl.createDiv({ cls: "modal-button-container rt-text-input-modal-buttons" });
    new import_obsidian27.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
    new import_obsidian27.ButtonComponent(buttonRow).setButtonText("OK").setCta().onClick(() => {
      var _a;
      return this.submit(((_a = this.inputEl) == null ? void 0 : _a.value) || "");
    });
  }
  onClose() {
    if (this.inputEl && this._keydownHandler) {
      this.inputEl.removeEventListener("keydown", this._keydownHandler);
    }
  }
  submit(value) {
    const trimmedValue = value.trim();
    if (trimmedValue) {
      this.onSubmit(trimmedValue);
      this.close();
    } else {
      new import_obsidian27.Notice("Please enter a template name");
    }
  }
};
var AiContextModal = class extends import_obsidian27.Modal {
  constructor(app, plugin, onSave) {
    super(app);
    this.isDirty = false;
    this.plugin = plugin;
    this.onSave = onSave;
    this.templates = JSON.parse(JSON.stringify(plugin.settings.aiContextTemplates || []));
    this.currentTemplateId = plugin.settings.activeAiContextTemplateId || "commercial_genre";
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("AI context templates");
    const infoEl = contentEl.createDiv({ cls: "rt-ai-context-info" });
    infoEl.setText("Define context for AI LLM analysis and Gossamer score generation. This text prepends all prompts sent to LLM to establish role and context and is used for the copy template button to generate Gossamer scores.");
    const selectorSection = contentEl.createDiv({ cls: "rt-ai-context-selector-section" });
    const selectorLabel = selectorSection.createDiv({ cls: "rt-ai-context-label" });
    selectorLabel.setText("Template:");
    const selectorRow = selectorSection.createDiv({ cls: "rt-ai-context-selector-row" });
    this.dropdownComponent = new import_obsidian27.DropdownComponent(selectorRow);
    this.updateDropdownOptions();
    this.dropdownComponent.setValue(this.currentTemplateId);
    this.dropdownComponent.onChange((value) => {
      var _a;
      if (this.isDirty) {
        const discard = window.confirm("You have unsaved changes. Discard them?");
        if (!discard) {
          (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(this.currentTemplateId);
          return;
        }
        this.isDirty = false;
      }
      this.currentTemplateId = value;
      this.updateEditorSection();
    });
    const buttonRow = selectorSection.createDiv({ cls: "rt-ai-context-button-row" });
    new import_obsidian27.ButtonComponent(buttonRow).setButtonText("New template").onClick(() => this.createNewTemplate());
    this.renameButton = new import_obsidian27.ButtonComponent(buttonRow).setButtonText("Rename").onClick(() => this.renameTemplate());
    this.copyButton = new import_obsidian27.ButtonComponent(buttonRow).setButtonText("Create copy").onClick(() => this.copyTemplate());
    this.deleteButton = new import_obsidian27.ButtonComponent(buttonRow).setButtonText("Delete").setWarning().onClick(() => this.deleteTemplate());
    const editorSection = contentEl.createDiv({ cls: "rt-ai-context-editor-section" });
    const editorLabel = editorSection.createDiv({ cls: "rt-ai-context-label" });
    editorLabel.setText("Prompt:");
    this.textareaEl = editorSection.createEl("textarea", { cls: "rt-ai-context-textarea" });
    this.textareaEl.placeholder = "Enter your AI context prompt here...";
    const previewSection = contentEl.createDiv({ cls: "rt-ai-context-preview-section" });
    const previewLabel = previewSection.createDiv({ cls: "rt-ai-context-label" });
    previewLabel.setText("How it will appear:");
    const previewText = previewSection.createDiv({ cls: "rt-ai-context-preview" });
    const handleInput = () => {
      var _a;
      const currentTemplate = this.getCurrentTemplate();
      if (currentTemplate && !currentTemplate.isBuiltIn) {
        this.isDirty = true;
        this.updateButtonStates();
      }
      const prompt = ((_a = this.textareaEl) == null ? void 0 : _a.value.trim()) || "";
      if (prompt) {
        previewText.textContent = `${prompt}

Before taking action, prepare an action plan.

[Rest of AI prompt...]`;
      } else {
        previewText.textContent = "[No context set - will use default AI prompt]";
      }
    };
    this.textareaEl.addEventListener("input", handleInput);
    this._inputHandler = handleInput;
    const actionRow = contentEl.createDiv({ cls: "rt-ai-context-actions" });
    this.saveButton = new import_obsidian27.ButtonComponent(actionRow).setButtonText("Save changes").setCta().onClick(() => this.saveChanges());
    new import_obsidian27.ButtonComponent(actionRow).setButtonText("Set as active & close").onClick(() => this.setActiveAndClose());
    new import_obsidian27.ButtonComponent(actionRow).setButtonText("Cancel").onClick(() => {
      if (this.isDirty) {
        const discard = window.confirm("You have unsaved changes. Discard them?");
        if (!discard) return;
      }
      this.close();
    });
    this.updateEditorSection();
    this.updateButtonStates();
  }
  onClose() {
    if (this.textareaEl && this._inputHandler) {
      this.textareaEl.removeEventListener("input", this._inputHandler);
    }
  }
  updateDropdownOptions() {
    if (!this.dropdownComponent) return;
    this.dropdownComponent.selectEl.empty();
    this.templates.forEach((template) => {
      const label = template.isBuiltIn ? `${template.name} (Built-in)` : template.name;
      this.dropdownComponent.addOption(template.id, label);
    });
  }
  getCurrentTemplate() {
    return this.templates.find((t) => t.id === this.currentTemplateId);
  }
  updateEditorSection() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate) return;
    if (this.textareaEl) {
      this.textareaEl.value = currentTemplate.prompt;
      this.textareaEl.disabled = currentTemplate.isBuiltIn;
      const previewText = this.contentEl.querySelector(".rt-ai-context-preview");
      if (previewText) {
        const prompt = currentTemplate.prompt.trim();
        if (prompt) {
          previewText.textContent = `${prompt}

Before taking action, prepare an action plan.

[Rest of AI prompt...]`;
        } else {
          previewText.textContent = "[No context set - will use default AI prompt]";
        }
      }
    }
    this.isDirty = false;
    this.updateButtonStates();
  }
  updateButtonStates() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate) return;
    const isBuiltIn = currentTemplate.isBuiltIn;
    if (this.saveButton) {
      this.saveButton.setDisabled(isBuiltIn || !this.isDirty);
    }
    if (this.deleteButton) {
      this.deleteButton.setDisabled(isBuiltIn);
    }
    if (this.renameButton) {
      this.renameButton.setDisabled(isBuiltIn);
    }
    if (this.copyButton) {
      this.copyButton.setDisabled(!isBuiltIn);
    }
  }
  createNewTemplate() {
    const currentTemplate = this.getCurrentTemplate();
    const basePrompt = (currentTemplate == null ? void 0 : currentTemplate.prompt) || "";
    const modal = new TextInputModal(
      this.app,
      "Enter template name",
      "",
      (name) => {
        var _a;
        const id = `custom-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newTemplate = {
          id,
          name,
          prompt: basePrompt,
          isBuiltIn: false
        };
        this.templates.push(newTemplate);
        this.updateDropdownOptions();
        (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(id);
        this.currentTemplateId = id;
        this.updateEditorSection();
        new import_obsidian27.Notice(`Created template: ${name}`);
      }
    );
    modal.open();
  }
  renameTemplate() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate || currentTemplate.isBuiltIn) return;
    const modal = new TextInputModal(
      this.app,
      "Enter new name",
      currentTemplate.name,
      (newName) => {
        var _a;
        currentTemplate.name = newName;
        this.updateDropdownOptions();
        (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(this.currentTemplateId);
        new import_obsidian27.Notice(`Renamed to: ${newName}`);
      }
    );
    modal.open();
  }
  copyTemplate() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate) return;
    const modal = new TextInputModal(
      this.app,
      "Enter name for copy",
      `${currentTemplate.name} (Copy)`,
      (name) => {
        var _a;
        const id = `custom-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;
        const newTemplate = {
          id,
          name,
          prompt: currentTemplate.prompt,
          isBuiltIn: false
        };
        this.templates.push(newTemplate);
        this.updateDropdownOptions();
        (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(id);
        this.currentTemplateId = id;
        this.updateEditorSection();
        new import_obsidian27.Notice(`Created copy: ${name}`);
      }
    );
    modal.open();
  }
  deleteTemplate() {
    var _a;
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate || currentTemplate.isBuiltIn) return;
    const confirmed = window.confirm(`Delete template "${currentTemplate.name}"? This cannot be undone.`);
    if (!confirmed) return;
    this.templates = this.templates.filter((t) => t.id !== this.currentTemplateId);
    if (this.templates.length > 0) {
      this.currentTemplateId = this.templates[0].id;
    } else {
      this.currentTemplateId = "commercial_genre";
    }
    this.updateDropdownOptions();
    (_a = this.dropdownComponent) == null ? void 0 : _a.setValue(this.currentTemplateId);
    this.updateEditorSection();
    new import_obsidian27.Notice(`Deleted template: ${currentTemplate.name}`);
  }
  saveChanges() {
    const currentTemplate = this.getCurrentTemplate();
    if (!currentTemplate || currentTemplate.isBuiltIn) return;
    if (this.textareaEl) {
      currentTemplate.prompt = this.textareaEl.value;
    }
    this.isDirty = false;
    this.updateButtonStates();
    new import_obsidian27.Notice("Template saved");
  }
  async setActiveAndClose() {
    if (this.isDirty) {
      this.saveChanges();
    }
    this.plugin.settings.aiContextTemplates = this.templates;
    this.plugin.settings.activeAiContextTemplateId = this.currentTemplateId;
    await this.plugin.saveSettings();
    const currentTemplate = this.getCurrentTemplate();
    new import_obsidian27.Notice(`Active template: ${(currentTemplate == null ? void 0 : currentTemplate.name) || "Unknown"}`);
    this.onSave();
    this.close();
  }
};

// src/settings/sections/TemplatesSection.ts
function renderStoryBeatsSection(params) {
  const { app, plugin, containerEl } = params;
  new import_obsidian28.Setting(containerEl).setName("Gossamer and story beats system").setHeading();
  new import_obsidian28.Setting(containerEl).setName("Story beats system").setDesc("Select the story structure model for your manuscript. This will establish the story beat system and can be used to create beat notes and graph scores using Gossamer view.").addDropdown((dropdown) => {
    dropdown.addOption("Save The Cat", "Save The Cat (15 beats)").addOption("Hero's Journey", "Hero's Journey (12 beats)").addOption("Story Grid", "Story Grid (15 beats)").addOption("Custom", "Custom (User defined beat structure)").setValue(plugin.settings.beatSystem || "Custom").onChange(async (value) => {
      plugin.settings.beatSystem = value;
      await plugin.saveSettings();
      updateStoryStructureDescription(storyStructureInfo, value);
      updateTemplateButton(templateSetting, value);
    });
    dropdown.selectEl.style.minWidth = "200px";
  });
  const storyStructureInfo = containerEl.createEl("div", { cls: "setting-item-description" });
  storyStructureInfo.style.marginTop = "-8px";
  storyStructureInfo.style.marginBottom = "18px";
  storyStructureInfo.style.paddingLeft = "0";
  updateStoryStructureDescription(storyStructureInfo, plugin.settings.beatSystem || "Custom");
  const templateSetting = new import_obsidian28.Setting(containerEl).setName("Create story beat template notes").setDesc("Generate template beat notes based on the selected story structure system including YAML frontmatter and body summary.").addButton((button) => button.setButtonText("Create templates").setTooltip("Creates story beat note templates in your source path").onClick(async () => {
    await createBeatTemplates();
  }));
  updateTemplateButton(templateSetting, plugin.settings.beatSystem || "Custom");
  const getActiveTemplateName = () => {
    const templates = plugin.settings.aiContextTemplates || [];
    const activeId = plugin.settings.activeAiContextTemplateId;
    const active = templates.find((t) => t.id === activeId);
    return (active == null ? void 0 : active.name) || "Generic Editor";
  };
  const contextTemplateSetting = new import_obsidian28.Setting(containerEl).setName("AI prompt context template").setDesc(`Active: ${getActiveTemplateName()}`).addExtraButton((button) => button.setIcon("gear").setTooltip("Manage context templates for AI prompt generation and Gossamer score generation").onClick(() => {
    const modal = new AiContextModal(app, plugin, () => {
      contextTemplateSetting.setDesc(`Active: ${getActiveTemplateName()}`);
    });
    modal.open();
  }));
  function updateStoryStructureDescription(container, selectedSystem) {
    const descriptions = {
      "Save The Cat": "Commercial fiction, screenplays, and genre stories. Emphasizes clear emotional beats and audience engagement.",
      "Hero's Journey": "Mythic, adventure, and transformation stories. Focuses on the protagonist's arc through trials and self-discovery.",
      "Story Grid": "Literary fiction and complex narratives. Balances micro and macro structure with progressive complications.",
      "Custom": "Uses any story beat notes you create. Perfect for when you don't follow a traditional story structure."
    };
    container.empty();
    for (const [system, desc] of Object.entries(descriptions)) {
      const isSelected = system === selectedSystem;
      const lineDiv = container.createDiv();
      if (isSelected) {
        lineDiv.classList.add("rt-story-structure-selected");
      }
      const boldSpan = lineDiv.createEl("b");
      boldSpan.textContent = system;
      lineDiv.appendText(`: ${desc}`);
    }
  }
  function updateTemplateButton(setting, selectedSystem) {
    const isCustom = selectedSystem === "Custom";
    if (isCustom) {
      setting.setName("Create story beat template notes");
      setting.setDesc("Custom story structures must be created manually by the author.");
    } else {
      setting.setName(`Create story beat template notes for ${selectedSystem}`);
      setting.setDesc(`Generate ${selectedSystem} template beat notes including YAML frontmatter and body summary.`);
    }
    const settingEl = setting.settingEl;
    if (isCustom) {
      settingEl.style.opacity = "0.6";
    } else {
      settingEl.style.opacity = "1";
    }
  }
  async function createBeatTemplates() {
    const storyStructureName = plugin.settings.beatSystem || "Custom";
    if (storyStructureName === "Custom") {
      new import_obsidian28.Notice("Custom story structure selected. Create your own Beat notes with Class: Beat. No templates will be generated.");
      return;
    }
    const storyStructure = getPlotSystem(storyStructureName);
    if (!storyStructure) {
      new import_obsidian28.Notice(`Unknown story structure: ${storyStructureName}`);
      return;
    }
    const modal = new CreateBeatsTemplatesModal(
      app,
      plugin,
      storyStructureName,
      storyStructure.beatCount
    );
    modal.open();
    const result = await modal.waitForConfirmation();
    if (!result.confirmed) return;
    try {
      const sourcePath = plugin.settings.sourcePath || "";
      const { created, skipped, errors } = await createBeatTemplateNotes(
        app.vault,
        storyStructureName,
        sourcePath
      );
      if (errors.length > 0) {
        new import_obsidian28.Notice(`Created ${created} notes. ${skipped} skipped. ${errors.length} errors. Check console.`);
        console.error("[Beat Templates] Errors:", errors);
      } else if (created === 0 && skipped > 0) {
        new import_obsidian28.Notice(`All ${skipped} Beat notes already exist. No new notes created.`);
      } else {
        new import_obsidian28.Notice(`\u2713 Successfully created ${created} Beat template notes!`);
      }
    } catch (error) {
      console.error("[Beat Templates] Failed:", error);
      new import_obsidian28.Notice(`Failed to create story beat templates: ${error}`);
    }
  }
}

// src/settings/SettingsTab.ts
init_anthropicApi();
init_openaiApi();
init_geminiApi();

// src/settings/sections/ColorsSection.ts
var import_obsidian29 = require("obsidian");
function renderColorsSection(containerEl, plugin) {
  const pubHeading = new import_obsidian29.Setting(containerEl).setName("Publishing stage colors").setHeading();
  pubHeading.settingEl.classList.add("rt-section-heading");
  containerEl.createEl("p", { cls: "rt-color-section-desc", text: "Used for completed scenes, stage matrix, act labels and more." });
  const stageGrid = containerEl.createDiv({ cls: "rt-color-grid" });
  const stages = Object.entries(plugin.settings.publishStageColors);
  stages.forEach(([stage, color]) => {
    const cell = stageGrid.createDiv({ cls: "rt-color-grid-item" });
    const label = cell.createDiv({ cls: "rt-color-grid-label" });
    label.setText(stage);
    let textInputRef;
    let colorPickerRef;
    const control = cell.createDiv({ cls: "rt-color-grid-controls" });
    colorPickerRef = new import_obsidian29.ColorComponent(control).setValue(color).onChange(async (value) => {
      if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
        plugin.settings.publishStageColors[stage] = value;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        textInputRef == null ? void 0 : textInputRef.setValue(value);
      }
    });
    const colorInput = control.querySelector('input[type="color"]:last-of-type');
    if (colorInput) colorInput.classList.add("rt-hidden-color-input");
    const swatchEl = control.createDiv({ cls: `rt-swatch-trigger rt-stage-${stage}` });
    plugin.registerDomEvent(swatchEl, "click", () => {
      colorInput == null ? void 0 : colorInput.click();
    });
    new import_obsidian29.Setting(control).addText((textInput) => {
      textInputRef = textInput;
      textInput.inputEl.classList.add("rt-hex-input");
      textInput.setValue(color).onChange(async (value) => {
        if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
          plugin.settings.publishStageColors[stage] = value;
          await plugin.saveSettings();
          plugin.setCSSColorVariables();
          colorPickerRef == null ? void 0 : colorPickerRef.setValue(value);
        }
      });
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        const defaultColor = DEFAULT_SETTINGS.publishStageColors[stage];
        plugin.settings.publishStageColors[stage] = defaultColor;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        textInputRef == null ? void 0 : textInputRef.setValue(defaultColor);
        colorPickerRef == null ? void 0 : colorPickerRef.setValue(defaultColor);
      });
    });
  });
  const subplotHeading = new import_obsidian29.Setting(containerEl).setName("Subplot ring colors").setHeading();
  subplotHeading.settingEl.classList.add("rt-section-heading");
  containerEl.createEl("p", { cls: "rt-color-section-desc", text: "Subplot ring colors used for rings 1 through 16 moving inward." });
  const subplotGrid = containerEl.createDiv({ cls: "rt-color-grid" });
  const ensureArray = (arr) => Array.isArray(arr) ? arr : [];
  const subplotColors = ensureArray(plugin.settings.subplotColors);
  for (let i = 0; i < 16; i++) {
    const labelText = `Ring ${i + 1}`;
    const current = subplotColors[i] || DEFAULT_SETTINGS.subplotColors[i];
    const cell = subplotGrid.createDiv({ cls: "rt-color-grid-item" });
    const label = cell.createDiv({ cls: "rt-color-grid-label" });
    label.setText(labelText);
    const control = cell.createDiv({ cls: "rt-color-grid-controls" });
    let inputRef;
    let colorPickerRef;
    colorPickerRef = new import_obsidian29.ColorComponent(control).setValue(current).onChange(async (value) => {
      if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
        const next = [...plugin.settings.subplotColors || DEFAULT_SETTINGS.subplotColors];
        next[i] = value;
        plugin.settings.subplotColors = next;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        inputRef == null ? void 0 : inputRef.setValue(value);
      }
    });
    const colorInput2 = control.querySelector('input[type="color"]:last-of-type');
    if (colorInput2) colorInput2.classList.add("rt-hidden-color-input");
    const swatchEl2 = control.createDiv({ cls: `rt-swatch-trigger rt-subplot-${i}` });
    plugin.registerDomEvent(swatchEl2, "click", () => {
      colorInput2 == null ? void 0 : colorInput2.click();
    });
    new import_obsidian29.Setting(control).addText((text) => {
      inputRef = text;
      text.inputEl.classList.add("rt-hex-input");
      text.setValue(current).onChange(async (value) => {
        if (/^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(value)) {
          const next = [...plugin.settings.subplotColors || DEFAULT_SETTINGS.subplotColors];
          next[i] = value;
          plugin.settings.subplotColors = next;
          await plugin.saveSettings();
          plugin.setCSSColorVariables();
          colorPickerRef == null ? void 0 : colorPickerRef.setValue(value);
        }
      });
    }).addExtraButton((button) => {
      button.setIcon("reset").setTooltip("Reset to default").onClick(async () => {
        const value = DEFAULT_SETTINGS.subplotColors[i];
        const next = [...plugin.settings.subplotColors || DEFAULT_SETTINGS.subplotColors];
        next[i] = value;
        plugin.settings.subplotColors = next;
        await plugin.saveSettings();
        plugin.setCSSColorVariables();
        inputRef == null ? void 0 : inputRef.setValue(value);
        colorPickerRef == null ? void 0 : colorPickerRef.setValue(value);
      });
    });
  }
}

// src/settings/sections/ReadmeSection.ts
var import_obsidian30 = require("obsidian");
function renderReadmeSection(params) {
  const { app, containerEl, setComponentRef } = params;
  containerEl.createEl("hr", { cls: "rt-settings-separator" });
  const readmeContainer = containerEl.createDiv({ cls: "rt-manuscript-readme-container" });
  const readmeMarkdown = true ? '<p align="center">\n  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/logo.png" alt="Radial Timeline Logo" width="10%">\n</p>\n<p align="center" style="font-family: \'Lato\', sans-serif; font-weight: 100; font-size: 14px; margin-top: 12px; margin-bottom: 0; letter-spacing: 8px;">\n  Radial Timeline\u2122\n</p>\n<p align="center" style="font-family: \'Lato\', sans-serif; font-size: 14px; margin-top: 4px;">\n  by Eric Rhys Taylor\n</p>\n\n\n<p align="center">\n    <a href="https://github.com/EricRhysTaylor/radial-timeline/stargazers" target="_blank" rel="noopener"><img src="https://img.shields.io/github/stars/EricRhysTaylor/radial-timeline?colorA=363a4f&colorB=e0ac00&style=for-the-badge" alt="GitHub star count"></a><!-- Enhancements --><a href="https://github.com/EricRhysTaylor/radial-timeline/issues?q=is%3Aissue+is%3Aopen+label%3Aenhancement" target="_blank" rel="noopener">\n  <img src="https://img.shields.io/github/issues/EricRhysTaylor/radial-timeline/enhancement?colorA=363a4f&colorB=00bfa5&style=for-the-badge&label=enhancements" alt="Open enhancements on GitHub">\n</a><a href="https://github.com/EricRhysTaylor/radial-timeline/issues?q=is%3Aclosed+label%3Aenhancement" target="_blank" rel="noopener">\n  <img src="https://img.shields.io/github/issues-closed/EricRhysTaylor/radial-timeline/enhancement?colorA=363a4f&colorB=4a90e2&style=for-the-badge&label=closed%20enhancements" alt="Closed enhancements on GitHub">\n</a>\n<a href="https://github.com/EricRhysTaylor/radial-timeline/issues?q=is%3Aissue+is%3Aopen+label%3Abug" target="_blank" rel="noopener">\n  <img src="https://img.shields.io/github/issues/EricRhysTaylor/radial-timeline/bug?colorA=363a4f&colorB=e93147&style=for-the-badge&label=bugs" alt="Open bugs on GitHub">\n</a>\n    <br/>\n	<a href="https://obsidian.md/plugins?id=radial-timeline" target="_blank" rel="noopener"><img src="https://img.shields.io/badge/dynamic/json?url=https://raw.githubusercontent.com/obsidianmd/obsidian-releases/master/community-plugin-stats.json&query=$.radial-timeline.downloads&label=Downloads&style=for-the-badge&colorA=363a4f&colorB=d53984" alt="Plugin Downloads"/></a>\n	<a href="https://github.com/EricRhysTaylor/radial-timeline/blob/master/LICENSE" target="_blank" rel="noopener"><img src="https://img.shields.io/static/v1.svg?style=for-the-badge&label=License&message=Non-Commercial&colorA=363a4f&colorB=b7bdf8" alt="Non-Commercial license"/></a>\n</p>\n\n<hr style="margin-bottom: 20px;">\n\n\nThe manuscript visualization plugin for Obsidian.\n\n**Stop losing track of subplot threads across dozens of scenes.** Radial Timeline\u2122 transforms your manuscript into a live visual map where you can see your entire story structure at a glance.\n\n## What It Does\n\nRadial Timeline\u2122 arranges your scenes by act, subplot, narrative or chronological order in a striking radial layout\u2014revealing the structure, rhythm, and scope of your story. Each ring represents a subplot; hover interactions surface important details like scene synopsis and story beats. Scenes highlight across subplots to show interrelationships. Multiple view modes dissect your novel like an X-ray.\n\n**Before**: Scrolling through line after line of spreadsheet tables and files, losing sight of how your B-plot interweaves with the main storyline.  \n\n**After**: One visual map showing every scene, every subplot, every beat color coded and connected to the big picture.\n\nRadial Timeline\u2122 captures and visualizes all 4 critical timelines, revealing everything you need to know as your manuscript evolves from the nucleus of an idea to the final polished novel.\n\n**Narrative time**: the sequence you reveal events to readers.<br>\n**Chronological time**: when events happen in your story\'s world. (can be the same as Narrative)<br>\n**Author time**: your real-world writing progress toward completion.<br>\n**Publishing time**: manuscript revision stages from Zero draft through Press-ready.\n\n<hr>\n\n## Visual Overview\n\n<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap;">\n  <div style="text-align: center;">\n    <a href="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot1.jpeg" target="_blank" rel="noopener" style="cursor: pointer;">\n      <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot1.jpeg" alt="All Scenes Timeline" style="width: 300px; max-width: 100%; border-radius: 8px;" />\n    </a>\n    <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Narrative Timeline</div>\n  </div>\n  <div style="text-align: center;">\n    <a href="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot2.jpeg" target="_blank" rel="noopener" style="cursor: pointer;">\n      <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot2.jpeg" alt="Timeline Hover Synopsis" style="width: 300px; max-width: 100%; border-radius: 8px;" />\n    </a>\n    <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Timeline Hover Synopsis</div>\n  </div>\n</div>\n\n<div style="text-align: center; font-size: 0.8em; margin-top: 10px; color: #888;">\n  Click image to view full size in browser\n</div>  \n\n<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px;">\n  <div style="text-align: center;">\n    <a href="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot3.jpeg" target="_blank" rel="noopener" style="cursor: pointer;">\n      <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot3.jpeg" alt="Main Plot Mode" style="width: 300px; max-width: 100%; border-radius: 8px;" />\n    </a>\n    <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Subplot Mode</div>\n  </div>\n  <div style="text-align: center;">\n    <a href="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot4.jpeg" target="_blank" rel="noopener" style="cursor: pointer;">\n      <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot4.jpeg" alt="Gossamer View" style="width: 300px; max-width: 100%; border-radius: 8px;" />\n    </a>\n    <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Gossamer View</div>\n  </div>\n</div>\n\n<div style="display: flex; justify-content: center; gap: 20px; flex-wrap: wrap; margin-top: 20px;">\n  <div style="text-align: center;">\n    <a href="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot6.jpeg" target="_blank" rel="noopener" style="cursor: pointer;">\n      <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot6.jpeg" alt="Chronologue Mode" style="width: 300px; max-width: 100%; border-radius: 8px;" />\n    </a>\n    <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Chronologue Mode</div>\n  </div>\n  <div style="text-align: center;">\n     <a href="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot5.jpeg" target="_blank" rel="noopener" style="cursor: pointer;">\n      <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot5.jpeg" alt="Chronologue Mode - SHIFT" style="width: 300px; max-width: 100%; border-radius: 8px;" />\n    </a>\n    <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Chronologue Mode - SHIFT</div>\n  </div>\n</div>\n\n<div style="text-align: center; font-size: 0.8em; margin-top: 10px; color: #888;">\n  Click image to view full size in browser\n</div>  \n\n---\n\n## Quick Start\n\n**Get your first timeline in 3 steps:**\n\n1. **Install the plugin**: Settings \u2192 Community plugins \u2192 Browse \u2192 "Radial Timeline"\n2. **Create your first scene**: Use command palette (`Cmd/Ctrl + P`) \u2192 "Radial Timeline: Create template note"\n3. **Open the timeline**: Click the timeline ribbon icon or use command palette \u2192 "Radial Timeline: Open timeline view"\n\nThat\'s it! Your first scene appears on the timeline. Create more scenes by:\n- Duplicating the template scene\n- Using command palette \u2192 "Create template note"\n- Use Obsidian\'s core templates plugin\n\n**Optional - Insert story beats**: Consider inserting story beats for your chosen system such as the 15-beat Save the Cat by going to Settings \u2192 Radial Timeline \u2192 Create Templates.\n\n**Pro tip**: Organize your vault for multiple books by creating folders for each then set your Radial Timeline\u2122 plugin source path (Settings \u2192 Radial timeline \u2192 Source path) to a specific folder like `Book 1: The Saga Begins` to quickly organize your vault.\n\n<br>\n<a href="https://youtu.be/7noTSFaj8Eo" target="_blank" rel="noopener">\n  <p align="center">\n    <img src="https://i.ytimg.com/vi/7noTSFaj8Eo/maxresdefault.jpg" alt="Plan your novel with radial timeline in obsidian | complete author walkthrough & setup guide" style="max-width: 80%; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);">\n  </p>\n  <p align="center" style="font-family: \'Lato\', sans-serif; font-size: 16px; margin-top: 10px;">\n    Plan your novel with radial timeline in obsidian<br>\n    Complete author walkthrough & setup guide\n  </p>\n</a>\n\n\n---\n\n## Core Workflows\n\n## Planning Your Novel\n\n- **Story Beats**: Use any story beat system (Save the Cat, Hero\'s Journey, Story Grid, or Custom) to lay out the story momentum scaffolding\n- **Act Structure**: Create and distribute scenes by act (1-3) to see your three-act structure take shape as scene ideas come to you\n- **Subplot Tracking**: Each ring represents a different subplot\u2014see how plot threads interweave\n- **Beat Templates**: Generate complete story beat sets like Save the Cat using Settings \u2192 Story beat system\n\n**Command**: Create template note<br>\n**Settings**: Story beat system\n\n## Tracking Progress\n\n- **Status Colors**: Scenes color-coded by status (Todo = plaid, Working = pink, Overdue = red, Complete = publish stage or subplot color customizable in settings)\n- **Completion Estimates**: Plugin calculates target completion date based on your recent writing pace\n- **Publishing Stages**: Track manuscript through Zero \u2192 Author \u2192 House \u2192 Press\n- **Subplot Mode**: Switch to subplot mode (navigation top right via page icon or keyboard 2) for simplified view emphasizing publication progress as well as individual subplots\n\n**Modes**: Narrative (key 1) or Subplot (key 2)<br>\n**Settings**: Publishing stage colors\n\n## Constructing Your Story Timeline with Chronologue Mode\n\nChronologue mode is essential for constructing and visualizing the chronological backbone of your story\u2014particularly valuable for non-linear narratives, mysteries, thrillers, or any story where **when events happen** differs from **when you reveal them**.\n\n**Core workflow:**\n\n1. **Add chronological metadata**: As you create scenes, fill in the `When` field (YYYY-MM-DD HH:MM) and `Duration` field (e.g., "2 hours", "3 days", "1 week")\n2. **Switch to Chronologue mode** (keyboard **3** or top-right navigation): Scenes rearrange to show story-world event order across the full 360\xB0 circle\n3. **Activate Shift mode** (keyboard **Shift** or click shift button or use caps lock): See the bones of your story\'s temporal structure for all scenes and subplots \n4. **Compare elapsed time**: In shift mode, click two scenes to see the elapsed story-time between them with the duration arc. Keep clicking more scenes as needed.\n5. **Analyze time gaps**: Also in shift mode, discontinuities (large time jumps) appear with \u221E symbol\u2014identify gaps that might need bridging scenes.\n\n> **Minimum metadata**: Chronologue only needs a year in the `When` field to place a scene. Year-only (`When: 2045`), year+month (`When: 2045-07`), or textual month+year (`When: July 2045`) all work\u2014missing pieces default to the 1st of that month at noon. Month-only, day-only, or time-only values are ignored and treated as "no When" until you add at least the year.\n\n> **Drafting calmly**: Red "Missing When" number squares only appear once a scene\'s `Status` is `Working` or `Complete`, so Todo scenes can stay quiet while you\'re still sketching.\n\n**Why this matters**: Some authors choose to organize scenes in manuscript/narrative order, but Chronologue mode lets you construct and verify the underlying chronological scaffolding without the constraints of the 3 acts or title ordering. You can spot:\n- Pacing issues (too much/too little story time between events)\n- Flashback positioning opportunities\n- Timeline consistency problems\n- Missing transition scenes\n\n**Modes**: Chronologue mode (key **3**), Shift mode (key **Shift**)<br>\n**Settings**: Duration arc cap, Discontinuity gap threshold (Chronologue section)\n\n## Analyzing Narrative Momentum with Gossamer Mode\n\n- **Gossamer Mode**: Chart narrative momentum across story beats and over time with manual score entry<br>\n- **Historical tracking**: Compare momentum scores across up to 30 iterations to track how your story evolves\n\n**Modes**: Gossamer mode (key **4**)<br>\n**Command**: Gossamer enter momentum scores<br>\n**Settings**: Story beats system\n\n## AI story beats scene analysis (triplets)\n\n- **Scene-by-scene evaluation**: AI analyzes individual scenes in triplets (previous/current/next) to provide story beat assessment and grade evaluation\n- **Multiple ordering options**: Run analysis in manuscript order (Narrative mode) or by subplot order to get different perspectives on narrative scene flow\n\n**Modes**: Narrative mode (key 1), Subplot mode (key 2), Chronologue mode (key 3)<br>\n**Command**: AI scene analysis (manuscript order), AI scene analysis (subplot order)<br>\n**Settings**: AI LLM for scene analysis\n\n<div style="text-align: center; margin: 20px 0;">\n  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot-beats.png" alt="Story Beats Analysis" style="width: 600; max-width: 100%;" />\n  <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Story Beats Analysis</div>\n</div>\n\n\n## Finding & Navigating Scenes\n\n- **Search Timeline**: Keyword search across scene objects and synopsis title, date, time, duration, synopsis, AI beats, subplots, and characters.\n- **Hover Details**: See full title, date/time and duration, revision/overdue status, synopsis, AI story beats (optional), subplots and characters on hover. \n- **Adaptive Synopsis Color System**: Scene title color adapts to match the subplot ring in Narrative/Chronologue modes or the publish stage in Subplot mode. Subplots match respective subplot color.\n- **Click to Open**: Click any scene or beat to jump directly to that note\n\n**Command**: Search timeline, Clear search<br>\n**Settings**: Toggle AI story beats\n\n---\n<div style="text-align: center; margin: 20px 0;">\n  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot-navigation.png" alt="Navigating in Radial Timeline" style="width: 235; max-width: 100%;" />\n  <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Navigating in Radial Timeline</div>\n</div>\n\n## View modes via primary navigation\n\n## Narrative Mode (keyboard 1)\nShows all scenes from all subplots on the outer ring with story beats and subplot color-coding. Structured around the **3-act model** with scenes organized by act divisions (120\xB0 per act). Provides comprehensive view with every detail. This is your primary manuscript-order workspace showing **Narrative time** (reading order) and **Author time** (completion progress). **Tip** For scenes in more than one subplot, click on the scene to make that subplot dominant in the color styling of the narrative mode outer ring.\n\n## Subplot Mode (keyboard 2)\nShows Main Plot subplot in the outer ring with publish stage coloring, other subplots in their respective inner rings. Removes story beats for a cleaner view. Structured around the **3-act model** with scenes distributed across three acts (120\xB0 per act). Simplified view emphasizing **Publishing time** (revision stages) and completion readiness. Perfect for tracking manuscript progress through Zero \u2192 Author \u2192 House \u2192 Press stages.\n\n## Chronologue Mode (keyboard 3)\nDisplays scenes in chronological story order based on `When` field. **Removes the 3-act structure** entirely\u2014scenes are positioned across the full 360\xB0 circle based solely on when they occur in your story\'s timeline. Perfect for mystery/thriller writers or anyone mapping **Chronological time** (event sequences in story-world) while also arranging for narrative order to maximize suspense.\n\n- **Shift Mode** (keyboard **Shift**, **caps lock** or click button): wireframe view revealing the chronological backbone\n  - Click shift button, then select two scenes to see elapsed time comparison\n  - Color-coded elapsed time arc: Start tick (Zero stage purple) \u2192 End tick (Press stage green)  \n  - **Discontinuities marked with \u221E symbol**: Large time jumps between scenes are automatically detected and displayed in shift mode. The threshold is auto-calculated as 3\xD7 the median gap between scenes, or customize it in Settings \u2192 Chronologue \u2192 Discontinuity gap threshold\n  <div style="text-align: center; margin: 20px 0;">\n  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot-discontinuity.png" alt="Discontinuity infinity symbols in Chronologue Mode" style="width: 380; max-width: 100%;" />\n  <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Discontinuity infinity symbols in Chronologue Mode</div>\n</div>\n- **Smart duration labels**: Time-period-appropriate formatting (hours/days/weeks/months/years)\n- **Dynamic duration arc cap**: Chronologue mode proportionally scales scene durations up to a selected maximum (Settings \u2192 Advanced)\n\n<div style="text-align: center; margin: 20px 0;">\n  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot-duration.png" alt="Duration Marks in Chronologue Mode (red, orange and normal)" style="width: 380; max-width: 100%;" />\n  <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Duration Marks in Chronologue Mode (red, orange and normal)</div>\n</div>\n**Tip**: Use shift mode\'s decluttered wireframe view to analyze your story\'s temporal structure and identify chronological discontinuities that may need bridging scenes.\n\n\n\n## Gossamer Mode (keyboard 4)\nVisualizes narrative momentum using story beat scores. Timeline grays out; momentum values display across story beats to show tension/excitement building.\n\n- Works with any beat structure\n- Historical comparison (up to 30 runs) creates a shaded envelope across min/max scores.\n- Ideal Range based on `Range=0-20` yaml for each story beat creating an idealized story momentum shape.\n- Manual score entry to track momentum changes over time with suggested LLM prompt.\n\n**Command**: Gossamer enter momentum scores\n\n<div style="text-align: center; margin: 20px 0;">\n  <img src="https://raw.githubusercontent.com/EricRhysTaylor/radial-timeline/master/screenshot-gossamer.png" alt="Gossamer Range & Three Scores" style="width: 400; max-width: 100%;" />\n  <div style="font-size: 0.85em; margin-top: 8px; color: #666;">Gossamer Range & Three Scores</div>\n</div>\n\n## Zero Draft Mode\nPrevents edits to completed zero-draft scenes. Click completed scene \u2192 modal for pending edits \u2192 save ideas for later revision. Keeps you progress to new scenes instead of endlessly revising.\n\n**Settings**: \u2192 Radial Timeline \u2192 Zero draft mode\n\n---\n\n## Settings & Customization\n\nAccess via Obsidian Settings \u2192 Community Plugins \u2192 Radial Timeline\n\n**Source path:**\n- Root folder for scene files (e.g., `Book 1`). Leave blank to scan entire vault.\n\n**Publication and progress:**\n- **Target completion date**: Optional target (YYYY-MM-DD). Marker appears on outer ring.\n- **Show estimated completion date**: Toggle visibility of the completion date estimate label near the progress ring.\n- **Zero draft mode**: Prevents edits to completed zero-draft scenes\n\n**Chronologue mode settings:**\n- **Chronologue duration arc cap**: Select maximum duration to display on scene duration arcs, or use "auto" for intelligent selection based on your story\'s longest scene. Scenes at or above this value fill the entire segment; shorter durations scale proportionally.\n- **Discontinuity gap threshold**: Controls when the \u221E symbol appears in shift mode. Auto-calculated as 3\xD7 the median time gap between consecutive scenes. Override with a custom gap threshold (e.g., "4 days", "1 week") to mark larger or smaller time jumps as discontinuities.\n\n**Gossamer story beats system:**\n- **Story beats system**: Select story structure model (Save The Cat, Hero\'s Journey, Story Grid, or Custom)\n- **Create story beat template notes**: Generate template beat notes with YAML frontmatter\n\n**AI features:**\n- **AI Provider**: Choose Anthropic, Gemini, or OpenAI for scene analysis\n- **Contextual Prompt**: Customize AI analysis prompts\n- **API Logging**: Track AI interactions in "AI" folder and manuscript generation with table of contents\n\n**Advanced:**\n- **Auto-expand clipped scene titles**: Disable to prevent scene title expansion on hover, making it easier to quickly slide over multiple scenes and read titles from the synopsis instead.\n- **Metadata refresh debounce (ms)**: Delay before refreshing timeline after YAML frontmatter changes. Increase (default 5000ms) if your vault is large and updates feel too frequent.\n\n**Visual customization:**\n- **Publishing stage colors**: Customize colors for Zero, Author, House, Press stages (click swatch for color picker and each has reset to default button)\n- **Ring colors**: Customize up to 16 subplot ring colors (repeats after 16)\n\n---\n\n## Frontmatter Quick Reference\n\nAll scene and beat notes use YAML frontmatter. Place this at the very beginning of your note before any other text.\n\n## Minimal Scene (Required Fields)\n\n```yaml\n---\nClass: Scene              # Type: Scene or Beat\nAct: 1                    # Which act (1-3)\nWhen:                     # Story chronology date (YYYY-MM-DD 12:34pm)\nDuration:                 # How long the scene lasts (e.g., "45 seconds", "45s", "45sec", "2 hours", "3days")\nSynopsis:                 # Brief description of what happens in this scene\nStatus: Todo              # Scene status (Todo/Working/Complete)\nSubplot: Main Plot        # Single subplot (or use array format below for multiple)\nCharacter:                # Characters in the scene (use array format below for multiple)\nPOV:                      # blank, first, you, third, omni, narrator, two, all, count\nPlace:                    # Location where scene takes place (use array format for multiple)\nDue:                      # Target completion date (YYYY-MM-DD)\nPublish Stage: Zero       # Revision stage (Zero/Author/House/Press)\nRevision:                 # Revision count (leave blank until stage > zero)\nPending Edits:            # Notes for future revisions (especially for zero draft mode)\nWords:                    # Scene word count\nBook:                     # Book title (appears in timeline tab, defaults to "Book 1")\nBeats Update:             # AI-generated story beat analysis flag\n---\n```\n\n**For multiple subplots or characters, use YAML list format:**\n```yaml\nSubplot:\n  - Main Plot\n  - Romance Arc\nCharacter:\n  - "[[Protagonist]]"       #Obsidian wikilink format to click through to a note\n  - "Mentor"\n  - Child One                #No link\nPlace:\n  - "[[Castle]]"            #wikilink\n  - "Forest"\n  - Planet Nine\n```\n> **Note**: Use of brackets denotes a link to a character or place file (optional).\n\n> **POV keywords**: Set `pov:` to one word. Supported modes: `first`, `second`, `third`, `omni`, `objective`. Examples:\n> - `pov: first` \u2014 first listed character gets a `\xB9` marker.\n> - `pov: second` / `pov: you` \u2014 inserts `You\xB2` ahead of the cast.\n> - `pov: omni` \u2014 shows `Omni\xB3` to signal an omniscient narrator.\n> - `pov: objective` \u2014 shows `Narrator\xB0` for camera-eye scenes.\n> Need to highlight multiple carriers? Use counts: `pov: two`, `pov: 4`, `pov: count`, or `pov: all`. Numeric values highlight that many leading characters using the active mode (global default if no mode keyword is specified). Counts never exceed the number of names under `Character:`.\n> Leave `pov:` blank to stick with the global default (first listed character, legacy marker).\n\n## Standard Beat\n\n```yaml\n---\nClass: Beat                   # Formerly Plot, Deprecated\nAct: 1\nWhen:                         # Optional: Story timeline date for chronological positioning (YYYY-MM-DD HH:MM)\nDescription: The first impression of your story. A snapshot before the journey begins.\nBeat Model: Save The Cat\nRange: 0-20\nGossamer1: 12                 # First run (oldest) - Up to 30 evaluation passes\nGossamer1 Justification: \nGossamer2: 21                 # Second run (most recent in this example)\nGossamer2 Justification: \n---\n```\n\n> **Tip**: Beat notes are currently displayed in narrative order using the Act field and filename prefix numbers (e.g., `1 Opening Image.md`).\n\n**Need more fields?** See the complete [YAML Field Reference](./docs/YAML_REFERENCE.md) for:\n- Standard scene with common metadata (Revision, Book, Words, and more)\n- Advanced scenes with AI beats and Story Grid analysis\n- Beat examples with historical Gossamer tracking\n- Complete field documentation and tips\n\n---\n\n## Installation\n\nFrom Obsidian\n\n1.  Open settings \u2192 community plugins.\n2.  Click browse and search for "radial timeline".\n3.  Click install and then enable.\n\nManual installation\n\n1.  Download the latest main.js, styles.css, and manifest.json from the <a href="https://github.com/EricRhysTaylor/radial-timeline/releases" target="_blank" rel="noopener">releases</a> page.\n2.  Extract the files to your vault\'s .obsidian/plugins/radial-timeline (may be hidden by file system)\n\n<hr>\n\n## Screen resolution suggestions\n\nThe radial timeline is designed for high pixel density displays (around 200 ppi or higher) for optimal visual quality. This means:\n\n- All Apple Retina displays or 2x pixel density (macbooks, imacs, etc.). Consider setting MacOS to `More Space` under Settings \u2192 Display\n- Windows systems with 4k displays or higher (may require adjusted scaling) will work well\n- Tablets and mobile phones all operate at high dpi\n\nIf you\'re experiencing visual quality issues on Windows, please check your display scaling settings in Windows settings \u2192 system \u2192 display \u2192 scale and layout.\n\n<hr>\n\n## Technical implementation\n\nThe radial timeline visualization was inspired by and draws on principles from <a href="https://d3js.org" target="_blank" rel="noopener">d3.js</a>, a powerful javascript library for producing dynamic, interactive data visualizations. While the plugin doesn\'t directly use the d3 library to reduce dependencies, it implements several d3-style approaches:\n\n- SVG-based visualization techniques\n- Data-driven document manipulation\n- Interactive elements with hover and click behaviors\n- Radial layouts and polar coordinates\n- Scale transformations and data mapping\n- Dynamic color manipulation and pattern generation\n\nThe visualizations are built using pure SVG and javascript, offering a lightweight solution that maintains the elegance and interactivity of d3-style visualizations while being fully compatible with Obsidian\'s document object model.\n\n<hr>\n\n## Acknowledgements\n\nThis project stands on the shoulders of many generous teachers, tools, and storytellers:\n\n- d3.js at [d3js.org](https://d3js.org) for pioneering data-driven, SVG-based visualization patterns that informed the radial layout, scales, and interaction patterns used here, even though the plugin implements them in plain SVG and javascript within the DOM of Obsidian.\n- Save the Cat! Writes a Novel (2018), Jessica Brody \u2014 a practical articulation of the Save the Cat beats used by many authors. [Save the Cat](https://www.jessicabrody.com/books/non-fiction/save-cat-writes-novel/about/).\n- The Story Grid, Shawn Coyne \u2014 a rigorous methodology for analyzing scenes and beat flow; helpful for systematically evaluating arcs across scenes. [storygrid.com](https://storygrid.com).\n- The Obsidian community for a thriving plugin ecosystem and thoughtful feature development and implementation. [obsidian.md](https://obsidian.md).\n- The W3C SVG specification and countless browser engineers for making vector graphics on the web dependable. [w3.org/Graphics/SVG](https://www.w3.org/Graphics/SVG/).\n\n<hr>\n\n## Feedback and support\n\nPlease see the Github Wiki for documentation at <a href="https://github.com/EricRhysTaylor/Radial-Timeline/wiki"  target="_blank" rel="noopener">Github Radial Timeline Wiki</a>. Also check out the Discussions group at <a href="https://github.com/EricRhysTaylor/Radial-Timeline/discussions" target="_blank" rel="noopener">Discussions</a>. If you encounter issues or have feature requests, please file an issue on the <a href="https://github.com/EricRhysTaylor/radial-timeline/issues" target="_blank" rel="noopener">Github Repository Issues page</a>. If you find the radial timeline plugin useful and would like to support continued development, please consider joining my <a href="https://www.patreon.com/c/EricRhysTaylor" target="_blank" rel="noopener">Patreon</a> or just buying me a coffee:\n\n<a href="https://www.buymeacoffee.com/ericrhysTaylor" target="_blank" rel="noopener">\n  <img src="https://cdn.buymeacoffee.com/buttons/v2/default-yellow.png" alt="buy me a coffee" style="width: 150px;"></a>\n&nbsp;&nbsp;&nbsp;&nbsp;\n<a href=\'https://ko-fi.com/Z8Z21NMQRN\' target=\'_blank\'><img style=\'border:0px;width:150px;\' src=\'https://storage.ko-fi.com/cdn/kofi4.png?v=6\' border=\'0\' alt=\'Buy Me a Coffee at ko-fi.com\' /></a>\n\n<hr>\n\n## Author\n\nCreated by Eric Rhys Taylor\n\nReviewed and approved for the Obsidian Community Plugins directory. Developed with best practices and secure API use in mind.\n\n## License & Intellectual Property\n\nRadial Timeline\u2122 \xA9 2025 Eric Rhys Taylor  \nReleased under a **Source-Available, Non-Commercial License**.  \n\n- You may view, install, and use this plugin for personal or educational purposes.\n- Commercial use, redistribution, or creation of derivative works using this source code is prohibited without written permission.\n- The \u201CRadial Timeline\u201D name is a trademark of Eric Rhys Taylor.  \n\nSee the [LICENSE](./LICENSE) and [NOTICE](./NOTICE) files for full details.\n\n## Disclaimer & Limitation of Liability\n\nThis software is provided \u201Cas is\u201D without warranty of any kind, express or implied.\nThe author makes no guarantees regarding performance, reliability, or compatibility with third-party plugins, APIs, or services.\n' : "README content could not be loaded. Please ensure the plugin was built correctly or view the README.md file directly.";
  const ytThumbRe = /!\[[^\]]*\]\((https?:\/\/i\.ytimg\.com\/vi\/([a-zA-Z0-9_-]+)\/[^)]+)\)/gi;
  const externalImgRe = /!\[([^\]]*)\]\((https?:\/\/[^)]+)\)/gi;
  const safeReadme = readmeMarkdown.replace(ytThumbRe, (_m, _url, vid) => `[Watch on YouTube](https://youtu.be/${vid})`).replace(externalImgRe, (_m, alt, url) => `[${alt || "Open link"}](${url})`);
  const component = new import_obsidian30.Component();
  setComponentRef(component);
  import_obsidian30.MarkdownRenderer.render(
    app,
    safeReadme,
    readmeContainer,
    "",
    component
  );
}

// src/settings/sections/AdvancedSection.ts
var import_obsidian31 = require("obsidian");
function renderAdvancedSection(params) {
  const { app, plugin, containerEl } = params;
  new import_obsidian31.Setting(containerEl).setName("Advanced").setHeading();
  new import_obsidian31.Setting(containerEl).setName("Auto-expand clipped scene titles").setDesc("When hovering over a scene, automatically expand it if the title text is clipped. Disable this if you prefer to quickly slide through scenes and read titles from the synopsis instead.").addToggle((toggle) => {
    var _a;
    return toggle.setValue((_a = plugin.settings.enableSceneTitleAutoExpand) != null ? _a : true).onChange(async (value) => {
      plugin.settings.enableSceneTitleAutoExpand = value;
      await plugin.saveSettings();
    });
  });
  new import_obsidian31.Setting(containerEl).setName("Metadata refresh debounce (ms)").setDesc("Delay before refreshing the timeline after YAML frontmatter changes. Increase if your vault is large and updates feel too frequent.").addText((text) => {
    var _a;
    const current = String((_a = plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4);
    text.setPlaceholder("e.g., 10000").setValue(current).onChange(async (value) => {
      var _a2;
      const n = Number(value.trim());
      if (!Number.isFinite(n) || n < 0) {
        new import_obsidian31.Notice("Please enter a non-negative number.");
        text.setValue(String((_a2 = plugin.settings.metadataRefreshDebounceMs) != null ? _a2 : 1e4));
        return;
      }
      plugin.settings.metadataRefreshDebounceMs = n;
      await plugin.saveSettings();
    });
  });
  new import_obsidian31.Setting(containerEl).setName("Reset subplot color dominance").setDesc("Clear all saved subplot color dominance preferences for scenes that appear in multiple subplots. This resets to the default ordering (outermost to innermost rings based on subplot scene population).").addButton((button) => button.setButtonText("Reset to default").setWarning().onClick(async () => {
    const count = Object.keys(plugin.settings.dominantSubplots || {}).length;
    plugin.settings.dominantSubplots = {};
    await plugin.saveSettings();
    plugin.refreshTimelineIfNeeded(null);
    if (count > 0) {
      new import_obsidian31.Notice(`Cleared saved colors for ${count} multi-subplot scene${count === 1 ? "" : "s"}.`);
    } else {
      new import_obsidian31.Notice("No subplot dominance preferences to reset.");
    }
  }));
  const sortSetting = new import_obsidian31.Setting(containerEl).setName("Scene ordering based on When date").setDesc("Coming someday maybe not sure yet: Sort scenes chronologically by When date instead of manuscript order for all modes.").addToggle((toggle) => toggle.setValue(false).setDisabled(true).onChange(async () => {
  }));
  sortSetting.settingEl.style.opacity = "0.5";
  sortSetting.settingEl.style.cursor = "not-allowed";
}

// src/settings/sections/AiSection.ts
var import_obsidian32 = require("obsidian");

// src/data/aiModels.ts
var CURATED_MODELS = {
  openai: [
    {
      id: "gpt-5.1-2025-11-13",
      label: "GPT-5.1 (Nov 2025 build)",
      tier: "premium",
      guidance: "Deep-think powerhouse from OpenAI\u2014best when you need maximum technical rigor across massive manuscripts. [FYI](https://platform.openai.com/docs/models#gpt-5-1)"
    }
  ],
  anthropic: [
    {
      id: "claude-sonnet-4-5-20250929",
      label: "Claude Sonnet 4.5",
      tier: "premium",
      guidance: "Anthropic\u2019s creative specialist\u2014excellent narrative instincts and polished first-draft feedback for writers. [FYI](https://docs.anthropic.com/en/docs/about-claude/models#claude-sonnet-45)"
    }
  ],
  gemini: [
    {
      id: "models/gemini-2.5-pro",
      label: "Gemini 2.5 Pro",
      tier: "premium",
      guidance: "Google\u2019s momentum analyst\u2014huge context window and strong beat-level analytics for structural planning. [FYI](https://ai.google.dev/gemini-api/docs/models/gemini#gemini-25-pro)"
    }
  ]
};

// src/settings/sections/AiSection.ts
function renderAiSection(params) {
  var _a, _b, _c, _d;
  const { app, plugin, containerEl } = params;
  new import_obsidian32.Setting(containerEl).setName("AI LLM for scene analysis").setHeading();
  new import_obsidian32.Setting(containerEl).setName("Enable AI LLM features").setDesc("Show command palette options and UI scene analysis colors and hover synopsis. When off, these visuals are hidden, but metadata remains unchanged.").addToggle((toggle) => {
    var _a2;
    return toggle.setValue((_a2 = plugin.settings.enableAiSceneAnalysis) != null ? _a2 : true).onChange(async (value) => {
      plugin.settings.enableAiSceneAnalysis = value;
      await plugin.saveSettings();
      params.toggleAiSettingsVisibility(value);
      plugin.refreshTimelineIfNeeded(null);
    });
  });
  const modelPickerSetting = new import_obsidian32.Setting(containerEl).setName("Model").setDesc("Pick preferred model for advanced writing analysis.");
  const controlRow = modelPickerSetting.controlEl.createDiv({ cls: "rt-model-picker-row" });
  const guidanceEl = controlRow.createDiv({ cls: "rt-model-guidance" });
  const dropdownContainer = controlRow.createDiv({ cls: "rt-model-picker-select" });
  const dropdownComponent = new import_obsidian32.DropdownComponent(dropdownContainer);
  dropdownComponent.selectEl.classList.add("rt-setting-dropdown", "rt-provider-dropdown");
  {
    const tierLabel = {
      premium: "Premium",
      balanced: "Balanced",
      budget: "Budget"
    };
    const providerLabel = {
      anthropic: "Anthropic",
      gemini: "Gemini",
      openai: "OpenAI"
    };
    const choices = Object.entries(CURATED_MODELS).flatMap(([provider, models]) => models.map((model) => ({
      optionId: `${provider}:${model.id}`,
      provider,
      modelId: model.id,
      label: `${providerLabel[provider]} \u2014 ${model.label}`,
      tier: model.tier,
      guidance: model.guidance
    })));
    choices.forEach((opt) => {
      dropdownComponent.addOption(opt.optionId, `${opt.label} (${tierLabel[opt.tier]})`);
    });
    const findDefaultChoice = () => {
      const provider = plugin.settings.defaultAiProvider || "openai";
      const modelId = provider === "anthropic" ? plugin.settings.anthropicModelId : provider === "gemini" ? plugin.settings.geminiModelId : plugin.settings.openaiModelId;
      return choices.find((choice) => choice.provider === provider && choice.modelId === modelId) || choices.find((choice) => choice.provider === provider) || choices[0];
    };
    const updateGuidance = (choice) => {
      guidanceEl.empty();
      if (!choice) {
        guidanceEl.setText("Select a model to see guidance on when to use it.");
        return;
      }
      const match = choice.guidance.match(/\[FYI\]\((https?:\/\/[^\s)]+)\)/i);
      const summary = match ? choice.guidance.replace(match[0], "").trim() : choice.guidance;
      const text = document.createElement("span");
      text.textContent = summary;
      guidanceEl.appendChild(text);
      if (match) {
        guidanceEl.appendChild(document.createTextNode(" "));
        const anchor = guidanceEl.createEl("a", { text: "FYI", href: match[1] });
        anchor.target = "_blank";
        anchor.rel = "noopener";
      }
    };
    const defaultChoice = findDefaultChoice();
    if (defaultChoice) {
      dropdownComponent.setValue(defaultChoice.optionId);
      updateGuidance(defaultChoice);
    } else {
      updateGuidance();
    }
    dropdownComponent.onChange(async (value) => {
      const choice = choices.find((c) => c.optionId === value);
      if (!choice) return;
      plugin.settings.defaultAiProvider = choice.provider;
      if (choice.provider === "anthropic") plugin.settings.anthropicModelId = choice.modelId;
      if (choice.provider === "gemini") plugin.settings.geminiModelId = choice.modelId;
      if (choice.provider === "openai") plugin.settings.openaiModelId = choice.modelId;
      await plugin.saveSettings();
      params.refreshProviderDimming();
      updateGuidance(choice);
    });
  }
  params.addAiRelatedElement(modelPickerSetting.settingEl);
  const anthropicSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-anthropic" });
  const geminiSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-gemini" });
  const openaiSection = containerEl.createDiv({ cls: "rt-provider-section rt-provider-openai" });
  params.setProviderSections({ anthropic: anthropicSection, gemini: geminiSection, openai: openaiSection });
  params.addAiRelatedElement(anthropicSection);
  params.addAiRelatedElement(geminiSection);
  params.addAiRelatedElement(openaiSection);
  new import_obsidian32.Setting(anthropicSection).setName("Anthropic API key").setDesc((() => {
    const frag = document.createDocumentFragment();
    const span = document.createElement("span");
    span.textContent = "Your Anthropic API key for using Claude AI features. ";
    const link = document.createElement("a");
    link.href = "https://platform.claude.com";
    link.textContent = "Get key";
    link.target = "_blank";
    link.rel = "noopener";
    frag.appendChild(span);
    frag.appendChild(link);
    return frag;
  })()).addText((text) => text.setPlaceholder("Enter your Anthropic API key").setValue(plugin.settings.anthropicApiKey || "").onChange(async (value) => {
    plugin.settings.anthropicApiKey = value.trim();
    await plugin.saveSettings();
    params.setKeyInputRef("anthropic", text.inputEl);
    params.scheduleKeyValidation("anthropic");
  }));
  new import_obsidian32.Setting(geminiSection).setName("Gemini API key").setDesc((() => {
    const frag = document.createDocumentFragment();
    const span = document.createElement("span");
    span.textContent = "Your Gemini API key for using Google Gemini models. ";
    const link = document.createElement("a");
    link.href = "https://aistudio.google.com";
    link.textContent = "Get key";
    link.target = "_blank";
    link.rel = "noopener";
    frag.appendChild(span);
    frag.appendChild(link);
    return frag;
  })()).addText((text) => text.setPlaceholder("Enter your Gemini API key").setValue(plugin.settings.geminiApiKey || "").onChange(async (value) => {
    plugin.settings.geminiApiKey = value.trim();
    await plugin.saveSettings();
    params.setKeyInputRef("gemini", text.inputEl);
    params.scheduleKeyValidation("gemini");
  }));
  new import_obsidian32.Setting(openaiSection).setName("OpenAI API key").setDesc((() => {
    const frag = document.createDocumentFragment();
    const span = document.createElement("span");
    span.textContent = "Your OpenAI API key for using ChatGPT AI features.";
    const link = document.createElement("a");
    link.href = "https://platform.openai.com";
    link.textContent = "Get key";
    link.target = "_blank";
    link.rel = "noopener";
    frag.appendChild(span);
    frag.appendChild(link);
    return frag;
  })()).addText((text) => text.setPlaceholder("Enter your API key").setValue(plugin.settings.openaiApiKey || "").onChange(async (value) => {
    plugin.settings.openaiApiKey = value.trim();
    await plugin.saveSettings();
    params.setKeyInputRef("openai", text.inputEl);
    const v = value.trim();
    text.inputEl.removeClass("rt-setting-input-success");
    text.inputEl.removeClass("rt-setting-input-error");
    if (v && !v.startsWith("sk-")) {
      text.inputEl.addClass("rt-setting-input-error");
      new import_obsidian32.Notice('This does not look like an OpenAI secret key. Keys start with "sk-".');
    } else {
      params.scheduleKeyValidation("openai");
    }
  }));
  params.refreshProviderDimming();
  if ((_a = plugin.settings.anthropicApiKey) == null ? void 0 : _a.trim()) {
    const input = anthropicSection.querySelector('input[type="text"], input[type="password"], input');
    params.setKeyInputRef("anthropic", input);
    params.scheduleKeyValidation("anthropic");
  }
  if ((_b = plugin.settings.geminiApiKey) == null ? void 0 : _b.trim()) {
    const input = geminiSection.querySelector('input[type="text"], input[type="password"], input');
    params.setKeyInputRef("gemini", input);
    params.scheduleKeyValidation("gemini");
  }
  if ((_c = plugin.settings.openaiApiKey) == null ? void 0 : _c.trim()) {
    const input = openaiSection.querySelector('input[type="text"], input[type="password"], input');
    params.setKeyInputRef("openai", input);
    params.scheduleKeyValidation("openai");
  }
  const apiLoggingSetting = new import_obsidian32.Setting(containerEl).setName("Log AI interactions to file").setDesc('If enabled, create a new note in the "AI" folder for each AI API request/response.').addToggle((toggle) => toggle.setValue(plugin.settings.logApiInteractions).onChange(async (value) => {
    plugin.settings.logApiInteractions = value;
    await plugin.saveSettings();
  }));
  params.addAiRelatedElement(apiLoggingSetting.settingEl);
  params.toggleAiSettingsVisibility((_d = plugin.settings.enableAiSceneAnalysis) != null ? _d : true);
}

// src/utils/releases.ts
var DEFAULT_RELEASES_URL = "https://github.com/EricRhysTaylor/Radial-Timeline/releases";
function parseReleaseVersion(version) {
  if (!version) return null;
  const normalized = version.trim().replace(/^v/i, "");
  const match = normalized.match(/^(\d+)(?:\.(\d+))?(?:\.(\d+))?/);
  if (!match) return null;
  const major = Number.parseInt(match[1], 10);
  const minor = match[2] !== void 0 ? Number.parseInt(match[2], 10) : null;
  const patch = match[3] !== void 0 ? Number.parseInt(match[3], 10) : null;
  const majorLabel = minor !== null ? `${major}.${minor}` : `${major}`;
  const fullLabel = patch !== null ? `${majorLabel}.${patch}` : majorLabel;
  return { major, minor, patch, majorLabel, fullLabel };
}
function compareReleaseVersionsDesc(aVersion, bVersion) {
  var _a, _b, _c, _d;
  const a = parseReleaseVersion(aVersion);
  const b = parseReleaseVersion(bVersion);
  if (!a && !b) return 0;
  if (!a) return 1;
  if (!b) return -1;
  if (a.major !== b.major) return b.major - a.major;
  const aMinor = (_a = a.minor) != null ? _a : 0;
  const bMinor = (_b = b.minor) != null ? _b : 0;
  if (aMinor !== bMinor) return bMinor - aMinor;
  const aPatch = (_c = a.patch) != null ? _c : 0;
  const bPatch = (_d = b.patch) != null ? _d : 0;
  return bPatch - aPatch;
}
function formatPublishedDate(value) {
  if (!value) return null;
  try {
    const date = new Date(value);
    if (Number.isNaN(date.getTime())) return null;
    return date.toLocaleDateString();
  } catch (e) {
    return null;
  }
}

// src/utils/releaseNotesRenderer.ts
var import_obsidian33 = require("obsidian");
async function renderReleaseNotesList(containerEl, entries, majorEntry, plugin, cssPrefix) {
  var _a, _b;
  for (const entry of entries) {
    const versionLabel = (_b = (_a = parseReleaseVersion(entry.version)) == null ? void 0 : _a.fullLabel) != null ? _b : entry.title || entry.version;
    const details = containerEl.createEl("details", { cls: `${cssPrefix}-details` });
    if (entry.version === majorEntry.version) {
      details.open = true;
    }
    const summaryEl = details.createEl("summary", { cls: `${cssPrefix}-details-summary` });
    const dateText = formatPublishedDate(entry.publishedAt);
    summaryEl.createSpan({
      text: dateText ? `${versionLabel} \u2014 ${dateText}` : versionLabel,
      cls: `${cssPrefix}-details-summary-label`
    });
    const entryBody = details.createDiv({ cls: `${cssPrefix}-body markdown-preview-view` });
    await import_obsidian33.MarkdownRenderer.renderMarkdown(entry.body, entryBody, "", plugin);
  }
}

// src/settings/sections/ReleaseNotesSection.ts
async function renderReleaseNotesSection({ plugin, containerEl }) {
  var _a, _b;
  const entries = plugin.getReleaseNotesEntries();
  const section = containerEl.createDiv({ cls: "rt-settings-release-notes" });
  section.createEl("h2", { text: "What's New" });
  if (!entries || entries.length === 0) {
    const fallback = section.createEl("p");
    fallback.setText("Release notes are not available in this build. ");
    const link = fallback.createEl("a", { text: "View releases on GitHub.", href: DEFAULT_RELEASES_URL });
    link.setAttr("target", "_blank");
    return;
  }
  const majorVersion = plugin.getReleaseNotesMajorVersion();
  const majorEntry = (_b = (_a = majorVersion ? entries.find((entry) => entry.version === majorVersion) : null) != null ? _a : entries[entries.length - 1]) != null ? _b : entries[0];
  await renderReleaseNotesList(section, entries, majorEntry, plugin, "rt-settings-release-notes");
}

// src/settings/sections/PovSection.ts
var import_obsidian34 = require("obsidian");
var POV_MODE_OPTIONS = {
  off: "Legacy (first listed character, \u201Cpov\u201D superscript)",
  first: "First-person voice (\xB9 marker on characters)",
  second: "Second-person voice (You\xB2 label)",
  third: "Third-person limited (\xB3 marker on characters)",
  omni: "Omni narrator (Omni\xB3 label)",
  objective: "Objective \u2014 camera-eye narrator (Narrator\xB0 label)"
};
function renderPovSection(params) {
  const { plugin, containerEl } = params;
  new import_obsidian34.Setting(containerEl).setName("Point of view").setHeading();
  const storedMode = plugin.settings.globalPovMode;
  const currentMode = storedMode && storedMode in POV_MODE_OPTIONS ? storedMode : "off";
  if (storedMode !== currentMode) {
    plugin.settings.globalPovMode = currentMode;
    void plugin.saveSettings();
  }
  new import_obsidian34.Setting(containerEl).setName("Global POV").setDesc('Optional. Choose a mode to apply whenever a scene omits the POV field (per-scene values like "pov: first" always win).').addDropdown((dropdown) => {
    Object.keys(POV_MODE_OPTIONS).forEach((key) => {
      dropdown.addOption(key, POV_MODE_OPTIONS[key]);
    });
    dropdown.setValue(currentMode);
    dropdown.onChange(async (value) => {
      var _a;
      const next = value || "off";
      plugin.settings.globalPovMode = next;
      await plugin.saveSettings();
      const debounce = (_a = plugin.settings.metadataRefreshDebounceMs) != null ? _a : 1e4;
      plugin.refreshTimelineIfNeeded(null, debounce);
    });
  });
  new import_obsidian34.Setting(containerEl).setName("Scene-level overrides & multiple POV markers").setDesc("Set `POV:` in YAML to: `first`, `second`, `third`, `omni`, `objective`, or a number such as `two`, `four`, `count`, or `all` if more than one `character:` is carrying the POV.");
}

// src/settings/SettingsTab.ts
var RadialTimelineSettingsTab = class extends import_obsidian35.PluginSettingTab {
  // Store references to AI-related settings
  constructor(app, plugin) {
    super(app, plugin);
    this.readmeComponent = null;
    // <<< ADD THIS LINE
    this._providerSections = {};
    this._keyValidateTimers = {};
    this._aiRelatedElements = [];
    this.plugin = plugin;
  }
  // Folder suggest implementation delegated to its own class
  attachFolderSuggest(text) {
    const inputEl = text.inputEl;
    new FolderSuggest(this.app, inputEl, this.plugin, text);
  }
  // Dims non-selected provider sections based on chosen model/provider
  refreshProviderDimming() {
    const selected = this.plugin.settings.defaultAiProvider || "openai";
    const map = this._providerSections;
    ["anthropic", "gemini", "openai"].forEach((key) => {
      const el = map[key];
      if (!el) return;
      if (key === selected) el.classList.remove("dimmed");
      else el.classList.add("dimmed");
    });
  }
  // Toggle visibility of AI-related settings
  toggleAiSettingsVisibility(show) {
    this._aiRelatedElements.forEach((el) => {
      if (show) {
        el.classList.remove("rt-settings-hidden");
        el.classList.add("rt-settings-visible");
      } else {
        el.classList.remove("rt-settings-visible");
        el.classList.add("rt-settings-hidden");
      }
    });
  }
  // Debounced API key validation using zero-cost model list endpoints
  scheduleKeyValidation(provider) {
    var _a;
    const prior = this._keyValidateTimers[provider];
    if (prior) window.clearTimeout(prior);
    const inputEl = provider === "anthropic" ? this._anthropicKeyInput : provider === "gemini" ? this._geminiKeyInput : this._openaiKeyInput;
    if (!inputEl) return;
    const key = (_a = inputEl.value) == null ? void 0 : _a.trim();
    if (!key) return;
    if (key.length < 8) return;
    this._keyValidateTimers[provider] = window.setTimeout(async () => {
      inputEl.removeClass("rt-setting-input-success");
      inputEl.removeClass("rt-setting-input-error");
      try {
        if (provider === "anthropic") {
          await fetchAnthropicModels(key);
        } else if (provider === "gemini") {
          await fetchGeminiModels(key);
        } else {
          await fetchOpenAiModels(key);
        }
        inputEl.addClass("rt-setting-input-success");
        window.setTimeout(() => inputEl.removeClass("rt-setting-input-success"), 1200);
      } catch (e) {
        const msg = e instanceof Error ? e.message : String(e);
        if (/401|unauthorized|invalid/i.test(msg)) {
          inputEl.addClass("rt-setting-input-error");
          window.setTimeout(() => inputEl.removeClass("rt-setting-input-error"), 1400);
        }
      }
    }, 800);
  }
  // Method to show path suggestions
  showPathSuggestions(currentValue, container, textInput) {
    const validPaths = this.plugin.settings.validFolderPaths;
    const filteredPaths = validPaths.filter(
      (path) => path.toLowerCase().includes(currentValue.toLowerCase()) || currentValue === ""
    );
    container.empty();
    if (filteredPaths.length === 0) {
      container.classList.add("hidden");
      return;
    }
    container.classList.remove("hidden");
    filteredPaths.forEach((path) => {
      const suggestionEl = container.createDiv({ cls: "rt-source-path-suggestion-item" });
      suggestionEl.textContent = path;
      this.plugin.registerDomEvent(suggestionEl, "click", async () => {
        textInput.setValue(path);
        const ok = await this.plugin.validateAndRememberPath(path);
        if (ok) {
          this.plugin.settings.sourcePath = path;
          await this.plugin.saveSettings();
          container.classList.add("hidden");
          textInput.inputEl.removeClass("rt-setting-input-error");
          textInput.inputEl.addClass("rt-setting-input-success");
          window.setTimeout(() => {
            textInput.inputEl.removeClass("rt-setting-input-success");
          }, 1e3);
        } else {
          textInput.inputEl.addClass("rt-setting-input-error");
          window.setTimeout(() => textInput.inputEl.removeClass("rt-setting-input-error"), 2e3);
        }
        try {
          textInput.inputEl.focus();
        } catch (e) {
        }
      });
    });
  }
  // Method to update the selected suggestion highlighting
  updateSelectedSuggestion(suggestions, selectedIndex) {
    suggestions.forEach((suggestion, index) => {
      const el = suggestion;
      if (index === selectedIndex) {
        el.classList.add("selected");
      } else {
        el.classList.remove("selected");
      }
    });
  }
  // Helper function to validate hex color
  isValidHex(hex) {
    return /^#?([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3})$/.test(hex);
  }
  // Render Patreon support section
  renderPatreonSection(containerEl) {
    const patreonContainer = containerEl.createDiv({ cls: "rt-patreon-support" });
    const bgLogo = patreonContainer.createDiv({ cls: "rt-patreon-bg-logo" });
    const bgSvg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    bgSvg.setAttribute("viewBox", "0 0 1080 1080");
    bgSvg.classList.add("rt-patreon-bg-svg");
    const bgPath = document.createElementNS("http://www.w3.org/2000/svg", "path");
    bgPath.setAttribute("d", "M1033.05,324.45c-0.19-137.9-107.59-250.92-233.6-291.7c-156.48-50.64-362.86-43.3-512.28,27.2 C106.07,145.41,49.18,332.61,47.06,519.31c-1.74,153.5,13.58,557.79,241.62,560.67c169.44,2.15,194.67-216.18,273.07-321.33 c55.78-74.81,127.6-95.94,216.01-117.82C929.71,603.22,1033.27,483.3,1033.05,324.45z");
    bgSvg.appendChild(bgPath);
    bgLogo.appendChild(bgSvg);
    const contentContainer = patreonContainer.createDiv({ cls: "rt-patreon-content" });
    const title = contentContainer.createEl("h3", { cls: "rt-patreon-title" });
    title.createSpan({ text: "Support Radial Timeline Development" });
    const description = contentContainer.createEl("p", { cls: "rt-patreon-description" });
    description.appendText("Join my Patreon to show your unbridled enthusiasm for the Radial Timeline! Help guide the development of the project into the far far future by voting in polls and sharing ideas and feedback directly with the creator.");
    const buttonContainer = contentContainer.createDiv({ cls: "rt-patreon-button-container" });
    const patreonButton = buttonContainer.createEl("a", {
      cls: "rt-patreon-button",
      href: "https://www.patreon.com/c/EricRhysTaylor"
    });
    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    svg.setAttribute("width", "16");
    svg.setAttribute("height", "16");
    svg.setAttribute("viewBox", "0 0 1080 1080");
    svg.setAttribute("fill", "currentColor");
    svg.classList.add("rt-patreon-icon");
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", "M1033.05,324.45c-0.19-137.9-107.59-250.92-233.6-291.7c-156.48-50.64-362.86-43.3-512.28,27.2 C106.07,145.41,49.18,332.61,47.06,519.31c-1.74,153.5,13.58,557.79,241.62,560.67c169.44,2.15,194.67-216.18,273.07-321.33 c55.78-74.81,127.6-95.94,216.01-117.82C929.71,603.22,1033.27,483.3,1033.05,324.45z");
    svg.appendChild(path);
    patreonButton.appendChild(svg);
    patreonButton.appendText("Join on Patreon");
    patreonButton.addEventListener("click", (e) => {
      e.preventDefault();
      window.open("https://www.patreon.com/c/EricRhysTaylor", "_blank");
    });
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this._aiRelatedElements = [];
    this.renderPatreonSection(containerEl);
    renderGeneralSection({ app: this.app, plugin: this.plugin, attachFolderSuggest: (t) => this.attachFolderSuggest(t), containerEl });
    renderPublicationSection({ app: this.app, plugin: this.plugin, containerEl });
    renderPovSection({ plugin: this.plugin, containerEl });
    renderChronologueSection({ app: this.app, plugin: this.plugin, containerEl });
    renderStoryBeatsSection({ app: this.app, plugin: this.plugin, containerEl });
    renderAiSection({
      app: this.app,
      plugin: this.plugin,
      containerEl,
      addAiRelatedElement: (el) => this._aiRelatedElements.push(el),
      toggleAiSettingsVisibility: (show) => this.toggleAiSettingsVisibility(show),
      refreshProviderDimming: () => this.refreshProviderDimming(),
      scheduleKeyValidation: (p) => this.scheduleKeyValidation(p),
      setProviderSections: (sections) => {
        this._providerSections = sections;
      },
      setKeyInputRef: (provider, input) => {
        if (provider === "anthropic") this._anthropicKeyInput = input;
        if (provider === "gemini") this._geminiKeyInput = input;
        if (provider === "openai") this._openaiKeyInput = input;
      }
    });
    renderAdvancedSection({ app: this.app, plugin: this.plugin, containerEl });
    renderColorsSection(containerEl, this.plugin);
    void renderReleaseNotesSection({ plugin: this.plugin, containerEl });
    renderReadmeSection({ app: this.app, containerEl, setComponentRef: (c) => {
      this.readmeComponent = c;
    } });
  }
  hide() {
    if (this.readmeComponent) {
      this.readmeComponent.unload();
      this.readmeComponent = null;
    }
  }
};

// src/services/ReleaseNotesService.ts
var import_obsidian37 = require("obsidian");

// src/modals/ReleaseNotesModal.ts
var import_obsidian36 = require("obsidian");
var ReleaseNotesModal = class extends import_obsidian36.Modal {
  constructor(app, plugin, entries, majorEntry) {
    super(app);
    this.plugin = plugin;
    this.entries = entries;
    this.majorEntry = majorEntry;
  }
  async onOpen() {
    const { contentEl, titleEl } = this;
    this.modalEl.addClass("rt-release-notes-modal");
    contentEl.empty();
    titleEl.setText("What's New");
    const bodyHost = contentEl.createDiv();
    await renderReleaseNotesList(bodyHost, this.entries, this.majorEntry, this.plugin, "rt-release-notes-modal");
    const footerEl = contentEl.createDiv({ cls: "rt-release-notes-modal-footer" });
    const closeButton = footerEl.createEl("button", { text: "Close" });
    closeButton.addEventListener("click", () => this.close());
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/services/ReleaseNotesService.ts
var ReleaseNotesService = class {
  constructor(settings, saveSettings) {
    this.settings = settings;
    this.saveSettings = saveSettings;
    this.releaseNotesBundle = null;
    this.releaseModalShownThisSession = false;
    this.releaseNotesFetchPromise = null;
  }
  /**
   * Initialize service state by merging embedded release notes with cached settings.
   */
  initializeFromEmbedded() {
    var _a, _b;
    const embedded = this.loadEmbeddedReleaseNotes();
    const cached = (_a = this.settings.cachedReleaseNotes) != null ? _a : null;
    const embeddedLatest = this.extractLatestVersion(embedded);
    const cachedLatest = this.extractLatestVersion(cached);
    const useEmbedded = embedded && (!cachedLatest || embeddedLatest && compareReleaseVersionsDesc(embeddedLatest, cachedLatest) <= 0);
    if (useEmbedded) {
      this.settings.cachedReleaseNotes = embedded;
      void this.saveSettings();
      this.releaseNotesBundle = embedded;
    } else {
      this.releaseNotesBundle = (_b = cached != null ? cached : embedded) != null ? _b : null;
    }
    this.releaseModalShownThisSession = false;
  }
  getBundle() {
    return this.releaseNotesBundle;
  }
  hasShownModalThisSession() {
    return this.releaseModalShownThisSession;
  }
  markModalShown() {
    this.releaseModalShownThisSession = true;
  }
  getLatestVersion() {
    const entries = this.getEntries();
    return entries.length > 0 ? entries[0].version : null;
  }
  async maybeShowReleaseNotesModal(app, plugin) {
    var _a;
    const entries = this.getEntries();
    if (entries.length === 0) {
      throw new Error("Release bundle missing entries");
    }
    const latestEntry = entries[0];
    const latestVersion = latestEntry.version;
    if (!latestVersion) {
      throw new Error("Release bundle missing latest version");
    }
    const latestKey = this.computeEntryKey(latestEntry);
    const seenVersion = (_a = this.settings.lastSeenReleaseNotesVersion) != null ? _a : "";
    const hasSeen = seenVersion === latestKey || seenVersion === latestVersion;
    if (hasSeen || this.releaseModalShownThisSession) return;
    this.releaseModalShownThisSession = true;
    await this.markReleaseNotesSeen(latestKey);
    this.openReleaseNotesModal(app, plugin);
  }
  openReleaseNotesModal(app, plugin) {
    const entries = this.getEntries();
    if (entries.length === 0) {
      throw new Error("Release bundle missing entries");
    }
    const majorEntry = this.getMajorEntry();
    if (!majorEntry) {
      throw new Error("Release bundle missing major release entry");
    }
    const modal = new ReleaseNotesModal(app, plugin, entries, majorEntry);
    modal.open();
  }
  async markReleaseNotesSeen(versionKey) {
    if (this.settings.lastSeenReleaseNotesVersion === versionKey) return;
    this.settings.lastSeenReleaseNotesVersion = versionKey;
    await this.saveSettings();
  }
  async ensureReleaseNotesFresh(force) {
    if (!force && this.releaseNotesFetchPromise) {
      return this.releaseNotesFetchPromise;
    }
    const task = this.performReleaseNotesFetch(force).finally(() => {
      this.releaseNotesFetchPromise = null;
    });
    this.releaseNotesFetchPromise = task;
    return task;
  }
  getEntries() {
    const bundle = this.releaseNotesBundle;
    if (!bundle) return [];
    return this.extractEntries(bundle);
  }
  getMajorVersion() {
    var _a, _b;
    if (!this.releaseNotesBundle) return null;
    if (this.releaseNotesBundle.majorVersion) return this.releaseNotesBundle.majorVersion;
    if ((_a = this.releaseNotesBundle.major) == null ? void 0 : _a.version) return this.releaseNotesBundle.major.version;
    const entries = this.extractEntries(this.releaseNotesBundle);
    const majorEntry = this.resolveMajorEntry(this.releaseNotesBundle, entries);
    return (_b = majorEntry == null ? void 0 : majorEntry.version) != null ? _b : null;
  }
  getMajorEntry() {
    if (!this.releaseNotesBundle) return null;
    const entries = this.extractEntries(this.releaseNotesBundle);
    return this.resolveMajorEntry(this.releaseNotesBundle, entries);
  }
  loadEmbeddedReleaseNotes() {
    const parsed = JSON.parse(`{
  "entries": [
    {
      "version": "4.1.1",
      "title": "4.1.1",
      "body": "## What's Changed\\r\\n\\r\\n- fix release-notes cache so major release version entry stays correct",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.1.1",
      "publishedAt": "2025-11-16T03:37:17Z"
    },
    {
      "version": "4.1.0",
      "title": "4.1.0",
      "body": "## New Release 4.1\\r\\n\\r\\n### Major Features Added\\r\\n\\r\\n1. **Dominant Subplot Color Feature - Narrative, Chronologue Mode**\\r\\n   - For Scenes with multiple subplots - click scene to open tab now sets associated subplot color to appear in all scenes ring above other subplot colors. The default subplot color dominance is outer to innermost.\\r\\n\\r\\n2. **Chronologue Mode**\\r\\n   - New plugin customization settings with calculations reported for both duration cap and discontinuity gaps\\r\\n   - Fine-tuned Chronologue styles for better readability and impact. Adjusted adaptive timeline units\\r\\n  \\r\\n3. **Gossamer Mode**\\r\\n   - Fine-tuned presentation by replacing some dots with smaller scores and replacing the Score dot with larger number text. \\r\\n   - Major revamp of how it handles a new vault and missing information. Degrades gracefully if scores are missing or ideal ranges. \\r\\n   - Improved handling of Manual Score Update Modal button Copy AI Template with verbose checkbox and inclusion of Story Beats details from actual Story Beat notes to better support story beat customizations by author.\\r\\n\\r\\n5. **Documentation & Settings**\\r\\n   - Reorganized Settings for better presentation and grouping\\r\\n   - Updated docs and README with latest changes and added illustrations\\r\\n   - Added Ko-fi Donate Button\\r\\n\\r\\n---\\r\\n\\r\\n### Major Refactors\\r\\n\\r\\n- Cache system (added then removed haha)\\r\\n- Fallbacks removed for cleaner, get it right the first time operation\\r\\n- Slimmed main.ts hugely\\r\\n- Renamed files and terms throughout code to avoid confusion\\r\\n\\r\\n---\\r\\n\\r\\n### Bug Fixes\\r\\n\\r\\n1. **Search Functionality**\\r\\n    - Fixed search term bugs (Nov 13)\\r\\n    - Resolved Chronologue bugs relating to Search and existing scene hover\\r\\n\\r\\n2. **Novel Completion Features** (Nov 10)\\r\\n    - Debugging Novel Complete Target date and Estimate Completion Ticks aligning properly\\r\\n\\r\\n---",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.1.0",
      "publishedAt": "2025-11-16T02:14:51Z"
    },
    {
      "version": "4.0.2",
      "title": "4.0.2",
      "body": "## Changes\\r\\n\\r\\n### README & Documentation\\r\\n- Various edits and improvements to documentation\\r\\n- New readme illustrations added\\r\\n\\r\\n### Chronologue Mode Refinements\\r\\n\\r\\n#### Outer Perimeter Fine-tuning\\r\\n- Enlarged duration arcs. Moved time unit labels up.\\r\\n- Moved chronological tick styling from inline SVG to CSS for easier customization\\r\\n\\r\\n#### Time Unit Labeling Finesse\\r\\n- **Elegant time display**: Now shows \\"noon\\" and \\"midnight\\" instead of \\"12:00pm\\" and \\"12:00am\\" (matching synopsis treatment)\\r\\n- **Intelligent adaptive labeling** maintains context-aware display based on time gaps between major scene labels",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.0.2",
      "publishedAt": "2025-11-08T00:24:59Z"
    },
    {
      "version": "4.0.1",
      "title": "4.0.1",
      "body": "## What's Changed\\r\\n\\r\\n- Bug in Chronologue mode, whereby hovering in all scenes, the ring will fail to activate the same scene in subplots.\\r\\n- Readme Updates",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.0.1",
      "publishedAt": "2025-11-06T22:57:22Z"
    },
    {
      "version": "4.0.0",
      "title": "4.0.0",
      "body": "## Major Release 4.0: Chronologue Mode & Timeline Intelligence\\r\\n\\r\\n### Chronologue Mode\\r\\n\\r\\nVisualize your story in true chronological order with the new **Chronologue Mode**. See the timeline of your story around the enlarged outer perimeter. All scenes and subplots now respect your date and time-based chronology. Perfect for understanding story flow and identifying pacing issues and temporal impossibilities.\\r\\n\\r\\n- Start date and end date at the top of timeline using zero stage color and press stage color\\r\\n- Duration time arcs show duration of each scene relative to other scenes\\r\\n- Intelligent time unit labeling reveals the timespan of the manuscript\\r\\n- Dedicated shift button for checking elapsed time between scene & discontinuities\\r\\n\\r\\n### Intelligent Date-Time Ordering\\r\\n\\r\\nScenes and plots now automatically organize based on when events actually occur in your narrative, not manuscript order. Ideal for complex narratives with flashbacks, parallel timelines, or non-linear storytelling.\\r\\n\\r\\n### Advanced Mode Control System\\r\\n\\r\\n- Four dedicated view modes: Main Plot, All Scenes, Chronologue and Gossamer\\r\\n- Keyboard shortcuts and current mode title\\r\\n\\r\\n### Enhanced Synopsis Display\\r\\n\\r\\n- Expanded synopsis details with larger scene title and searchable date and time\\r\\n- Duration tracking on a separate line below date and time\\r\\n- Improved text positioning for all quadrants\\r\\n\\r\\n### View Optimizations\\r\\n- Timeline radius adjusts to view mode so no space is wasted\\r\\n- Various advanced settings for customization of modes\\r\\n---\\r\\n",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.0.0",
      "publishedAt": "2025-11-05T20:39:14Z"
    }
  ],
  "majorVersion": "4.0.0",
  "major": {
    "version": "4.0.0",
    "title": "4.0.0",
    "body": "## Major Release 4.0: Chronologue Mode & Timeline Intelligence\\r\\n\\r\\n### Chronologue Mode\\r\\n\\r\\nVisualize your story in true chronological order with the new **Chronologue Mode**. See the timeline of your story around the enlarged outer perimeter. All scenes and subplots now respect your date and time-based chronology. Perfect for understanding story flow and identifying pacing issues and temporal impossibilities.\\r\\n\\r\\n- Start date and end date at the top of timeline using zero stage color and press stage color\\r\\n- Duration time arcs show duration of each scene relative to other scenes\\r\\n- Intelligent time unit labeling reveals the timespan of the manuscript\\r\\n- Dedicated shift button for checking elapsed time between scene & discontinuities\\r\\n\\r\\n### Intelligent Date-Time Ordering\\r\\n\\r\\nScenes and plots now automatically organize based on when events actually occur in your narrative, not manuscript order. Ideal for complex narratives with flashbacks, parallel timelines, or non-linear storytelling.\\r\\n\\r\\n### Advanced Mode Control System\\r\\n\\r\\n- Four dedicated view modes: Main Plot, All Scenes, Chronologue and Gossamer\\r\\n- Keyboard shortcuts and current mode title\\r\\n\\r\\n### Enhanced Synopsis Display\\r\\n\\r\\n- Expanded synopsis details with larger scene title and searchable date and time\\r\\n- Duration tracking on a separate line below date and time\\r\\n- Improved text positioning for all quadrants\\r\\n\\r\\n### View Optimizations\\r\\n- Timeline radius adjusts to view mode so no space is wasted\\r\\n- Various advanced settings for customization of modes\\r\\n---\\r\\n",
    "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.0.0",
    "publishedAt": "2025-11-05T20:39:14Z"
  },
  "latest": {
    "version": "4.1.1",
    "title": "4.1.1",
    "body": "## What's Changed\\r\\n\\r\\n- fix release-notes cache so major release version entry stays correct",
    "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.1.1",
    "publishedAt": "2025-11-16T03:37:17Z"
  },
  "patches": [
    {
      "version": "4.1.0",
      "title": "4.1.0",
      "body": "## New Release 4.1\\r\\n\\r\\n### Major Features Added\\r\\n\\r\\n1. **Dominant Subplot Color Feature - Narrative, Chronologue Mode**\\r\\n   - For Scenes with multiple subplots - click scene to open tab now sets associated subplot color to appear in all scenes ring above other subplot colors. The default subplot color dominance is outer to innermost.\\r\\n\\r\\n2. **Chronologue Mode**\\r\\n   - New plugin customization settings with calculations reported for both duration cap and discontinuity gaps\\r\\n   - Fine-tuned Chronologue styles for better readability and impact. Adjusted adaptive timeline units\\r\\n  \\r\\n3. **Gossamer Mode**\\r\\n   - Fine-tuned presentation by replacing some dots with smaller scores and replacing the Score dot with larger number text. \\r\\n   - Major revamp of how it handles a new vault and missing information. Degrades gracefully if scores are missing or ideal ranges. \\r\\n   - Improved handling of Manual Score Update Modal button Copy AI Template with verbose checkbox and inclusion of Story Beats details from actual Story Beat notes to better support story beat customizations by author.\\r\\n\\r\\n5. **Documentation & Settings**\\r\\n   - Reorganized Settings for better presentation and grouping\\r\\n   - Updated docs and README with latest changes and added illustrations\\r\\n   - Added Ko-fi Donate Button\\r\\n\\r\\n---\\r\\n\\r\\n### Major Refactors\\r\\n\\r\\n- Cache system (added then removed haha)\\r\\n- Fallbacks removed for cleaner, get it right the first time operation\\r\\n- Slimmed main.ts hugely\\r\\n- Renamed files and terms throughout code to avoid confusion\\r\\n\\r\\n---\\r\\n\\r\\n### Bug Fixes\\r\\n\\r\\n1. **Search Functionality**\\r\\n    - Fixed search term bugs (Nov 13)\\r\\n    - Resolved Chronologue bugs relating to Search and existing scene hover\\r\\n\\r\\n2. **Novel Completion Features** (Nov 10)\\r\\n    - Debugging Novel Complete Target date and Estimate Completion Ticks aligning properly\\r\\n\\r\\n---",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.1.0",
      "publishedAt": "2025-11-16T02:14:51Z"
    },
    {
      "version": "4.0.2",
      "title": "4.0.2",
      "body": "## Changes\\r\\n\\r\\n### README & Documentation\\r\\n- Various edits and improvements to documentation\\r\\n- New readme illustrations added\\r\\n\\r\\n### Chronologue Mode Refinements\\r\\n\\r\\n#### Outer Perimeter Fine-tuning\\r\\n- Enlarged duration arcs. Moved time unit labels up.\\r\\n- Moved chronological tick styling from inline SVG to CSS for easier customization\\r\\n\\r\\n#### Time Unit Labeling Finesse\\r\\n- **Elegant time display**: Now shows \\"noon\\" and \\"midnight\\" instead of \\"12:00pm\\" and \\"12:00am\\" (matching synopsis treatment)\\r\\n- **Intelligent adaptive labeling** maintains context-aware display based on time gaps between major scene labels",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.0.2",
      "publishedAt": "2025-11-08T00:24:59Z"
    },
    {
      "version": "4.0.1",
      "title": "4.0.1",
      "body": "## What's Changed\\r\\n\\r\\n- Bug in Chronologue mode, whereby hovering in all scenes, the ring will fail to activate the same scene in subplots.\\r\\n- Readme Updates",
      "url": "https://github.com/EricRhysTaylor/Radial-Timeline/releases/tag/4.0.1",
      "publishedAt": "2025-11-06T22:57:22Z"
    }
  ]
}`);
    return this.normalizeBundleFromValue(parsed);
  }
  requireBundle() {
    if (!this.releaseNotesBundle) {
      throw new Error("Release notes bundle is unavailable");
    }
    return this.releaseNotesBundle;
  }
  async performReleaseNotesFetch(force) {
    const now = Date.now();
    if (!force && this.settings.releaseNotesLastFetched) {
      const last = Date.parse(this.settings.releaseNotesLastFetched);
      if (!Number.isNaN(last) && now - last < 24 * 60 * 60 * 1e3) {
        return false;
      }
    }
    try {
      const bundle = await this.downloadReleaseNotesBundle();
      if (!bundle) {
        return false;
      }
      const embedded = this.loadEmbeddedReleaseNotes();
      const merged = bundle != null ? bundle : embedded;
      if (!merged) {
        throw new Error("Downloaded release bundle is empty");
      }
      this.settings.cachedReleaseNotes = merged;
      this.settings.releaseNotesLastFetched = new Date(now).toISOString();
      await this.saveSettings();
      this.releaseNotesBundle = merged;
      return true;
    } catch (error) {
      console.error("Failed to refresh release notes from GitHub:", error);
      return false;
    }
  }
  async downloadReleaseNotesBundle() {
    var _a;
    const url = "https://raw.githubusercontent.com/ericrhystaylor/radial-timeline/master/src/data/releaseNotesBundle.json";
    try {
      const response = await (0, import_obsidian37.requestUrl)({ url, method: "GET" });
      if (response.status !== 200) {
        console.warn(`[ReleaseNotes] Unexpected response (${response.status}) fetching release bundle`);
        return null;
      }
      const payload = (_a = response.json) != null ? _a : response.text ? JSON.parse(response.text) : null;
      return this.normalizeBundleFromValue(payload);
    } catch (error) {
      console.warn("Unable to fetch release notes bundle:", error);
      return null;
    }
  }
  normalizeBundleFromValue(value) {
    if (!value || typeof value !== "object") {
      throw new Error("Release bundle payload is missing or malformed");
    }
    const normalizeEntry = (entryValue) => {
      if (!entryValue || typeof entryValue !== "object") {
        throw new Error("Release entry is invalid");
      }
      const obj = entryValue;
      const version = obj.version;
      const title = obj.title;
      const body = obj.body;
      if (typeof version !== "string" || typeof title !== "string" || typeof body !== "string") {
        throw new Error("Release entry missing required fields");
      }
      return {
        version,
        title,
        body,
        url: typeof obj.url === "string" ? obj.url : void 0,
        publishedAt: typeof obj.publishedAt === "string" ? obj.publishedAt : void 0
      };
    };
    const bundleObj = value;
    const major = bundleObj.major ? normalizeEntry(bundleObj.major) : null;
    const latest = bundleObj.latest ? normalizeEntry(bundleObj.latest) : null;
    const patches = Array.isArray(bundleObj.patches) ? bundleObj.patches.map(normalizeEntry) : void 0;
    const entries = Array.isArray(bundleObj.entries) ? bundleObj.entries.map(normalizeEntry) : void 0;
    const majorVersion = typeof bundleObj.majorVersion === "string" ? bundleObj.majorVersion : void 0;
    return {
      entries,
      majorVersion,
      major,
      latest,
      patches
    };
  }
  computeEntryKey(entry) {
    var _a;
    const signature = `${entry.version}|${entry.title}|${entry.body}|${(_a = entry.publishedAt) != null ? _a : ""}`;
    let hash = 0;
    for (let i = 0; i < signature.length; i++) {
      hash = hash * 31 + signature.charCodeAt(i) | 0;
    }
    const hashHex = (hash >>> 0).toString(16);
    return `${entry.version}|${hashHex}`;
  }
  extractLatestVersion(bundle) {
    var _a, _b, _c, _d, _e, _f;
    if (!bundle) return null;
    if (Array.isArray(bundle.entries) && bundle.entries.length > 0) {
      return (_b = (_a = bundle.entries[0]) == null ? void 0 : _a.version) != null ? _b : null;
    }
    return (_f = (_e = (_c = bundle.latest) == null ? void 0 : _c.version) != null ? _e : (_d = bundle.major) == null ? void 0 : _d.version) != null ? _f : null;
  }
  extractEntries(bundle) {
    if (Array.isArray(bundle.entries) && bundle.entries.length > 0) {
      return bundle.entries.map((entry) => ({ ...entry }));
    }
    const entries = [];
    const seen = /* @__PURE__ */ new Set();
    const addEntry = (entry) => {
      if (!entry) return;
      if (seen.has(entry.version)) return;
      seen.add(entry.version);
      entries.push(entry);
    };
    addEntry(bundle.latest);
    const bundlePatches = Array.isArray(bundle.patches) ? [...bundle.patches] : [];
    bundlePatches.sort((a, b) => compareReleaseVersionsDesc(a.version, b.version));
    bundlePatches.forEach(addEntry);
    addEntry(bundle.major);
    if (entries.length === 0 && bundle.major) {
      entries.push(bundle.major);
    }
    if (entries.length === 0 && bundle.latest) {
      entries.push(bundle.latest);
    }
    return entries;
  }
  resolveMajorEntry(bundle, entries) {
    var _a, _b, _c;
    if (entries.length === 0) return null;
    const desiredVersions = [];
    if (bundle.majorVersion) desiredVersions.push(bundle.majorVersion);
    if ((_a = bundle.major) == null ? void 0 : _a.version) desiredVersions.push(bundle.major.version);
    for (const version of desiredVersions) {
      const match = entries.find((entry) => entry.version === version);
      if (match) return match;
    }
    const majorCandidate = entries.find((entry) => {
      const info = parseReleaseVersion(entry.version);
      return !!info && info.minor === 0 && info.patch === 0;
    });
    if (majorCandidate) return majorCandidate;
    return (_c = (_b = entries[entries.length - 1]) != null ? _b : entries[0]) != null ? _c : null;
  }
};

// src/services/CommandRegistrar.ts
var import_obsidian38 = require("obsidian");
init_manuscript();
init_GossamerCommands();
init_SceneAnalysisCommands();
var CommandRegistrar = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
  }
  registerAll() {
    this.registerRibbon();
    this.registerCommands();
  }
  registerRibbon() {
    this.plugin.addRibbonIcon("shell", "Radial timeline", () => {
      this.plugin.activateView();
    });
  }
  registerCommands() {
    this.plugin.addCommand({
      id: "search-timeline",
      name: "Search timeline",
      callback: () => this.plugin.openSearchPrompt()
    });
    this.plugin.addCommand({
      id: "clear-timeline-search",
      name: "Clear search",
      callback: () => this.plugin.clearSearch()
    });
    this.plugin.addCommand({
      id: "gossamer-enter-scores",
      name: "Gossamer enter momentum scores",
      callback: async () => {
        try {
          await openGossamerScoreEntry(this.plugin);
        } catch (e) {
          new import_obsidian38.Notice("Failed to open Gossamer score entry.");
          console.error(e);
        }
      }
    });
    this.plugin.addCommand({
      id: "gossamer-generate-manuscript",
      name: "Generate manuscript",
      callback: async () => this.generateManuscript()
    });
    this.plugin.addCommand({
      id: "create-template-scene",
      name: "Create template note",
      callback: async () => createTemplateScene(this.plugin, this.app.vault)
    });
    this.plugin.addCommand({
      id: "open-timeline-view",
      name: "Open",
      callback: () => this.plugin.activateView()
    });
  }
  async generateManuscript() {
    try {
      new import_obsidian38.Notice("Assembling manuscript...");
      const { getSortedSceneFiles: getSortedSceneFiles2 } = await Promise.resolve().then(() => (init_manuscript(), manuscript_exports));
      const { files: sceneFiles, sortOrder } = await getSortedSceneFiles2(this.plugin);
      if (sceneFiles.length === 0) {
        new import_obsidian38.Notice("No scenes found in source path.");
        return;
      }
      const manuscript = await assembleManuscript(sceneFiles, this.app.vault, void 0, true, sortOrder);
      if (!manuscript.text || manuscript.text.trim().length === 0) {
        new import_obsidian38.Notice("Manuscript is empty. Check that your scene files have content.");
        return;
      }
      const now = /* @__PURE__ */ new Date();
      const dateStr = now.toLocaleDateString(void 0, { year: "numeric", month: "short", day: "numeric" });
      const timeStr = now.toLocaleTimeString(void 0, { hour: "numeric", minute: "2-digit", hour12: true }).replace(/:/g, ".");
      const manuscriptPath = `AI/Manuscript ${dateStr} ${timeStr} PTD.md`;
      try {
        await this.app.vault.createFolder("AI");
      } catch (e) {
      }
      const existing = this.app.vault.getAbstractFileByPath(manuscriptPath);
      if (existing) {
        new import_obsidian38.Notice(`File ${manuscriptPath} already exists. Try again in a moment.`);
        return;
      }
      const createdFile = await this.app.vault.create(manuscriptPath, manuscript.text);
      const leaf = this.app.workspace.getLeaf("tab");
      await leaf.openFile(createdFile);
      new import_obsidian38.Notice(`Manuscript generated: ${manuscript.totalScenes} scenes, ${manuscript.totalWords.toLocaleString()} words. Saved to ${manuscriptPath}`);
    } catch (e) {
      const errorMsg = (e == null ? void 0 : e.message) || "Unknown error";
      new import_obsidian38.Notice(`Failed to generate manuscript: ${errorMsg}`);
      console.error(e);
    }
  }
};

// src/services/HoverHighlighter.ts
var HoverHighlighter = class {
  constructor(app, plugin, highlighter) {
    this.app = app;
    this.plugin = plugin;
    this.highlighter = highlighter;
    this.currentHoverPath = null;
    this.currentTabHoverPath = null;
    this.lastHighlightedFile = null;
  }
  register() {
    this.plugin.registerDomEvent(document, "mouseover", (evt) => {
      const target = evt.target;
      const fileItem = target.closest(".nav-file-title");
      if (!fileItem) return;
      const navFile = fileItem.closest(".nav-file");
      if (!navFile) return;
      const filePath = navFile.getAttribute("data-path");
      if (!filePath) return;
      if (this.currentHoverPath === filePath) return;
      this.currentHoverPath = filePath;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, true);
      }
    });
    this.plugin.registerDomEvent(document, "mouseout", (evt) => {
      const target = evt.target;
      const fileItem = target.closest(".nav-file-title");
      if (!fileItem) return;
      const navFile = fileItem.closest(".nav-file");
      if (!navFile) return;
      const filePath = navFile.getAttribute("data-path");
      if (!filePath || this.currentHoverPath !== filePath) return;
      this.currentHoverPath = null;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, false);
      }
    });
    this.plugin.registerDomEvent(document, "mouseover", (evt) => {
      var _a;
      const tabHeader = evt.target.closest(".workspace-tab-header");
      if (!tabHeader) return;
      const tabId = tabHeader.getAttribute("data-tab-id");
      if (!tabId) return;
      const leaf = this.app.workspace.getLeafById(tabId);
      if (!leaf) return;
      const state = leaf.getViewState();
      const filePath = (_a = state == null ? void 0 : state.state) == null ? void 0 : _a.file;
      if (!filePath || (state == null ? void 0 : state.type) !== "markdown") return;
      if (this.currentTabHoverPath === filePath) return;
      this.currentTabHoverPath = filePath;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, true);
      }
    });
    this.plugin.registerDomEvent(document, "mouseout", (evt) => {
      var _a;
      const tabHeader = evt.target.closest(".workspace-tab-header");
      if (!tabHeader) return;
      const tabId = tabHeader.getAttribute("data-tab-id");
      if (!tabId) return;
      const leaf = this.app.workspace.getLeafById(tabId);
      if (!leaf) return;
      const state = leaf.getViewState();
      const filePath = (_a = state == null ? void 0 : state.state) == null ? void 0 : _a.file;
      if (!filePath || (state == null ? void 0 : state.type) !== "markdown" || this.currentTabHoverPath !== filePath) return;
      this.currentTabHoverPath = null;
      if (this.highlighter.isSceneFile(filePath)) {
        this.highlighter.highlight(filePath, false);
      }
    });
    this.plugin.registerEvent(this.app.workspace.on("file-open", (file) => {
      if (file) {
        if (this.lastHighlightedFile && this.lastHighlightedFile !== file.path) {
          this.highlighter.highlight(this.lastHighlightedFile, false);
        }
        this.highlighter.highlight(file.path, true);
        this.lastHighlightedFile = file.path;
        if (this.highlighter.isSceneFile(file.path)) {
          this.plugin.openScenePaths.add(file.path);
          this.plugin.refreshTimelineIfNeeded(null);
        }
      } else {
        if (this.lastHighlightedFile) {
          this.highlighter.highlight(this.lastHighlightedFile, false);
          this.lastHighlightedFile = null;
        }
      }
    }));
  }
};

// src/services/SceneHighlighter.ts
var SceneHighlighter = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  highlight(filePath, isHighlighting) {
    if (!filePath) return;
    const views = this.plugin.getTimelineViews();
    if (views.length === 0) return;
    for (const view of views) {
      try {
        const container = view.contentEl.querySelector(".radial-timeline-container");
        if (!container) continue;
        const svgElement = container.querySelector("svg");
        if (!svgElement) continue;
        if (isHighlighting) {
          const allElements = svgElement.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
          allElements.forEach((element) => {
            element.classList.remove("rt-selected");
            const currentMode = svgElement.getAttribute("data-mode");
            if (currentMode !== "gossamer") {
              element.classList.remove("rt-non-selected");
            }
          });
        }
        let foundScene = false;
        let encodedPath = encodeURIComponent(filePath);
        let sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        if (!sceneGroup && filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(filePath.substring(1));
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        } else if (!sceneGroup && !filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(`/${filePath}`);
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        }
        if (sceneGroup) {
          foundScene = true;
          if (isHighlighting) {
            const currentPath = sceneGroup.querySelector(".rt-scene-path");
            if (currentPath) {
              currentPath.classList.add("rt-selected");
              const sceneId = currentPath.id;
              const numberSquare = svgElement.querySelector(`.rt-number-square[data-scene-id="${sceneId}"]`);
              const numberText = svgElement.querySelector(`.rt-number-text[data-scene-id="${sceneId}"]`);
              if (numberSquare) numberSquare.classList.add("rt-selected");
              if (numberText) numberText.classList.add("rt-selected");
              const sceneTitle = sceneGroup.querySelector(".rt-scene-title");
              if (sceneTitle) sceneTitle.classList.add("rt-selected");
              const allScenePaths = svgElement.querySelectorAll(".rt-scene-path:not(.rt-selected)");
              allScenePaths.forEach((element) => element.classList.add("rt-non-selected"));
              const synopsis = svgElement.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
              if (synopsis) synopsis.classList.add("rt-visible");
            }
          } else {
            const allElements = svgElement.querySelectorAll(".rt-scene-path, .rt-number-square, .rt-number-text, .rt-scene-title");
            allElements.forEach((element) => element.classList.remove("selected", "non-selected"));
            const currentPath = sceneGroup.querySelector(".rt-scene-path");
            if (currentPath) {
              const sceneId = currentPath.id;
              const synopsis = svgElement.querySelector(`.rt-scene-info[data-for-scene="${sceneId}"]`);
              if (synopsis) synopsis.classList.remove("rt-visible");
            }
          }
        }
        if (!foundScene) {
        }
      } catch (e) {
      }
    }
  }
  isSceneFile(filePath) {
    const views = this.plugin.getTimelineViews();
    if (views.length === 0) return false;
    for (const view of views) {
      const scenes = view["sceneData"] || [];
      if (scenes.length > 0) {
        const match = scenes.find((scene) => {
          if (!scene.path) return false;
          if (scene.path === filePath) return true;
          if (scene.path === `/${filePath}`) return true;
          if (`/${scene.path}` === filePath) return true;
          return false;
        });
        if (match) return true;
      } else {
        const container = view.contentEl.querySelector(".radial-timeline-container");
        if (!container) continue;
        const svgElement = container.querySelector("svg");
        if (!svgElement) continue;
        let encodedPath = encodeURIComponent(filePath);
        let sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        if (!sceneGroup && filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(filePath.substring(1));
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        } else if (!sceneGroup && !filePath.startsWith("/")) {
          encodedPath = encodeURIComponent(`/${filePath}`);
          sceneGroup = svgElement.querySelector(`.scene-group[data-path="${encodedPath}"]`);
        }
        if (sceneGroup) return true;
      }
    }
    return false;
  }
};

// src/services/GossamerScoreService.ts
var import_obsidian39 = require("obsidian");
init_frontmatter();
init_sceneHelpers();
init_gossamer();
var GossamerScoreService = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async saveScores(scores) {
    const sourcePath = this.plugin.settings.sourcePath || "";
    const allFiles = this.app.vault.getMarkdownFiles();
    const files = sourcePath ? allFiles.filter((f) => f.path.startsWith(sourcePath)) : allFiles;
    let updateCount = 0;
    for (const [beatTitle, newScore] of scores) {
      let file = null;
      for (const f of files) {
        const cache = this.app.metadataCache.getFileCache(f);
        const rawFm = cache == null ? void 0 : cache.frontmatter;
        const fm = rawFm ? normalizeFrontmatterKeys(rawFm) : void 0;
        if (fm && isStoryBeat(fm.Class)) {
          const filename = f.basename;
          const titleMatch = filename === beatTitle || filename === beatTitle.replace(/^\d+\s+/, "") || filename.toLowerCase() === beatTitle.toLowerCase() || filename.toLowerCase().replace(/[-\s]/g, "") === beatTitle.toLowerCase().replace(/[-\s]/g, "");
          if (titleMatch) {
            file = f;
            break;
          }
        }
      }
      if (!file) continue;
      try {
        await this.app.fileManager.processFrontMatter(file, (yaml) => {
          const fm = yaml;
          const shifted = shiftGossamerHistory(fm);
          Object.assign(fm, shifted);
          fm.Gossamer1 = newScore;
          delete fm.GossamerLocation;
          delete fm.GossamerNote;
          delete fm.GossamerRuns;
          delete fm.GossamerLatestRun;
        });
        updateCount++;
      } catch (e) {
        console.error(`[Gossamer] Failed to update beat ${beatTitle}:`, e);
      }
    }
    if (updateCount > 0) {
      new import_obsidian39.Notice(`Updated ${updateCount} beat score${updateCount > 1 ? "s" : ""}.`);
    } else {
      new import_obsidian39.Notice("No beats were updated.");
    }
  }
};

// src/services/SceneAnalysisService.ts
var import_obsidian40 = require("obsidian");
init_sceneHelpers();
var SceneAnalysisService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  registerCommands() {
    this.registerManuscriptCommand();
    this.registerSubplotCommand();
  }
  registerManuscriptCommand() {
    this.plugin.addCommand({
      id: "update-beats-manuscript-order",
      name: "Scene Analysis (manuscript order)",
      checkCallback: (checking) => {
        if (!this.plugin.settings.enableAiSceneAnalysis) return false;
        if (checking) return true;
        (async () => {
          if (!this.ensureApiKey()) return;
          try {
            await this.processByManuscriptOrder();
          } catch (error) {
            console.error("Error running manuscript order beat update:", error);
            new import_obsidian40.Notice("Error during manuscript order update.");
          }
        })();
        return true;
      }
    });
  }
  registerSubplotCommand() {
    this.plugin.addCommand({
      id: "update-beats-choose-subplot",
      name: "Scene Analysis (subplot order)",
      checkCallback: (checking) => {
        if (!this.plugin.settings.enableAiSceneAnalysis) return false;
        if (checking) return true;
        (async () => {
          if (!this.ensureApiKey()) return;
          const options = await this.getSubplotOptions();
          new SubplotPickerModal(this.plugin.app, this, options).open();
        })();
        return true;
      }
    });
  }
  async getSubplotOptions() {
    const { getDistinctSubplotNames: getDistinctSubplotNames2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    const names = await getDistinctSubplotNames2(this.plugin, this.plugin.app.vault);
    if (!Array.isArray(names) || names.length === 0) {
      throw new Error("No subplots found.");
    }
    const stats = await Promise.all(names.map((name) => this.countProcessableScenes(name)));
    return names.map((name, index) => ({ name, stats: stats[index] }));
  }
  ensureApiKey() {
    var _a, _b, _c;
    const provider = this.plugin.settings.defaultAiProvider || "openai";
    let hasKey2 = true;
    if (provider === "anthropic") hasKey2 = !!((_a = this.plugin.settings.anthropicApiKey) == null ? void 0 : _a.trim());
    else if (provider === "gemini") hasKey2 = !!((_b = this.plugin.settings.geminiApiKey) == null ? void 0 : _b.trim());
    else hasKey2 = !!((_c = this.plugin.settings.openaiApiKey) == null ? void 0 : _c.trim());
    if (!hasKey2) {
      const name = provider[0].toUpperCase() + provider.slice(1);
      new import_obsidian40.Notice(`${name} API key is not set in settings.`);
      return false;
    }
    return true;
  }
  async countProcessableScenes(subplotName) {
    const allScenes = await this.plugin.getSceneData();
    if (subplotName) {
      const filtered = allScenes.filter((scene) => {
        const subplots = scene.subplot ? Array.isArray(scene.subplot) ? scene.subplot : [scene.subplot] : [];
        return subplots.includes(subplotName);
      });
      const validScenes = filtered.filter((scene) => {
        const statusValue = Array.isArray(scene.status) ? scene.status[0] : scene.status;
        return (statusValue === "Working" || statusValue === "Complete") && normalizeBooleanValue(scene["Beats Update"]);
      });
      const processableScenes2 = filtered.filter((scene) => {
        const statusValue = Array.isArray(scene.status) ? scene.status[0] : scene.status;
        return statusValue === "Working" || statusValue === "Complete";
      });
      return {
        flagged: validScenes.length,
        processable: processableScenes2.length,
        total: filtered.length
      };
    }
    const processableScenes = allScenes.filter((scene) => {
      const statusValue = Array.isArray(scene.status) ? scene.status[0] : scene.status;
      return statusValue === "Working" || statusValue === "Complete";
    });
    const flaggedCount = processableScenes.filter((scene) => normalizeBooleanValue(scene["Beats Update"])).length;
    return {
      flagged: flaggedCount,
      processable: processableScenes.length,
      total: allScenes.length
    };
  }
  getActiveModelName() {
    const provider = this.plugin.settings.defaultAiProvider || "openai";
    if (provider === "anthropic") {
      const modelId2 = this.plugin.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
      if (modelId2.includes("sonnet-4-5") || modelId2.includes("sonnet-4.5")) return "Claude Sonnet 4.5";
      if (modelId2.includes("opus-4-1") || modelId2.includes("opus-4.1")) return "Claude Opus 4.1";
      if (modelId2.includes("opus-4")) return "Claude Opus 4";
      if (modelId2.includes("sonnet-4")) return "Claude Sonnet 4";
      return modelId2;
    }
    if (provider === "gemini") {
      const modelId2 = this.plugin.settings.geminiModelId || "gemini-2.5-pro";
      if (modelId2.includes("2.5-pro") || modelId2.includes("2-5-pro")) return "Gemini 2.5 Pro";
      if (modelId2.includes("2.0-pro") || modelId2.includes("2-0-pro")) return "Gemini 2.0 Pro";
      return modelId2;
    }
    const modelId = this.plugin.settings.openaiModelId || "gpt-4o";
    if (modelId.includes("4.1") || modelId.includes("4-1")) return "GPT-4.1";
    if (modelId.includes("4o")) return "GPT-4o";
    if (modelId.includes("o1")) return "GPT-o1";
    return modelId;
  }
  async processByManuscriptOrder() {
    const { processByManuscriptOrder: processByManuscriptOrder2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await processByManuscriptOrder2(this.plugin, this.plugin.app.vault);
  }
  async processBySubplotName(subplotName) {
    const { processBySubplotNameWithModal: processBySubplotNameWithModal2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await processBySubplotNameWithModal2(this.plugin, this.plugin.app.vault, subplotName);
  }
  async processEntireSubplot(subplotName) {
    const { processEntireSubplotWithModal: processEntireSubplotWithModal2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await processEntireSubplotWithModal2(this.plugin, this.plugin.app.vault, subplotName);
  }
  async purgeBeatsForSubplot(subplotName) {
    const { purgeBeatsBySubplotName: purgeBeatsBySubplotName2 } = await Promise.resolve().then(() => (init_SceneAnalysisCommands(), SceneAnalysisCommands_exports));
    await purgeBeatsBySubplotName2(this.plugin, this.plugin.app.vault, subplotName);
  }
};
var SubplotPickerModal = class extends import_obsidian40.Modal {
  constructor(app, service, options) {
    super(app);
    this.service = service;
    this.options = options;
    this.statsEl = null;
    this.dropdown = null;
    if (!options.length) {
      throw new Error("No subplot options available.");
    }
    this.selectedSubplot = options[0].name;
    this.statsBySubplot = new Map(options.map((opt) => [opt.name, opt.stats]));
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    titleEl.setText("Select subplot for beats processing");
    const modelName = this.service.getActiveModelName();
    const infoEl = contentEl.createDiv({ cls: "rt-subplot-picker-info" });
    infoEl.createEl("p", { text: `Process beats using ${modelName}` });
    const selectContainer = contentEl.createDiv({ cls: "rt-subplot-picker-select" });
    selectContainer.createEl("label", { text: "Select subplot:", cls: "rt-subplot-picker-label" });
    this.dropdown = new import_obsidian40.DropdownComponent(selectContainer);
    this.options.forEach((option, index) => {
      var _a;
      (_a = this.dropdown) == null ? void 0 : _a.addOption(option.name, `${index + 1}. ${option.name}`);
    });
    this.dropdown.setValue(this.selectedSubplot);
    this.dropdown.onChange((value) => {
      this.selectedSubplot = value;
      this.updateStats(value);
    });
    this.statsEl = contentEl.createDiv({ cls: "rt-subplot-picker-stats" });
    this.updateStats(this.selectedSubplot);
    const buttonRow = contentEl.createDiv({ cls: "rt-beats-actions" });
    new import_obsidian40.ButtonComponent(buttonRow).setButtonText("Process beats").setCta().onClick(async () => {
      this.close();
      await this.service.processBySubplotName(this.selectedSubplot);
    });
    new import_obsidian40.ButtonComponent(buttonRow).setButtonText("Process entire subplot").setCta().onClick(async () => {
      this.close();
      await this.service.processEntireSubplot(this.selectedSubplot);
    });
    new import_obsidian40.ButtonComponent(buttonRow).setButtonText("Purge all beats").setWarning().onClick(async () => {
      try {
        this.close();
        await this.service.purgeBeatsForSubplot(this.selectedSubplot);
      } catch (error) {
        new import_obsidian40.Notice(`Error: ${error instanceof Error ? error.message : String(error)}`);
      }
    });
    new import_obsidian40.ButtonComponent(buttonRow).setButtonText("Cancel").onClick(() => this.close());
  }
  updateStats(subplotName) {
    if (!this.statsEl) return;
    const stats = this.statsBySubplot.get(subplotName);
    if (!stats) {
      throw new Error(`Unknown subplot selection: ${subplotName}`);
    }
    this.statsEl.setText(`${stats.flagged} scene${stats.flagged !== 1 ? "s" : ""} will be processed (${stats.processable} processable, ${stats.total} total)`);
  }
};

// src/services/StatusBarService.ts
var StatusBarService = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.beatsStatusBarItem = null;
  }
  showBeatsStatus(current, total) {
    if (!this.beatsStatusBarItem) {
      this.beatsStatusBarItem = this.plugin.addStatusBarItem();
      this.beatsStatusBarItem.addClass("rt-beats-status-bar");
      this.plugin.registerDomEvent(this.beatsStatusBarItem, "click", () => {
        if (this.plugin.activeBeatsModal) {
          this.plugin.activeBeatsModal.open();
        }
      });
      this.beatsStatusBarItem.style.cursor = "pointer";
      this.beatsStatusBarItem.title = "Click to view progress";
    }
    const percentage = total > 0 ? Math.round(current / total * 100) : 0;
    this.beatsStatusBarItem.setText(`Scene beats: ${current}/${total} (${percentage}%)`);
  }
  hideBeatsStatus() {
    if (this.beatsStatusBarItem) {
      this.beatsStatusBarItem.remove();
      this.beatsStatusBarItem = null;
    }
  }
};

// src/services/BeatsProcessingService.ts
var BeatsProcessingService = class {
  constructor(statusBarService) {
    this.statusBarService = statusBarService;
  }
  showStatus(current, total) {
    this.statusBarService.showBeatsStatus(current, total);
  }
  hideStatus() {
    this.statusBarService.hideBeatsStatus();
  }
};

// src/services/ThemeService.ts
var ThemeService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  applyCssVariables() {
    const root = document.documentElement;
    const { publishStageColors, subplotColors } = this.plugin.settings;
    Object.entries(publishStageColors).forEach(([stage, color]) => {
      root.style.setProperty(`--rt-publishStageColors-${stage}`, color);
      const rgbValues = this.hexToRGB(color);
      if (rgbValues) {
        root.style.setProperty(`--rt-publishStageColors-${stage}-rgb`, rgbValues);
      }
    });
    if (Array.isArray(subplotColors)) {
      for (let i = 0; i < 16; i++) {
        const color = subplotColors[i] || DEFAULT_SETTINGS.subplotColors[i];
        if (color) {
          root.style.setProperty(`--rt-subplot-colors-${i}`, color);
        }
      }
    }
  }
  hexToRGB(hex) {
    const r = parseInt(hex.slice(1, 3), 16);
    const g = parseInt(hex.slice(3, 5), 16);
    const b = parseInt(hex.slice(5, 7), 16);
    if (isNaN(r) || isNaN(g) || isNaN(b)) {
      return null;
    }
    return `${r}, ${g}, ${b}`;
  }
};

// src/services/TimelineMetricsService.ts
init_sceneHelpers();
var TimelineMetricsService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  calculateCompletionEstimate(scenes) {
    const sceneNotesOnly = scenes.filter((scene) => !isBeatNote(scene));
    if (sceneNotesOnly.length === 0) return null;
    const today = /* @__PURE__ */ new Date();
    today.setHours(0, 0, 0, 0);
    const allScenesComplete = sceneNotesOnly.every((scene) => {
      var _a, _b;
      const publishStage = ((_a = scene["Publish Stage"]) == null ? void 0 : _a.toString().trim().toLowerCase()) || "";
      const sceneStatus = ((_b = scene.status) == null ? void 0 : _b.toString().trim().toLowerCase()) || "";
      return publishStage === "press" && (sceneStatus === "complete" || sceneStatus === "done");
    });
    if (allScenesComplete) {
      const targetDate = this.plugin.settings.targetCompletionDate ? /* @__PURE__ */ new Date(this.plugin.settings.targetCompletionDate + "T00:00:00") : null;
      this.captureLatestStats(sceneNotesOnly.length, 0, 0);
      return { date: targetDate, total: sceneNotesOnly.length, remaining: 0, rate: 0 };
    }
    const startOfYear = new Date(today.getFullYear(), 0, 1);
    const startOfYearTime = startOfYear.getTime();
    const todayTime = today.getTime();
    const daysPassedThisYear = Math.max(1, Math.round((todayTime - startOfYearTime) / (1e3 * 60 * 60 * 24)));
    let completedThisYear = 0;
    const completedPathsThisYear = /* @__PURE__ */ new Set();
    sceneNotesOnly.forEach((scene) => {
      var _a;
      const dueDateStr = scene.due;
      const scenePath = scene.path;
      const sceneStatus = (_a = scene.status) == null ? void 0 : _a.toString().trim().toLowerCase();
      if (sceneStatus !== "complete" && sceneStatus !== "done") return;
      if (!scenePath || completedPathsThisYear.has(scenePath)) return;
      if (!dueDateStr) return;
      try {
        const dueDate = /* @__PURE__ */ new Date(dueDateStr + "T00:00:00");
        dueDate.setHours(0, 0, 0, 0);
        const dueTime = dueDate.getTime();
        if (!isNaN(dueTime) && dueTime >= startOfYearTime && dueTime < todayTime) {
          completedThisYear++;
          completedPathsThisYear.add(scenePath);
        }
      } catch (e) {
      }
    });
    if (completedThisYear <= 0) {
      this.captureLatestStats(sceneNotesOnly.length, sceneNotesOnly.length, 0);
      return null;
    }
    const scenesPerDay = completedThisYear / daysPassedThisYear;
    const processedPaths = /* @__PURE__ */ new Set();
    const currentStatusCounts = sceneNotesOnly.reduce((acc, scene) => {
      var _a;
      if (!scene.path || processedPaths.has(scene.path)) {
        return acc;
      }
      processedPaths.add(scene.path);
      const normalizedStatus = ((_a = scene.status) == null ? void 0 : _a.toString().trim().toLowerCase()) || "Todo";
      if (normalizedStatus === "complete" || normalizedStatus === "done") {
        acc["Completed"] = (acc["Completed"] || 0) + 1;
      } else if (scene.due) {
        try {
          const dueDate = /* @__PURE__ */ new Date(scene.due + "T00:00:00");
          if (!isNaN(dueDate.getTime()) && dueDate.getTime() < todayTime) {
            acc["Due"] = (acc["Due"] || 0) + 1;
          } else {
            acc[normalizedStatus] = (acc[normalizedStatus] || 0) + 1;
          }
        } catch (e) {
          acc[normalizedStatus] = (acc[normalizedStatus] || 0) + 1;
        }
      } else {
        acc[normalizedStatus] = (acc[normalizedStatus] || 0) + 1;
      }
      return acc;
    }, {});
    this.plugin.latestStatusCounts = currentStatusCounts;
    const completedCount = currentStatusCounts["Completed"] || 0;
    const totalScenes = Object.values(currentStatusCounts).reduce((sum, count) => sum + count, 0);
    const remainingScenes = totalScenes - completedCount;
    if (remainingScenes <= 0) {
      this.captureLatestStats(totalScenes, 0, scenesPerDay * 7);
      return null;
    }
    const daysNeeded = remainingScenes / scenesPerDay;
    if (!isFinite(daysNeeded) || daysNeeded < 0 || scenesPerDay <= 0) {
      this.captureLatestStats(totalScenes, remainingScenes, scenesPerDay * 7);
      return null;
    }
    const scenesPerWeek = scenesPerDay * 7;
    const estimatedDate = new Date(today);
    estimatedDate.setDate(today.getDate() + Math.ceil(daysNeeded));
    this.captureLatestStats(totalScenes, remainingScenes, scenesPerWeek);
    return {
      date: estimatedDate,
      total: totalScenes,
      remaining: remainingScenes,
      rate: parseFloat(scenesPerWeek.toFixed(1))
    };
  }
  captureLatestStats(total, remaining, rate) {
    this.plugin.latestTotalScenes = total;
    this.plugin.latestRemainingScenes = remaining;
    this.plugin.latestScenesPerWeek = rate;
  }
};

// src/migrations/sceneAnalysis.ts
async function migrateSceneAnalysisFields(plugin) {
  try {
    const files = plugin.app.vault.getMarkdownFiles();
    let migratedCount = 0;
    for (const file of files) {
      const cache = plugin.app.metadataCache.getFileCache(file);
      const fm = cache == null ? void 0 : cache.frontmatter;
      if (fm && (fm["1beats"] || fm["2beats"] || fm["3beats"])) {
        const needsMigration = (fm["1beats"] || fm["2beats"] || fm["3beats"]) && !(fm["previousSceneAnalysis"] || fm["currentSceneAnalysis"] || fm["nextSceneAnalysis"]);
        if (needsMigration) {
          await plugin.app.fileManager.processFrontMatter(file, (frontmatter) => {
            const fmObj = frontmatter;
            if (fmObj["1beats"]) {
              fmObj["previousSceneAnalysis"] = fmObj["1beats"];
              delete fmObj["1beats"];
            }
            if (fmObj["2beats"]) {
              fmObj["currentSceneAnalysis"] = fmObj["2beats"];
              delete fmObj["2beats"];
            }
            if (fmObj["3beats"]) {
              fmObj["nextSceneAnalysis"] = fmObj["3beats"];
              delete fmObj["3beats"];
            }
          });
          migratedCount++;
        }
      }
    }
    void migratedCount;
  } catch (error) {
    console.error("[Radial Timeline] Error during migration:", error);
  }
}

// src/services/SettingsService.ts
var import_obsidian41 = require("obsidian");
var SettingsService = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async validateAndRememberPath(path) {
    if (!path || path.trim() === "") return false;
    const normalizedPath = (0, import_obsidian41.normalizePath)(path.trim());
    const file = this.plugin.app.vault.getAbstractFileByPath(normalizedPath);
    const isValid = file instanceof import_obsidian41.TFolder && file.path === normalizedPath;
    if (isValid) {
      const { validFolderPaths } = this.plugin.settings;
      if (!validFolderPaths.includes(normalizedPath)) {
        validFolderPaths.unshift(normalizedPath);
        if (validFolderPaths.length > 10) {
          this.plugin.settings.validFolderPaths = validFolderPaths.slice(0, 10);
        }
        await this.plugin.saveSettings();
      }
      return true;
    }
    return false;
  }
  normalizeModelIds() {
    const normalize = (prov, id) => {
      var _a;
      if (!id) return id;
      if (prov === "anthropic") {
        if (id === "claude-4.1-opus" || id === "claude-opus-4-1" || id === "claude-3-opus-20240229" || id === "claude-opus-4-0" || id === "claude-opus-4-1@20250805") return "claude-opus-4-1-20250805";
        if (id === "claude-4-sonnet" || id === "claude-sonnet-4-1" || id === "claude-3-7-sonnet-20250219" || id === "claude-sonnet-4-0" || id === "claude-sonnet-4-1@20250805" || id === "claude-sonnet-4-20250514") return "claude-sonnet-4-5-20250929";
        return id;
      }
      if (prov === "openai") {
        if (id === "gpt-5" || id === "o3" || id === "gpt-4o") return "gpt-4.1";
        return id;
      }
      if (prov === "gemini") {
        const trimmed = id.trim();
        const aliasMap = {
          "gemini-ultra": "gemini-2.5-pro",
          "gemini-creative": "gemini-2.5-pro",
          "gemini-1.0-pro": "gemini-2.5-pro",
          "gemini-1.5-pro": "gemini-2.5-pro"
        };
        return (_a = aliasMap[trimmed]) != null ? _a : trimmed;
      }
      return id;
    };
    const settings = this.plugin.settings;
    settings.anthropicModelId = normalize("anthropic", settings.anthropicModelId);
    settings.openaiModelId = normalize("openai", settings.openaiModelId);
    settings.geminiModelId = normalize("gemini", settings.geminiModelId);
  }
  async migrateAiContextTemplates() {
    const settings = this.plugin.settings;
    let migrated = false;
    const oldBuiltInIds = /* @__PURE__ */ new Set(["generic-editor", "ya-biopunk-scifi", "adult-thriller", "adult-romance"]);
    const cloneBuiltInTemplates = () => {
      var _a;
      return ((_a = DEFAULT_SETTINGS.aiContextTemplates) != null ? _a : []).map((template) => ({ ...template }));
    };
    if (!settings.aiContextTemplates || settings.aiContextTemplates.length === 0) {
      settings.aiContextTemplates = cloneBuiltInTemplates();
      migrated = true;
    } else {
      const builtInTemplates = cloneBuiltInTemplates();
      settings.aiContextTemplates = settings.aiContextTemplates.filter((template) => !template.isBuiltIn || !oldBuiltInIds.has(template.id));
      const existingIds = new Set(settings.aiContextTemplates.map((t) => t.id));
      for (const builtIn of builtInTemplates) {
        if (!existingIds.has(builtIn.id)) {
          settings.aiContextTemplates.push({ ...builtIn });
          migrated = true;
        }
      }
    }
    if (!settings.activeAiContextTemplateId || oldBuiltInIds.has(settings.activeAiContextTemplateId)) {
      settings.activeAiContextTemplateId = DEFAULT_SETTINGS.activeAiContextTemplateId;
      migrated = true;
    }
    return migrated;
  }
};

// src/main.ts
var TIMELINE_VIEW_TYPE2 = "radial-timeline";
var DEFAULT_SETTINGS = {
  sourcePath: "",
  validFolderPaths: [],
  // <<< ADDED: Default empty array for folder path history
  publishStageColors: {
    Zero: "#9E70CF",
    // Purple (Stage Zero)
    Author: "#5E85CF",
    // Blue   (Author)
    House: "#DA7847",
    // Orange (House)
    Press: "#6FB971"
    // Green  (Press)
  },
  subplotColors: [
    "#EFBDEB",
    // 0
    "#a35ca7",
    // 1
    "#6461A0",
    // 2
    "#314CB6",
    // 3
    "#0A81D1",
    // 4
    "#98CE00",
    // 5
    "#16E0BD",
    // 6
    "#78C3FB",
    // 7
    "#273C2C",
    // 8
    "#A6D8D4",
    // 9
    "#FF8600",
    // 10
    "#F9E784",
    // 11
    "#CEC3C1",
    // 12
    "#F3D34A",
    // 13
    "#004777",
    // 14
    "#8B4513"
    // 15 - Brown for Ring 16
  ],
  currentMode: "narrative",
  // Default to Narrative mode
  logApiInteractions: true,
  // <<< ADDED: Default for new setting
  targetCompletionDate: void 0,
  // Ensure it's undefined by default
  openaiApiKey: "",
  // Default to empty string
  anthropicApiKey: "",
  // <<< ADDED: Default empty string
  anthropicModelId: "claude-sonnet-4-5-20250929",
  // Default to Sonnet 4.5 (20250929)
  geminiApiKey: "",
  geminiModelId: "gemini-2.5-pro",
  // Default to Gemini 2.5 Pro
  defaultAiProvider: "openai",
  openaiModelId: "gpt-4.1",
  // Default to GPT-4.1
  enableAiSceneAnalysis: true,
  enableZeroDraftMode: false,
  metadataRefreshDebounceMs: 1e4,
  showEstimate: true,
  discontinuityThreshold: void 0,
  // Default to auto-calculated (3x median gap or 30 days)
  enableSceneTitleAutoExpand: true,
  // Default: enabled to maintain current behavior
  enableHoverDebugLogging: false,
  sortByWhenDate: false,
  // Default: manuscript order (backward compatible)
  chronologueDurationCapSelection: "auto",
  aiContextTemplates: [
    {
      id: "commercial_genre",
      name: "Commercial Genre Fiction (Balanced Depth)",
      prompt: `Act as a developmental editor for a commercial genre novel. Prioritize pacing, clarity, and emotional stakes. Ensure each scene moves the plot or deepens character conflict. Keep prose lean; prefer tension and subtext to exposition. Focus feedback on momentum, scene purpose, and reader engagement.`,
      isBuiltIn: true
    },
    {
      id: "literary",
      name: "Literary / Character-Driven Fiction",
      prompt: `Act as a developmental editor for a literary or character-driven novel. Emphasize emotional resonance, internal conflict, and subtext. Feedback should focus on authenticity of character motivation, narrative voice, and thematic depth. Avoid line-level polish; focus on the psychological realism of each beat.`,
      isBuiltIn: true
    },
    {
      id: "young_adult",
      name: "Young Adult / Coming-of-Age",
      prompt: `Act as a developmental editor for a young adult coming-of-age novel. Focus on pacing, clear emotional arcs, and voice consistency. Ensure stakes feel personal and immediate. Highlight areas where dialogue or internal monologue can better show growth or vulnerability. Keep feedback concise and energetic.`,
      isBuiltIn: true
    },
    {
      id: "science_fiction",
      name: "Epic or Hard Science Fiction / World-Building Focus",
      prompt: `Act as a developmental editor for a science-fiction novel with complex world-building. Balance clarity and immersion; ensure exposition is dramatized through character action or dialogue. Focus feedback on world logic, pacing through discovery, and integrating big ideas without slowing emotional momentum. Prioritize cohesion between technology, society, and theme.`,
      isBuiltIn: true
    },
    {
      id: "thriller",
      name: "Mystery / Thriller / Suspense",
      prompt: `Act as a developmental editor for a mystery or thriller novel. Emphasize pacing, tension, and clarity of motive. Identify where reveals or reversals land too early or too late. Ensure reader curiosity and suspense are sustained through every scene. Keep feedback focused on plot mechanics and emotional rhythm.`,
      isBuiltIn: true
    },
    {
      id: "romance",
      name: "Romance / Emotional-Arc Focused Fiction",
      prompt: `Act as a developmental editor for a romance or emotionally driven narrative. Focus feedback on relationship dynamics, emotional authenticity, and pacing of attraction/conflict/resolution. Ensure internal and external conflicts are intertwined. Highlight where subtext or tension could replace exposition.`,
      isBuiltIn: true
    }
  ],
  activeAiContextTemplateId: "commercial_genre",
  beatSystem: "Save The Cat",
  // Default beat system
  dominantSubplots: {},
  // Default: empty map, will use outermost subplot for scenes in multiple subplots
  globalPovMode: "off",
  lastSeenReleaseNotesVersion: "",
  cachedReleaseNotes: null,
  releaseNotesLastFetched: void 0
};
var RadialTimelinePlugin = class extends import_obsidian44.Plugin {
  constructor() {
    super(...arguments);
    // Do not store persistent references to views (per Obsidian guidelines)
    // Track open scene paths
    this.openScenePaths = /* @__PURE__ */ new Set();
    // Ensure settings tab is only added once per load
    this._settingsTabAdded = false;
    // Search related properties
    this.searchTerm = "";
    this.searchActive = false;
    this.searchResults = /* @__PURE__ */ new Set();
    this.eventBus = new EventTarget();
    this.metadataCacheListener = null;
    // Completion estimate stats
    this.latestTotalScenes = 0;
    this.latestRemainingScenes = 0;
    this.latestScenesPerWeek = 0;
    // Track active scene analysis processing modal and status bar item
    this.activeBeatsModal = null;
  }
  // Helper: get all currently open timeline views
  getTimelineViews() {
    return this.timelineService.getTimelineViews();
  }
  // Helper: get the first open timeline view (if any)
  getFirstTimelineView() {
    const list = this.getTimelineViews();
    return list.length > 0 ? list[0] : null;
  }
  // Settings access helpers
  get aiProvider() {
    return this.settings.defaultAiProvider || "openai";
  }
  getApiKey() {
    const provider = this.aiProvider;
    if (provider === "anthropic") return this.settings.anthropicApiKey;
    if (provider === "gemini") return this.settings.geminiApiKey;
    return this.settings.openaiApiKey;
  }
  getModelId() {
    const provider = this.aiProvider;
    if (provider === "anthropic") return this.settings.anthropicModelId || "claude-sonnet-4-5-20250929";
    if (provider === "gemini") return this.settings.geminiModelId || "gemini-2.5-pro";
    return this.settings.openaiModelId || "gpt-4.1";
  }
  /**
   * Position and curve the text elements in the SVG
   * @param container The container element with the SVG
   */
  curveTextElements(container, curveFactor, angleToCenter) {
    const textElements = container.querySelectorAll("text");
    if (!textElements.length) return;
    textElements.forEach((textEl) => {
      var _a;
      try {
        const pathId = `path-${Math.random().toString(36).substring(2, 9)}`;
        const pathElement = document.createElementNS("http://www.w3.org/2000/svg", "path");
        pathElement.setAttribute("id", pathId);
        pathElement.setAttribute("d", `M 0,0 Q ${Math.cos(angleToCenter) * 500},${Math.sin(angleToCenter) * 500 * curveFactor} 1000,0`);
        pathElement.classList.add("svg-path");
        (_a = textEl.parentNode) == null ? void 0 : _a.insertBefore(pathElement, textEl);
        textEl.setAttribute("path", `url(#${pathId})`);
        textEl.setAttribute("pathLength", "1");
        textEl.setAttribute("startOffset", "0");
      } catch (error) {
        console.error("Error applying text curvature:", error);
      }
    });
  }
  processHighlightedContent(fragment) {
    const container = document.createElement("div");
    container.appendChild(fragment.cloneNode(true));
    const resultNodes = [];
    Array.from(container.childNodes).forEach((node) => {
      if (node.nodeType === Node.TEXT_NODE) {
        if (node.textContent) {
          resultNodes.push(document.createTextNode(node.textContent));
        }
      } else if (node.nodeType === Node.ELEMENT_NODE) {
        const element = node;
        if (element.tagName.toLowerCase() === "tspan") {
          const svgTspan = document.createElementNS("http://www.w3.org/2000/svg", "tspan");
          Array.from(element.attributes).forEach((attr) => {
            svgTspan.setAttribute(attr.name, attr.value);
          });
          svgTspan.textContent = element.textContent;
          resultNodes.push(svgTspan);
        }
      }
    });
    return resultNodes;
  }
  getReleaseNotesBundle() {
    var _a, _b;
    return (_b = (_a = this.releaseNotesService) == null ? void 0 : _a.getBundle()) != null ? _b : null;
  }
  getReleaseNotesEntries() {
    var _a, _b;
    return (_b = (_a = this.releaseNotesService) == null ? void 0 : _a.getEntries()) != null ? _b : [];
  }
  getReleaseNotesMajorVersion() {
    var _a, _b;
    return (_b = (_a = this.releaseNotesService) == null ? void 0 : _a.getMajorVersion()) != null ? _b : null;
  }
  async markReleaseNotesSeen(version) {
    var _a;
    await ((_a = this.releaseNotesService) == null ? void 0 : _a.markReleaseNotesSeen(version));
  }
  async maybeShowReleaseNotesModal() {
    var _a;
    await ((_a = this.releaseNotesService) == null ? void 0 : _a.maybeShowReleaseNotesModal(this.app, this));
  }
  openReleaseNotesModal() {
    var _a;
    (_a = this.releaseNotesService) == null ? void 0 : _a.openReleaseNotesModal(this.app, this);
  }
  async onload() {
    this.settingsService = new SettingsService(this);
    await this.loadSettings();
    this.releaseNotesService = new ReleaseNotesService(this.settings, () => this.saveSettings());
    this.releaseNotesService.initializeFromEmbedded();
    void this.releaseNotesService.ensureReleaseNotesFresh(false);
    await migrateSceneAnalysisFields(this);
    this.timelineService = new TimelineService(this.app, this);
    this.sceneDataService = new SceneDataService(this.app, this.settings);
    const { SearchService: SearchService2 } = await Promise.resolve().then(() => (init_SearchService(), SearchService_exports));
    const { FileTrackingService: FileTrackingService2 } = await Promise.resolve().then(() => (init_FileTrackingService(), FileTrackingService_exports));
    this.searchService = new SearchService2(this.app, this);
    this.fileTrackingService = new FileTrackingService2(this);
    this.rendererService = new RendererService(this.app);
    this.synopsisManager = new SynopsisManager(this);
    this.commandRegistrar = new CommandRegistrar(this, this.app);
    this.sceneHighlighter = new SceneHighlighter(this);
    this.gossamerScoreService = new GossamerScoreService(this.app, this);
    this.sceneAnalysisService = new SceneAnalysisService(this);
    this.statusBarService = new StatusBarService(this);
    this.beatsProcessingService = new BeatsProcessingService(this.statusBarService);
    this.themeService = new ThemeService(this);
    this.timelineMetricsService = new TimelineMetricsService(this);
    this.registerView(
      TIMELINE_VIEW_TYPE2,
      (leaf) => {
        return new RadialTimelineView(leaf, this);
      }
    );
    this.commandRegistrar.registerAll();
    this.sceneAnalysisService.registerCommands();
    if (!this._settingsTabAdded) {
      this.addSettingTab(new RadialTimelineSettingsTab(this.app, this));
      this._settingsTabAdded = true;
    }
    this.fileTrackingService.registerWorkspaceListeners();
    new HoverHighlighter(this.app, this, this.sceneHighlighter).register();
  }
  getRendererService() {
    return this.rendererService;
  }
  isSceneFile(path) {
    return this.sceneHighlighter.isSceneFile(path);
  }
  async processSceneAnalysisByManuscriptOrder() {
    await this.sceneAnalysisService.processByManuscriptOrder();
  }
  async processSceneAnalysisBySubplotName(subplotName) {
    await this.sceneAnalysisService.processBySubplotName(subplotName);
  }
  async processEntireSubplot(subplotName) {
    await this.sceneAnalysisService.processEntireSubplot(subplotName);
  }
  // Helper to activate the timeline view
  async activateView() {
    const leaves = this.app.workspace.getLeavesOfType(TIMELINE_VIEW_TYPE2);
    if (leaves.length > 0) {
      this.app.workspace.revealLeaf(leaves[0]);
      return;
    }
    const leaf = this.app.workspace.getLeaf("tab");
    await leaf.setViewState({
      type: TIMELINE_VIEW_TYPE2,
      active: true
    });
    this.app.workspace.revealLeaf(leaf);
  }
  async getSceneData(options) {
    return this.sceneDataService.getSceneData(options);
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
    if (!this.settings.anthropicModelId) this.settings.anthropicModelId = DEFAULT_SETTINGS.anthropicModelId;
    if (!this.settings.openaiModelId) this.settings.openaiModelId = DEFAULT_SETTINGS.openaiModelId;
    if (!this.settings.geminiModelId) this.settings.geminiModelId = DEFAULT_SETTINGS.geminiModelId;
    if (!this.settings.defaultAiProvider || !["openai", "anthropic", "gemini"].includes(this.settings.defaultAiProvider)) {
      this.settings.defaultAiProvider = DEFAULT_SETTINGS.defaultAiProvider;
    }
    if (typeof this.settings.lastSeenReleaseNotesVersion !== "string") {
      this.settings.lastSeenReleaseNotesVersion = DEFAULT_SETTINGS.lastSeenReleaseNotesVersion;
    }
    if (this.settings.cachedReleaseNotes === void 0) {
      this.settings.cachedReleaseNotes = DEFAULT_SETTINGS.cachedReleaseNotes;
    }
    if (this.settings.releaseNotesLastFetched !== void 0) {
      const parsed = Date.parse(this.settings.releaseNotesLastFetched);
      if (Number.isNaN(parsed)) {
        this.settings.releaseNotesLastFetched = void 0;
      }
    }
    const before = JSON.stringify({
      anthropicModelId: this.settings.anthropicModelId,
      openaiModelId: this.settings.openaiModelId,
      geminiModelId: this.settings.geminiModelId
    });
    if (!this.settingsService) {
      this.settingsService = new SettingsService(this);
    }
    this.settingsService.normalizeModelIds();
    const templatesMigrated = await this.settingsService.migrateAiContextTemplates();
    const after = JSON.stringify({
      anthropicModelId: this.settings.anthropicModelId,
      openaiModelId: this.settings.openaiModelId,
      geminiModelId: this.settings.geminiModelId
    });
    if (before !== after || templatesMigrated) {
      await this.saveSettings();
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Helper method to validate and remember folder paths
  async validateAndRememberPath(path) {
    return this.settingsService.validateAndRememberPath(path);
  }
  // Remove redundant parseSceneTitle method - use the one from utils/text.ts instead
  // Method to refresh the timeline if the active view exists (with debouncing)
  refreshTimelineIfNeeded(file, delayMs) {
    const effectiveDelay = file === null && delayMs === void 0 ? 0 : delayMs != null ? delayMs : 400;
    this.timelineService.refreshTimelineIfNeeded(file, effectiveDelay);
  }
  // Search related methods
  openSearchPrompt() {
    this.searchService.openSearchPrompt();
  }
  performSearch(term) {
    this.searchService.performSearch(term);
  }
  clearSearch() {
    this.searchService.clearSearch();
  }
  setCSSColorVariables() {
    this.themeService.applyCssVariables();
  }
  // Add helper method to highlight search terms
  // Helper method to convert DocumentFragment to string for backward compatibility
  // --- START: Color Conversion & Desaturation Helpers ---
  // Ensure these are PUBLIC
  desaturateColor(hexColor, amount) {
    const rgb = hexToRgb(hexColor);
    if (!rgb) return hexColor;
    const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
    hsl.s = Math.max(0, hsl.s * (1 - amount));
    const desat = hslToRgb(hsl.h, hsl.s, hsl.l);
    return rgbToHex(desat.r, desat.g, desat.b);
  }
  // --- END: Color Conversion & Desaturation Helpers ---
  // Add this function inside the RadialTimelinePlugin class
  calculateCompletionEstimate(scenes) {
    return this.timelineMetricsService.calculateCompletionEstimate(scenes);
  }
  /**
   * Show status bar item with beats processing progress
   */
  showBeatsStatusBar(current, total) {
    this.beatsProcessingService.showStatus(current, total);
  }
  /**
   * Hide and remove status bar item when processing completes
   */
  hideBeatsStatusBar() {
    var _a;
    (_a = this.beatsProcessingService) == null ? void 0 : _a.hideStatus();
  }
  async saveGossamerScores(scores) {
    await this.gossamerScoreService.saveScores(scores);
  }
  onunload() {
    this.hideBeatsStatusBar();
  }
  dispatch(type, detail) {
    this.eventBus.dispatchEvent(new CustomEvent(type, { detail }));
  }
};

/* nosourcemap */