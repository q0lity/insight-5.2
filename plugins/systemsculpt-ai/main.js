/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/core/ui/modals/PopupModal.ts
async function showPopup(app, message, options = {}) {
  const popup = new PopupComponent(app, message, options);
  return popup.open();
}
var import_obsidian, PopupComponent;
var init_PopupModal = __esm({
  "src/core/ui/modals/PopupModal.ts"() {
    import_obsidian = require("obsidian");
    PopupComponent = class {
      constructor(app, message, options = {}) {
        this.result = null;
        this.listeners = [];
        this.app = app;
        this.message = message;
        this.options = options;
      }
      registerListener(element, type, listener) {
        element.addEventListener(type, listener);
        this.listeners.push({ element, type, listener });
      }
      removeAllListeners() {
        this.listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
        this.listeners = [];
      }
      createPopup() {
        this.containerEl = document.createElement("div");
        this.containerEl.addClass("systemsculpt-popup-container");
        document.body.appendChild(this.containerEl);
        const popupEl = this.containerEl.createDiv({ cls: "systemsculpt-popup" });
        const content = popupEl.createDiv({ cls: "systemsculpt-popup-content" });
        if (this.options.title) {
          const titleEl = content.createDiv({ cls: "systemsculpt-popup-title" });
          if (this.options.icon) {
            const iconEl = titleEl.createSpan({ cls: "systemsculpt-popup-icon" });
            (0, import_obsidian.setIcon)(iconEl, this.options.icon);
          }
          titleEl.createSpan({ text: this.options.title });
        }
        if (this.message) {
          content.createDiv({
            cls: "systemsculpt-popup-message",
            text: this.message
          });
        }
        if (this.options.description) {
          content.createDiv({
            cls: "systemsculpt-popup-description",
            text: this.options.description
          });
        }
        if (this.options.checkboxLabel) {
          const checkboxContainer = content.createDiv({ cls: "systemsculpt-popup-checkbox-container" });
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.id = "systemsculpt-popup-checkbox";
          const label = document.createElement("label");
          label.htmlFor = "systemsculpt-popup-checkbox";
          label.textContent = this.options.checkboxLabel;
          checkboxContainer.appendChild(checkbox);
          checkboxContainer.appendChild(label);
          this.checkboxEl = checkbox;
        }
        if (this.options.inputs) {
          const inputsContainer = content.createDiv({
            cls: "systemsculpt-popup-inputs"
          });
          this.options.inputs.forEach((input) => {
            if (input.type === "textarea") {
              inputsContainer.createEl("textarea", {
                cls: `systemsculpt-popup-textarea ${input.className || ""}`,
                placeholder: input.placeholder,
                value: input.value || "",
                attr: {
                  required: input.required ? true : null
                }
              });
            } else {
              inputsContainer.createEl("input", {
                type: input.type,
                cls: `systemsculpt-popup-input ${input.className || ""}`,
                placeholder: input.placeholder,
                value: input.value || "",
                attr: {
                  required: input.required ? true : null
                }
              });
            }
          });
        }
        const buttonContainer = popupEl.createDiv({
          cls: "systemsculpt-popup-buttons"
        });
        if (this.options.secondaryButton) {
          const secondaryButton = buttonContainer.createEl("button", {
            cls: "ss-button ss-button--secondary",
            text: this.options.secondaryButton
          });
          this.registerListener(secondaryButton, "click", () => {
            this.result = { confirmed: false };
            this.close();
          });
        }
        const primaryButton = buttonContainer.createEl("button", {
          cls: this.options.primaryButton === "Become A Patron" || this.options.primaryButton === "Become a Patron" ? "ss-button ss-button--primary ss-button--patron mod-cta" : "ss-button ss-button--primary mod-cta",
          text: this.options.primaryButton || "OK"
        });
        if (this.options.primaryButton) {
          primaryButton.setAttribute("data-button-text", this.options.primaryButton);
        }
        this.registerListener(primaryButton, "click", () => {
          var _a, _b, _c, _d;
          if (this.options.inputs) {
            const inputs = Array.from(
              popupEl.querySelectorAll("input, textarea")
            );
            const hasEmptyRequired = inputs.some(
              (input) => input.required && !input.value.trim()
            );
            if (hasEmptyRequired) {
              return;
            }
            this.result = {
              confirmed: true,
              inputs: inputs.map((input) => input.value),
              checkboxChecked: (_b = (_a = this.checkboxEl) == null ? void 0 : _a.checked) != null ? _b : false
            };
          } else {
            this.result = {
              confirmed: true,
              checkboxChecked: (_d = (_c = this.checkboxEl) == null ? void 0 : _c.checked) != null ? _d : false
            };
          }
          this.close();
        });
        this.registerListener(this.containerEl, "keydown", (e) => {
          if (e.key === "Escape") {
            this.result = { confirmed: false };
            this.close();
          }
          if (e.key === "Enter" && !e.isComposing && !e.shiftKey) {
            primaryButton.click();
          }
        });
        this.registerListener(this.containerEl, "mousedown", (e) => {
          if (e.target === this.containerEl) {
            this.result = { confirmed: false };
            this.close();
          }
        });
      }
      close() {
        this.containerEl.addClass("systemsculpt-popup-closing");
        setTimeout(() => {
          this.removeAllListeners();
          this.containerEl.remove();
          if (this.resolvePromise) {
            this.resolvePromise(this.result);
          }
        }, 200);
      }
      open() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.createPopup();
        });
      }
    };
  }
});

// src/core/ui/notifications.ts
var notifications_exports = {};
__export(notifications_exports, {
  displayNotice: () => displayNotice,
  initializeNotificationQueue: () => initializeNotificationQueue,
  showAlert: () => showAlert,
  showConfirm: () => showConfirm,
  showNoticeWhenReady: () => showNoticeWhenReady
});
function initializeNotificationQueue(app) {
  app.workspace.onLayoutReady(() => {
    var _a;
    uiReady = true;
    for (const { message, options } of pendingNotices) {
      new import_obsidian2.Notice(message, (_a = options.duration) != null ? _a : 4e3);
    }
    pendingNotices.length = 0;
  });
}
function showNoticeWhenReady(app, message, options = {}) {
  var _a;
  if (uiReady) {
    new import_obsidian2.Notice(message, (_a = options.duration) != null ? _a : 4e3);
  } else {
    pendingNotices.push({ message, options });
  }
}
async function showAlert(app, message, options = {}) {
  const {
    title = options.type === "error" ? "Error" : options.type === "warning" ? "Warning" : "Alert",
    primaryButton = "OK",
    secondaryButton,
    icon = options.type === "error" ? "alert-circle" : options.type === "warning" ? "alert-triangle" : "info"
  } = options;
  const result = await showPopup(app, message, {
    title,
    primaryButton,
    secondaryButton,
    icon
  });
  return { confirmed: (result == null ? void 0 : result.confirmed) || false };
}
async function showConfirm(app, message, options = {}) {
  const {
    title = "Confirm Action",
    primaryButton = "Confirm",
    secondaryButton = "Cancel",
    icon = "help-circle"
  } = options;
  const result = await showPopup(app, message, {
    title,
    primaryButton,
    secondaryButton,
    icon
  });
  return { confirmed: (result == null ? void 0 : result.confirmed) || false };
}
function displayNotice(app, parts, options = {}) {
  var _a;
  const fragment = document.createDocumentFragment();
  const titleEl = fragment.createDiv({ cls: "systemsculpt-notice-title" });
  titleEl.setText(parts.title);
  if (parts.path) {
    const pathEl = fragment.createDiv({ cls: "systemsculpt-notice-path" });
    pathEl.setText(parts.path);
  }
  if (parts.message) {
    const messageEl = fragment.createDiv({ cls: "systemsculpt-notice-message" });
    messageEl.setText(parts.message);
  }
  new import_obsidian2.Notice(fragment, (_a = options.duration) != null ? _a : 5e3);
}
var import_obsidian2, uiReady, pendingNotices;
var init_notifications = __esm({
  "src/core/ui/notifications.ts"() {
    import_obsidian2 = require("obsidian");
    init_PopupModal();
    uiReady = false;
    pendingNotices = [];
  }
});

// src/types/llm.ts
var DEFAULT_FILTER_SETTINGS;
var init_llm = __esm({
  "src/types/llm.ts"() {
    DEFAULT_FILTER_SETTINGS = {
      showVisionModels: false,
      showReasoningModels: false,
      showCreativeModels: false
    };
  }
});

// src/types/favorites.ts
var DEFAULT_FAVORITES_FILTER_SETTINGS;
var init_favorites = __esm({
  "src/types/favorites.ts"() {
    DEFAULT_FAVORITES_FILTER_SETTINGS = {
      showFavoritesOnly: false,
      favoritesFirst: true,
      modelSortOrder: "default"
      // Default to natural order
    };
  }
});

// src/utils/errorHandling.ts
function setLogLevel(level) {
  currentLogLevel = level;
}
function logError(context, message, error) {
}
async function logMobileError(context, message, error, additionalInfo) {
  logError(context, message, error);
}
var import_obsidian3, currentLogLevel;
var init_errorHandling = __esm({
  "src/utils/errorHandling.ts"() {
    import_obsidian3 = require("obsidian");
    currentLogLevel = 1 /* WARNING */;
  }
});

// src/types/chatExport.ts
function createDefaultChatExportOptions() {
  return { ...DEFAULT_CHAT_EXPORT_OPTIONS };
}
function mergeChatExportOptions(base, overrides) {
  if (!overrides) {
    return { ...base };
  }
  return {
    ...base,
    ...overrides
  };
}
function normalizeChatExportOptions(overrides) {
  return mergeChatExportOptions(createDefaultChatExportOptions(), overrides);
}
var DEFAULT_CHAT_EXPORT_OPTIONS;
var init_chatExport = __esm({
  "src/types/chatExport.ts"() {
    DEFAULT_CHAT_EXPORT_OPTIONS = {
      includeMetadata: true,
      includeSystemPrompt: true,
      includeContextFiles: true,
      includeContextFileContents: true,
      includeConversation: true,
      includeUserMessages: true,
      includeAssistantMessages: true,
      includeToolMessages: false,
      includeReasoning: true,
      includeToolCalls: true,
      includeToolCallArguments: true,
      includeToolCallResults: true,
      includeImages: true
    };
  }
});

// src/types.ts
var LICENSE_URL, DEFAULT_TITLE_GENERATION_PROMPT, DEFAULT_SETTINGS;
var init_types = __esm({
  "src/types.ts"() {
    init_llm();
    init_favorites();
    init_errorHandling();
    init_chatExport();
    LICENSE_URL = "https://systemsculpt.com/resources?tab=license";
    DEFAULT_TITLE_GENERATION_PROMPT = `You are a specialized title generation assistant focused on creating precise, meaningful titles.

Your task is to analyze the provided conversation and generate a single, concise title that:
- Captures the main topic or central theme of the conversation
- Uses clear, descriptive language
- Is between 3-8 words long
- Avoids unnecessary articles (a, an, the) unless essential
- Maintains professional tone and proper capitalization
- Includes key technical terms when relevant
- NEVER includes characters that are invalid in filenames: \\ / : * ? " < > |
- Uses proper spacing between all words

Output ONLY the title itself - no additional text, no "Title:" prefix, no quotes, no explanation.`;
    DEFAULT_SETTINGS = {
      // Default to a simple, friendly experience
      settingsMode: "standard",
      licenseKey: "",
      licenseValid: false,
      suppressLicenseUpgradePrompt: false,
      selectedModelId: "",
      useLatestModelEverywhere: true,
      // defaultModelId: "", // DEPRECATED
      defaultTemplateModelId: "",
      chatsDirectory: "SystemSculpt/Chats",
      savedChatsDirectory: "SystemSculpt/Saved Chats",
      lastValidated: 0,
      showWelcomeOnStartup: true,
      // This is the fallback system prompt if the user hasn't chosen a custom or preset
      systemPrompt: "You are a helpful AI assistant. You help users with their questions and tasks in a clear and concise way.",
      recordingsDirectory: "SystemSculpt/Recordings",
      preferredMicrophoneId: "",
      autoTranscribeRecordings: true,
      autoPasteTranscription: true,
      keepRecordingsAfterTranscription: true,
      postProcessingPrompt: `You are a transcription post-processor. Your task is to fix any transcription errors, correct grammar and punctuation, and ensure the text is properly formatted. Keep the original meaning intact while making the text more readable.

Please process the following raw transcript to:
- Fix grammar, punctuation, and capitalization
- Remove filler words (um, uh, like, you know)
- Format into clear paragraphs
- Maintain the original meaning and speaker's voice

Raw transcript:`,
      postProcessingEnabled: false,
      postProcessingPromptType: "preset",
      postProcessingPromptPresetId: "transcript-cleaner",
      postProcessingPromptFilePath: "",
      postProcessingProviderId: "systemsculpt",
      // Default to native provider
      postProcessingModelId: "",
      // Default to empty; logic should handle fallback if unset
      cleanTranscriptionOutput: false,
      autoSubmitAfterTranscription: false,
      transcriptionProvider: "systemsculpt",
      customTranscriptionEndpoint: "",
      customTranscriptionApiKey: "",
      customTranscriptionModel: "whisper-large-v3",
      enableAutoAudioResampling: true,
      showModelTooltips: false,
      showVisionModelsOnly: false,
      showTopPicksOnly: false,
      selectedProvider: "all",
      serverUrl: "",
      // Will be set from API_BASE_URL on first load
      attachmentsDirectory: "SystemSculpt/Attachments",
      extractionsDirectory: "SystemSculpt/Extractions",
      systemPromptsDirectory: "SystemSculpt/System Prompts",
      skipEmptyNoteWarning: false,
      /**
       * NEW FIELDS DEFAULTS:
       */
      systemPromptType: "general-use",
      systemPromptPath: "",
      useLatestSystemPromptForNewChats: true,
      /**
       * Agent mode toggle - enables vault exploration and autonomous tool use
       */
      agentMode: false,
      /**
       * Default agent mode setting - when enabled, new chats will start with agent mode enabled
       * Only available for licensed users
       */
      defaultAgentMode: false,
      /**
       * Title generation prompt defaults
       */
      titleGenerationPrompt: DEFAULT_TITLE_GENERATION_PROMPT,
      titleGenerationPromptType: "precise",
      titleGenerationPromptPath: "",
      automaticTitleGeneration: false,
      titleGenerationProviderId: "systemsculpt",
      // Default to native provider
      titleGenerationModelId: "",
      // Default to empty; logic should handle fallback if unset
      /**
       * Custom provider defaults
       */
      customProviders: [],
      modelFilterSettings: DEFAULT_FILTER_SETTINGS,
      favoriteModels: [],
      favoritesFilterSettings: DEFAULT_FAVORITES_FILTER_SETTINGS,
      favoriteChats: [],
      activeProvider: {
        id: "systemsculpt",
        name: "SystemSculpt",
        type: "native"
      },
      /**
       * Template settings defaults
       */
      templateHotkey: "/",
      enableTemplateHotkey: true,
      lastSaveAsNoteFolder: "SystemSculpt/AI Responses",
      chatExportPreferences: {
        options: createDefaultChatExportOptions(),
        lastFolder: "",
        openAfterExport: true,
        lastFileName: ""
      },
      showDiagnostics: false,
      enableExperimentalFeatures: false,
      // Deprecated option removed; custom providers are not filtered by server allowlists
      /**
       * Maximum number of individual directory entries to include in the system prompt.
       * When the vault has more than this number of directories, we switch to a
       * summarised representation to keep prompts compact.
       */
      maxVaultDirectoryEntries: 300,
      enableSystemSculptProvider: true,
      useSystemSculptAsFallback: true,
      /**
       * Percentage of the model context window to use (0-100)
       */
      contextWindowPercentage: 25,
      logLevel: 1 /* WARNING */,
      debugMode: false,
      preserveReasoningVerbatim: true,
      showUpdateNotifications: true,
      /**
       * MCP (Model Context Protocol) defaults
       */
      mcpServers: [{
        id: "mcp-filesystem",
        name: "Filesystem Tools",
        transport: "internal",
        isEnabled: true,
        connectionStatus: "connected",
        availableTools: []
      }],
      mcpEnabledTools: [
        "mcp-filesystem:read",
        "mcp-filesystem:write",
        "mcp-filesystem:edit",
        "mcp-filesystem:create_folders",
        "mcp-filesystem:list_items",
        "mcp-filesystem:move",
        "mcp-filesystem:trash",
        "mcp-filesystem:find",
        "mcp-filesystem:search",
        "mcp-filesystem:open",
        "mcp-filesystem:context"
      ],
      mcpAutoAcceptTools: [],
      mcpEnabled: true,
      mcpAutoAccept: false,
      chatFontSize: "medium",
      openAiApiKey: "",
      /**
       * Embeddings defaults
       */
      embeddingsEnabled: false,
      embeddingsModel: "text-embedding-004-multilingual",
      embeddingsAutoProcess: true,
      embeddingsExclusions: {
        folders: [],
        patterns: [],
        ignoreChatHistory: true,
        respectObsidianExclusions: true
      },
      embeddingsMobileEnabled: false,
      embeddingsProvider: "systemsculpt",
      embeddingsCustomEndpoint: "",
      embeddingsCustomApiKey: "",
      embeddingsCustomModel: "",
      embeddingsBatchSize: 20,
      // Optimized batch size for parallel processing
      embeddingsRateLimitPerMinute: 50,
      // Default rate limiting
      embeddingsQuietPeriodMs: 1200,
      // Search behavior defaults removed; handled internally
      /**
       * Automatic backup defaults
       */
      automaticBackupsEnabled: true,
      // Enable automatic backups by default
      automaticBackupInterval: 24,
      // Create backups every 24 hours
      automaticBackupRetentionDays: 30,
      // Keep backups for 30 days
      lastAutomaticBackup: 0,
      // No automatic backup yet
      /**
       * Model selection modal provider preferences defaults
       */
      selectedModelProviders: []
      // Empty array means use default initialization logic
      // preserveReasoningVerbatim default already defined above
    };
  }
});

// src/utils/errors.ts
function getErrorMessage(code, model) {
  const messages = {
    // Authentication Errors
    [ERROR_CODES.INVALID_LICENSE]: "Invalid license key. Please check your license in settings.",
    [ERROR_CODES.LICENSE_EXPIRED]: "Your license has expired. Please renew your subscription.",
    [ERROR_CODES.LICENSE_DISABLED]: "Your license has been disabled. Please contact support.",
    [ERROR_CODES.PRO_REQUIRED]: "This feature requires a Pro license. Please upgrade your subscription.",
    // Model Errors
    [ERROR_CODES.MODEL_UNAVAILABLE]: (model2) => model2 ? `Model "${model2}" is currently unavailable. Please try another model.` : "The selected model is currently unavailable.",
    [ERROR_CODES.MODEL_REQUEST_ERROR]: (model2) => model2 ? `Error processing request with model "${model2}". Please try again.` : "Error processing your request. Please try again.",
    // Stream Errors
    [ERROR_CODES.STREAM_ERROR]: "Error in streaming response. Please try again.",
    [ERROR_CODES.INVALID_RESPONSE]: "Received invalid response from the service. Please try again.",
    [ERROR_CODES.NO_IMAGE]: "No image detected in the current note.",
    // File Processing Errors
    [ERROR_CODES.FILE_NOT_FOUND]: "File not found. Please check the file path.",
    [ERROR_CODES.FILE_TOO_LARGE]: "File is too large to process. Please try with a smaller file.",
    [ERROR_CODES.UNSUPPORTED_FORMAT]: "Unsupported file format. Please try with a supported format.",
    [ERROR_CODES.PROCESSING_ERROR]: "Error processing the file. Please try again.",
    // Network Errors
    [ERROR_CODES.NETWORK_ERROR]: "Network error. Please check your internet connection.",
    [ERROR_CODES.TIMEOUT_ERROR]: "Request timed out. Please try again.",
    [ERROR_CODES.SERVICE_UNAVAILABLE]: "Service is temporarily unavailable. Please try again later.",
    [ERROR_CODES.RATE_LIMIT_ERROR]: "Rate limit exceeded. Please wait a moment before trying again.",
    // Generic Errors
    [ERROR_CODES.UNKNOWN_ERROR]: "An unexpected error occurred. Please try again.",
    [ERROR_CODES.QUOTA_EXCEEDED]: "Usage quota exceeded. Please check your account limits."
  };
  const message = messages[code];
  if (typeof message === "function") {
    return message(model);
  }
  return message;
}
var ERROR_CODES, SystemSculptError;
var init_errors = __esm({
  "src/utils/errors.ts"() {
    ERROR_CODES = {
      // Authentication Errors
      INVALID_LICENSE: "INVALID_LICENSE",
      LICENSE_EXPIRED: "LICENSE_EXPIRED",
      LICENSE_DISABLED: "LICENSE_DISABLED",
      PRO_REQUIRED: "PRO_REQUIRED",
      // Model Errors
      MODEL_UNAVAILABLE: "MODEL_UNAVAILABLE",
      MODEL_REQUEST_ERROR: "MODEL_REQUEST_ERROR",
      // Stream Errors
      STREAM_ERROR: "STREAM_ERROR",
      INVALID_RESPONSE: "INVALID_RESPONSE",
      NO_IMAGE: "NO_IMAGE",
      // File Processing Errors
      FILE_NOT_FOUND: "FILE_NOT_FOUND",
      FILE_TOO_LARGE: "FILE_TOO_LARGE",
      UNSUPPORTED_FORMAT: "UNSUPPORTED_FORMAT",
      PROCESSING_ERROR: "PROCESSING_ERROR",
      // Network Errors
      NETWORK_ERROR: "NETWORK_ERROR",
      TIMEOUT_ERROR: "TIMEOUT_ERROR",
      SERVICE_UNAVAILABLE: "SERVICE_UNAVAILABLE",
      RATE_LIMIT_ERROR: "RATE_LIMIT_ERROR",
      // Generic Errors
      UNKNOWN_ERROR: "UNKNOWN_ERROR",
      QUOTA_EXCEEDED: "QUOTA_EXCEEDED"
    };
    SystemSculptError = class extends Error {
      constructor(message, code = ERROR_CODES.UNKNOWN_ERROR, statusCode = 500, metadata) {
        super(message);
        this.code = code;
        this.statusCode = statusCode;
        this.metadata = metadata;
        this.name = "SystemSculptError";
      }
    };
  }
});

// src/mcp-tools/filesystem/constants.ts
var FILESYSTEM_LIMITS, TOOL_DISPLAY_NAMES, TOOL_DISPLAY_DESCRIPTIONS;
var init_constants = __esm({
  "src/mcp-tools/filesystem/constants.ts"() {
    FILESYSTEM_LIMITS = {
      MAX_FILE_READ_LENGTH: 25e3,
      // Characters per read window
      MAX_LINE_LENGTH: 2e3,
      MAX_OPERATIONS: 100,
      // Max operations for batch tools
      MAX_SEARCH_RESULTS: 25,
      // Global results cap for search-type tools (grep/find/etc.)
      MAX_FILE_SIZE: 2e5,
      // 200KB max file size for processing
      MAX_CONTENT_SIZE: 25e4,
      // 250KB max content size for writing
      HARD_LIMIT: 25e3,
      // Same as MAX_FILE_READ_LENGTH â€“ absolute per-window cap
      MAX_RESPONSE_CHARS: 25e3,
      // Hard cap for the size (in characters) of any single tool response
      CONTEXT_CHARS: 200,
      // Characters to show before and after match in grep
      BATCH_SIZE: 15,
      // Process files in batches to prevent UI freeze
      MAX_PROCESSING_TIME: 8e3,
      // 8 seconds max processing time
      MAX_MATCHES_PER_FILE: 20,
      // Stop processing file after this many matches
      MAX_TOTAL_FILES_PROCESSED: 1e3,
      // Hard limit on files processed
      MAX_FILES_PER_REQUEST: 10,
      // Max files for context management
      CONCURRENCY_LIMIT: 10,
      // Parallel operations limit
      // Token-capped tool result policy
      MAX_TOOL_RESULT_TOKENS: 2048,
      // Per tool-call result budget
      GREP_BODY_TOKENS: 1900,
      // Body slice target
      GREP_FOOTER_TOKENS: 148
      // Reserved for footer/meta
    };
    TOOL_DISPLAY_NAMES = {
      read: "View File",
      write: "Create or Replace File",
      edit: "Edit Text in File",
      create_folders: "Create Folders",
      list_items: "Browse Folder",
      move: "Move or Rename",
      trash: "Trash Files or Folders",
      find: "Find by Name",
      search: "Search Note Contents",
      open: "Open Files in Obsidian",
      context: "Manage AI Context"
    };
    TOOL_DISPLAY_DESCRIPTIONS = {
      read: "View the contents of one or more files.",
      write: "Create a new file or replace an existing one.",
      edit: "Find and replace text in a file.",
      create_folders: "Create new folders.",
      list_items: "See what's inside a folder (files and subfolders).",
      move: "Move or rename files and folders.",
      trash: "Send files or folders to the trash (you can restore them).",
      find: "Quickly find files or folders by name.",
      search: "Search within notes for specific words or phrases.",
      open: "Open files next to the chat for easy viewing.",
      context: "Choose which files the AI can reference during the chat."
    };
  }
});

// src/mcp-tools/filesystem/toolDefinitions/fileToolDefinitions.ts
var fileToolDefinitions;
var init_fileToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/fileToolDefinitions.ts"() {
    fileToolDefinitions = [
      {
        name: "read",
        description: "View the contents of one or more files. Works well with large files and shows size and timestamps.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              description: "File paths to open (relative to vault root)"
            },
            // Helpful alias: some models incorrectly send "path" instead of "paths".
            // We accept it here to prevent upstream tool-validation errors and normalize at runtime.
            path: {
              oneOf: [
                { type: "string" },
                { type: "array", items: { type: "string" }, minItems: 1 }
              ],
              description: "Alias for 'paths'. Accepts a single path or an array of paths."
            },
            offset: {
              type: "number",
              minimum: 0,
              default: 0,
              description: "Start reading from this character (advanced)"
            },
            length: {
              type: "number",
              minimum: 1,
              maximum: 25e3,
              default: 25e3,
              description: "How much to read at once (25KB limit)"
            }
          },
          // Require at least one of 'paths' or 'path'
          oneOf: [
            { required: ["paths"] },
            { required: ["path"] }
          ],
          additionalProperties: false
        }
      },
      {
        name: "write",
        description: "Create a new file or replace an existing one. Use 'Edit Text in File' for partial updates.",
        inputSchema: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "Where to save the file (relative to vault root)"
            },
            content: {
              type: "string",
              description: "Full content of the file"
            },
            createDirs: {
              type: "boolean",
              default: true,
              description: "Create parent directories if they do not exist"
            },
            ifExists: {
              type: "string",
              enum: ["overwrite", "skip", "error", "append"],
              default: "overwrite",
              description: "Behavior if the file already exists"
            },
            appendNewline: {
              type: "boolean",
              default: false,
              description: "Append a trailing newline when appending content"
            }
          },
          required: ["path", "content"],
          additionalProperties: false
        }
      },
      {
        name: "edit",
        description: "Find and replace text in an existing file with advanced targeting (ranges, regex, and loose whitespace matching).",
        inputSchema: {
          type: "object",
          properties: {
            path: {
              type: "string",
              description: "Which file to edit"
            },
            edits: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  oldText: { type: "string", description: "Text to find (string or regex pattern)" },
                  newText: { type: "string", description: "Replace with" },
                  isRegex: { type: "boolean", default: false },
                  flags: { type: "string", description: "Regex flags (e.g., gim)" },
                  occurrence: {
                    oneOf: [
                      { type: "string", enum: ["first", "last", "all"] },
                      { type: "number", minimum: 1 }
                    ],
                    default: "first",
                    description: "Which occurrence to replace"
                  },
                  mode: { type: "string", enum: ["exact", "loose"], default: "exact", description: "Loose ignores indentation/CRLF differences" },
                  range: {
                    type: "object",
                    properties: {
                      startLine: { type: "number", minimum: 1 },
                      endLine: { type: "number", minimum: 1 },
                      startIndex: { type: "number", minimum: 0 },
                      endIndex: { type: "number", minimum: 0 }
                    },
                    additionalProperties: false
                  },
                  preserveIndent: { type: "boolean", default: true }
                },
                required: ["oldText", "newText"],
                additionalProperties: false
              },
              description: "List all find/replace steps to apply in order"
            },
            strict: { type: "boolean", default: true, description: "Error if any edit cannot be applied" }
          },
          required: ["path", "edits"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/directoryToolDefinitions.ts
var directoryToolDefinitions;
var init_directoryToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/directoryToolDefinitions.ts"() {
    init_constants();
    directoryToolDefinitions = [
      {
        name: "create_folders",
        description: "Create one or more folders. Parent folders are created automatically and it's safe if they already exist.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              description: "Directory paths to create (relative to vault root)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      },
      {
        name: "list_items",
        description: "Browse a folder with helpful filtering and sorting. Shows size and timestamps.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              maxItems: 5,
              description: "Folder paths to browse (max 5)"
            },
            filter: {
              type: "string",
              enum: ["all", "files", "directories"],
              default: "all",
              description: "Filter by type"
            },
            sort: {
              type: "string",
              enum: ["modified", "size", "name", "created"],
              default: "modified",
              description: "How to sort the results"
            },
            recursive: {
              type: "boolean",
              default: false,
              description: "Include subfolders (may be slower in large vaults)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      },
      {
        name: "move",
        description: "Batch move or rename files/folders. Updates all internal links automatically. Creates destination directories if needed. Use for organizing vault structure.",
        inputSchema: {
          type: "object",
          properties: {
            items: {
              type: "array",
              minItems: 1,
              // Align with internal MAX_OPERATIONS, provider validates this upstream
              maxItems: FILESYSTEM_LIMITS.MAX_OPERATIONS,
              items: {
                type: "object",
                properties: {
                  source: {
                    type: "string",
                    description: "Current path of file/folder"
                  },
                  destination: {
                    type: "string",
                    description: "New path (rename if same dir, move if different)"
                  }
                },
                required: ["source", "destination"],
                additionalProperties: false
              },
              description: "List of move operations to perform in one request (processed internally in safe batches)"
            }
          },
          required: ["items"],
          additionalProperties: false
        }
      },
      {
        name: "trash",
        description: "Move files/folders to Obsidian trash (recoverable). Safer than permanent deletion. Preserves file history and can be restored from .trash folder.",
        inputSchema: {
          type: "object",
          properties: {
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              maxItems: 100,
              description: "Paths to trash (files or folders)"
            }
          },
          required: ["paths"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/searchToolDefinitions.ts
var searchToolDefinitions;
var init_searchToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/searchToolDefinitions.ts"() {
    searchToolDefinitions = [
      {
        name: "find",
        description: "Quickly find files or folders by name. Great when you remember part of the name. Results include path, size, and timestamps.",
        inputSchema: {
          type: "object",
          properties: {
            patterns: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              description: "Words to look for in file or folder names (at least 1)"
            }
          },
          required: ["patterns"],
          additionalProperties: false
        }
      },
      {
        name: "search",
        description: "Search within notes for specific words or phrases. Returns matching lines with helpful context.",
        inputSchema: {
          type: "object",
          properties: {
            patterns: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              description: "What to search for (words or phrases). Advanced users can use regular expressions."
            },
            searchIn: {
              type: "string",
              enum: ["content", "frontmatter", "both"],
              default: "content",
              description: "Where to search: note text, properties (YAML), or both"
            },
            cursor: {
              type: "string",
              description: "Opaque pagination cursor returned by a previous call"
            },
            pageTokens: {
              type: "number",
              minimum: 512,
              maximum: 4096,
              default: 2048,
              description: "Token budget for this page (defaults 2048; rare bumps to 4096)"
            }
          },
          required: ["patterns"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions/managementToolDefinitions.ts
var managementToolDefinitions;
var init_managementToolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions/managementToolDefinitions.ts"() {
    managementToolDefinitions = [
      {
        name: "open",
        description: "Open files in Obsidian so you can view them. Opens in the current pane or a new tab.",
        inputSchema: {
          type: "object",
          properties: {
            files: {
              type: "array",
              items: {
                type: "object",
                properties: {
                  path: {
                    type: "string",
                    description: "File path to open in Obsidian"
                  }
                },
                required: ["path"],
                additionalProperties: false
              },
              minItems: 1,
              maxItems: 5,
              description: "Files to open (max 5)"
            }
          },
          required: ["files"],
          additionalProperties: false
        }
      },
      {
        name: "context",
        description: "Choose which files the AI can reference during the chat. Add or remove files from context.",
        inputSchema: {
          type: "object",
          properties: {
            action: {
              type: "string",
              enum: ["add", "remove"],
              description: "add = include files in AI context, remove = take them out"
            },
            paths: {
              type: "array",
              items: { type: "string" },
              minItems: 1,
              maxItems: 10,
              description: "File paths to add/remove from AI context"
            }
          },
          required: ["action", "paths"],
          additionalProperties: false
        }
      }
    ];
  }
});

// src/mcp-tools/filesystem/toolDefinitions.ts
var toolDefinitions;
var init_toolDefinitions = __esm({
  "src/mcp-tools/filesystem/toolDefinitions.ts"() {
    init_fileToolDefinitions();
    init_directoryToolDefinitions();
    init_searchToolDefinitions();
    init_managementToolDefinitions();
    toolDefinitions = [
      ...fileToolDefinitions,
      ...directoryToolDefinitions,
      ...searchToolDefinitions,
      ...managementToolDefinitions
    ];
  }
});

// src/mcp-tools/filesystem/utils.ts
function formatBytes(bytes) {
  if (bytes === 0) return "0 Bytes";
  const k = 1024;
  const sizes = ["Bytes", "KB", "MB", "GB"];
  const i = Math.floor(Math.log(bytes) / Math.log(k));
  return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + " " + sizes[i];
}
function validatePath(path, allowedPaths) {
  const normalizedPath = (0, import_obsidian4.normalizePath)(path);
  for (const allowedPath of allowedPaths) {
    if (allowedPath === "/" || normalizedPath.startsWith(allowedPath)) {
      return true;
    }
  }
  return false;
}
function normalizeLineEndings(text) {
  return text.replace(/\r\n/g, "\n");
}
function createSimpleDiff(originalContent, newContent, filepath = "file") {
  const normalizedOriginal = normalizeLineEndings(originalContent);
  const normalizedNew = normalizeLineEndings(newContent);
  if (normalizedOriginal === normalizedNew) {
    return "No changes made.";
  }
  const originalLines = normalizedOriginal.split("\n");
  const newLines = normalizedNew.split("\n");
  let diffLines = [];
  diffLines.push(`--- ${filepath}`);
  diffLines.push(`+++ ${filepath}`);
  const maxLines = Math.max(originalLines.length, newLines.length);
  let shownAdded = 0;
  let shownRemoved = 0;
  let totalAdded = 0;
  let totalRemoved = 0;
  const MAX_CHARS = FILESYSTEM_LIMITS.MAX_RESPONSE_CHARS;
  const SUMMARY_RESERVE = 256;
  const HEADER_LEN = diffLines.join("\n").length + 1;
  let used = HEADER_LEN;
  const pushIfFits = (line) => {
    const need = line.length + 1;
    if (used + need <= MAX_CHARS - SUMMARY_RESERVE) {
      diffLines.push(line);
      used += need;
      return true;
    }
    return false;
  };
  let budgetExceeded = false;
  let truncated = false;
  for (let i = 0; i < maxLines; i++) {
    const oldLine = originalLines[i];
    const newLine = newLines[i];
    if (oldLine !== newLine) {
      if (oldLine !== void 0) {
        totalRemoved++;
        if (!budgetExceeded) {
          if (!pushIfFits(`- ${oldLine}`)) {
            budgetExceeded = true;
            truncated = true;
          } else {
            shownRemoved++;
          }
        }
      }
      if (newLine !== void 0) {
        totalAdded++;
        if (!budgetExceeded) {
          if (!pushIfFits(`+ ${newLine}`)) {
            budgetExceeded = true;
            truncated = true;
          } else {
            shownAdded++;
          }
        }
      }
    }
  }
  const summarySuffix = truncated ? ` (truncated to ${FILESYSTEM_LIMITS.MAX_RESPONSE_CHARS} chars)` : "";
  return diffLines.join("\n") + `

Summary: +${totalAdded} -${totalRemoved} lines${summarySuffix}`;
}
async function runWithConcurrency(items, worker, concurrency = 10) {
  const ret = [];
  let idx = 0;
  const runners = new Array(Math.min(concurrency, items.length)).fill(null).map(async () => {
    while (idx < items.length) {
      const current = items[idx++];
      try {
        ret.push(await worker(current));
      } catch (err) {
        ret.push({ error: err, path: current });
      }
    }
  });
  await Promise.all(runners);
  return ret;
}
function createLineCalculator(content) {
  const lineStarts = [0];
  for (let i = 0; i < content.length; i++) {
    if (content[i] === "\n") {
      lineStarts.push(i + 1);
    }
  }
  return (index) => {
    let left = 0;
    let right = lineStarts.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      const start = lineStarts[mid];
      const end = mid < lineStarts.length - 1 ? lineStarts[mid + 1] : content.length;
      if (index >= start && index < end) {
        return mid + 1;
      } else if (index < start) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return lineStarts.length;
  };
}
function getFilesFromFolder(folder) {
  const files = [];
  const processFolder = (currentFolder) => {
    for (const child of currentFolder.children) {
      if (child instanceof import_obsidian4.TFile) {
        files.push(child);
      } else if (child instanceof import_obsidian4.TFolder) {
        processFolder(child);
      }
    }
  };
  processFolder(folder);
  return files;
}
function wouldExceedCharLimit(currentSize, addition, limit) {
  try {
    const additionSize = typeof addition === "string" ? addition.length : JSON.stringify(addition).length;
    return currentSize + additionSize > limit;
  } catch (e) {
    return true;
  }
}
function shouldExcludeFromSearch(file, plugin) {
  var _a, _b;
  const settings = plugin.settings;
  const exclusions = settings.embeddingsExclusions;
  if ((exclusions == null ? void 0 : exclusions.ignoreChatHistory) !== false) {
    const chatsDirectory = settings.chatsDirectory || "SystemSculpt/Chats";
    if (file.path.startsWith(chatsDirectory + "/") && file.extension === "md") {
      return true;
    }
  }
  if ((exclusions == null ? void 0 : exclusions.respectObsidianExclusions) !== false) {
    try {
      const userIgnoreFilters = plugin.app.vault.getConfig("userIgnoreFilters");
      if (userIgnoreFilters && Array.isArray(userIgnoreFilters)) {
        for (const pattern of userIgnoreFilters) {
          try {
            const regex = new RegExp(pattern);
            if (regex.test(file.path)) {
              return true;
            }
          } catch (e) {
          }
        }
      }
    } catch (e) {
    }
  }
  if (file.path.startsWith(".obsidian/") || file.path.includes("node_modules/")) {
    return true;
  }
  const systemDirs = [
    "SystemSculpt/Recordings",
    "SystemSculpt/System Prompts",
    "SystemSculpt/Attachments",
    "SystemSculpt/Extractions"
  ];
  for (const dir of systemDirs) {
    if (file.path.startsWith(dir + "/")) {
      return true;
    }
  }
  if ((_a = plugin.settings.embeddingsExclusions) == null ? void 0 : _a.folders) {
    for (const folder of plugin.settings.embeddingsExclusions.folders) {
      if (folder && file.path.startsWith(folder + "/")) {
        return true;
      }
    }
  }
  if ((_b = plugin.settings.embeddingsExclusions) == null ? void 0 : _b.patterns) {
    for (const pattern of plugin.settings.embeddingsExclusions.patterns) {
      try {
        const regex = new RegExp(pattern);
        if (regex.test(file.path)) {
          return true;
        }
      } catch (e) {
      }
    }
  }
  return false;
}
function fuzzyMatchScore(needle, haystack) {
  const lcNeedle = needle.toLowerCase();
  const lcHaystack = haystack.toLowerCase();
  const exactIdx = lcHaystack.indexOf(lcNeedle);
  if (exactIdx !== -1) {
    return exactIdx;
  }
  let nIdx = 0;
  let score = 0;
  for (let hIdx = 0; hIdx < lcHaystack.length && nIdx < lcNeedle.length; hIdx++) {
    if (lcHaystack[hIdx] === lcNeedle[nIdx]) {
      nIdx++;
    } else {
      score += 1;
    }
  }
  if (nIdx !== lcNeedle.length) {
    return null;
  }
  score += lcHaystack.length - lcNeedle.length;
  return score;
}
var import_obsidian4;
var init_utils = __esm({
  "src/mcp-tools/filesystem/utils.ts"() {
    import_obsidian4 = require("obsidian");
    init_constants();
  }
});

// src/mcp-tools/filesystem/tools/FileOperations.ts
var import_obsidian5, FileOperations;
var init_FileOperations = __esm({
  "src/mcp-tools/filesystem/tools/FileOperations.ts"() {
    import_obsidian5 = require("obsidian");
    init_constants();
    init_utils();
    FileOperations = class {
      constructor(app, allowedPaths) {
        this.app = app;
        this.allowedPaths = allowedPaths;
      }
      /**
       * Read multiple files with windowing support
       */
      async readFiles(params) {
        var _a;
        let paths = [];
        if (Array.isArray(params == null ? void 0 : params.paths)) {
          paths = params.paths;
        } else if (typeof (params == null ? void 0 : params.paths) === "string") {
          paths = [params.paths];
        } else if (Array.isArray(params == null ? void 0 : params.path)) {
          paths = params.path;
        } else if (typeof (params == null ? void 0 : params.path) === "string") {
          paths = [params.path];
        }
        const offset = Number((_a = params == null ? void 0 : params.offset) != null ? _a : 0);
        const lengthArg = params == null ? void 0 : params.length;
        if (paths.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Too many files requested (${paths.length}). Maximum allowed is ${FILESYSTEM_LIMITS.MAX_OPERATIONS}`);
        }
        const actualOffset = offset;
        const defaultLength = FILESYSTEM_LIMITS.MAX_FILE_READ_LENGTH;
        const files = [];
        for (const path of paths) {
          if (!validatePath(path, this.allowedPaths)) {
            files.push({ path, content: "", error: "Access denied" });
            continue;
          }
          const file = this.app.vault.getAbstractFileByPath(path);
          if (file instanceof import_obsidian5.TFile) {
            try {
              const fullContent = await this.app.vault.read(file);
              const fileSize = fullContent.length;
              const windowStart = Math.max(0, Math.min(actualOffset, fileSize));
              const requestedRaw = Number(lengthArg != null ? lengthArg : defaultLength);
              const requested = Number.isFinite(requestedRaw) && requestedRaw > 0 ? requestedRaw : defaultLength;
              const actualLength = Math.min(requested, FILESYSTEM_LIMITS.MAX_FILE_READ_LENGTH);
              const windowEnd = Math.min(windowStart + actualLength, fileSize);
              let windowContent = fullContent.substring(windowStart, windowEnd);
              const lengthWasProvided = lengthArg !== void 0 && lengthArg !== null;
              const requestedRawForClampCheck = Number(lengthArg != null ? lengthArg : defaultLength);
              const coercedRequested = Number.isFinite(requestedRawForClampCheck) && requestedRawForClampCheck > 0 ? requestedRawForClampCheck : defaultLength;
              const lengthWasClamped = coercedRequested > actualLength;
              const hasMore = windowEnd < fileSize;
              if (hasMore && (!lengthWasProvided || lengthWasClamped)) {
                const nextOffset = windowEnd;
                const notice = `

[... truncated: showing ${windowStart}-${windowEnd} of ${fileSize} chars. Continue with offset=${nextOffset}]`;
                const MAX = FILESYSTEM_LIMITS.MAX_FILE_READ_LENGTH;
                const reserved = notice.length;
                if (windowContent.length + reserved > MAX) {
                  windowContent = windowContent.slice(0, Math.max(0, MAX - reserved));
                }
                windowContent += notice;
              }
              const metadata = {
                fileSize,
                created: new Date(file.stat.ctime).toISOString(),
                modified: new Date(file.stat.mtime).toISOString(),
                windowStart,
                windowEnd,
                hasMore
              };
              files.push({
                path,
                content: windowContent,
                metadata
              });
            } catch (err) {
              files.push({ path, content: "", error: "Failed to read file" });
            }
          } else {
            files.push({ path, content: "", error: "File not found or is a directory" });
          }
        }
        return { files };
      }
      /**
       * Write or overwrite a single file
       */
      async writeFile(params) {
        const { path, content, createDirs = true, ifExists = "overwrite", appendNewline = false } = params;
        if (!validatePath(path, this.allowedPaths)) {
          throw new Error(`Access denied: ${path}`);
        }
        if (content.length > FILESYSTEM_LIMITS.MAX_CONTENT_SIZE) {
          throw new Error(`Content too large (${content.length} characters). Maximum allowed is ${FILESYSTEM_LIMITS.MAX_CONTENT_SIZE} characters`);
        }
        const normalizedPath = (0, import_obsidian5.normalizePath)(path);
        const file = this.app.vault.getAbstractFileByPath(normalizedPath);
        if (file && file instanceof import_obsidian5.TFile) {
          if (ifExists === "skip") {
            return { path, success: true };
          }
          if (ifExists === "error") {
            throw new Error(`File already exists: ${path}`);
          }
          if (ifExists === "append") {
            const current = await this.app.vault.read(file);
            const newContent = current + (appendNewline && !current.endsWith("\n") ? "\n" : "") + content;
            await this.app.vault.modify(file, newContent);
          } else {
            await this.app.vault.modify(file, content);
          }
        } else {
          if (createDirs) {
            const lastSlash = normalizedPath.lastIndexOf("/");
            if (lastSlash > 0) {
              const folderPath = normalizedPath.substring(0, lastSlash);
              try {
                await this.app.vault.createFolder(folderPath);
              } catch (e) {
              }
            }
          }
          await this.app.vault.create(normalizedPath, content);
        }
        return { path, success: true };
      }
      /**
       * Apply file edits using the clean MCP filesystem server approach
       */
      async editFile(params) {
        const { path: filePath, edits, strict = true } = params;
        const normalizedPath = (0, import_obsidian5.normalizePath)(filePath);
        const abstractFile = this.app.vault.getAbstractFileByPath(normalizedPath);
        if (!(abstractFile instanceof import_obsidian5.TFile)) {
          throw new Error(`File not found: ${filePath}`);
        }
        const content = normalizeLineEndings(await this.app.vault.read(abstractFile));
        let modifiedContent = content;
        for (const edit of edits) {
          try {
            modifiedContent = this.applySingleEdit(modifiedContent, edit);
          } catch (e) {
            if (strict) {
              throw e;
            }
          }
        }
        const diff = createSimpleDiff(content, modifiedContent, filePath);
        await this.app.vault.modify(abstractFile, modifiedContent);
        return diff;
      }
      applySingleEdit(source, edit) {
        var _a, _b, _c;
        const text = normalizeLineEndings(source);
        const oldText = normalizeLineEndings(edit.oldText);
        const newText = normalizeLineEndings(edit.newText);
        const mode = edit.mode || "exact";
        const preserveIndent = edit.preserveIndent !== false;
        const { sliceStart, sliceEnd } = this.computeRange(text, edit);
        const head = text.slice(0, sliceStart);
        const target = text.slice(sliceStart, sliceEnd);
        const tail = text.slice(sliceEnd);
        let replaced = target;
        if (edit.isRegex) {
          const flags = edit.flags || "g";
          const regex = new RegExp(oldText, flags.includes("g") ? flags : flags + "g");
          replaced = this.replaceByOccurrenceRegex(target, regex, newText, (_a = edit.occurrence) != null ? _a : "first");
        } else if (mode === "exact") {
          replaced = this.replaceByOccurrenceString(target, oldText, newText, (_b = edit.occurrence) != null ? _b : "first");
        } else {
          replaced = this.replaceLoose(target, oldText, newText, preserveIndent, (_c = edit.occurrence) != null ? _c : "first");
        }
        if (replaced === target) {
          throw new Error("Edit produced no changes");
        }
        return head + replaced + tail;
      }
      computeRange(text, edit) {
        var _a, _b, _c, _d;
        const totalLength = text.length;
        const range = edit.range;
        if (!range) return { sliceStart: 0, sliceEnd: totalLength };
        if (typeof range.startIndex === "number" || typeof range.endIndex === "number") {
          const startIndex = Math.max(0, Math.min(totalLength, (_a = range.startIndex) != null ? _a : 0));
          const endIndex = Math.max(startIndex, Math.min(totalLength, (_b = range.endIndex) != null ? _b : totalLength));
          return { sliceStart: startIndex, sliceEnd: endIndex };
        }
        const lines = text.split("\n");
        const startLine = Math.max(1, (_c = range.startLine) != null ? _c : 1);
        const endLine = Math.max(startLine, (_d = range.endLine) != null ? _d : lines.length);
        let cursor = 0;
        let sliceStart = 0;
        let sliceEnd = totalLength;
        for (let i = 1; i <= lines.length; i++) {
          const line = lines[i - 1];
          const next = cursor + line.length + (i < lines.length ? 1 : 0);
          if (i === startLine) sliceStart = cursor;
          if (i === endLine) {
            sliceEnd = next;
            break;
          }
          cursor = next;
        }
        return { sliceStart, sliceEnd };
      }
      replaceByOccurrenceString(target, find, replacement, occurrence) {
        if (occurrence === "all") {
          return target.split(find).join(replacement);
        }
        if (occurrence === "first") {
          const idx = target.indexOf(find);
          if (idx === -1) return target;
          return target.slice(0, idx) + replacement + target.slice(idx + find.length);
        }
        if (occurrence === "last") {
          const idx = target.lastIndexOf(find);
          if (idx === -1) return target;
          return target.slice(0, idx) + replacement + target.slice(idx + find.length);
        }
        if (typeof occurrence === "number") {
          let count = 0;
          let idx = -1;
          while (true) {
            idx = target.indexOf(find, idx + 1);
            if (idx === -1) return target;
            count++;
            if (count === occurrence) {
              return target.slice(0, idx) + replacement + target.slice(idx + find.length);
            }
          }
        }
        return target;
      }
      replaceByOccurrenceRegex(target, pattern, replacement, occurrence) {
        if (occurrence === "all") {
          return target.replace(pattern, replacement);
        }
        const matches = Array.from(target.matchAll(new RegExp(pattern.source, pattern.flags.includes("g") ? pattern.flags : pattern.flags + "g")));
        if (matches.length === 0) return target;
        let which = 0;
        if (occurrence === "first") which = 0;
        else if (occurrence === "last") which = matches.length - 1;
        else if (typeof occurrence === "number") which = Math.max(0, Math.min(matches.length - 1, occurrence - 1));
        const m = matches[which];
        const start = m.index;
        const end = start + m[0].length;
        return target.slice(0, start) + m[0].replace(new RegExp(pattern.source, pattern.flags.replace("g", "")), replacement) + target.slice(end);
      }
      replaceLoose(target, oldText, newText, preserveIndent, occurrence) {
        const oldLines = oldText.split("\n");
        const tgtLines = target.split("\n");
        const windows = [];
        for (let i = 0; i <= tgtLines.length - oldLines.length; i++) {
          const window2 = tgtLines.slice(i, i + oldLines.length);
          const match = oldLines.every((l, idx) => {
            var _a;
            return l.trim() === ((_a = window2[idx]) != null ? _a : "").trim();
          });
          if (match) windows.push(i);
        }
        if (windows.length === 0) return target;
        const replaceAt = (pos) => {
          var _a;
          const originalIndent = ((_a = tgtLines[pos].match(/^\s*/)) == null ? void 0 : _a[0]) || "";
          const newLines = newText.split("\n").map((line, j) => {
            if (!preserveIndent) return line;
            if (j === 0) return originalIndent + line.trimStart();
            return originalIndent + line.trimStart();
          });
          tgtLines.splice(pos, oldLines.length, ...newLines);
        };
        if (occurrence === "all") {
          for (let k = windows.length - 1; k >= 0; k--) replaceAt(windows[k]);
        } else {
          let indexToUse = 0;
          if (occurrence === "last") indexToUse = windows.length - 1;
          else if (typeof occurrence === "number") indexToUse = Math.max(0, Math.min(windows.length - 1, occurrence - 1));
          replaceAt(windows[indexToUse]);
        }
        return tgtLines.join("\n");
      }
    };
  }
});

// src/mcp-tools/filesystem/tools/DirectoryOperations.ts
var import_obsidian6, DirectoryOperations;
var init_DirectoryOperations = __esm({
  "src/mcp-tools/filesystem/tools/DirectoryOperations.ts"() {
    import_obsidian6 = require("obsidian");
    init_constants();
    init_utils();
    DirectoryOperations = class {
      constructor(app, allowedPaths, plugin) {
        this.app = app;
        this.allowedPaths = allowedPaths;
        this.plugin = plugin;
      }
      /**
       * Create multiple directories
       */
      async createDirectories(params) {
        const { paths } = params;
        if (paths.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Too many directories requested (${paths.length}). Maximum allowed is ${FILESYSTEM_LIMITS.MAX_OPERATIONS}`);
        }
        const results = await Promise.all(paths.map(async (path) => {
          if (!validatePath(path, this.allowedPaths)) {
            return { path, success: false, error: `Access denied: ${path}` };
          }
          const normalizedPath = (0, import_obsidian6.normalizePath)(path);
          try {
            await this.app.vault.createFolder(normalizedPath);
            return { path, success: true };
          } catch (error) {
            const errorMessage = error instanceof Error ? error.message : "Unknown error";
            if (errorMessage.includes("already exists")) {
              return { path, success: true };
            }
            return { path, success: false, error: errorMessage };
          }
        }));
        return { results };
      }
      /**
       * List directory contents, with filtering, sorting, and optional recursion
       */
      async listDirectories(params) {
        const { paths } = params;
        const { filter = "all", sort = "modified", recursive = false } = params;
        if (typeof filter === "object" && filter.semantic) {
          return { results: [{ path: paths[0] || "", error: 'Semantic search has been disabled \u2013 use "Search Note Contents" instead' }] };
        }
        const results = await Promise.all(paths.map(async (path) => {
          try {
            if (!validatePath(path, this.allowedPaths)) {
              return { path, error: `Access denied: ${path}` };
            }
            const MAX_RESULTS = FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS * 3;
            const normalizedPath = path === "/" ? "" : (0, import_obsidian6.normalizePath)(path);
            const folder = normalizedPath ? this.app.vault.getAbstractFileByPath(normalizedPath) : this.app.vault.getRoot();
            if (!folder || !(folder instanceof import_obsidian6.TFolder)) {
              return { path, error: `Directory not found: ${path}` };
            }
            const pathResult = { path };
            if (filter === "all" || filter === "files") {
              pathResult.files = [];
            }
            if (filter === "all" || filter === "directories") {
              pathResult.directories = [];
            }
            let allItems = [];
            const collectItems = (folder2) => {
              for (const child of folder2.children) {
                if (child instanceof import_obsidian6.TFile || child instanceof import_obsidian6.TFolder) {
                  if (child instanceof import_obsidian6.TFile && shouldExcludeFromSearch(child, this.plugin)) {
                    continue;
                  }
                  allItems.push(child);
                  if (recursive && child instanceof import_obsidian6.TFolder) {
                    collectItems(child);
                  }
                }
              }
            };
            collectItems(folder);
            allItems.sort((a, b) => {
              const sortType = sort;
              switch (sortType) {
                case "size":
                  const aSize = a instanceof import_obsidian6.TFile ? a.stat.size : -1;
                  const bSize = b instanceof import_obsidian6.TFile ? b.stat.size : -1;
                  return bSize - aSize;
                // Largest first
                case "name":
                  return a.name.localeCompare(b.name);
                case "created":
                  const aCtime = a instanceof import_obsidian6.TFile ? a.stat.ctime : 0;
                  const bCtime = b instanceof import_obsidian6.TFile ? b.stat.ctime : 0;
                  return bCtime - aCtime;
                // Newest first
                case "modified":
                default:
                  const aMtime = a instanceof import_obsidian6.TFile ? a.stat.mtime : 0;
                  const bMtime = b instanceof import_obsidian6.TFile ? b.stat.mtime : 0;
                  return bMtime - aMtime;
              }
            });
            const children = allItems.slice(0, MAX_RESULTS);
            let fileCount = 0;
            let dirCount = 0;
            let totalSize = 0;
            const PREVIEW_MAX_FILES = 12;
            const PREVIEW_MAX_BYTES = 200 * 1024;
            let previewsGenerated = 0;
            for (const child of children) {
              if (child instanceof import_obsidian6.TFile && pathResult.files) {
                fileCount++;
                totalSize += child.stat.size;
                const fileInfo = {
                  name: child.name,
                  size: child.stat.size,
                  created: new Date(child.stat.ctime).toISOString(),
                  modified: new Date(child.stat.mtime).toISOString(),
                  extension: child.extension
                };
                if (previewsGenerated < PREVIEW_MAX_FILES && (child.extension === "md" || child.extension === "txt") && (child.stat.size || 0) <= PREVIEW_MAX_BYTES) {
                  try {
                    const content = await this.app.vault.cachedRead(child);
                    const lines = content.split("\n").filter((line) => line.trim());
                    fileInfo.preview = lines[0] ? lines[0].length > 150 ? lines[0].substring(0, 150) + "..." : lines[0] : content.length > 150 ? content.substring(0, 150) + "..." : content;
                    previewsGenerated++;
                  } catch (e) {
                  }
                }
                pathResult.files.push(fileInfo);
              } else if (child instanceof import_obsidian6.TFolder && pathResult.directories) {
                dirCount++;
                const folderInfo = {
                  name: child.name,
                  itemCount: child.children.length,
                  modified: void 0
                  // Folders don't have stat in Obsidian API
                };
                pathResult.directories.push(folderInfo);
              }
            }
            const totalItems = allItems.length;
            const itemsShown = Math.min(totalItems, MAX_RESULTS);
            if (totalItems > MAX_RESULTS) {
              pathResult.summary = `Showing ${itemsShown} of ${totalItems} items (${fileCount} files, ${dirCount} folders). Total size: ${formatBytes(totalSize)}. Sorted by: ${sort}${recursive ? " (recursive)" : ""}`;
            } else {
              pathResult.summary = `${totalItems} items (${fileCount} files, ${dirCount} folders). Total size: ${formatBytes(totalSize)}. Sorted by: ${sort}${recursive ? " (recursive)" : ""}`;
            }
            return pathResult;
          } catch (error) {
            return { path, error: error instanceof Error ? error.message : "Unknown error" };
          }
        }));
        return { results };
      }
      /**
       * Move or rename multiple files/folders
       */
      async moveItems(params) {
        const { items } = params;
        if (items.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Cannot move more than ${FILESYSTEM_LIMITS.MAX_OPERATIONS} items at once.`);
        }
        const results = [];
        const CHUNK_SIZE = 5;
        for (let i = 0; i < items.length; i += CHUNK_SIZE) {
          const chunk = items.slice(i, i + CHUNK_SIZE);
          for (const { source, destination } of chunk) {
            try {
              if (!validatePath(source, this.allowedPaths)) {
                throw new Error(`Access denied: ${source}`);
              }
              if (!validatePath(destination, this.allowedPaths)) {
                throw new Error(`Access denied: ${destination}`);
              }
              const sourceFile = this.app.vault.getAbstractFileByPath((0, import_obsidian6.normalizePath)(source));
              if (!sourceFile) {
                throw new Error(`Item not found: ${source}`);
              }
              await this.app.fileManager.renameFile(sourceFile, (0, import_obsidian6.normalizePath)(destination));
              results.push({ source, destination, success: true });
            } catch (error) {
              results.push({ source, destination, success: false, error: (error == null ? void 0 : error.message) || String(error) });
            }
          }
        }
        const ok = results.filter((r) => r.success).length;
        const failed = results.length - ok;
        try {
          if (ok > 0) new import_obsidian6.Notice(`Moved ${ok} item${ok === 1 ? "" : "s"}${failed ? ` (${failed} failed)` : ""}.`);
        } catch (e) {
        }
        return { results };
      }
      /**
       * Move multiple files/folders to trash
       */
      async trashFiles(params) {
        const { paths } = params;
        if (paths.length > FILESYSTEM_LIMITS.MAX_OPERATIONS) {
          throw new Error(`Cannot trash more than ${FILESYSTEM_LIMITS.MAX_OPERATIONS} items at once.`);
        }
        const settled = await runWithConcurrency(paths, async (p) => {
          await this.trashFile(p);
          return { path: p, success: true };
        });
        const results = settled.map((res) => {
          var _a, _b, _c, _d;
          if (res && res.success) return res;
          const errObj = res;
          return {
            path: (_a = errObj == null ? void 0 : errObj.path) != null ? _a : "<unknown>",
            success: false,
            error: (_d = (_c = (_b = errObj == null ? void 0 : errObj.error) == null ? void 0 : _b.message) != null ? _c : errObj == null ? void 0 : errObj.message) != null ? _d : String(errObj)
          };
        });
        const successfulCount = results.filter((r) => r.success).length;
        if (successfulCount > 0) {
          new import_obsidian6.Notice(`Moved ${successfulCount} item(s) to trash.`);
        }
        return { results };
      }
      /**
       * Move a file/folder to trash
       */
      async trashFile(path) {
        if (!validatePath(path, this.allowedPaths)) {
          throw new Error(`Access denied: ${path}`);
        }
        const file = this.app.vault.getAbstractFileByPath((0, import_obsidian6.normalizePath)(path));
        if (!file) {
          throw new Error(`File not found: ${path}`);
        }
        const normalizedPath = (0, import_obsidian6.normalizePath)(file.path);
        await this.app.vault.adapter.trashLocal(normalizedPath);
        return { path, success: true };
      }
    };
  }
});

// src/services/embeddings/utils/TokenEstimator.ts
var TokenEstimator;
var init_TokenEstimator = __esm({
  "src/services/embeddings/utils/TokenEstimator.ts"() {
    TokenEstimator = class {
      /**
       * Estimate token count for a text
       * Uses a conservative estimate of 4 characters per token
       */
      static estimateTokens(text) {
        var _a, _b, _c;
        if (!text || text.length === 0) {
          return 0;
        }
        const words = text.trim().split(/\s+/).filter((w) => w.length > 0);
        const wordCount = words.length;
        const charCount = text.length;
        const urlMatchesRaw = (_a = text.match(/https?:\/\/[^\s)]+/gi)) != null ? _a : [];
        const urlMatches = urlMatchesRaw;
        const urlChars = urlMatches.reduce((sum, m) => sum + m.length, 0);
        const cjkMatchesRaw = (_b = text.match(/[\u4E00-\u9FFF\u3400-\u4DBF\u3040-\u30FF\uAC00-\uD7AF]/g)) != null ? _b : [];
        const cjkMatches = cjkMatchesRaw;
        const cjkChars = cjkMatches.length;
        const emojiMatchesRaw = (_c = text.match(/[\u{1F300}-\u{1FAFF}\u{2600}-\u{27BF}]/gu)) != null ? _c : [];
        const emojiMatches = emojiMatchesRaw;
        const emojiCount = emojiMatches.length;
        const urlTokens = urlChars > 0 ? urlChars / 3.2 : 0;
        const cjkTokens = cjkChars;
        const emojiTokens = emojiCount * 2;
        const nonSpecialChars = Math.max(0, charCount - urlChars - cjkChars - emojiCount);
        const baseTokens = nonSpecialChars / this.CHARS_PER_TOKEN;
        const charBasedEstimate = urlTokens + cjkTokens + emojiTokens + baseTokens;
        const wordBasedEstimate = wordCount * 1.3;
        return Math.ceil(Math.max(wordBasedEstimate, charBasedEstimate));
      }
      /**
       * Calculate optimal batch size based on text lengths
       */
      static calculateOptimalBatchSize(texts) {
        if (texts.length === 0) return 0;
        const tokenCounts = texts.map((text) => this.estimateTokens(text));
        tokenCounts.sort((a, b) => b - a);
        const maxTokensAllowed = this.MAX_TOKENS_PER_REQUEST * this.SAFETY_MARGIN;
        let batchSize = 0;
        let totalTokens = 0;
        for (const tokens of tokenCounts) {
          if (totalTokens + tokens <= maxTokensAllowed && batchSize < this.MAX_BATCH_SIZE) {
            totalTokens += tokens;
            batchSize++;
          } else {
            break;
          }
        }
        return Math.max(1, batchSize);
      }
      /**
       * Create optimized batches that respect token limits
       */
      static createOptimizedBatches(items) {
        if (items.length === 0) return [];
        const batches = [];
        let currentBatch = [];
        let currentTokenCount = 0;
        const maxTokensAllowed = this.MAX_TOKENS_PER_REQUEST * this.SAFETY_MARGIN;
        const sortedItems = [...items].sort(
          (a, b) => a.content.length - b.content.length
        );
        for (const item of sortedItems) {
          const itemTokens = this.estimateTokens(item.content);
          if (itemTokens > maxTokensAllowed) {
            if (currentBatch.length > 0) {
              batches.push(currentBatch);
              currentBatch = [];
              currentTokenCount = 0;
            }
            batches.push([item]);
            continue;
          }
          if (currentTokenCount + itemTokens > maxTokensAllowed || currentBatch.length >= this.MAX_BATCH_SIZE) {
            batches.push(currentBatch);
            currentBatch = [item];
            currentTokenCount = itemTokens;
          } else {
            currentBatch.push(item);
            currentTokenCount += itemTokens;
          }
        }
        if (currentBatch.length > 0) {
          batches.push(currentBatch);
        }
        return batches;
      }
      /**
       * Truncate text to fit within token limit
       */
      static truncateToTokenLimit(text, maxTokens) {
        const limit = maxTokens || this.MAX_TOKENS_PER_REQUEST * this.SAFETY_MARGIN;
        const estimatedTokens = this.estimateTokens(text);
        if (estimatedTokens <= limit) {
          return text;
        }
        const charLimit = Math.floor(limit * this.CHARS_PER_TOKEN * 0.9);
        return text.substring(0, charLimit) + "...";
      }
      /**
       * Get statistics for batch optimization
       */
      static getBatchStatistics(texts) {
        if (texts.length === 0) {
          return {
            totalTexts: 0,
            totalEstimatedTokens: 0,
            averageTokensPerText: 0,
            maxTokensInSingleText: 0,
            recommendedBatchSize: 0,
            estimatedBatches: 0
          };
        }
        const tokenCounts = texts.map((text) => this.estimateTokens(text));
        const totalTokens = tokenCounts.reduce((sum, count) => sum + count, 0);
        const maxTokens = Math.max(...tokenCounts);
        const avgTokens = totalTokens / texts.length;
        const recommendedBatchSize = this.calculateOptimalBatchSize(texts);
        const estimatedBatches = Math.ceil(texts.length / recommendedBatchSize);
        return {
          totalTexts: texts.length,
          totalEstimatedTokens: totalTokens,
          averageTokensPerText: Math.round(avgTokens),
          maxTokensInSingleText: maxTokens,
          recommendedBatchSize,
          estimatedBatches
        };
      }
    };
    // Average characters per token (conservative estimate)
    TokenEstimator.CHARS_PER_TOKEN = 4;
    // OpenAI embeddings model limits
    TokenEstimator.MAX_TOKENS_PER_REQUEST = 8191;
    // Safety margin to avoid edge cases (10% buffer)
    TokenEstimator.SAFETY_MARGIN = 0.9;
    // Maximum batch size (API limit)
    TokenEstimator.MAX_BATCH_SIZE = 50;
  }
});

// src/utils/jsonRepair.ts
var jsonRepair_exports = {};
__export(jsonRepair_exports, {
  normalizeJsonString: () => normalizeJsonString,
  repairAndParseJson: () => repairAndParseJson
});
function repairAndParseJson(input) {
  try {
    if (input == null) return { ok: true, value: {} };
    if (typeof input === "object") return { ok: true, value: input };
    if (typeof input !== "string") return { ok: true, value: {} };
    const original = input.trim();
    if (original.length === 0) return { ok: true, value: {} };
    try {
      return { ok: true, value: JSON.parse(original) };
    } catch (e) {
    }
    let candidate = original;
    if (candidate.includes("'") && !candidate.includes('"')) {
      candidate = candidate.replace(/'([^'\\]*(?:\\.[^'\\]*)*)'/g, '"$1"');
    }
    if (!/^[\[{]/.test(candidate) && /\w\s*:\s*/.test(candidate)) {
      candidate = `{${candidate}}`;
    }
    candidate = candidate.replace(/([,{\s])([A-Za-z_][A-Za-z0-9_\-]*)\s*:/g, '$1"$2":');
    candidate = candidate.replace(/,\s*([}\]])/g, "$1");
    candidate = balanceDelimiters(candidate);
    try {
      return { ok: true, value: JSON.parse(candidate) };
    } catch (e) {
      return { ok: false, error: (e == null ? void 0 : e.message) || "Invalid JSON" };
    }
  } catch (e) {
    return { ok: false, error: (e == null ? void 0 : e.message) || "Invalid JSON" };
  }
}
function normalizeJsonString(input) {
  var _a;
  const result = repairAndParseJson(input);
  if (result.ok) {
    try {
      return JSON.stringify((_a = result.value) != null ? _a : {});
    } catch (e) {
    }
  }
  return "{}";
}
function balanceDelimiters(text) {
  let openCurly = 0;
  let closeCurly = 0;
  let openSquare = 0;
  let closeSquare = 0;
  for (const ch of text) {
    if (ch === "{") openCurly++;
    else if (ch === "}") closeCurly++;
    else if (ch === "[") openSquare++;
    else if (ch === "]") closeSquare++;
  }
  let result = text;
  for (let i = 0; i < Math.max(0, openSquare - closeSquare); i++) result += "]";
  for (let i = 0; i < Math.max(0, openCurly - closeCurly); i++) result += "}";
  return result;
}
var init_jsonRepair = __esm({
  "src/utils/jsonRepair.ts"() {
  }
});

// src/utils/tokenCounting.ts
function ensureTokenizerLoading() {
  if (attemptedTokenizerLoad) return;
  attemptedTokenizerLoad = true;
  import("gpt-tokenizer/esm/encoding").then((mod) => {
    if (mod && typeof mod.encode === "function") {
      encodeImpl = (text) => mod.encode(text);
    }
  }).catch(() => {
  });
}
function countTextTokens(text) {
  if (!text) return 0;
  ensureTokenizerLoading();
  const cached = tokenCache.get(text);
  if (cached !== void 0) return cached;
  let tokens;
  try {
    if (encodeImpl) {
      tokens = encodeImpl(text).length;
    } else {
      tokens = TokenEstimator.estimateTokens(text);
    }
  } catch (e) {
    tokens = TokenEstimator.estimateTokens(text);
  }
  tokenCache.set(text, tokens);
  return tokens;
}
function contentToText(content) {
  if (typeof content === "string") return content;
  if (Array.isArray(content)) {
    let buffer = "";
    for (const part of content) {
      if ((part == null ? void 0 : part.type) === "text") {
        buffer += part.text || "";
        buffer += "\n";
      }
    }
    return buffer.trim();
  }
  return "";
}
function countMessageTokens(message) {
  if (!message) return 0;
  let total = 0;
  total += 3;
  if ("content" in message) {
    total += countTextTokens(contentToText(message.content));
  }
  if (Array.isArray(message.tool_calls)) {
    try {
      const serialized = JSON.stringify(message.tool_calls);
      total += countTextTokens(serialized);
    } catch (e) {
      total += 0;
    }
  }
  if (message.role === "tool" && typeof message.content === "string") {
    total += countTextTokens(message.content);
  }
  return total;
}
function countMessagesTokens(messages) {
  if (!messages || messages.length === 0) return 0;
  let total = 0;
  for (const m of messages) total += countMessageTokens(m);
  total += Math.max(0, messages.length - 1) * 2;
  return total;
}
function countRequestTokens(body) {
  if (!body || typeof body !== "object") return 0;
  let total = 0;
  if (typeof body.system === "string") {
    total += countTextTokens(body.system);
  }
  if (Array.isArray(body.messages)) {
    total += countMessagesTokens(body.messages);
  }
  if (Array.isArray(body.tools) && body.tools.length > 0) {
    try {
      const brief = JSON.stringify(body.tools.slice(0, 10));
      total += Math.min(countTextTokens(brief), 2e3);
    } catch (e) {
    }
  }
  if (body.web_search_options) {
    try {
      total += countTextTokens(JSON.stringify(body.web_search_options));
    } catch (e) {
    }
  }
  if (Array.isArray(body.plugins) && body.plugins.length > 0) {
    try {
      total += countTextTokens(JSON.stringify(body.plugins));
    } catch (e) {
    }
  }
  return total;
}
function estimateTokens(text) {
  return countTextTokens(text);
}
function calculateOptimalBatchSize(texts) {
  if (!texts || texts.length === 0) return 0;
  const tokenCounts = texts.map((t) => estimateTokens(t)).sort((a, b) => b - a);
  const maxTokensAllowed = MAX_TOKENS_PER_REQUEST * SAFETY_MARGIN;
  let batchSize = 0;
  let total = 0;
  for (const n of tokenCounts) {
    if (total + n <= maxTokensAllowed && batchSize < MAX_BATCH_SIZE) {
      total += n;
      batchSize++;
    } else {
      break;
    }
  }
  return Math.max(1, batchSize);
}
function createOptimizedBatches(items) {
  if (!items || items.length === 0) return [];
  const batches = [];
  let current = [];
  let currentTokens = 0;
  const maxTokensAllowed = MAX_TOKENS_PER_REQUEST * SAFETY_MARGIN;
  const sorted = [...items].sort((a, b) => a.content.length - b.content.length);
  for (const item of sorted) {
    const itemTokens = estimateTokens(item.content);
    if (itemTokens > maxTokensAllowed) {
      if (current.length > 0) {
        batches.push(current);
        current = [];
        currentTokens = 0;
      }
      batches.push([item]);
      continue;
    }
    if (currentTokens + itemTokens > maxTokensAllowed || current.length >= MAX_BATCH_SIZE) {
      batches.push(current);
      current = [item];
      currentTokens = itemTokens;
    } else {
      current.push(item);
      currentTokens += itemTokens;
    }
  }
  if (current.length > 0) batches.push(current);
  return batches;
}
function truncateToTokenLimit(text, maxTokens) {
  const limit = maxTokens || MAX_TOKENS_PER_REQUEST * SAFETY_MARGIN;
  const est = estimateTokens(text);
  if (est <= limit) return text;
  const charLimit = Math.floor(limit * HEURISTIC_CHARS_PER_TOKEN * 0.9);
  return text.substring(0, Math.max(0, charLimit)) + "...";
}
function getBatchStatistics(texts) {
  if (!texts || texts.length === 0) {
    return {
      totalTexts: 0,
      totalEstimatedTokens: 0,
      averageTokensPerText: 0,
      maxTokensInSingleText: 0,
      recommendedBatchSize: 0,
      estimatedBatches: 0
    };
  }
  const counts = texts.map((t) => estimateTokens(t));
  const total = counts.reduce((s, n) => s + n, 0);
  const max = Math.max(...counts);
  const avg = total / texts.length;
  const recommended = calculateOptimalBatchSize(texts);
  const batches = Math.ceil(texts.length / (recommended || 1));
  return {
    totalTexts: texts.length,
    totalEstimatedTokens: total,
    averageTokensPerText: Math.round(avg),
    maxTokensInSingleText: max,
    recommendedBatchSize: recommended,
    estimatedBatches: batches
  };
}
function countToolCallPayloadTokens(toolCall) {
  var _a, _b, _c;
  try {
    const fn = ((_a = toolCall == null ? void 0 : toolCall.request) == null ? void 0 : _a.function) || (toolCall == null ? void 0 : toolCall.function) || ((_c = (_b = toolCall == null ? void 0 : toolCall.request) == null ? void 0 : _b.tool) == null ? void 0 : _c.function);
    const name = String((fn == null ? void 0 : fn.name) || "");
    let argsStr = "";
    try {
      const ra = fn == null ? void 0 : fn.arguments;
      argsStr = typeof ra === "string" ? normalizeJsonString(ra) : normalizeJsonString(ra != null ? ra : {});
    } catch (e) {
      argsStr = "";
    }
    const normalized = {
      type: "function",
      function: { name, arguments: argsStr }
    };
    if (toolCall == null ? void 0 : toolCall.id) normalized.id = toolCall.id;
    return countTextTokens(JSON.stringify(normalized));
  } catch (e) {
    return 0;
  }
}
var LruCache, attemptedTokenizerLoad, encodeImpl, tokenCache, HEURISTIC_CHARS_PER_TOKEN, MAX_TOKENS_PER_REQUEST, SAFETY_MARGIN, MAX_BATCH_SIZE;
var init_tokenCounting = __esm({
  "src/utils/tokenCounting.ts"() {
    init_TokenEstimator();
    init_jsonRepair();
    LruCache = class {
      constructor(maxEntries) {
        this.maxEntries = Math.max(50, maxEntries);
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value !== void 0) {
          this.map.delete(key);
          this.map.set(key, value);
        }
        return value;
      }
      set(key, value) {
        if (this.map.has(key)) {
          this.map.delete(key);
        }
        this.map.set(key, value);
        if (this.map.size > this.maxEntries) {
          const firstKey = this.map.keys().next().value;
          if (firstKey !== void 0) {
            this.map.delete(firstKey);
          }
        }
      }
    };
    attemptedTokenizerLoad = false;
    encodeImpl = null;
    tokenCache = new LruCache(1e3);
    HEURISTIC_CHARS_PER_TOKEN = 4;
    MAX_TOKENS_PER_REQUEST = 8191;
    SAFETY_MARGIN = 0.9;
    MAX_BATCH_SIZE = 50;
  }
});

// src/mcp-tools/filesystem/searchScoring.ts
function extractSearchTerms(query) {
  const terms = query.toLowerCase().split(/[\s\-_]+/).filter((term) => term.length > 0);
  const variations = [];
  variations.push(...terms);
  if (terms.length > 1) {
    variations.push(terms.map(
      (t, i) => i === 0 ? t : t.charAt(0).toUpperCase() + t.slice(1)
    ).join(""));
    variations.push(terms.map(
      (t) => t.charAt(0).toUpperCase() + t.slice(1)
    ).join(""));
  }
  if (terms.length > 1) {
    variations.push(terms.join("_"));
  }
  if (terms.length > 1) {
    variations.push(terms.join("-"));
  }
  return [...new Set(variations)];
}
function calculateScore(filePath, content, context) {
  const filename = filePath.split("/").pop() || "";
  const pathParts = filePath.toLowerCase().split("/");
  const lowerContent = (content == null ? void 0 : content.toLowerCase()) || "";
  let score = 0;
  const keywordsFound = [];
  const matchLocations = [];
  const reasons = [];
  for (const term of context.searchTerms) {
    const lowerTerm = term.toLowerCase();
    let termFound = false;
    if (filename.toLowerCase().includes(lowerTerm)) {
      score += 40;
      termFound = true;
      if (!matchLocations.includes("filename")) {
        matchLocations.push("filename");
      }
      reasons.push(`"${term}" in filename (+40)`);
    }
    if (pathParts.some((part) => part.includes(lowerTerm))) {
      score += 20;
      termFound = true;
      if (!matchLocations.includes("path")) {
        matchLocations.push("path");
      }
      reasons.push(`"${term}" in path (+20)`);
    }
    if (lowerContent.includes(lowerTerm)) {
      score += 10;
      termFound = true;
      if (!matchLocations.includes("content")) {
        matchLocations.push("content");
      }
      reasons.push(`"${term}" in content (+10)`);
    }
    if (termFound && !keywordsFound.includes(term)) {
      keywordsFound.push(term);
    }
  }
  const originalTerms = context.originalQuery.toLowerCase().split(/[\s\-_]+/).filter((t) => t.length > 0);
  const foundOriginalTerms = originalTerms.filter(
    (term) => filename.toLowerCase().includes(term) || pathParts.some((part) => part.includes(term)) || lowerContent.includes(term)
  );
  if (foundOriginalTerms.length === originalTerms.length && originalTerms.length > 1) {
    score += 30;
    reasons.push(`All original terms found (+30)`);
  }
  if (content && content.toLowerCase().includes(context.originalQuery.toLowerCase())) {
    score += 20;
    reasons.push(`Exact phrase match (+20)`);
  }
  const relevantPaths = ["email", "campaign", "marketing", "draft", "template", "brand"];
  const pathBonus = relevantPaths.filter(
    (rp) => pathParts.some((part) => part.includes(rp))
  ).length * 5;
  if (pathBonus > 0) {
    score += pathBonus;
    reasons.push(`Relevant directory (+${pathBonus})`);
  }
  const penaltyPaths = ["archive", "backup", "old", "legacy", "deprecated"];
  const pathPenalty = penaltyPaths.filter(
    (pp) => pathParts.some((part) => part.includes(pp))
  ).length * 10;
  if (pathPenalty > 0) {
    score -= pathPenalty;
    reasons.push(`Archive/backup directory (-${pathPenalty})`);
  }
  score = Math.min(100, Math.max(0, score));
  const keywordsMissing = originalTerms.filter(
    (term) => !keywordsFound.map((k) => k.toLowerCase()).includes(term.toLowerCase())
  );
  return {
    file: filename,
    path: filePath,
    score,
    matchDetails: {
      keywordsFound,
      keywordsMissing,
      matchLocations,
      reasoning: reasons.join(", ")
    }
  };
}
function sortByScore(results) {
  return results.sort((a, b) => b.score - a.score);
}
function formatScoredResults(results, maxResults = 25) {
  var _a, _b, _c;
  const topResults = results.slice(0, maxResults);
  return {
    results: topResults.map((r) => ({
      file: r.file,
      path: r.path,
      score: r.score,
      reasoning: r.matchDetails.reasoning,
      keywordsFound: r.matchDetails.keywordsFound,
      keywordsMissing: r.matchDetails.keywordsMissing,
      contexts: r.contexts,
      created: r.created,
      modified: r.modified,
      fileSize: r.fileSize
    })),
    totalFound: results.length,
    searchSummary: {
      topScore: ((_a = topResults[0]) == null ? void 0 : _a.score) || 0,
      averageScore: topResults.length > 0 ? Math.round(topResults.reduce((sum, r) => sum + r.score, 0) / topResults.length) : 0,
      confidenceLevel: ((_b = topResults[0]) == null ? void 0 : _b.score) >= 70 ? "high" : ((_c = topResults[0]) == null ? void 0 : _c.score) >= 40 ? "medium" : "low"
    }
  };
}
var init_searchScoring = __esm({
  "src/mcp-tools/filesystem/searchScoring.ts"() {
  }
});

// src/mcp-tools/filesystem/tools/SearchOperations.ts
var import_obsidian7, SearchOperations;
var init_SearchOperations = __esm({
  "src/mcp-tools/filesystem/tools/SearchOperations.ts"() {
    import_obsidian7 = require("obsidian");
    init_constants();
    init_tokenCounting();
    init_utils();
    init_searchScoring();
    SearchOperations = class {
      constructor(app, allowedPaths, plugin) {
        this.app = app;
        this.allowedPaths = allowedPaths;
        this.plugin = plugin;
      }
      normalizeStringArray(input) {
        if (!Array.isArray(input)) return [];
        return input.map((v) => typeof v === "string" ? v : String(v != null ? v : "")).map((s) => s.trim()).filter((s) => s.length > 0);
      }
      /**
       * Search for files and directories by name patterns - with intelligent scoring
       */
      async findFiles(params) {
        const patterns = this.normalizeStringArray(params == null ? void 0 : params.patterns);
        if (patterns.length === 0) {
          throw new Error(`Missing required 'patterns'. Provide one or more search terms, e.g., ["cloudflare", "CF_API_TOKEN"].`);
        }
        const originalQuery = patterns.join(" ");
        const searchTerms = extractSearchTerms(originalQuery);
        const scoredResults = [];
        const files = this.app.vault.getFiles();
        for (const file of files) {
          if (shouldExcludeFromSearch(file, this.plugin)) {
            continue;
          }
          const scoreResult = calculateScore(file.path, "", {
            searchTerms,
            originalQuery
          });
          scoreResult.created = new Date(file.stat.ctime).toISOString();
          scoreResult.modified = new Date(file.stat.mtime).toISOString();
          scoreResult.fileSize = file.stat.size;
          scoredResults.push(scoreResult);
        }
        const searchFolder = (folder) => {
          var _a, _b;
          for (const child of folder.children) {
            if (child instanceof import_obsidian7.TFolder) {
              const scoreResult = calculateScore(child.path, "", {
                searchTerms,
                originalQuery
              });
              const created = ((_a = child.stat) == null ? void 0 : _a.ctime) ? new Date(child.stat.ctime).toISOString() : void 0;
              const modified = ((_b = child.stat) == null ? void 0 : _b.mtime) ? new Date(child.stat.mtime).toISOString() : void 0;
              if (created) scoreResult.created = created;
              if (modified) scoreResult.modified = modified;
              scoredResults.push(scoreResult);
              searchFolder(child);
            }
          }
        };
        const rootFolder = this.app.vault.getRoot();
        searchFolder(rootFolder);
        const sortedResults = sortByScore(scoredResults);
        return formatScoredResults(sortedResults, FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS * 3);
      }
      /**
       * Search within note contents using one or more search terms (regex supported) - with intelligent scoring
       */
      async grepVault(params) {
        var _a;
        const patterns = this.normalizeStringArray(params == null ? void 0 : params.patterns);
        const searchIn = (_a = params == null ? void 0 : params.searchIn) != null ? _a : "content";
        const requestedPageTokens = Math.max(512, Math.min(4096, Number((params == null ? void 0 : params.pageTokens) || FILESYSTEM_LIMITS.MAX_TOOL_RESULT_TOKENS)));
        const bodyTokenBudget = Math.max(256, requestedPageTokens - FILESYSTEM_LIMITS.GREP_FOOTER_TOKENS);
        if (patterns.length === 0) {
          throw new Error(`Missing required 'patterns'. Add one or more words or regex patterns, e.g., ["cloudflare", "api key"].`);
        }
        const originalQuery = patterns.join(" ");
        const searchTerms = extractSearchTerms(originalQuery);
        const metaResults = [];
        const fileHits = [];
        const MAX_CHARS = FILESYSTEM_LIMITS.MAX_RESPONSE_CHARS;
        let currentSize = 0;
        let truncated = false;
        const CONTEXT_CHARS = FILESYSTEM_LIMITS.CONTEXT_CHARS;
        const BATCH_SIZE = FILESYSTEM_LIMITS.BATCH_SIZE;
        const MAX_PROCESSING_TIME = FILESYSTEM_LIMITS.MAX_PROCESSING_TIME;
        const MAX_FILE_SIZE3 = FILESYSTEM_LIMITS.MAX_FILE_SIZE;
        const MAX_MATCHES_PER_FILE = FILESYSTEM_LIMITS.MAX_MATCHES_PER_FILE;
        const metrics = {
          filesProcessed: 0,
          filesSkipped: 0,
          totalMatches: 0,
          processingTime: 0,
          largestFile: 0,
          timeouts: 0
        };
        const startTime = Date.now();
        const getFiles = () => {
          var _a2, _b, _c;
          const plugin = (_b = (_a2 = this.app.plugins) == null ? void 0 : _a2.plugins) == null ? void 0 : _b["systemsculpt-ai"];
          try {
            return ((_c = plugin == null ? void 0 : plugin.vaultFileCache) == null ? void 0 : _c.getMarkdownFiles()) || this.app.vault.getMarkdownFiles();
          } catch (_) {
            return [];
          }
        };
        let filesToSearch = getFiles();
        filesToSearch = filesToSearch.filter((file) => !shouldExcludeFromSearch(file, this.plugin));
        filesToSearch.sort((a, b) => {
          var _a2, _b;
          return (((_a2 = a.stat) == null ? void 0 : _a2.size) || 0) - (((_b = b.stat) == null ? void 0 : _b.size) || 0);
        });
        let resultsCount = 0;
        const processFile = async (file) => {
          var _a2, _b;
          if (resultsCount >= FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
            return;
          }
          if (Date.now() - startTime > MAX_PROCESSING_TIME) {
            metrics.timeouts++;
            return;
          }
          if (file.stat && file.stat.size > MAX_FILE_SIZE3) {
            metrics.filesSkipped++;
            return;
          }
          if (file.stat && file.stat.size > metrics.largestFile) {
            metrics.largestFile = file.stat.size;
          }
          let hasPathMatch = false;
          for (const pattern of patterns) {
            try {
              const regex = new RegExp(pattern, "i");
              if (regex.test(file.path)) {
                hasPathMatch = true;
                break;
              }
            } catch (e) {
            }
          }
          if (hasPathMatch) {
            const fileResult = {
              file: file.path,
              created: new Date(file.stat.ctime).toISOString(),
              modified: new Date(file.stat.mtime).toISOString(),
              totalMatches: 0,
              contexts: [],
              fileSize: ((_a2 = file.stat) == null ? void 0 : _a2.size) || 0,
              pathMatchOnly: true
            };
            if (!wouldExceedCharLimit(currentSize, fileResult, MAX_CHARS)) {
              fileHits.push(fileResult);
              currentSize += JSON.stringify(fileResult).length;
              resultsCount++;
            } else {
              truncated = true;
            }
            if (resultsCount >= FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
              return;
            }
          }
          try {
            const fullContent = await this.app.vault.cachedRead(file);
            metrics.filesProcessed++;
            if (!fullContent || fullContent.length === 0) {
              return;
            }
            let content = fullContent;
            let contentOffset = 0;
            if (searchIn === "frontmatter" || searchIn === "both") {
              const frontmatterMatch = fullContent.match(/^---\n([\s\S]*?)\n---/);
              if (frontmatterMatch) {
                if (searchIn === "frontmatter") {
                  content = frontmatterMatch[0];
                }
              } else if (searchIn === "frontmatter") {
                return;
              }
            } else if (searchIn === "content") {
              const frontmatterMatch = fullContent.match(/^---\n[\s\S]*?\n---\n/);
              if (frontmatterMatch) {
                content = fullContent.substring(frontmatterMatch[0].length);
                contentOffset = frontmatterMatch[0].length;
              }
            }
            const getLineNumber = createLineCalculator(fullContent);
            const allMatches = [];
            for (const pattern of patterns) {
              const regex = new RegExp(pattern, "gi");
              let match;
              while ((match = regex.exec(content)) !== null && allMatches.length < MAX_MATCHES_PER_FILE) {
                const lineNumber = getLineNumber(match.index + contentOffset);
                allMatches.push({
                  index: match.index + contentOffset,
                  text: match[0],
                  line: lineNumber,
                  pattern
                });
                metrics.totalMatches++;
              }
              regex.lastIndex = 0;
              if (allMatches.length >= MAX_MATCHES_PER_FILE) break;
            }
            if (allMatches.length === 0) {
              return;
            }
            if (resultsCount < FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
              const contextWindows = [];
              for (const matchInfo of allMatches) {
                const matchStart = matchInfo.index;
                const matchEnd = matchStart + matchInfo.text.length;
                let contextStart = Math.max(0, matchStart - CONTEXT_CHARS);
                let contextEnd = Math.min(content.length, matchEnd + CONTEXT_CHARS);
                let adjustments = 0;
                while (contextStart > 0 && content[contextStart - 1].match(/\w/) && adjustments < 50) {
                  contextStart--;
                  adjustments++;
                }
                adjustments = 0;
                while (contextEnd < content.length && content[contextEnd].match(/\w/) && adjustments < 50) {
                  contextEnd++;
                  adjustments++;
                }
                let merged = false;
                for (let i2 = 0; i2 < contextWindows.length; i2++) {
                  const window2 = contextWindows[i2];
                  if (contextStart <= window2.end && contextEnd >= window2.start) {
                    window2.start = Math.min(window2.start, contextStart);
                    window2.end = Math.max(window2.end, contextEnd);
                    window2.lines.push(matchInfo.line);
                    window2.matchCount++;
                    merged = true;
                    break;
                  }
                }
                if (!merged) {
                  contextWindows.push({
                    start: contextStart,
                    end: contextEnd,
                    lines: [matchInfo.line],
                    matchCount: 1
                  });
                }
              }
              const fileResults = contextWindows.map((window2) => {
                let contextStr = content.substring(window2.start, window2.end);
                for (const pattern of patterns) {
                  contextStr = contextStr.replace(new RegExp(pattern, "gi"), "\u3010$&\u3011");
                }
                if (window2.start > 0) contextStr = "..." + contextStr;
                if (window2.end < content.length) contextStr = contextStr + "...";
                return {
                  lines: window2.lines,
                  matchCount: window2.matchCount,
                  context: contextStr
                };
              });
              if (fileResults.length > 0) {
                const fileResult = {
                  file: file.path,
                  created: new Date(file.stat.ctime).toISOString(),
                  modified: new Date(file.stat.mtime).toISOString(),
                  totalMatches: allMatches.length,
                  contexts: fileResults,
                  fileSize: ((_b = file.stat) == null ? void 0 : _b.size) || 0
                  // used for ranking
                };
                if (!wouldExceedCharLimit(currentSize, fileResult, MAX_CHARS)) {
                  fileHits.push(fileResult);
                  currentSize += JSON.stringify(fileResult).length;
                  resultsCount++;
                } else {
                  truncated = true;
                }
              }
            }
          } catch (err) {
            metrics.filesSkipped++;
          }
        };
        for (let i2 = 0; i2 < filesToSearch.length; i2 += BATCH_SIZE) {
          if (Date.now() - startTime > MAX_PROCESSING_TIME) {
            metaResults.push({
              file: "_timeout",
              message: `Search timed out after ${MAX_PROCESSING_TIME / 1e3} seconds to prevent UI freeze. Found ${resultsCount} results. Use more specific search terms or paths.`,
              totalMatches: metrics.totalMatches,
              contexts: []
            });
            break;
          }
          if (resultsCount >= FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS) {
            metaResults.push({
              file: "_summary",
              message: `Search stopped after ${FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS} files with matches. More results may exist.`,
              totalMatches: metrics.totalMatches,
              contexts: []
            });
            break;
          }
          const batch = filesToSearch.slice(i2, i2 + BATCH_SIZE);
          await Promise.all(batch.map((file) => processFile(file)));
          await new Promise((resolve) => setTimeout(resolve, 0));
        }
        metrics.processingTime = Date.now() - startTime;
        if (metrics.processingTime > 2e3 || metrics.filesSkipped > 10 || metrics.timeouts > 0) {
          metaResults.push({
            file: "_performance",
            message: `Search completed in ${metrics.processingTime}ms. Processed: ${metrics.filesProcessed} files, Skipped: ${metrics.filesSkipped} files, Total matches: ${metrics.totalMatches}. Largest file: ${Math.round(metrics.largestFile / 1024)}KB.`,
            totalMatches: metrics.totalMatches,
            contexts: []
          });
        }
        if (fileHits.length === 0) {
          metaResults.push({
            file: "_no_matches",
            message: `No matches found for: ${patterns.map((p) => `"${p}"`).join(", ")}. Try different words, adjust where you search (text vs. properties), or limit the search to a specific folder for speed.`,
            totalMatches: 0,
            contexts: []
          });
        }
        const scoredResults = [];
        for (const hit of fileHits) {
          let contentSnippet = "";
          if (hit.contexts && hit.contexts.length > 0) {
            contentSnippet = hit.contexts.map((c) => c.context).join(" ");
          }
          const scoreResult = calculateScore(hit.file, contentSnippet, {
            searchTerms,
            originalQuery
          });
          scoreResult.created = hit.created;
          scoreResult.modified = hit.modified;
          scoreResult.fileSize = hit.fileSize;
          scoreResult.contexts = hit.contexts;
          if (hit.totalMatches > 0) {
            const matchBonus = Math.min(20, hit.totalMatches * 2);
            scoreResult.score = Math.min(100, scoreResult.score + matchBonus);
            scoreResult.matchDetails.reasoning += `, ${hit.totalMatches} content matches (+${matchBonus})`;
          }
          scoredResults.push(scoreResult);
        }
        const now = Date.now();
        for (const r of scoredResults) {
          if (r.modified) {
            const days = Math.max(0, (now - new Date(r.modified).getTime()) / 864e5);
            const recencyBonus = Math.max(0, Math.min(20, Math.round(20 * (30 / (30 + days)))));
            r.score = Math.min(100, r.score + recencyBonus);
          }
        }
        const sortedResults = sortByScore(scoredResults);
        const makeSnippets = () => {
          const snippets = [];
          const seen = /* @__PURE__ */ new Set();
          for (const r of sortedResults) {
            const ctxs = r.contexts || [];
            for (const c of ctxs) {
              const line = Array.isArray(c.lines) && c.lines.length > 0 ? Math.min(...c.lines) : 1;
              const text = `${r.path}:${line}  ${c.context}`;
              const key = `${r.path}|${line}|${c.context}`;
              if (seen.has(key)) continue;
              seen.add(key);
              snippets.push({ path: r.path, line, text });
            }
          }
          return snippets;
        };
        const allSnippets = makeSnippets();
        const totalSnippetCount = allSnippets.length;
        const buildOrder = (n) => {
          const head = Math.ceil(n * 0.3);
          const tail = Math.ceil(n * 0.3);
          const order2 = [];
          for (let i2 = 0; i2 < Math.min(head, n); i2++) order2.push(i2);
          for (let i2 = Math.max(n - tail, head); i2 < n; i2++) order2.push(i2);
          for (let i2 = head; i2 < Math.max(n - tail, head); i2++) order2.push(i2);
          return order2;
        };
        const order = buildOrder(allSnippets.length);
        const encodeCursor = (state) => {
          try {
            return Buffer.from(JSON.stringify(state)).toString("base64");
          } catch (e) {
            return "";
          }
        };
        const decodeCursor = (cursor) => {
          if (!cursor || typeof cursor !== "string") return null;
          try {
            return JSON.parse(Buffer.from(cursor, "base64").toString("utf8"));
          } catch (e) {
            return null;
          }
        };
        const qId = `${searchIn}|${patterns.join("")}`;
        const cursorState = decodeCursor(params == null ? void 0 : params.cursor);
        const startOffset = cursorState && cursorState.q === qId && Number.isFinite(cursorState.o) ? Math.max(0, Math.min(order.length, cursorState.o)) : 0;
        let usedTokens = 0;
        const included = [];
        let i = startOffset;
        for (; i < order.length; i++) {
          const idx = order[i];
          const snip = allSnippets[idx];
          const t = countTextTokens(snip.text);
          if (usedTokens + t > bodyTokenBudget) break;
          included.push(snip);
          usedTokens += t;
        }
        const remainingCount = order.length - i;
        let omittedTokens = 0;
        if (remainingCount > 0) {
          for (let j = i; j < order.length; j++) {
            omittedTokens += countTextTokens(allSnippets[order[j]].text);
          }
        }
        const formattedResults = formatScoredResults(sortedResults, FILESYSTEM_LIMITS.MAX_SEARCH_RESULTS);
        if (metaResults.length > 0) formattedResults.metaInfo = metaResults;
        if (truncated) {
          formattedResults.truncated = true;
          formattedResults.notice = `Results were truncated to stay within the ${MAX_CHARS} character response cap.`;
        }
        const sliceText = included.map((s) => s.text);
        const footerNote = remainingCount > 0 ? `...[omitted ${omittedTokens} tokens across ${remainingCount} matches]` : "";
        const nextCursor = i < order.length ? encodeCursor({ q: qId, o: i }) : null;
        const response = {
          ...formattedResults,
          page: {
            tokensBudget: requestedPageTokens,
            tokensUsed: usedTokens,
            bodyTokenBudget,
            next_cursor: nextCursor,
            total_matches: totalSnippetCount,
            returned_matches: included.length,
            omitted_matches: remainingCount,
            omitted_tokens: omittedTokens
          },
          snippets: sliceText,
          footer: footerNote
        };
        return response;
      }
    };
  }
});

// src/utils/workspaceUtils.ts
function findLeafByPath(app, path) {
  const matchingLeaves = [];
  app.workspace.iterateAllLeaves((leaf) => {
    const view = leaf.view;
    const state = leaf.getViewState();
    const pathFromView = view.file ? (0, import_obsidian8.normalizePath)(view.file.path) : null;
    const pathFromState = state.state && typeof state.state.file === "string" ? (0, import_obsidian8.normalizePath)(state.state.file) : null;
    const leafPath = pathFromView || pathFromState;
    if (leafPath && leafPath === path) {
      matchingLeaves.push(leaf);
    }
  });
  if (matchingLeaves.length === 0) {
    return null;
  }
  const markdownLeaf = matchingLeaves.find((leaf) => leaf.getViewState().type === "markdown");
  if (markdownLeaf) {
    return markdownLeaf;
  }
  return matchingLeaves[0];
}
async function openFileInMainWorkspace(app, filePath) {
  const normalizedPath = (0, import_obsidian8.normalizePath)(filePath);
  const file = app.vault.getAbstractFileByPath(normalizedPath);
  const currentLeaf = app.workspace.activeLeaf;
  if (!file) {
    return { leaf: null, action: "error" };
  }
  if (!(file instanceof import_obsidian8.TFile)) {
    return { leaf: null, action: "error" };
  }
  const existingFileLeaf = findLeafByPath(app, normalizedPath);
  if (existingFileLeaf && currentLeaf && existingFileLeaf.parent === currentLeaf.parent) {
    app.workspace.setActiveLeaf(existingFileLeaf, { focus: true });
    displayNotice(app, {
      title: "Switched to tab",
      path: normalizedPath
    });
    return { leaf: existingFileLeaf, action: "switched_in_pane" };
  }
  if (existingFileLeaf) {
    app.workspace.setActiveLeaf(existingFileLeaf, { focus: false });
    displayNotice(app, {
      title: "Focused existing tab",
      path: normalizedPath,
      message: "File is in another pane/window."
    });
    return { leaf: existingFileLeaf, action: "focused_other_pane" };
  } else {
    let targetLeaf = null;
    let noticeTitle = "";
    let noticeMessage = "";
    if (import_obsidian8.Platform.isMobile) {
      targetLeaf = app.workspace.getLeaf("tab");
      noticeTitle = "Opened in new tab";
    } else {
      let suitablePane = null;
      app.workspace.iterateAllLeaves((leaf) => {
        if (leaf.getRoot() === app.workspace.rootSplit && leaf !== currentLeaf) {
          if (!suitablePane) suitablePane = leaf;
        }
      });
      if (suitablePane) {
        app.workspace.setActiveLeaf(suitablePane, { focus: false });
        targetLeaf = app.workspace.getLeaf("tab");
        noticeTitle = "Opened in new tab";
        noticeMessage = "Added to an existing pane in the main workspace.";
      } else {
        if (currentLeaf && currentLeaf.getRoot() === app.workspace.rootSplit) {
          targetLeaf = app.workspace.createLeafBySplit(currentLeaf, "vertical", true);
          noticeTitle = "Opened in new split";
          noticeMessage = "Created a side-by-side view with the chat.";
        } else {
          targetLeaf = app.workspace.getLeaf(true);
          noticeTitle = "Opened in new pane";
          noticeMessage = "Created a new pane in the main workspace.";
        }
      }
    }
    if (targetLeaf) {
      await targetLeaf.openFile(file);
      displayNotice(app, {
        title: noticeTitle,
        path: normalizedPath,
        message: noticeMessage
      });
      return { leaf: targetLeaf, action: "created_new" };
    }
  }
  return { leaf: null, action: "error" };
}
var import_obsidian8;
var init_workspaceUtils = __esm({
  "src/utils/workspaceUtils.ts"() {
    import_obsidian8 = require("obsidian");
    init_notifications();
  }
});

// src/constants/api.ts
var api_exports = {};
__export(api_exports, {
  API_BASE_URL: () => API_BASE_URL,
  DEVELOPMENT_MODE: () => DEVELOPMENT_MODE,
  SYSTEMSCULPT_API_ENDPOINTS: () => SYSTEMSCULPT_API_ENDPOINTS,
  SYSTEMSCULPT_API_HEADERS: () => SYSTEMSCULPT_API_HEADERS,
  getServerUrl: () => getServerUrl
});
function getServerUrl(productionUrl, developmentUrl) {
  if (DEVELOPMENT_MODE === "DEVELOPMENT") {
    return developmentUrl;
  }
  return productionUrl;
}
var DEVELOPMENT_MODE, API_BASE_URL, SYSTEMSCULPT_API_ENDPOINTS, SYSTEMSCULPT_API_HEADERS;
var init_api = __esm({
  "src/constants/api.ts"() {
    DEVELOPMENT_MODE = "PRODUCTION";
    API_BASE_URL = getServerUrl("https://api.systemsculpt.com/api/v1", "http://localhost:3001/api/v1");
    SYSTEMSCULPT_API_ENDPOINTS = {
      PLUGINS: {
        LATEST: (pluginId) => `/plugins/${pluginId}/latest`,
        RELEASES: (pluginId) => `/plugins/${pluginId}/releases`
      },
      LICENSE: {
        VALIDATE: () => `/license/validate`
      },
      MODELS: {
        LIST: "/models",
        GET: (modelId) => `/models/${modelId}`
      },
      CHAT: {
        COMPLETIONS: "/chat/completions"
      },
      EMBEDDINGS: {
        GENERATE: "/embeddings"
      },
      SYSTEM_PROMPTS: {
        GET: (id) => `/system-prompts/${id}`,
        LIST: "/system-prompts"
      },
      DOCUMENTS: {
        PROCESS: "/documents/process",
        GET: (id) => `/documents/${id}`,
        DOWNLOAD: (id) => `/documents/${id}/download`
      },
      CREDITS: {
        GET: "/credits"
      }
    };
    SYSTEMSCULPT_API_HEADERS = {
      DEFAULT: {
        "Content-Type": "application/json"
      },
      WITH_LICENSE: (licenseKey) => ({
        ...SYSTEMSCULPT_API_HEADERS.DEFAULT,
        "x-license-key": licenseKey
      })
    };
  }
});

// src/utils/helpers.ts
function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}
var init_helpers = __esm({
  "src/utils/helpers.ts"() {
  }
});

// src/utils/devlog.ts
function shouldLog(level) {
  switch (level) {
    case "error":
      return true;
    case "warn":
      return currentLogLevel >= 1 /* WARNING */;
    case "info":
      return currentLogLevel >= 2 /* INFO */;
    case "debug":
      return currentLogLevel >= 3 /* DEBUG */;
    default:
      return false;
  }
}
function writeToConsole(level, label, payload) {
  var _a;
  if (!shouldLog(level)) {
    return;
  }
  const logger = (_a = console[level]) != null ? _a : console.log;
  try {
    logger(label, payload);
  } catch (error) {
    try {
      console.error(`${label} console logging failed`, error);
    } catch (e) {
    }
  }
}
function appendDevlogEntry(app, logPath, entry, options = {}) {
  var _a, _b, _c;
  const label = options.consoleLabel ? `[SystemSculpt][${options.consoleLabel}]` : "[SystemSculpt][Devlog]";
  const level = (_a = options.consoleLevel) != null ? _a : "debug";
  const payload = {
    timestamp: (_b = entry.timestamp) != null ? _b : (/* @__PURE__ */ new Date()).toISOString(),
    ...entry
  };
  writeToConsole(level, label, payload);
  const adapter = (_c = app == null ? void 0 : app.vault) == null ? void 0 : _c.adapter;
  if (!adapter) {
    return;
  }
  const normalizedPath = (0, import_obsidian9.normalizePath)(logPath);
  const segments = normalizedPath.split("/");
  const directory = segments.length > 1 ? segments.slice(0, -1).join("/") : "";
  const normalizedDirectory = directory ? (0, import_obsidian9.normalizePath)(directory) : null;
  const line = `${JSON.stringify(payload)}
`;
  void (async () => {
    var _a2;
    try {
      if (normalizedDirectory) {
        try {
          await ((_a2 = adapter.mkdir) == null ? void 0 : _a2.call(adapter, normalizedDirectory));
        } catch (e) {
        }
      }
      if (typeof adapter.append === "function") {
        await adapter.append(normalizedPath, line);
        return;
      }
      let existing = "";
      try {
        existing = await adapter.read(normalizedPath);
      } catch (e) {
      }
      await adapter.write(normalizedPath, `${existing}${line}`);
    } catch (error) {
      writeToConsole("error", `${label} file logging failed`, {
        error: error instanceof Error ? error.message : String(error),
        path: normalizedPath
      });
    }
  })();
}
var import_obsidian9;
var init_devlog = __esm({
  "src/utils/devlog.ts"() {
    import_obsidian9 = require("obsidian");
    init_errorHandling();
  }
});

// src/utils/documentProcessingLog.ts
function logDocumentProcessingEvent(app, entry, options = {}) {
  var _a, _b;
  const level = (_a = options.consoleLevel) != null ? _a : entry.stage === "error" ? "error" : "debug";
  const payload = {
    source: (_b = entry.source) != null ? _b : "DocumentProcessing",
    ...entry
  };
  appendDevlogEntry(app, PROCESSING_DEVLOG_PATH, payload, {
    consoleLabel: "DocProcessing",
    consoleLevel: level
  });
}
function logProcessingEventFromProgress(app, event, extras = {}) {
  logDocumentProcessingEvent(app, {
    ...event,
    ...extras
  });
}
var PROCESSING_DEVLOG_PATH;
var init_documentProcessingLog = __esm({
  "src/utils/documentProcessingLog.ts"() {
    init_devlog();
    PROCESSING_DEVLOG_PATH = "SystemSculpt/devlogs/document-processing.log";
  }
});

// src/utils/errorLogger.ts
var errorLogger_exports = {};
__export(errorLogger_exports, {
  errorLogger: () => errorLogger
});
var import_obsidian10, ErrorLogger, errorLogger;
var init_errorLogger = __esm({
  "src/utils/errorLogger.ts"() {
    import_obsidian10 = require("obsidian");
    init_errorHandling();
    ErrorLogger = class _ErrorLogger {
      constructor() {
        this.logHistory = [];
        this.maxHistorySize = 100;
        this.debugMode = false;
      }
      static getInstance() {
        if (!_ErrorLogger.instance) {
          _ErrorLogger.instance = new _ErrorLogger();
        }
        return _ErrorLogger.instance;
      }
      setDebugMode(enabled) {
        this.debugMode = enabled;
        if (enabled) {
          console.log("[SystemSculpt] Debug mode enabled - verbose logging active");
        }
      }
      formatLogMessage(entry) {
        var _a, _b, _c;
        const timestamp = entry.timestamp.toISOString();
        const level = entry.level.toUpperCase();
        const source = ((_a = entry.context) == null ? void 0 : _a.source) || "SystemSculpt";
        const method = ((_b = entry.context) == null ? void 0 : _b.method) ? `::${entry.context.method}` : "";
        let message = `[${timestamp}] [${level}] [${source}${method}] ${entry.message}`;
        if ((_c = entry.context) == null ? void 0 : _c.metadata) {
          message += "\nMetadata: " + JSON.stringify(entry.context.metadata, null, 2);
        }
        if (entry.error && entry.stack) {
          message += "\nStack trace:\n" + entry.stack;
        }
        return message;
      }
      addToHistory(entry) {
        this.logHistory.push(entry);
        if (this.logHistory.length > this.maxHistorySize) {
          this.logHistory.shift();
        }
      }
      logToConsole(entry) {
        if (!this.shouldLogToConsole(entry.level)) {
          return;
        }
        const formattedMessage = this.formatLogMessage(entry);
        switch (entry.level) {
          case "error":
            console.error(formattedMessage);
            if (entry.error) {
              console.error("Original error object:", entry.error);
            }
            break;
          case "warn":
            console.warn(formattedMessage);
            break;
          case "info":
            console.info(formattedMessage);
            break;
          case "debug":
            if (this.debugMode) {
              console.debug(formattedMessage);
            }
            break;
        }
      }
      shouldLogToConsole(level) {
        switch (level) {
          case "error":
            return true;
          case "warn":
            return currentLogLevel >= 1 /* WARNING */;
          case "info":
            return this.debugMode || currentLogLevel >= 2 /* INFO */;
          case "debug":
            return this.debugMode && currentLogLevel >= 3 /* DEBUG */;
          default:
            return false;
        }
      }
      shouldShowNotice(level) {
        return level === "error" || level === "warn" || this.debugMode && level === "info";
      }
      getNoticeMessage(entry) {
        var _a;
        if (((_a = entry.context) == null ? void 0 : _a.source) === "AnthropicAdapter") {
          if (entry.message.includes("401") || entry.message.includes("Invalid") && entry.message.includes("key")) {
            return "\u26A0\uFE0F Invalid Anthropic API key. Please check Settings > Custom Endpoints.";
          }
          if (entry.message.includes("429") || entry.message.includes("Rate limit")) {
            return "\u23F1\uFE0F Rate limit exceeded. Please wait a moment and try again.";
          }
          if (entry.message.includes("credit") || entry.message.includes("Insufficient")) {
            return "\u{1F4B3} Insufficient credits. Please add credits to your Anthropic account.";
          }
          if (entry.message.includes("500") || entry.message.includes("502") || entry.message.includes("503")) {
            return "\u{1F527} Anthropic API is temporarily unavailable. Please try again later.";
          }
          if (entry.message.includes("network") || entry.message.includes("Failed to fetch")) {
            return "\u{1F310} Network error: Unable to connect to Anthropic. Check your internet connection.";
          }
        }
        if (entry.message.includes("\u26A0\uFE0F") || entry.message.includes("\u274C") || entry.message.includes("\u{1F4B3}") || entry.message.includes("\u{1F527}") || entry.message.includes("\u{1F310}") || entry.message.includes("\u23F1\uFE0F")) {
          return entry.message;
        }
        if (entry.level === "error") {
          return `\u274C An error occurred: ${entry.message}`;
        }
        return entry.message;
      }
      log(level, message, error, context) {
        const entry = {
          timestamp: /* @__PURE__ */ new Date(),
          level,
          message,
          error: error instanceof Error ? error : void 0,
          context,
          stack: error instanceof Error ? error.stack : void 0
        };
        this.logToConsole(entry);
        this.addToHistory(entry);
        if (this.shouldShowNotice(level)) {
          const noticeMessage = this.getNoticeMessage(entry);
          const duration = level === "error" ? 1e4 : 5e3;
          new import_obsidian10.Notice(noticeMessage, duration);
        }
      }
      error(message, error, context) {
        this.log("error", message, error, context);
      }
      warn(message, context) {
        this.log("warn", message, void 0, context);
      }
      info(message, context) {
        this.log("info", message, void 0, context);
      }
      debug(message, context) {
        this.log("debug", message, void 0, context);
      }
      getLogHistory() {
        return [...this.logHistory];
      }
      clearHistory() {
        this.logHistory = [];
      }
      exportLogs() {
        return this.logHistory.map((entry) => this.formatLogMessage(entry)).join("\n\n" + "=".repeat(80) + "\n\n");
      }
    };
    errorLogger = ErrorLogger.getInstance();
  }
});

// src/utils/httpClient.ts
var httpClient_exports = {};
__export(httpClient_exports, {
  httpRequest: () => httpRequest,
  isHostTemporarilyDisabled: () => isHostTemporarilyDisabled
});
function getHost(url) {
  try {
    return new URL(url).host;
  } catch (e) {
    return "";
  }
}
function normalizeHeaders(method, headers, body) {
  const out = { ...headers || {} };
  const m = (method || "GET").toUpperCase();
  if (m === "GET") {
    for (const k of Object.keys(out)) {
      if (k.toLowerCase() === "content-type") delete out[k];
    }
  } else if (body && !Object.keys(out).some((k) => k.toLowerCase() === "content-type")) {
    out["Content-Type"] = "application/json";
  }
  return out;
}
async function httpRequest(opts) {
  var _a, _b, _c;
  const method = opts.method || "GET";
  const headers = normalizeHeaders(method, opts.headers, opts.body);
  const host = getHost(opts.url);
  const now = Date.now();
  const state = hostState.get(host);
  const disabled = !!((state == null ? void 0 : state.disabledUntil) && state.disabledUntil > now);
  const timeoutMs = Math.max(0, Number(opts.timeoutMs || 0));
  async function withTimeout(promise) {
    if (!timeoutMs) return promise;
    return await Promise.race([
      promise,
      new Promise((_, reject) => setTimeout(() => reject(new Error("Request timed out")), timeoutMs))
    ]);
  }
  if (disabled) {
    const waitMs = (state.disabledUntil || 0) - now;
    const mins = Math.max(1, Math.round(waitMs / 6e4));
    const message = `Host temporarily unavailable (circuit open). Retry in ~${mins} min.`;
    try {
      const { errorLogger: errorLogger2 } = await Promise.resolve().then(() => (init_errorLogger(), errorLogger_exports));
      errorLogger2.debug("HTTP circuit open; skipping request", { source: "httpClient", method: "httpRequest", metadata: { host, retryInMs: waitMs } });
    } catch (e) {
    }
    const shortError = new Error(message);
    shortError.status = 0;
    throw shortError;
  }
  if (disabled && typeof fetch === "function" && !Obsidian.Platform.isMobileApp) {
    try {
      const fr = await withTimeout(fetch(opts.url, { method, headers, body: opts.body, cache: "no-store" }));
      const text = await fr.text();
      let json = void 0;
      try {
        json = text ? JSON.parse(text) : void 0;
      } catch (e) {
      }
      if (!fr.status || fr.status >= 400) {
        throw { status: fr.status || 500, text, json, message: text || json && (((_a = json.error) == null ? void 0 : _a.message) || json.message) || `HTTP ${fr.status}` };
      }
      const responseHeaders = {};
      fr.headers.forEach((value, key) => {
        responseHeaders[key] = value;
      });
      return { status: fr.status, text, json, headers: responseHeaders };
    } catch (e) {
    }
  }
  try {
    const r = await withTimeout(Obsidian.requestUrl({ url: opts.url, method, headers, body: opts.body, throw: false }));
    const status = r.status || 0;
    const text = r.text;
    let parsed = void 0;
    try {
      parsed = text ? JSON.parse(text) : void 0;
    } catch (e) {
    }
    if (!status || status >= 400) {
      throw { status: status || 500, text, json: parsed, message: text || parsed && (((_b = parsed.error) == null ? void 0 : _b.message) || parsed.message) || `HTTP ${status}` };
    }
    const hdrs = r.headers || {};
    if (host) hostState.set(host, { failures: 0, disabledUntil: void 0 });
    return { status, text, json: parsed, headers: hdrs };
  } catch (err) {
    const msg = String((err == null ? void 0 : err.message) || "");
    const status = typeof (err == null ? void 0 : err.status) === "number" ? err.status : void 0;
    const responseText = typeof (err == null ? void 0 : err.text) === "string" ? err.text : "";
    const looksHtml = responseText.trim().startsWith("<");
    const isGatewayish = status === 502 || status === 503 || status === 504;
    const isServerDegraded = isGatewayish || !!status && status >= 500 && looksHtml;
    const isNetworkish = msg.includes("net::ERR") || msg.includes("ENOTFOUND") || msg.includes("ECONN") || msg.includes("ECONNRESET") || msg.includes("REFUSED");
    const shouldBackoff = isNetworkish || isServerDegraded;
    const canTryFetch = typeof fetch === "function" && !Obsidian.Platform.isMobileApp && isNetworkish;
    if (canTryFetch) {
      try {
        const fr = await withTimeout(fetch(opts.url, { method, headers, body: opts.body, cache: "no-store" }));
        const text = await fr.text();
        let json = void 0;
        try {
          json = text ? JSON.parse(text) : void 0;
        } catch (e) {
        }
        if (!fr.status || fr.status >= 400) {
          throw { status: fr.status || 500, text, json, message: text || json && (((_c = json.error) == null ? void 0 : _c.message) || json.message) || `HTTP ${fr.status}` };
        }
        const responseHeaders = {};
        fr.headers.forEach((value, key) => {
          responseHeaders[key] = value;
        });
        if (host) hostState.set(host, { failures: 0, disabledUntil: void 0 });
        return { status: fr.status, text, json, headers: responseHeaders };
      } catch (fetchErr) {
        if (host && isNetworkish) {
          const s = hostState.get(host) || { failures: 0, disabledUntil: void 0 };
          s.failures += 1;
          const backoffMinutes = s.failures <= 1 ? 0 : Math.min(60, 2 * Math.pow(2, Math.min(5, s.failures - 2)));
          if (backoffMinutes > 0) s.disabledUntil = Date.now() + backoffMinutes * 60 * 1e3;
          hostState.set(host, s);
          try {
            const { errorLogger: errorLogger2 } = await Promise.resolve().then(() => (init_errorLogger(), errorLogger_exports));
            errorLogger2.debug("HTTP network failure; circuit update", { source: "httpClient", method: "httpRequest", metadata: { host, failures: s.failures, disabledUntil: s.disabledUntil } });
          } catch (e) {
          }
        }
        throw err;
      }
    }
    if (host) {
      const s = hostState.get(host) || { failures: 0, disabledUntil: void 0 };
      s.failures += 1;
      const backoffMinutes = shouldBackoff ? s.failures <= 1 ? 0 : Math.min(60, 2 * Math.pow(2, Math.min(5, s.failures - 2))) : 0;
      if (backoffMinutes > 0) s.disabledUntil = Date.now() + backoffMinutes * 60 * 1e3;
      hostState.set(host, s);
      try {
        const { errorLogger: errorLogger2 } = await Promise.resolve().then(() => (init_errorLogger(), errorLogger_exports));
        const metadata = { host, failures: s.failures, disabledUntil: s.disabledUntil, status, message: msg };
        if (isServerDegraded) {
          errorLogger2.warn("HTTP gateway error; circuit update", { source: "httpClient", method: "httpRequest", metadata });
        } else {
          errorLogger2.debug("HTTP error; circuit update", { source: "httpClient", method: "httpRequest", metadata });
        }
      } catch (e) {
      }
    }
    throw err;
  }
}
function isHostTemporarilyDisabled(url) {
  const host = getHost(url);
  if (!host) return { disabled: false, retryInMs: 0 };
  const s = hostState.get(host);
  const now = Date.now();
  if ((s == null ? void 0 : s.disabledUntil) && s.disabledUntil > now) {
    return { disabled: true, retryInMs: s.disabledUntil - now };
  }
  return { disabled: false, retryInMs: 0 };
}
var Obsidian, hostState;
var init_httpClient = __esm({
  "src/utils/httpClient.ts"() {
    Obsidian = __toESM(require("obsidian"), 1);
    hostState = /* @__PURE__ */ new Map();
  }
});

// src/services/DocumentProcessingService.ts
var import_obsidian11, STAGE_ICONS, DocumentProcessingService;
var init_DocumentProcessingService = __esm({
  "src/services/DocumentProcessingService.ts"() {
    import_obsidian11 = require("obsidian");
    init_SystemSculptService();
    init_api();
    init_helpers();
    init_documentProcessingLog();
    init_errorLogger();
    STAGE_ICONS = {
      queued: "inbox",
      validating: "shield-check",
      uploading: "upload",
      processing: "cpu",
      downloading: "download",
      contextualizing: "sparkles",
      ready: "check-circle",
      error: "x-circle"
    };
    DocumentProcessingService = class _DocumentProcessingService {
      constructor(app, plugin) {
        this.imageMetadataLog = [];
        this.app = app;
        this.plugin = plugin;
        this.sculptService = SystemSculptService.getInstance(plugin);
      }
      clampProgress(value) {
        if (typeof value !== "number" || Number.isNaN(value)) {
          return 0;
        }
        if (!Number.isFinite(value)) {
          return value > 0 ? 100 : 0;
        }
        return Math.min(100, Math.max(0, value));
      }
      emitProgress(handler, event, meta = {}, fallbackFlow = "document") {
        var _a, _b;
        const normalizedEvent = {
          ...event,
          progress: this.clampProgress(event.progress),
          flow: (_a = event.flow) != null ? _a : fallbackFlow
        };
        try {
          handler == null ? void 0 : handler(normalizedEvent);
        } catch (error) {
          errorLogger.error("Progress handler threw", error, {
            source: "DocumentProcessingService",
            method: "emitProgress",
            metadata: {
              stage: normalizedEvent.stage,
              filePath: meta.filePath
            }
          });
        }
        logProcessingEventFromProgress(this.app, normalizedEvent, {
          ...meta,
          source: (_b = meta.source) != null ? _b : "DocumentProcessingService"
        });
      }
      mapNormalizedStatusToStage(status) {
        switch ((status != null ? status : "").toLowerCase()) {
          case "queued":
            return "queued";
          case "validating":
          case "preparing":
            return "validating";
          case "uploading":
            return "uploading";
          case "chunking":
          case "extracting":
          case "processing":
          case "analyzing":
          case "analysis":
            return "processing";
          case "downloading":
            return "downloading";
          case "contextualizing":
          case "integrating":
            return "contextualizing";
          case "completed":
          case "ready":
            return "ready";
          case "failed":
          case "error":
          case "timed_out":
            return "error";
          default:
            return "processing";
        }
      }
      /**
       * Get the singleton instance of DocumentProcessingService
       */
      static getInstance(app, plugin) {
        if (!_DocumentProcessingService.instance) {
          _DocumentProcessingService.instance = new _DocumentProcessingService(app, plugin);
        }
        return _DocumentProcessingService.instance;
      }
      /**
       * Process a document file and convert it to markdown
       * @param file The file to process
       * @param options Processing options
       * @returns Promise with the path to the extracted markdown file
       */
      /**
       * Process a document file and convert it to markdown
       * @param file The file to process
       * @param options Processing options
       * @returns Promise with the path to the extracted markdown file
       */
      async processDocument(file, options = {}) {
        const {
          onProgress,
          addToContext = false,
          showNotices = true,
          flow = "document"
        } = options;
        const meta = {
          filePath: file.path,
          fileName: file.name
        };
        const startedAt = Date.now();
        let documentId;
        let lastStage = "queued";
        let emittedError = false;
        const progressHandler = onProgress;
        try {
          this.emitProgress(
            progressHandler,
            {
              stage: "validating",
              progress: 5,
              label: "Validating license\u2026",
              icon: STAGE_ICONS.validating,
              metadata: { startedAt }
            },
            meta,
            flow
          );
          const hasValidLicense = await this.plugin.getLicenseManager().validateLicenseKey(true, false);
          if (!hasValidLicense) {
            throw new Error("Valid license required for document processing");
          }
          this.emitProgress(
            progressHandler,
            {
              stage: "uploading",
              progress: 15,
              label: "Uploading document to DataLab\u2026",
              icon: STAGE_ICONS.uploading
            },
            meta,
            flow
          );
          let uploadResult;
          try {
            uploadResult = await this.sculptService.uploadDocument(file);
          } catch (uploadError) {
            const message = uploadError instanceof Error ? uploadError.message : String(uploadError);
            this.emitProgress(
              progressHandler,
              {
                stage: "error",
                progress: 0,
                label: `Upload failed: ${message}`,
                icon: STAGE_ICONS.error,
                error: message
              },
              meta,
              flow
            );
            lastStage = "error";
            emittedError = true;
            throw uploadError;
          }
          documentId = uploadResult == null ? void 0 : uploadResult.documentId;
          const cached = Boolean(uploadResult == null ? void 0 : uploadResult.cached);
          if (documentId) {
            meta.documentId = documentId;
          }
          this.emitProgress(
            progressHandler,
            {
              stage: "uploading",
              progress: cached ? 45 : 35,
              label: cached ? "Upload skipped \u2014 cached extraction available" : "Upload complete, queued for processing",
              icon: cached ? "history" : "check",
              documentId,
              cached
            },
            meta,
            flow
          );
          if (cached && documentId) {
            lastStage = "processing";
            this.emitProgress(
              progressHandler,
              {
                stage: "processing",
                progress: 55,
                label: "Reusing cached extraction results",
                icon: "archive",
                documentId,
                cached: true
              },
              meta,
              flow
            );
            const extractionData = await this.downloadExtraction(documentId);
            this.emitProgress(
              progressHandler,
              {
                stage: "downloading",
                progress: 85,
                label: "Downloading cached results\u2026",
                icon: STAGE_ICONS.downloading,
                documentId,
                cached: true
              },
              meta,
              flow
            );
            const extractionPath = await this.saveExtractionResults(file, extractionData, {
              addToContext
            });
            this.emitProgress(
              progressHandler,
              {
                stage: "downloading",
                progress: 90,
                label: "Cached results saved to vault",
                icon: "hard-drive",
                documentId,
                cached: true
              },
              meta,
              flow
            );
            if (showNotices) {
              new import_obsidian11.Notice("Document successfully converted from cache");
            }
            meta.durationMs = Date.now() - startedAt;
            lastStage = "downloading";
            return extractionPath;
          }
          if (!documentId) {
            throw new Error("Upload did not return a document ID");
          }
          lastStage = "processing";
          const pollResult = await this.pollUntilComplete(
            documentId,
            progressHandler,
            meta,
            flow
          );
          if (!pollResult.completed) {
            throw new Error(
              pollResult.error || "Document processing failed or timed out"
            );
          }
          this.emitProgress(
            progressHandler,
            {
              stage: "downloading",
              progress: 85,
              label: "Downloading processed results\u2026",
              icon: STAGE_ICONS.downloading,
              documentId
            },
            meta,
            flow
          );
          try {
            const downloadPromise = this.downloadExtraction(documentId);
            const timeoutPromise = new Promise(
              (_, reject) => setTimeout(() => reject(new Error("Download timed out")), 3e4)
            );
            let extractionData = await Promise.race([
              downloadPromise,
              timeoutPromise
            ]);
            if (!extractionData || typeof extractionData === "object" && !extractionData.content && !extractionData.text && !extractionData.markdown && !extractionData.extraction) {
              try {
                const fallbackUrl = `${this.sculptService.baseUrl}/documents/${documentId}/raw`;
                const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
                const fallbackResponse = await httpRequest2({
                  url: fallbackUrl,
                  method: "GET",
                  headers: {
                    "x-license-key": this.plugin.settings.licenseKey || ""
                  }
                });
                if (fallbackResponse.status && fallbackResponse.status < 400) {
                  const rawText = fallbackResponse.text || "";
                  if (rawText) {
                    extractionData = { content: rawText };
                  }
                }
              } catch (fallbackError) {
                this.emitProgress(
                  progressHandler,
                  {
                    stage: "processing",
                    progress: 88,
                    label: "Fallback download attempt failed",
                    icon: "alert-triangle",
                    documentId,
                    details: fallbackError instanceof Error ? fallbackError.message : String(fallbackError)
                  },
                  meta,
                  flow
                );
              }
            }
            const extractionPath = await this.saveExtractionResults(file, extractionData, {
              addToContext
            });
            this.emitProgress(
              progressHandler,
              {
                stage: "downloading",
                progress: 92,
                label: "Extraction saved",
                icon: "file-down",
                documentId
              },
              meta,
              flow
            );
            if (showNotices) {
              new import_obsidian11.Notice("Document successfully converted to markdown");
            }
            meta.durationMs = Date.now() - startedAt;
            lastStage = "downloading";
            return extractionPath;
          } catch (downloadError) {
            const message = downloadError instanceof Error ? downloadError.message : String(downloadError);
            this.emitProgress(
              progressHandler,
              {
                stage: "error",
                progress: 0,
                label: "Error downloading results",
                icon: STAGE_ICONS.error,
                documentId,
                error: message,
                details: "The server might be experiencing issues. The operation will continue in the background."
              },
              meta,
              flow
            );
            lastStage = "error";
            emittedError = true;
            throw downloadError;
          }
        } catch (error) {
          const message = error instanceof Error ? error.message : String(error);
          if (!emittedError) {
            this.emitProgress(
              progressHandler,
              {
                stage: "error",
                progress: 0,
                label: `Error: ${message}`,
                icon: STAGE_ICONS.error,
                documentId,
                error: message
              },
              meta,
              flow
            );
            lastStage = "error";
            emittedError = true;
          }
          if (showNotices) {
            new import_obsidian11.Notice(`Failed to process document: ${message}`);
          }
          throw error;
        }
      }
      /**
       * Poll for document processing completion
       * @param documentId The document ID to poll for
       * @param progressHandler Optional progress handler function
       * @param maxAttempts Maximum number of polling attempts
       * @returns Promise<boolean> indicating success or failure
       */
      async pollUntilComplete(documentId, handler, meta, flow, maxAttempts = 30) {
        let consecutiveErrors = 0;
        const maxConsecutiveErrors = 5;
        let lastStatus = "processing";
        let lastError;
        const pollMeta = { ...meta, documentId };
        for (let i = 0; i < maxAttempts; i++) {
          try {
            const baseUrl = this.sculptService.baseUrl;
            const endpoint = SYSTEMSCULPT_API_ENDPOINTS.DOCUMENTS.GET(documentId);
            const url = `${baseUrl}${endpoint}`;
            const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
            const response = await httpRequest2({
              url,
              method: "GET",
              headers: {
                "Content-Type": "application/json",
                "x-license-key": this.plugin.settings.licenseKey || ""
              }
            });
            if (!response.status || response.status >= 400) {
              consecutiveErrors++;
              lastError = `HTTP ${response.status}`;
              const progress2 = 40 + i / maxAttempts * 30;
              const message = response.status === 500 ? "Server error, retrying\u2026" : `Error ${response.status}, retrying\u2026`;
              this.emitProgress(
                handler,
                {
                  stage: "processing",
                  progress: progress2,
                  label: message,
                  icon: "alert-triangle",
                  documentId,
                  details: lastError,
                  metadata: { attempt: i + 1 }
                },
                { ...pollMeta, attempt: i + 1 },
                flow
              );
              if (consecutiveErrors >= maxConsecutiveErrors) {
                this.emitProgress(
                  handler,
                  {
                    stage: "error",
                    progress: 0,
                    label: "Server returned repeated errors",
                    icon: STAGE_ICONS.error,
                    documentId,
                    error: lastError
                  },
                  pollMeta,
                  flow
                );
                await sleep(3e3);
                return {
                  completed: false,
                  status: lastStatus,
                  error: lastError || "Server returned repeated errors"
                };
              }
              await sleep(3e3);
              continue;
            }
            consecutiveErrors = 0;
            const statusInfo = this.parseDocumentStatusResponse(response);
            lastStatus = statusInfo.normalizedStatus || statusInfo.rawStatus || lastStatus;
            lastError = statusInfo.error || lastError;
            const stage = this.mapNormalizedStatusToStage(statusInfo.normalizedStatus);
            const baseProgress = Math.min(45 + i / maxAttempts * 45, 90);
            const progress = typeof statusInfo.progress === "number" ? Math.max(baseProgress, statusInfo.progress) : baseProgress;
            if (stage === "error") {
              const errorMessage = statusInfo.error || `Document processing failed (${statusInfo.rawStatus || "unknown"})`;
              this.emitProgress(
                handler,
                {
                  stage: "error",
                  progress,
                  label: errorMessage,
                  icon: STAGE_ICONS.error,
                  documentId,
                  error: errorMessage,
                  details: statusInfo.error
                },
                pollMeta,
                flow
              );
              await sleep(2e3);
              return {
                completed: false,
                status: statusInfo.normalizedStatus,
                error: errorMessage
              };
            }
            if (stage === "ready") {
              this.emitProgress(
                handler,
                {
                  stage: "processing",
                  progress: Math.max(progress, 92),
                  label: "Processing complete, finalizing\u2026",
                  icon: "check",
                  documentId,
                  status: statusInfo.rawStatus
                },
                pollMeta,
                flow
              );
              return { completed: true, status: "completed" };
            }
            const label = stage === "queued" ? "Queued at document processor\u2026" : "Processing document\u2026";
            const icon = stage === "queued" ? STAGE_ICONS.queued : STAGE_ICONS.processing;
            this.emitProgress(
              handler,
              {
                stage,
                progress,
                label,
                icon,
                documentId,
                status: statusInfo.rawStatus,
                details: statusInfo.error,
                metadata: { attempt: i + 1 }
              },
              { ...pollMeta, attempt: i + 1 },
              flow
            );
          } catch (error) {
            consecutiveErrors++;
            lastError = error instanceof Error ? error.message : String(error);
            const progress = 45 + i / maxAttempts * 35;
            this.emitProgress(
              handler,
              {
                stage: "processing",
                progress,
                label: "Connection issue, retrying\u2026",
                icon: "alert-triangle",
                documentId,
                details: lastError,
                metadata: { attempt: i + 1 }
              },
              { ...pollMeta, attempt: i + 1 },
              flow
            );
            if (consecutiveErrors >= maxConsecutiveErrors) {
              this.emitProgress(
                handler,
                {
                  stage: "error",
                  progress: 0,
                  label: "Too many connection errors. Please check your internet connection and try again.",
                  icon: STAGE_ICONS.error,
                  documentId,
                  error: lastError
                },
                pollMeta,
                flow
              );
              await sleep(3e3);
              return {
                completed: false,
                status: "error",
                error: lastError || "Too many connection errors. Please check your internet connection and try again."
              };
            }
          }
          await sleep(2e3);
        }
        this.emitProgress(
          handler,
          {
            stage: "error",
            progress: 0,
            label: "Document processing is taking longer than expected. Please try again later.",
            icon: "clock",
            documentId,
            error: lastError || "Document processing timed out"
          },
          pollMeta,
          flow
        );
        await sleep(3e3);
        return {
          completed: false,
          status: lastStatus,
          error: lastError || "Document processing timed out"
        };
      }
      parseDocumentStatusResponse(response) {
        var _a;
        let payload = response.json;
        if ((!payload || typeof payload !== "object") && response.text) {
          try {
            payload = JSON.parse(response.text);
          } catch (e) {
            payload = {};
          }
        }
        if (!payload || typeof payload !== "object") {
          payload = {};
        }
        const data = payload.data && typeof payload.data === "object" ? payload.data : {};
        const rawStatusValue = (_a = data && typeof data.status === "string" ? data.status : void 0) != null ? _a : typeof payload.status === "string" ? payload.status : void 0;
        const normalizedStatusValue = typeof data.normalizedStatus === "string" ? data.normalizedStatus : rawStatusValue;
        const normalizedStatus = normalizedStatusValue ? normalizedStatusValue.toLowerCase() : "processing";
        const rawStatus = rawStatusValue || normalizedStatusValue || "processing";
        const errorMessage = typeof data.error === "string" ? data.error : typeof payload.error === "string" ? payload.error : void 0;
        const progress = typeof data.progress === "number" ? data.progress : void 0;
        return {
          normalizedStatus,
          rawStatus,
          error: errorMessage,
          progress
        };
      }
      /**
       * Download extraction data for a document
       * @param documentId The document ID to download extraction for
       * @returns Promise with the extraction data
       */
      async downloadExtraction(documentId) {
        var _a;
        try {
          const baseUrl = this.sculptService.baseUrl;
          const endpoint = SYSTEMSCULPT_API_ENDPOINTS.DOCUMENTS.DOWNLOAD(documentId);
          const url = `${baseUrl}${endpoint}`;
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({
            url,
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "x-license-key": this.plugin.settings.licenseKey || ""
            }
          });
          if (!response.status || response.status >= 400) {
            throw new Error(`Failed to download extraction: ${response.status}`);
          }
          const data = response.json || (response.text ? JSON.parse(response.text) : {});
          if (data && data.success === false) {
            const errorMessage = data.error || data.details || "Document extraction is not ready yet.";
            throw new Error(errorMessage);
          }
          const nestedExtraction = data && typeof data === "object" && data.extractionResult ? data.extractionResult : (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.extractionResult;
          if (nestedExtraction && typeof nestedExtraction === "object") {
            if (!data.content && nestedExtraction.markdown) {
              data.content = nestedExtraction.markdown;
            }
            if (!data.text && nestedExtraction.text) {
              data.text = nestedExtraction.text;
            }
            if (!data.markdown && nestedExtraction.markdown) {
              data.markdown = nestedExtraction.markdown;
            }
            if (!data.images && nestedExtraction.images) {
              data.images = nestedExtraction.images;
            }
            if (!data.metadata && nestedExtraction.metadata) {
              data.metadata = nestedExtraction.metadata;
            }
          }
          if (!data || typeof data === "object" && !data.content && !data.text) {
            throw new Error("Empty extraction data received from server");
          }
          return data;
        } catch (error) {
          throw error;
        }
      }
      /**
       * Save extraction results to disk and optionally add to context
       * @param file The original file
       * @param data The extraction data
       * @param options Options for saving
       * @returns Promise with the path to the saved extraction file
       */
      async saveExtractionResults(file, data, options = {}) {
        var _a;
        const { addToContext = false } = options;
        try {
          const extractionFolder = this.sculptService.extractionsDirectory;
          const baseName = this.sanitizeFilename(file.basename);
          const parentPath = extractionFolder ? `${extractionFolder}/${baseName}` : `${((_a = file.parent) == null ? void 0 : _a.path) || ""}/${baseName}`;
          if (this.plugin.directoryManager) {
            await this.plugin.directoryManager.ensureDirectoryByPath(parentPath);
          } else {
            await this.plugin.createDirectory(parentPath);
          }
          let processedContent = data;
          const images = this.extractImagesFromData(data);
          if (images && Object.keys(images).length > 0) {
            processedContent.images = images;
            const documentId = this.sanitizeFilename(baseName).substring(0, 20);
            const imagesPath = `${parentPath}/images-${documentId}`;
            const directoryExists = await this.app.vault.adapter.exists(imagesPath);
            if (directoryExists) {
              try {
                const files = await this.app.vault.adapter.list(imagesPath);
                if (files && files.files && files.files.length > 0) {
                  for (const file2 of files.files) {
                    await this.app.vault.adapter.remove(file2);
                  }
                }
              } catch (error) {
              }
            }
            if (this.plugin.directoryManager) {
              await this.plugin.directoryManager.ensureDirectoryByPath(imagesPath);
            } else {
              await this.plugin.createDirectory(imagesPath);
            }
            const imagePathMap = /* @__PURE__ */ new Map();
            const processedImages = /* @__PURE__ */ new Map();
            for (const [imageName, imageBase64] of Object.entries(images)) {
              try {
                const imageHash = this.simpleHash(imageBase64.substring(0, 1e3));
                const existingImage = processedImages.get(imageHash);
                if (existingImage) {
                  imagePathMap.set(imageName, existingImage);
                  continue;
                }
                const uniqueImageName = this.generateUniqueImageName(baseName, imageName, imageBase64);
                const imagePath = this.normalizePath(`${imagesPath}/${uniqueImageName}`);
                const imageArrayBuffer = this.base64ToArrayBuffer(imageBase64);
                if (imageArrayBuffer.byteLength < 100) {
                }
                await this.app.vault.createBinary(imagePath, imageArrayBuffer);
                const folderName = imagesPath.split("/").pop() || "images";
                const relativeImagePath = `${folderName}/${uniqueImageName}`;
                imagePathMap.set(imageName, relativeImagePath);
                processedImages.set(imageHash, relativeImagePath);
                this.recordImageMetadata({
                  originalName: imageName,
                  newName: uniqueImageName,
                  path: imagePath,
                  size: imageArrayBuffer.byteLength,
                  documentName: file.basename,
                  timestamp: Date.now()
                });
                if (addToContext) {
                }
              } catch (imageError) {
              }
            }
            if (processedContent.content && imagePathMap.size > 0) {
              let updatedContent = processedContent.content;
              imagePathMap.forEach((newPath, originalName) => {
                try {
                  const escapedOriginalName = originalName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                  const imgRegex = new RegExp(`!\\[([^\\]]*)\\]\\(${escapedOriginalName}\\)`, "g");
                  updatedContent = updatedContent.replace(imgRegex, `![$1](${newPath})`);
                  const imgRegexNoAlt = new RegExp(`!\\[\\]\\(${escapedOriginalName}\\)`, "g");
                  updatedContent = updatedContent.replace(imgRegexNoAlt, `![](${newPath})`);
                  const htmlImgRegex = new RegExp(`<img[^>]*src=["']${escapedOriginalName}["'][^>]*>`, "g");
                  updatedContent = updatedContent.replace(htmlImgRegex, (match) => {
                    return match.replace(escapedOriginalName, newPath);
                  });
                  const filenameOnly = escapedOriginalName.split("/").pop();
                  if (filenameOnly && filenameOnly !== escapedOriginalName) {
                    const filenameRegex = new RegExp(`!\\[([^\\]]*)\\]\\(${filenameOnly}\\)`, "g");
                    updatedContent = updatedContent.replace(filenameRegex, `![$1](${newPath})`);
                  }
                } catch (regexError) {
                }
              });
              processedContent.content = updatedContent;
            }
          }
          const extractionPath = this.normalizePath(
            `${parentPath}/${baseName}-extraction.md`
          );
          if (!processedContent) {
            throw new Error("Invalid extraction data received");
          }
          const content = this.formatExtractionContent(processedContent);
          const existingFile = this.app.vault.getAbstractFileByPath(extractionPath);
          if (existingFile instanceof import_obsidian11.TFile) {
            await this.app.vault.modify(existingFile, content);
          } else {
            await this.app.vault.create(extractionPath, content);
          }
          return extractionPath;
        } catch (error) {
          throw error;
        }
      }
      /**
       * Format extraction content for display
       * @param data The extraction data
       * @returns Formatted markdown content
       */
      formatExtractionContent(data) {
        let title = "Document Extraction";
        let content = "";
        if (data) {
          if (data.title) {
            title = data.title;
          } else if (data.metadata && data.metadata.title) {
            title = data.metadata.title;
          } else if (data.document && data.document.title) {
            title = data.document.title;
          }
          if (data.content) {
            content = data.content;
          } else if (data.text) {
            content = data.text;
          } else if (data.document && data.document.content) {
            content = data.document.content;
          } else if (data.document && data.document.text) {
            content = data.document.text;
          } else if (typeof data === "string") {
            content = data;
          } else if (data.markdown) {
            content = data.markdown;
          } else if (data.extraction) {
            content = data.extraction;
          }
        }
        if (!content && data) {
          try {
            if (typeof data === "object") {
              content = JSON.stringify(data, null, 2);
            }
          } catch (e) {
          }
        }
        if (!content) {
          content = "No content was extracted from this document. The server may be experiencing issues or the document format is not supported.";
        }
        let imageNote = "";
        if (data && data.images && Object.keys(data.images).length > 0) {
          const imageCount = Object.keys(data.images).length;
          let folderInfo = "the images folder";
          if (this.imageMetadataLog && this.imageMetadataLog.length > 0) {
            const firstImage = this.imageMetadataLog[this.imageMetadataLog.length - imageCount];
            if (firstImage && firstImage.path) {
              const pathParts = firstImage.path.split("/");
              if (pathParts.length >= 2) {
                folderInfo = `the '${pathParts[pathParts.length - 2]}' folder`;
              }
            }
          }
          imageNote = `

> [!note] Images
> ${imageCount} image${imageCount > 1 ? "s were" : " was"} extracted from this document and saved in ${folderInfo}.
`;
        }
        return `# ${title}

${content}${imageNote}

---
Extracted with SystemSculpt
`;
      }
      /**
       * Extracts images from different possible locations in the API response
       * @param data The API response data
       * @returns Object containing image name to base64 mappings
       */
      extractImagesFromData(data) {
        const images = {};
        if (!data) return images;
        if (data.images && typeof data.images === "object") {
          Object.entries(data.images).forEach(([key, value]) => {
            if (typeof value === "string") {
              images[key] = value;
            }
          });
        }
        if (data.document && data.document.images && typeof data.document.images === "object") {
          Object.entries(data.document.images).forEach(([key, value]) => {
            if (typeof value === "string") {
              images[key] = value;
            }
          });
        }
        if (data.imageList && Array.isArray(data.imageList)) {
          data.imageList.forEach((img, index) => {
            if (img && typeof img.data === "string") {
              const name = img.name || `image-${index}.png`;
              images[name] = img.data;
            }
          });
        }
        if (data.figures && Array.isArray(data.figures)) {
          data.figures.forEach((fig, index) => {
            if (fig && typeof fig.image === "string") {
              const name = fig.name || `figure-${index}.png`;
              images[name] = fig.image;
            }
          });
        }
        return images;
      }
      /**
       * Generates a deterministic image filename to prevent collisions and ensure consistency
       * @param baseName Base name for the image
       * @param imageName Original image name
       * @param imageData Base64 image data (used for content-based hashing)
       * @returns A unique image filename
       */
      generateUniqueImageName(baseName, imageName, imageData) {
        var _a;
        const extension = ((_a = imageName.split(".").pop()) == null ? void 0 : _a.toLowerCase()) || "png";
        const sanitizedBaseName = this.sanitizeFilename(baseName);
        let contentHash = "";
        if (imageData) {
          try {
            const sampleData = imageData.substring(0, 1e3);
            contentHash = this.simpleHash(sampleData);
          } catch (e) {
            contentHash = this.simpleHash(`${baseName}-${imageName}`);
          }
        } else {
          contentHash = this.simpleHash(`${baseName}-${imageName}`);
        }
        const sanitizedImageName = this.sanitizeFilename(imageName.split(".")[0]);
        return `${sanitizedBaseName}-${sanitizedImageName}-${contentHash}.${extension}`;
      }
      /**
       * Creates a simple hash from a string
       * @param str String to hash
       * @returns A simple hash string
       */
      simpleHash(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
          const char = str.charCodeAt(i);
          hash = (hash << 5) - hash + char;
          hash = hash & hash;
        }
        return (hash >>> 0).toString(16).substring(0, 8);
      }
      /**
       * Converts a base64 string to an ArrayBuffer
       * @param base64 The base64 string to convert
       * @returns ArrayBuffer
       */
      base64ToArrayBuffer(base64) {
        const base64Data = base64.replace(/^data:image\/(png|jpeg|jpg|gif);base64,/, "");
        const binaryString = window.atob(base64Data);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        return bytes.buffer;
      }
      /**
       * Records metadata about processed images for tracking and debugging
       * @param metadata Image metadata to record
       */
      recordImageMetadata(metadata) {
        try {
          this.imageMetadataLog.push(metadata);
        } catch (e) {
        }
      }
      /**
       * Sanitizes a filename to remove invalid characters
       * @param filename The filename to sanitize
       * @returns Sanitized filename
       */
      sanitizeFilename(filename) {
        return filename.replace(/[^a-zA-Z0-9-_]/g, "-");
      }
      /**
       * Normalizes a path to ensure it's valid for Obsidian
       * @param path The path to normalize
       * @returns Normalized path
       */
      normalizePath(path) {
        return path.replace(/\\/g, "/").replace(/^\/+|\/+$/g, "");
      }
    };
  }
});

// src/core/ui/components/LoadingIndicator.ts
var init_LoadingIndicator = __esm({
  "src/core/ui/components/LoadingIndicator.ts"() {
  }
});

// src/core/ui/components/Button.ts
var init_Button = __esm({
  "src/core/ui/components/Button.ts"() {
  }
});

// src/core/ui/modals/standard/StandardModal.ts
var import_obsidian12, StandardModal;
var init_StandardModal = __esm({
  "src/core/ui/modals/standard/StandardModal.ts"() {
    import_obsidian12 = require("obsidian");
    StandardModal = class extends import_obsidian12.Modal {
      constructor(app) {
        super(app);
        this.listeners = [];
        this.modalEl.addClass("ss-modal");
      }
      onOpen() {
        this.createModalStructure();
      }
      onClose() {
        this.removeAllListeners();
        this.modalEl.empty();
      }
      /**
       * Registers a DOM event on the given element and ensures it will be cleaned up when the modal is closed
       */
      registerDomEvent(element, type, listener) {
        element.addEventListener(type, listener);
        this.listeners.push({ element, type, listener });
      }
      /**
       * Removes all registered DOM event listeners
       */
      removeAllListeners() {
        this.listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
        this.listeners = [];
      }
      /**
       * Create the standard three-part modal structure:
       * header, content, and footer
       */
      createModalStructure() {
        this.modalEl.empty();
        this.headerEl = this.modalEl.createDiv("ss-modal__header");
        this.contentEl = this.modalEl.createDiv("ss-modal__content");
        this.footerEl = this.modalEl.createDiv("ss-modal__footer");
      }
      /**
       * Set the size variant of the modal
       * @param size small, medium, large, or fullwidth
       */
      setSize(size) {
        this.modalEl.removeClass("ss-modal--small", "ss-modal--medium", "ss-modal--large", "ss-modal--fullwidth");
        this.modalEl.addClass(`ss-modal--${size}`);
      }
      /**
       * Add an element to the header section
       * @param el Element to add
       */
      addToHeader(el) {
        this.headerEl.appendChild(el);
      }
      /**
       * Add an element to the content section
       * @param el Element to add
       */
      addToContent(el) {
        this.contentEl.appendChild(el);
      }
      /**
       * Add an element to the footer section
       * @param el Element to add
       */
      addToFooter(el) {
        this.footerEl.appendChild(el);
      }
      /**
       * Add a title to the header
       * @param title Title text
       * @param description Optional description text
       */
      addTitle(title, description) {
        const titleContainer = this.headerEl.createDiv({ cls: "ss-modal__title-container" });
        titleContainer.createEl("h2", { text: title, cls: "ss-modal__title" });
        const closeButton = titleContainer.createDiv({ cls: "ss-modal__close-button" });
        (0, import_obsidian12.setIcon)(closeButton, "x");
        this.registerDomEvent(closeButton, "click", () => this.close());
        if (description) {
          this.headerEl.createDiv({ text: description, cls: "ss-modal__description" });
        }
      }
      /**
       * Add an action button to the footer
       * @param text Button text
       * @param callback Click handler
       * @param primary Whether this is a primary button
       * @param icon Optional icon name to show before text
       */
      addActionButton(text, callback, primary = false, icon) {
        const button = this.footerEl.createEl("button", {
          cls: primary ? "ss-button ss-button--primary" : "ss-button ss-button--secondary"
        });
        if (icon) {
          const iconEl = button.createSpan("ss-button__icon");
          (0, import_obsidian12.setIcon)(iconEl, icon);
        }
        button.appendChild(document.createTextNode(text));
        this.registerDomEvent(button, "click", callback);
        return button;
      }
      /**
       * Add a search bar to the modal
       * @param placeholder Placeholder text
       * @param callback Function called when search input changes
       */
      addSearchBar(placeholder, callback) {
        const searchContainer = this.contentEl.createDiv("ss-modal__search");
        const searchIcon = searchContainer.createDiv("ss-modal__search-icon");
        (0, import_obsidian12.setIcon)(searchIcon, "search");
        const searchInput = searchContainer.createEl("input", {
          type: "text",
          placeholder,
          cls: "ss-modal__search-input"
        });
        const clearButton = searchContainer.createDiv("ss-modal__search-clear");
        (0, import_obsidian12.setIcon)(clearButton, "x");
        clearButton.style.display = "none";
        this.registerDomEvent(searchInput, "input", () => {
          const value = searchInput.value;
          clearButton.style.display = value ? "flex" : "none";
          callback(value);
        });
        this.registerDomEvent(clearButton, "click", () => {
          searchInput.value = "";
          clearButton.style.display = "none";
          callback("");
          searchInput.focus();
        });
        return searchInput;
      }
      /**
       * Add filter buttons to the modal
       * @param filters Array of filter objects
       * @param callback Function called when a filter is toggled
       */
      addFilterButtons(filters, callback) {
        const filterContainer = this.contentEl.createDiv("ss-modal__filter");
        const filterGroup = filterContainer.createDiv("ss-modal__filter-group");
        filters.forEach((filter) => {
          const button = filterGroup.createEl("button", {
            cls: `ss-button ss-button--small ${filter.active ? "ss-active" : ""}`,
            attr: {
              "data-filter-id": filter.id
            }
          });
          if (filter.icon) {
            const iconContainer = button.createSpan("ss-button__icon");
            (0, import_obsidian12.setIcon)(iconContainer, filter.icon);
          }
          button.appendChild(document.createTextNode(filter.label));
          this.registerDomEvent(button, "click", () => {
            const isActive = button.classList.toggle("ss-active");
            callback(filter.id, isActive);
          });
        });
        return filterContainer;
      }
      /**
       * Create an item component for displaying model/context/search results
       * @param title Item title
       * @param description Optional description
       * @param icon Optional icon name
       * @param badge Optional badge text
       */
      createItem(title, description, icon, badge) {
        const item = document.createElement("div");
        item.className = "ss-modal__item";
        if (icon) {
          const iconEl = item.createDiv("ss-modal__item-icon");
          (0, import_obsidian12.setIcon)(iconEl, icon);
        }
        const content = item.createDiv("ss-modal__item-content");
        content.createDiv({ text: title, cls: "ss-modal__item-title" });
        if (description) {
          content.createDiv({ text: description, cls: "ss-modal__item-description" });
        }
        if (badge) {
          const badgeEl = item.createSpan({ text: badge, cls: "ss-modal__item-badge" });
        }
        return item;
      }
    };
  }
});

// src/core/ui/modals/standard/TextEditModal.ts
var init_TextEditModal = __esm({
  "src/core/ui/modals/standard/TextEditModal.ts"() {
    init_StandardModal();
    init_types();
  }
});

// src/core/ui/services/KeyboardNavigationService.ts
var import_obsidian13, KeyboardNavigationService;
var init_KeyboardNavigationService = __esm({
  "src/core/ui/services/KeyboardNavigationService.ts"() {
    import_obsidian13 = require("obsidian");
    KeyboardNavigationService = class extends import_obsidian13.Component {
      /**
       * Create a new KeyboardNavigationService
       * 
       * @param {HTMLElement} container - The element to attach key listeners to
       * @param {KeyboardNavigationOptions} options - Configuration options
       */
      constructor(container, options = {}) {
        super();
        this.container = container;
        this.focusedIndex = -1;
        this.itemCount = 0;
        this.options = {
          multiSelect: false,
          closeOnSelect: true,
          allowSpaceToggle: false,
          ...options
        };
        this.registerDomEvent(this.container, "keydown", this.handleKeyDown.bind(this));
      }
      /**
       * Update the number of available items
       */
      setItemCount(count) {
        this.itemCount = count;
        if (this.focusedIndex >= count) {
          this.focusedIndex = count > 0 ? count - 1 : -1;
        }
      }
      /**
       * Get the currently focused item index
       */
      getFocusedIndex() {
        return this.focusedIndex;
      }
      /**
       * Set the focused item index
       */
      setFocusedIndex(index) {
        if (index >= -1 && index < this.itemCount) {
          this.focusedIndex = index;
          if (this.options.onFocus && index >= 0) {
            this.options.onFocus(index);
          }
        }
      }
      /**
       * Clear the current focus
       */
      clearFocus() {
        this.focusedIndex = -1;
      }
      /**
       * Handle keyboard events
       */
      handleKeyDown(event) {
        if (this.itemCount === 0) return;
        if (event.key === "ArrowDown") {
          event.preventDefault();
          const newIndex = this.focusedIndex < 0 ? 0 : Math.min(this.focusedIndex + 1, this.itemCount - 1);
          this.setFocusedIndex(newIndex);
        } else if (event.key === "ArrowUp") {
          event.preventDefault();
          const newIndex = this.focusedIndex < 0 ? 0 : Math.max(this.focusedIndex - 1, 0);
          this.setFocusedIndex(newIndex);
        } else if (event.key === "Enter" && this.focusedIndex !== -1) {
          event.preventDefault();
          if ((event.metaKey || event.ctrlKey) && this.options.multiSelect) {
            if (this.options.onConfirm) {
              this.options.onConfirm();
            }
          } else {
            if (this.options.onSelect) {
              this.options.onSelect(this.focusedIndex);
            }
            if (this.options.multiSelect && this.options.onToggle) {
              this.options.onToggle(this.focusedIndex);
            }
          }
        } else if (event.code === "Space" && this.focusedIndex !== -1 && this.options.allowSpaceToggle) {
          event.preventDefault();
          if (this.options.onToggle) {
            this.options.onToggle(this.focusedIndex);
          }
        } else if (event.key === "Tab") {
          if (this.itemCount > 0) {
            if (event.shiftKey) {
              const newIndex = this.focusedIndex <= 0 ? this.itemCount - 1 : this.focusedIndex - 1;
              this.setFocusedIndex(newIndex);
            } else {
              const newIndex = this.focusedIndex >= this.itemCount - 1 ? 0 : this.focusedIndex + 1;
              this.setFocusedIndex(newIndex);
            }
          }
        }
      }
    };
  }
});

// src/core/ui/index.ts
var init_ui = __esm({
  "src/core/ui/index.ts"() {
    init_LoadingIndicator();
    init_Button();
    init_TextEditModal();
    init_PopupModal();
    init_notifications();
    init_KeyboardNavigationService();
  }
});

// src/core/license/LicenseChecker.ts
var LicenseChecker;
var init_LicenseChecker = __esm({
  "src/core/license/LicenseChecker.ts"() {
    init_ui();
    init_types();
    LicenseChecker = class {
      static requiresProLicense(extension) {
        return this.PRO_EXTENSIONS.includes(extension.toLowerCase());
      }
      static hasValidLicense(plugin) {
        var _a;
        return !!((_a = plugin.settings.licenseKey) == null ? void 0 : _a.trim()) && plugin.settings.licenseValid === true;
      }
      static async showProFeaturePopup(app) {
        const result = await showPopup(
          app,
          "Support SystemSculpt's development and unlock powerful document processing features. Upgrade to Pro to process PDFs, Word documents, and audio files.",
          {
            title: "Pro Feature Required",
            primaryButton: "Get License",
            secondaryButton: "Maybe Later",
            icon: "sparkles"
          }
        );
        if (result == null ? void 0 : result.confirmed) {
          window.open(LICENSE_URL, "_blank");
        }
        return (result == null ? void 0 : result.confirmed) || false;
      }
      static async checkLicenseForFile(file, app, plugin) {
        if (this.requiresProLicense(file.extension.toLowerCase())) {
          if (!this.hasValidLicense(plugin)) {
            await this.showProFeaturePopup(app);
            return false;
          }
        }
        return true;
      }
    };
    LicenseChecker.PRO_EXTENSIONS = [
      "pdf",
      "doc",
      "docx",
      "ppt",
      "pptx",
      "xls",
      "xlsx",
      "mp3",
      "wav",
      "m4a",
      "ogg",
      "webm"
    ];
  }
});

// src/constants/fileTypes.ts
var DOCUMENT_EXTENSIONS, DOCUMENT_MIME_TYPES, AUDIO_EXTENSIONS, toReadonlySet, DOCUMENT_FILE_EXTENSIONS, AUDIO_FILE_EXTENSIONS, DOCUMENT_MIME_TYPE_MAP, normalizeFileExtension, isDocumentFileExtension, isAudioFileExtension, getDocumentMimeType;
var init_fileTypes = __esm({
  "src/constants/fileTypes.ts"() {
    DOCUMENT_EXTENSIONS = [
      "pdf",
      "doc",
      "docx",
      "ppt",
      "pptx",
      "xls",
      "xlsx"
    ];
    DOCUMENT_MIME_TYPES = {
      pdf: "application/pdf",
      doc: "application/msword",
      docx: "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
      ppt: "application/vnd.ms-powerpoint",
      pptx: "application/vnd.openxmlformats-officedocument.presentationml.presentation",
      xls: "application/vnd.ms-excel",
      xlsx: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    };
    AUDIO_EXTENSIONS = ["mp3", "wav", "m4a", "ogg", "webm"];
    toReadonlySet = (values) => new Set(values);
    DOCUMENT_FILE_EXTENSIONS = toReadonlySet(
      DOCUMENT_EXTENSIONS
    );
    AUDIO_FILE_EXTENSIONS = toReadonlySet(
      AUDIO_EXTENSIONS
    );
    DOCUMENT_MIME_TYPE_MAP = DOCUMENT_MIME_TYPES;
    normalizeFileExtension = (extension) => (extension != null ? extension : "").trim().toLowerCase();
    isDocumentFileExtension = (extension) => {
      const normalized = normalizeFileExtension(extension);
      return normalized !== "" && DOCUMENT_FILE_EXTENSIONS.has(normalized);
    };
    isAudioFileExtension = (extension) => {
      const normalized = normalizeFileExtension(extension);
      return normalized !== "" && AUDIO_FILE_EXTENSIONS.has(normalized);
    };
    getDocumentMimeType = (extension) => {
      const normalized = normalizeFileExtension(extension);
      if (normalized === "") {
        return void 0;
      }
      return DOCUMENT_MIME_TYPE_MAP[normalized];
    };
  }
});

// src/services/DocumentContextManager.ts
var DocumentContextManager_exports = {};
__export(DocumentContextManager_exports, {
  DocumentContextManager: () => DocumentContextManager
});
var import_obsidian14, DocumentContextManager;
var init_DocumentContextManager = __esm({
  "src/services/DocumentContextManager.ts"() {
    import_obsidian14 = require("obsidian");
    init_DocumentProcessingService();
    init_LicenseChecker();
    init_fileTypes();
    DocumentContextManager = class _DocumentContextManager {
      constructor(app, plugin) {
        this.app = app;
        this.plugin = plugin;
        this.documentProcessingService = DocumentProcessingService.getInstance(app, plugin);
      }
      /**
       * Get the singleton instance of DocumentContextManager
       */
      static getInstance(app, plugin) {
        if (!_DocumentContextManager.instance) {
          _DocumentContextManager.instance = new _DocumentContextManager(app, plugin);
        }
        return _DocumentContextManager.instance;
      }
      /**
       * Add a file to context
       * @param file The file to add to context
       * @param contextManager The FileContextManager to update
       * @param options Options for adding the file
       * @returns Promise<boolean> indicating success or failure
       */
      async addFileToContext(file, contextManager, options = {}) {
        const { showNotices = true, updateUI = true, saveChanges = true } = options;
        try {
          if (!await LicenseChecker.checkLicenseForFile(file, this.app, this.plugin)) {
            return false;
          }
          const extension = normalizeFileExtension(file.extension);
          let contextPath;
          if (isDocumentFileExtension(extension)) {
            try {
              contextManager.updateProcessingStatus(file, {
                stage: "queued",
                progress: 0,
                label: "Queued for processing",
                icon: "inbox",
                flow: "document"
              });
              const extractionPath = await this.documentProcessingService.processDocument(file, {
                onProgress: (event) => {
                  var _a;
                  contextManager.updateProcessingStatus(file, {
                    ...event,
                    flow: (_a = event.flow) != null ? _a : "document"
                  });
                },
                showNotices: false,
                addToContext: false
              });
              contextManager.updateProcessingStatus(file, {
                stage: "contextualizing",
                progress: 94,
                label: "Adding extracted content to context\u2026",
                icon: "sparkles",
                flow: "document"
              });
              const mdWikiLink = `[[${extractionPath}]]`;
              contextManager.addToContextFiles(mdWikiLink);
              await this.addExtractedImagesToContext(extractionPath, contextManager);
              contextPath = extractionPath;
              contextManager.updateProcessingStatus(file, {
                stage: "ready",
                progress: 100,
                label: "Document added to context",
                icon: "check-circle",
                flow: "document"
              });
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              contextManager.updateProcessingStatus(file, {
                stage: "error",
                progress: 0,
                label: `Error: ${message}`,
                icon: "x-circle",
                flow: "document",
                error: message
              });
              if (showNotices) {
                new import_obsidian14.Notice(`Error processing ${file.basename}: ${message}`, 5e3);
              }
              return false;
            }
          } else if (isAudioFileExtension(extension)) {
            try {
              const transcriptionPath = await contextManager.processAudioFile(file);
              contextManager.updateProcessingStatus(file, {
                stage: "ready",
                progress: 100,
                label: "Transcription added to context",
                icon: "check-circle",
                flow: "audio"
              });
              const transcriptionWikiLink = `[[${transcriptionPath}]]`;
              contextManager.addToContextFiles(transcriptionWikiLink);
              contextPath = transcriptionPath;
            } catch (error) {
              const message = error instanceof Error ? error.message : String(error);
              contextManager.updateProcessingStatus(file, {
                stage: "error",
                progress: 0,
                label: `Error: ${message}`,
                icon: "x-circle",
                flow: "audio",
                error: message
              });
              if (showNotices) {
                new import_obsidian14.Notice(`Error processing ${file.basename}: ${message}`, 5e3);
              }
              return false;
            }
          } else {
            contextPath = file.path;
            const wikiLink = `[[${contextPath}]]`;
            if (contextManager.hasContextFile(wikiLink)) {
              if (showNotices) {
                new import_obsidian14.Notice(`${file.basename} is already added to context`, 3e3);
              }
              return false;
            }
            contextManager.addToContextFiles(wikiLink);
          }
          if (updateUI) {
            contextManager.updateContextPanel();
          }
          if (saveChanges) {
            await contextManager.triggerContextChange();
          }
          if (showNotices) {
            new import_obsidian14.Notice(`Added ${file.basename} to context`, 3e3);
          }
          return true;
        } catch (error) {
          if (showNotices) {
            new import_obsidian14.Notice(`Error adding ${file.basename} to context: ${error.message}`, 5e3);
          }
          return false;
        }
      }
      /**
       * Add extracted images to context
       * @param extractionPath The path to the extraction file
       * @param contextManager The FileContextManager to update
       */
      async addExtractedImagesToContext(extractionPath, contextManager) {
        try {
          const extractionFile = this.app.vault.getAbstractFileByPath(extractionPath);
          if (!extractionFile) {
            return;
          }
          const parentFolder = extractionFile.parent;
          if (!parentFolder) {
            return;
          }
          const allFiles = this.app.vault.getAllLoadedFiles();
          const imageFiles = allFiles.filter((file) => {
            if (!(file instanceof import_obsidian14.TFile)) return false;
            const filePath = file.path;
            if (!filePath.startsWith(parentFolder.path)) return false;
            if (!filePath.includes("images-")) return false;
            return filePath.endsWith(".png") || filePath.endsWith(".jpg") || filePath.endsWith(".jpeg") || filePath.endsWith(".gif");
          });
          for (const imageFile of imageFiles) {
            const imageWikiLink = `[[${imageFile.path}]]`;
            contextManager.addToContextFiles(imageWikiLink);
          }
        } catch (error) {
        }
      }
      /**
       * Process multiple files and add them to context
       * @param files The files to add to context
       * @param contextManager The FileContextManager to update
       * @param options Options for adding the files
       * @returns Promise<number> The number of files successfully added
       */
      async addFilesToContext(files, contextManager, options = {}) {
        const { showNotices = true, updateUI = true, saveChanges = true, maxFiles = 100 } = options;
        let successCount = 0;
        let currentContextSize = contextManager.getContextFiles().size;
        for (const file of files) {
          if (currentContextSize >= maxFiles) {
            if (showNotices) {
              new import_obsidian14.Notice(`File limit reached (${maxFiles} total)`, 3e3);
            }
            break;
          }
          const success = await this.addFileToContext(file, contextManager, {
            showNotices: false,
            // We'll handle notices ourselves
            updateUI: false,
            // We'll update the UI after all files are added
            saveChanges: false
            // We'll save changes after all files are added
          });
          if (success) {
            successCount++;
            currentContextSize++;
            if (showNotices) {
              new import_obsidian14.Notice(`Added ${file.name} to context (${currentContextSize}/${maxFiles})`, 3e3);
            }
          }
        }
        if (updateUI) {
          contextManager.updateContextPanel();
        }
        if (saveChanges) {
          await contextManager.triggerContextChange();
        }
        return successCount;
      }
    };
  }
});

// src/mcp-tools/filesystem/tools/ManagementOperations.ts
var import_obsidian15, ManagementOperations;
var init_ManagementOperations = __esm({
  "src/mcp-tools/filesystem/tools/ManagementOperations.ts"() {
    import_obsidian15 = require("obsidian");
    init_constants();
    init_utils();
    init_workspaceUtils();
    ManagementOperations = class {
      constructor(app, plugin, allowedPaths) {
        this.app = app;
        this.plugin = plugin;
        this.allowedPaths = allowedPaths;
      }
      /**
       * Manage workspace by opening files with intelligent placement
       */
      async manageWorkspace(params) {
        const { files } = params;
        const opened = [];
        const errors = [];
        const currentLeaf = this.app.workspace.activeLeaf;
        let shouldRestoreFocus = true;
        for (const file of files) {
          const filePath = file.path;
          const { leaf, action } = await openFileInMainWorkspace(this.app, filePath);
          if (leaf) {
            opened.push(filePath);
            if (action === "switched_in_pane") {
              shouldRestoreFocus = false;
            }
          } else {
            errors.push(`Failed to open file: ${filePath}`);
          }
        }
        if (currentLeaf && shouldRestoreFocus) {
          this.app.workspace.setActiveLeaf(currentLeaf, { focus: true });
        }
        return { opened, errors };
      }
      /**
       * Manage context by adding or removing files from the current chat's context window
       */
      async manageContext(params) {
        const { action, paths } = params;
        if (!Array.isArray(paths) || paths.length === 0) {
          throw new Error("The 'paths' parameter must be a non-empty array of file or directory paths");
        }
        if (paths.length > 10) {
          throw new Error("Maximum 10 paths allowed per request to prevent context overflow");
        }
        const MAX_FILES_PER_REQUEST = FILESYSTEM_LIMITS.MAX_FILES_PER_REQUEST;
        const results = [];
        let totalFilesProcessed = 0;
        const currentChatView = this.getCurrentChatView();
        if (!currentChatView) {
          throw new Error("No active chat view found. This tool can only be used from within a chat conversation.");
        }
        if (action === "add") {
          let filesInCurrentRequest = 0;
          for (const path of paths) {
            try {
              const abstractFile = this.app.vault.getAbstractFileByPath(path);
              if (!abstractFile) {
                results.push({ path, success: false, reason: "File or directory not found" });
                continue;
              }
              if (abstractFile instanceof import_obsidian15.TFolder) {
                const folderFiles = getFilesFromFolder(abstractFile);
                if (folderFiles.length > MAX_FILES_PER_REQUEST) {
                  results.push({
                    path,
                    success: false,
                    reason: `Directory contains ${folderFiles.length} files, which exceeds the limit of ${MAX_FILES_PER_REQUEST} files per request. Please specify individual files instead.`
                  });
                  continue;
                }
                if (filesInCurrentRequest + folderFiles.length > MAX_FILES_PER_REQUEST) {
                  const remainingSlots = MAX_FILES_PER_REQUEST - filesInCurrentRequest;
                  results.push({
                    path,
                    success: false,
                    reason: `Cannot add ${folderFiles.length} files from directory. Only ${remainingSlots} slots remaining in this request.`
                  });
                  continue;
                }
                const { DocumentContextManager: DocumentContextManager2 } = await Promise.resolve().then(() => (init_DocumentContextManager(), DocumentContextManager_exports));
                const documentContextManager = DocumentContextManager2.getInstance(this.app, this.plugin);
                const addedCount = await documentContextManager.addFilesToContext(
                  folderFiles,
                  currentChatView.contextManager,
                  {
                    showNotices: false,
                    updateUI: true,
                    saveChanges: false,
                    // We'll save once at the end
                    maxFiles: 100
                    // Use the global context limit
                  }
                );
                if (addedCount > 0) {
                  results.push({ path, success: true });
                  filesInCurrentRequest += addedCount;
                  totalFilesProcessed += addedCount;
                } else {
                  results.push({ path, success: false, reason: "No files were added from directory" });
                }
              } else if (abstractFile instanceof import_obsidian15.TFile) {
                if (filesInCurrentRequest >= MAX_FILES_PER_REQUEST) {
                  results.push({
                    path,
                    success: false,
                    reason: "Reached maximum of 10 files per request"
                  });
                  continue;
                }
                const { DocumentContextManager: DocumentContextManager2 } = await Promise.resolve().then(() => (init_DocumentContextManager(), DocumentContextManager_exports));
                const documentContextManager = DocumentContextManager2.getInstance(this.app, this.plugin);
                const success = await documentContextManager.addFileToContext(
                  abstractFile,
                  currentChatView.contextManager,
                  {
                    showNotices: false,
                    updateUI: true,
                    saveChanges: false
                    // We'll save once at the end
                  }
                );
                if (success) {
                  results.push({ path, success: true });
                  filesInCurrentRequest++;
                  totalFilesProcessed++;
                } else {
                  results.push({ path, success: false, reason: "Failed to add file to context (may already be in context)" });
                }
              }
            } catch (error) {
              results.push({
                path,
                success: false,
                reason: error.message || "Unknown error occurred"
              });
            }
          }
          if (totalFilesProcessed > 0) {
            await currentChatView.contextManager.triggerContextChange();
          }
        } else if (action === "remove") {
          for (const path of paths) {
            try {
              const wikiLink = `[[${path}]]`;
              const hasFile = currentChatView.contextManager.hasContextFile(wikiLink) || currentChatView.contextManager.hasContextFile(path);
              if (hasFile) {
                const removed = await currentChatView.contextManager.removeFromContextFiles(path);
                if (removed) {
                  results.push({ path, success: true });
                  totalFilesProcessed++;
                } else {
                  results.push({
                    path,
                    success: false,
                    reason: "Failed to remove file from context"
                  });
                }
              } else {
                results.push({
                  path,
                  success: false,
                  reason: "File not found in current context"
                });
              }
            } catch (error) {
              results.push({
                path,
                success: false,
                reason: error.message || "Unknown error occurred"
              });
            }
          }
        } else {
          throw new Error("Invalid action. Must be 'add' or 'remove'");
        }
        const successCount = results.filter((r) => r.success).length;
        const failureCount = results.filter((r) => !r.success).length;
        let summary = `Context management completed: ${action} operation processed ${totalFilesProcessed} files. `;
        summary += `${successCount} paths succeeded, ${failureCount} paths failed.`;
        if (action === "add" && totalFilesProcessed > 0) {
          const currentCount = currentChatView.contextManager.getContextFiles().size;
          summary += ` Current context: ${currentCount} files total.`;
        }
        return {
          action,
          processed: totalFilesProcessed,
          results,
          summary
        };
      }
      /**
       * Get the current active chat view
       */
      getCurrentChatView() {
        const leaves = this.app.workspace.getLeavesOfType("systemsculpt-chat-view");
        for (const leaf of leaves) {
          if (leaf === this.app.workspace.activeLeaf) {
            return leaf.view;
          }
        }
        if (leaves.length > 0) {
          return leaves[0].view;
        }
        return null;
      }
    };
  }
});

// src/mcp-tools/filesystem/MCPFilesystemServer.ts
var MCPFilesystemServer_exports = {};
__export(MCPFilesystemServer_exports, {
  MCPFilesystemServer: () => MCPFilesystemServer
});
var MCPFilesystemServer;
var init_MCPFilesystemServer = __esm({
  "src/mcp-tools/filesystem/MCPFilesystemServer.ts"() {
    init_constants();
    init_toolDefinitions();
    init_FileOperations();
    init_DirectoryOperations();
    init_SearchOperations();
    init_ManagementOperations();
    MCPFilesystemServer = class {
      constructor(plugin, app) {
        this.allowedPaths = [];
        this.plugin = plugin;
        this.app = app;
        this.allowedPaths = ["/"];
        this.fileOps = new FileOperations(this.app, this.allowedPaths);
        this.directoryOps = new DirectoryOperations(this.app, this.allowedPaths, this.plugin);
        this.searchOps = new SearchOperations(this.app, this.allowedPaths, this.plugin);
        this.managementOps = new ManagementOperations(this.app, this.plugin, this.allowedPaths);
      }
      /**
       * Get available tools
       */
      async getTools() {
        return toolDefinitions;
      }
      /**
       * Get human-friendly description for a tool
       */
      static getToolDisplayDescription(toolName) {
        return TOOL_DISPLAY_DESCRIPTIONS[toolName] || "No description available";
      }
      /**
       * Get human-friendly display name for a tool
       */
      static getToolDisplayName(toolName) {
        return TOOL_DISPLAY_NAMES[toolName] || toolName;
      }
      /**
       * Execute a tool
       */
      async executeTool(toolName, args, chatView) {
        if (chatView && !chatView.agentMode) {
          throw new Error("Filesystem tool execution denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use filesystem tools.");
        }
        switch (toolName) {
          case "read":
            return await this.fileOps.readFiles(args);
          case "write":
            return await this.fileOps.writeFile(args);
          case "edit":
            const diff = await this.fileOps.editFile(args);
            return { path: args.path, success: true, diff };
          case "create_folders":
            return await this.directoryOps.createDirectories(args);
          case "list_items":
            return await this.directoryOps.listDirectories(args);
          case "move":
            return await this.directoryOps.moveItems(args);
          case "trash":
            return await this.directoryOps.trashFiles(args);
          case "find":
            return await this.searchOps.findFiles(args);
          case "search":
            return await this.searchOps.grepVault(args);
          case "open":
            return await this.managementOps.manageWorkspace(args);
          case "context":
            return await this.managementOps.manageContext(args);
          default:
            throw new Error(`Unknown tool: ${toolName}`);
        }
      }
      /**
       * Set allowed paths for security
       */
      setAllowedPaths(paths) {
        this.allowedPaths = paths.map((p) => p);
        this.fileOps = new FileOperations(this.app, this.allowedPaths);
        this.directoryOps = new DirectoryOperations(this.app, this.allowedPaths, this.plugin);
        this.searchOps = new SearchOperations(this.app, this.allowedPaths, this.plugin);
        this.managementOps = new ManagementOperations(this.app, this.plugin, this.allowedPaths);
      }
    };
  }
});

// src/mcp/adapters/FilesystemAdapter.ts
var FilesystemAdapter;
var init_FilesystemAdapter = __esm({
  "src/mcp/adapters/FilesystemAdapter.ts"() {
    init_MCPFilesystemServer();
    FilesystemAdapter = class {
      constructor(plugin, app) {
        this.fsServer = new MCPFilesystemServer(plugin, app);
      }
      async listTools() {
        return await this.fsServer.getTools();
      }
      async executeTool(toolName, args, chatView) {
        return await this.fsServer.executeTool(toolName, args, chatView);
      }
    };
  }
});

// src/mcp/adapters/HTTPAdapter.ts
var HTTPAdapter;
var init_HTTPAdapter = __esm({
  "src/mcp/adapters/HTTPAdapter.ts"() {
    HTTPAdapter = class {
      constructor(server, plugin, app, nextId) {
        this.server = server;
        this.plugin = plugin;
        this.app = app;
        this.nextId = nextId;
      }
      getHeaders() {
        const headers = { "Content-Type": "application/json" };
        if (this.server.apiKey) headers["Authorization"] = `Bearer ${this.server.apiKey}`;
        return headers;
      }
      assertEndpoint() {
        if (this.server.transport !== "http" || !this.server.endpoint) {
          throw new Error("Invalid HTTP server configuration");
        }
        return this.server.endpoint;
      }
      async listTools() {
        var _a;
        const endpoint = this.assertEndpoint();
        const request = { jsonrpc: "2.0", id: this.nextId(), method: "tools/list", params: {} };
        let response;
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const r = await httpRequest2({ url: endpoint, method: "POST", headers: this.getHeaders(), body: JSON.stringify(request) });
          response = new Response(r.text || JSON.stringify(r.json || {}), { status: r.status });
        } catch (error) {
          const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
          const message = `\u274C Connection to MCP server '${this.server.name}' refused:

${endpoint}

Please ensure the MCP server is running and accessible at this URL.`;
          showNoticeWhenReady2(this.app, message, { type: "error", duration: 15e3 });
          throw error;
        }
        if (!response.ok) {
          const errorData = await response.json().catch(() => ({}));
          if (response.status === 401) throw new Error("Invalid authentication. Please check your API key and try again.");
          if (response.status === 403) throw new Error("Access denied. Please verify your authentication has the correct permissions.");
          if (response.status === 404) throw new Error("MCP endpoint not found. Please check the URL and ensure the server supports JSON-RPC over HTTP.");
          throw new Error(`HTTP error: ${((_a = errorData.error) == null ? void 0 : _a.message) || response.statusText}`);
        }
        const jsonRpcResponse = await response.json();
        if (jsonRpcResponse.error) throw new Error(`MCP server error: ${jsonRpcResponse.error.message}`);
        const toolsResult = jsonRpcResponse.result;
        if (!toolsResult || !Array.isArray(toolsResult.tools)) {
          throw new Error("Invalid tools response format from MCP server");
        }
        return toolsResult.tools.map((tool) => ({
          name: tool.name,
          description: tool.description,
          inputSchema: tool.inputSchema || {}
        }));
      }
      async executeTool(toolName, args) {
        const endpoint = this.assertEndpoint();
        const request = {
          jsonrpc: "2.0",
          id: this.nextId(),
          method: "tools/call",
          params: { name: toolName, arguments: args }
        };
        const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
        const r = await httpRequest2({ url: endpoint, method: "POST", headers: this.getHeaders(), body: JSON.stringify(request) });
        const response = new Response(r.text || JSON.stringify(r.json || {}), { status: r.status });
        if (!response.ok) throw new Error(`Tool execution failed: ${response.statusText}`);
        const jsonRpcResponse = await response.json();
        if (jsonRpcResponse.error) throw new Error(`Tool execution error: ${jsonRpcResponse.error.message}`);
        return jsonRpcResponse.result;
      }
    };
  }
});

// src/mcp/MCPService.ts
var _MCPService, MCPService;
var init_MCPService = __esm({
  "src/mcp/MCPService.ts"() {
    init_FilesystemAdapter();
    init_HTTPAdapter();
    _MCPService = class _MCPService {
      constructor(plugin, app) {
        // Adapter instances keyed by server id
        this.adapters = /* @__PURE__ */ new Map();
        this.CACHE_DURATION = 30 * 60 * 1e3;
        // 30 minutes
        this.requestIdCounter = 0;
        this.plugin = plugin;
        this.app = app;
        this.logger = console;
      }
      getAdapterForServer(server) {
        const existing = this.adapters.get(server.id);
        if (existing) return existing;
        let adapter;
        if (server.transport === "internal" && server.id === "mcp-filesystem") {
          adapter = new FilesystemAdapter(this.plugin, this.app);
        } else if (server.transport === "http") {
          adapter = new HTTPAdapter(server, this.plugin, this.app, () => ++this.requestIdCounter);
        } else {
          throw new Error("Only HTTP and internal transports are currently supported");
        }
        this.adapters.set(server.id, adapter);
        return adapter;
      }
      clearCache() {
        _MCPService.connectionTestCache.clear();
        _MCPService.connectionTestPromises.clear();
      }
      async testConnection(server) {
        const cached = _MCPService.connectionTestCache.get(server.id);
        if (cached && Date.now() - cached.result.timestamp < this.CACHE_DURATION) {
          return cached.result;
        }
        const existingPromise = _MCPService.connectionTestPromises.get(server.id);
        if (existingPromise) return existingPromise;
        const testPromise = this.performConnectionTest(server);
        _MCPService.connectionTestPromises.set(server.id, testPromise);
        try {
          const result = await testPromise;
          if (result.success) {
            _MCPService.connectionTestCache.set(server.id, { result, timestamp: Date.now() });
          }
          return result;
        } finally {
          _MCPService.connectionTestPromises.delete(server.id);
        }
      }
      async performConnectionTest(server) {
        try {
          const tools = await this.discoverTools(server);
          return { success: true, tools, timestamp: Date.now() };
        } catch (error) {
          this.logger.error(`MCP connection test failed for ${server.name}:`, error);
          return { success: false, error: this.getErrorMessage(error), timestamp: Date.now() };
        }
      }
      async discoverTools(server) {
        const adapter = this.getAdapterForServer(server);
        return await adapter.listTools();
      }
      async getAvailableTools() {
        if (!this.plugin.settings.mcpEnabled) {
          const activeChatView = this.plugin.app.workspace.getLeavesOfType("systemsculpt-chat-view").map((leaf) => leaf.view).find((view) => view && view.leaf === this.plugin.app.workspace.activeLeaf);
          const isAgentModeActive = !!(activeChatView == null ? void 0 : activeChatView.agentMode);
          if (!isAgentModeActive) return [];
        }
        const allServers = this.plugin.settings.mcpServers || [];
        const enabledServers = allServers.filter((s) => s.isEnabled);
        const filesystemServer = allServers.find((s) => s.id === "mcp-filesystem");
        if (filesystemServer && !enabledServers.find((s) => s.id === "mcp-filesystem")) {
          enabledServers.push(filesystemServer);
        }
        if (enabledServers.length === 0) return [];
        const serverToolsArrays = await Promise.all(
          enabledServers.map(async (server) => {
            try {
              const connectionResult = await this.testConnection(server);
              if (!connectionResult.success || !connectionResult.tools) return [];
              const converted = [];
              for (const tool of connectionResult.tools) {
                try {
                  const openAITool = this.convertToOpenAITool(tool, server);
                  if (!this.plugin.settings.mcpEnabled) {
                    const readOnlyFilesystemTools = [
                      "read",
                      "list_items",
                      "find",
                      "search",
                      "open",
                      "context"
                    ];
                    const isFilesystemReadOnly = server.id === "mcp-filesystem" && readOnlyFilesystemTools.includes(tool.name);
                    if (!isFilesystemReadOnly) continue;
                  }
                  converted.push(openAITool);
                } catch (error) {
                  this.logger.warn(`[SystemSculpt] Failed to convert tool ${tool.name || "unnamed"} from server ${server.name}:`, error);
                }
              }
              return converted;
            } catch (error) {
              this.logger.warn(`Failed to get tools from MCP server ${server.name}:`, error);
              return [];
            }
          })
        );
        const allTools = [];
        for (const arr of serverToolsArrays) allTools.push(...arr);
        return allTools;
      }
      convertToOpenAITool(tool, server) {
        if (!tool || !tool.name || tool.name.trim() === "") {
          this.logger.warn(`[SystemSculpt] Skipping tool with invalid name:`, tool);
          throw new Error(`Tool missing required name property`);
        }
        if (!server || !server.id) {
          this.logger.warn(`[SystemSculpt] Server missing valid ID:`, server);
          throw new Error(`Server missing required id property`);
        }
        const openAITool = {
          type: "function",
          function: {
            name: `${server.id}_${tool.name}`,
            description: `[${server.name}] ${tool.description || "No description provided"}`,
            parameters: tool.inputSchema || {}
          }
        };
        if (!openAITool.function.name || typeof openAITool.function.name !== "string") {
          this.logger.error(`[SystemSculpt] Generated invalid OpenAI tool:`, openAITool);
          throw new Error(`Failed to generate valid OpenAI tool`);
        }
        return openAITool;
      }
      async executeTool(toolName, args, chatView) {
        if (chatView && !chatView.agentMode) {
          throw new Error("Tool execution denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use tools.");
        }
        const firstUnderscoreIndex = toolName.indexOf("_");
        if (firstUnderscoreIndex === -1) {
          throw new Error(`Invalid tool name format: ${toolName}`);
        }
        const serverId = toolName.substring(0, firstUnderscoreIndex);
        const actualToolName = toolName.substring(firstUnderscoreIndex + 1);
        const server = this.plugin.settings.mcpServers.find((s) => s.id === serverId);
        if (!server) throw new Error(`MCP server not found: ${serverId}`);
        if (!server.isEnabled) throw new Error(`MCP server is disabled: ${server.name}`);
        const adapter = this.getAdapterForServer(server);
        return await adapter.executeTool(actualToolName, args, chatView);
      }
      async testAllServers() {
        const results = {};
        const enabledServers = this.plugin.settings.mcpServers.filter((server) => server.isEnabled);
        const testResults = await Promise.all(enabledServers.map(async (server) => {
          const result = await this.testConnection(server);
          return { serverId: server.id, result };
        }));
        for (const { serverId, result } of testResults) results[serverId] = result;
        return results;
      }
      getErrorMessage(error) {
        if (error instanceof Error) {
          if (error.name === "AbortError") return "Connection timed out. Please check your internet connection and try again.";
          return error.message;
        }
        return "An unexpected error occurred. Please try again or contact support if the issue persists.";
      }
    };
    // Static caches shared across instances
    _MCPService.connectionTestCache = /* @__PURE__ */ new Map();
    _MCPService.connectionTestPromises = /* @__PURE__ */ new Map();
    MCPService = _MCPService;
  }
});

// src/views/chatview/MCPService.ts
var MCPService_exports = {};
__export(MCPService_exports, {
  MCPService: () => MCPService
});
var init_MCPService2 = __esm({
  "src/views/chatview/MCPService.ts"() {
    init_MCPService();
  }
});

// src/utils/debugLogger.ts
var _DebugLogger, DebugLogger;
var init_debugLogger = __esm({
  "src/utils/debugLogger.ts"() {
    _DebugLogger = class _DebugLogger {
      constructor() {
      }
      // Called by the plugin on load â€“ we keep it for compatibility.
      static initialize(_app) {
      }
      // Standard singleton accessor â€“ always returns the same stub instance.
      static getInstance() {
        return _DebugLogger.instance;
      }
      // Generic logging helpers â€“ now no-ops.
      log(..._args) {
      }
      logToolCall(..._args) {
      }
      logStreamChunk(..._args) {
      }
      logUserAction(..._args) {
      }
      logAPIRequest(..._args) {
      }
      logAPIResponse(..._args) {
      }
      logToolApproval(..._args) {
      }
      logToolExecution(..._args) {
      }
      logChatViewLoad(..._args) {
      }
      logChatViewRender(..._args) {
      }
      logChatViewStructure(..._args) {
      }
      logChatSave(..._args) {
      }
      logError(..._args) {
      }
      setEnabled(_enabled) {
      }
      clearLog() {
      }
      async exportMobileLogs() {
        return "";
      }
      logMobileError(..._args) {
      }
      logMobilePerformance(..._args) {
      }
      logGlobalUncaughtError(..._args) {
      }
    };
    _DebugLogger.instance = new _DebugLogger();
    DebugLogger = _DebugLogger;
  }
});

// src/utils/modelUtils.ts
var modelUtils_exports = {};
__export(modelUtils_exports, {
  MODEL_ID_SEPARATOR: () => MODEL_ID_SEPARATOR,
  createCanonicalId: () => createCanonicalId,
  ensureCanonicalId: () => ensureCanonicalId,
  filterChatModels: () => filterChatModels,
  findModelById: () => findModelById,
  getCanonicalId: () => getCanonicalId,
  getDisplayName: () => getDisplayName,
  getImageCompatibilityInfo: () => getImageCompatibilityInfo,
  getModelLabelWithProvider: () => getModelLabelWithProvider,
  getProviderDisplayPrefix: () => getProviderDisplayPrefix,
  getToolCompatibilityInfo: () => getToolCompatibilityInfo,
  isEmbeddingModel: () => isEmbeddingModel,
  migrateFromLegacyId: () => migrateFromLegacyId,
  parseCanonicalId: () => parseCanonicalId,
  supportsImages: () => supportsImages,
  supportsTools: () => supportsTools
});
function createCanonicalId(providerId, modelId) {
  return `${providerId.toLowerCase()}${MODEL_ID_SEPARATOR}${modelId}`;
}
function parseCanonicalId(canonicalId) {
  if (!(canonicalId == null ? void 0 : canonicalId.includes(MODEL_ID_SEPARATOR))) {
    return null;
  }
  const [providerId, ...modelIdParts] = canonicalId.split(MODEL_ID_SEPARATOR);
  return {
    providerId: providerId.toLowerCase(),
    modelId: modelIdParts.join(MODEL_ID_SEPARATOR)
    // Rejoin in case model ID contains separator
  };
}
function migrateFromLegacyId(legacyId, defaultProvider = "systemsculpt") {
  if (legacyId == null ? void 0 : legacyId.includes(MODEL_ID_SEPARATOR)) {
    return legacyId;
  }
  const knownProviders = ["openrouter", "together", "fireworks"];
  if (legacyId == null ? void 0 : legacyId.includes("/")) {
    for (const provider of knownProviders) {
      if (legacyId.toLowerCase().startsWith(`${provider}/`)) {
        const providerId = provider;
        const modelId = legacyId.substring(provider.length + 1);
        return createCanonicalId(providerId, modelId);
      }
    }
    const parts = legacyId.split("/");
    if (parts.length >= 2) {
      return createCanonicalId(
        parts[0].toLowerCase(),
        parts.slice(1).join("/")
        // Preserve any slashes in the model ID portion
      );
    }
  }
  return createCanonicalId(defaultProvider, legacyId);
}
function getCanonicalId(model) {
  var _a, _b, _c;
  if ((_a = model.id) == null ? void 0 : _a.includes(MODEL_ID_SEPARATOR)) {
    return model.id;
  }
  if (((_b = model.identifier) == null ? void 0 : _b.providerId) && ((_c = model.identifier) == null ? void 0 : _c.modelId)) {
    return createCanonicalId(model.identifier.providerId, model.identifier.modelId);
  }
  if (model.provider) {
    return createCanonicalId(model.provider, model.id || model.name);
  }
  return createCanonicalId("unknown", model.id || model.name || "unknown-model");
}
function findModelById(models, modelId) {
  const canonicalId = modelId.includes(MODEL_ID_SEPARATOR) ? modelId : migrateFromLegacyId(modelId);
  let model = models.find((m) => m.id === canonicalId);
  if (model) {
    return model;
  }
  const parsed = parseCanonicalId(canonicalId);
  if (!parsed) {
    return void 0;
  }
  model = models.find((m) => {
    var _a;
    if (m.provider.toLowerCase() !== parsed.providerId) {
      return false;
    }
    return ((_a = m.identifier) == null ? void 0 : _a.modelId) === parsed.modelId || // Match by identifier.modelId
    m.name === parsed.modelId;
  });
  if (model) {
    return model;
  }
  if (parsed.providerId === "openai") {
    const normalizedModelId = parsed.modelId.toLowerCase().replace(/[-\.]/g, "").replace(/\s+/g, "");
    model = models.find((m) => {
      if (m.provider.toLowerCase() !== "openai") return false;
      const normalizedName = (m.name || "").toLowerCase().replace(/[-\.]/g, "").replace(/\s+/g, "");
      return normalizedName.includes(normalizedModelId) || normalizedModelId.includes(normalizedName);
    });
    if (model) {
      return model;
    }
  }
  return void 0;
}
function getDisplayName(modelId) {
  if (modelId == null ? void 0 : modelId.includes(MODEL_ID_SEPARATOR)) {
    const parsed = parseCanonicalId(modelId);
    if (parsed) {
      return parsed.modelId;
    }
  }
  if (modelId == null ? void 0 : modelId.includes("/")) {
    const parts = modelId.split("/");
    if (parts.length >= 2) {
      return parts[parts.length - 1];
    }
  }
  return modelId;
}
function getProviderDisplayPrefix(providerId) {
  const normalized = (providerId || "").toLowerCase();
  if (!normalized) {
    return "";
  }
  if (normalized === "systemsculpt") {
    return "[SS AI] ";
  }
  return `[${normalized.toUpperCase()}] `;
}
function getModelLabelWithProvider(modelId) {
  if (!modelId) {
    return "";
  }
  const canonical = ensureCanonicalId(modelId);
  const parsed = parseCanonicalId(canonical);
  if (parsed) {
    const prefix = getProviderDisplayPrefix(parsed.providerId);
    return `${prefix}${getDisplayName(canonical)}`;
  }
  return getDisplayName(modelId);
}
function supportsImages(model) {
  var _a;
  if (!model) return false;
  const caps = (model.capabilities || []).map((c) => c.toLowerCase());
  if (caps.includes("vision") || caps.includes("image") || caps.includes("images")) {
    return true;
  }
  const modality = (((_a = model.architecture) == null ? void 0 : _a.modality) || "").toLowerCase();
  if (modality.includes("vision") || modality.includes("image") || modality.includes("text+image")) {
    return true;
  }
  return false;
}
function getImageCompatibilityInfo(model) {
  var _a;
  if (!model) {
    return { isCompatible: false, reason: "No model provided", confidence: "low" };
  }
  const caps = (model.capabilities || []).map((c) => c.toLowerCase());
  if (caps.includes("vision") || caps.includes("image") || caps.includes("images")) {
    return {
      isCompatible: true,
      reason: "Model capabilities include vision/image",
      confidence: "high"
    };
  }
  const modality = (((_a = model.architecture) == null ? void 0 : _a.modality) || "").toLowerCase();
  if (modality.includes("vision") || modality.includes("image") || modality.includes("text+image")) {
    return {
      isCompatible: true,
      reason: "Architecture modality indicates vision support",
      confidence: "medium"
    };
  }
  return {
    isCompatible: false,
    reason: "No vision indicators detected",
    confidence: "medium"
  };
}
function ensureCanonicalId(modelId, defaultProvider = "systemsculpt") {
  if (!modelId) {
    return "";
  }
  if (modelId.includes(MODEL_ID_SEPARATOR)) {
    return modelId;
  }
  return migrateFromLegacyId(modelId, defaultProvider);
}
function isEmbeddingModel(model) {
  const nameCheck = model.name.toLowerCase().includes("embed");
  const idCheck = model.id.toLowerCase().includes("embed");
  const capabilitiesCheck = model.capabilities && model.capabilities.includes("embeddings") && !model.capabilities.includes("chat");
  return nameCheck || idCheck || capabilitiesCheck;
}
function filterChatModels(models) {
  return models.filter((model) => !isEmbeddingModel(model));
}
function supportsTools(model) {
  if (model.supported_parameters && Array.isArray(model.supported_parameters)) {
    return model.supported_parameters.includes("tools");
  }
  if (model.capabilities && model.capabilities.length > 0) {
    const toolCapabilities = [
      "tools",
      "function_calling",
      "function-calling",
      "tool_use",
      "tool-use"
    ];
    const hasCapability = model.capabilities.some(
      (cap) => toolCapabilities.includes(cap.toLowerCase())
    );
    if (hasCapability) {
      return true;
    }
  }
  return hasKnownToolSupport(model);
}
function hasKnownToolSupport(model) {
  return true;
}
function getToolCompatibilityInfo(model) {
  if (model.supported_parameters && Array.isArray(model.supported_parameters)) {
    const supportsTools2 = model.supported_parameters.includes("tools");
    return {
      isCompatible: supportsTools2,
      reason: supportsTools2 ? 'OpenRouter confirms model supports "tools" parameter' : 'OpenRouter data shows model does not support "tools" parameter',
      confidence: "high"
    };
  }
  if (model.capabilities && model.capabilities.length > 0) {
    const toolCapabilities = [
      "tools",
      "function_calling",
      "function-calling",
      "tool_use",
      "tool-use"
    ];
    const hasToolCapability = model.capabilities.some(
      (cap) => toolCapabilities.includes(cap.toLowerCase())
    );
    if (hasToolCapability) {
      return {
        isCompatible: true,
        reason: "Model capabilities indicate tool support",
        confidence: "medium"
      };
    }
  }
  return {
    isCompatible: true,
    reason: "No explicit tool support data - will attempt (OpenRouter safely ignores unsupported params)",
    confidence: "low"
  };
}
var MODEL_ID_SEPARATOR;
var init_modelUtils = __esm({
  "src/utils/modelUtils.ts"() {
    MODEL_ID_SEPARATOR = "@@";
  }
});

// src/utils/cryptoUtils.ts
function simpleHash(str) {
  let hash = 0;
  for (let i = 0; i < str.length; i++) {
    const char = str.charCodeAt(i);
    hash = (hash << 5) - hash + char;
    hash = hash & hash;
  }
  return Math.abs(hash).toString(16).padStart(8, "0");
}
var init_cryptoUtils = __esm({
  "src/utils/cryptoUtils.ts"() {
  }
});

// src/utils/id.ts
function deterministicId(input, prefix) {
  const hash = simpleHash(input);
  const extendedHash = simpleHash(hash + input) + simpleHash(input + hash);
  return `${prefix}_${extendedHash.slice(0, 24)}`;
}
var init_id = __esm({
  "src/utils/id.ts"() {
    init_cryptoUtils();
  }
});

// src/utils/tooling.ts
function isValidOpenAITool(tool) {
  return !!tool && tool.type === "function" && !!tool.function && typeof tool.function.name === "string" && tool.function.name.length > 0;
}
function normalizeOpenAITools(tools) {
  const seen = /* @__PURE__ */ new Set();
  const result = [];
  for (const tool of tools || []) {
    if (!isValidOpenAITool(tool)) continue;
    const name = tool.function.name.trim();
    if (seen.has(name)) continue;
    seen.add(name);
    const parameters = tool.function.parameters && typeof tool.function.parameters === "object" ? tool.function.parameters : {};
    result.push({
      type: "function",
      function: {
        name,
        description: tool.function.description || "",
        parameters
      }
    });
  }
  return result;
}
function transformToolsForModel(modelId, providerEndpoint, tools) {
  if (!Array.isArray(tools) || tools.length === 0) return [];
  const isO4Mini = typeof modelId === "string" && (modelId.toLowerCase().includes("o4-mini") || modelId.toLowerCase().includes("o4 mini"));
  const isOpenRouter = typeof providerEndpoint === "string" && providerEndpoint.includes("openrouter.ai");
  if (isO4Mini && isOpenRouter) {
    return tools.map((t) => ({
      type: t.type || "function",
      name: t.function.name,
      description: t.function.description || "",
      parameters: t.function.parameters || {}
    }));
  }
  return tools;
}
function mapAssistantToolCallsForApi(rawToolCalls) {
  if (!Array.isArray(rawToolCalls)) return [];
  return rawToolCalls.map((toolCall) => {
    const req = toolCall && (toolCall.request || toolCall) || {};
    const fn = req.function || toolCall.function || {};
    if (!fn || !fn.name) return null;
    const normalizedArgs = normalizeJsonString(fn.arguments);
    const id = typeof req.id === "string" && req.id.length > 0 ? req.id : deterministicId(String(fn.name) + normalizedArgs, "call");
    return {
      id,
      type: "function",
      function: {
        name: String(fn.name),
        arguments: normalizedArgs
      }
    };
  }).filter((tc) => tc !== null);
}
function buildToolResultMessagesFromToolCalls(toolCalls) {
  const messages = [];
  for (const toolCall of toolCalls || []) {
    let toolContent;
    const state = toolCall.state;
    const result = toolCall.result;
    if (state === "completed" && (result == null ? void 0 : result.success)) {
      toolContent = typeof result.data === "string" ? result.data : JSON.stringify(result.data);
    } else if (state === "failed" || state === "completed" && !(result == null ? void 0 : result.success)) {
      toolContent = JSON.stringify({ error: (result == null ? void 0 : result.error) || { code: "EXECUTION_FAILED", message: "Tool execution failed without a specific error." } });
    } else if (state === "denied") {
      toolContent = JSON.stringify({ error: { code: "USER_DENIED", message: "The user has explicitly denied this tool call request." } });
    } else {
      continue;
    }
    messages.push({
      role: "tool",
      tool_call_id: toolCall.id,
      content: toolContent,
      message_id: deterministicId(toolContent, "tool")
    });
  }
  return messages;
}
function normalizeJsonSchema(schema) {
  if (!schema || typeof schema !== "object") {
    return { type: "object", properties: {}, additionalProperties: true };
  }
  const cloned = { ...schema };
  let type = cloned.type;
  if (!type || type !== "object") {
    type = "object";
  }
  const properties = cloned.properties && typeof cloned.properties === "object" ? { ...cloned.properties } : {};
  const required = Array.isArray(cloned.required) ? [...cloned.required] : void 0;
  const hasTopLevelUnion = !!(cloned.oneOf || cloned.anyOf || cloned.allOf);
  let additionalProperties = typeof cloned.additionalProperties === "boolean" || typeof cloned.additionalProperties === "object" ? cloned.additionalProperties : true;
  if (hasTopLevelUnion) {
    try {
      const options = cloned.oneOf || cloned.anyOf || cloned.allOf;
      const objectOptions = (Array.isArray(options) ? options : []).filter((o) => o && typeof o === "object");
      let mergedProps = { ...properties };
      let mergedRequired = required ? [...required] : void 0;
      if (objectOptions.length > 0) {
        const requiredSets = [];
        for (const opt of objectOptions) {
          const optType = opt.type;
          const optProps = opt && opt.properties && typeof opt.properties === "object" ? opt.properties : void 0;
          if (optType === "object" && optProps) {
            mergedProps = { ...mergedProps, ...optProps };
            if (Array.isArray(opt.required)) {
              requiredSets.push(opt.required.filter((v) => typeof v === "string"));
            }
            if (typeof opt.additionalProperties !== "undefined") {
              additionalProperties = opt.additionalProperties;
            }
          }
        }
        if (cloned.allOf && requiredSets.length > 0) {
          mergedRequired = Array.from(/* @__PURE__ */ new Set([...mergedRequired || [], ...requiredSets.flat()]));
        } else if ((cloned.oneOf || cloned.anyOf) && requiredSets.length > 0) {
          const intersect = (arrs) => arrs.reduce((acc, cur, idx) => {
            if (idx === 0) return [...cur];
            const set = new Set(cur);
            return acc.filter((x) => set.has(x));
          }, []);
          mergedRequired = intersect(requiredSets);
        }
      }
      const sanitized = {
        type: "object",
        properties: mergedProps,
        ...mergedRequired && mergedRequired.length > 0 ? { required: mergedRequired } : {},
        ...typeof additionalProperties !== "undefined" ? { additionalProperties } : {}
      };
      if (typeof cloned.description === "string") sanitized.description = cloned.description;
      if (typeof cloned.title === "string") sanitized.title = cloned.title;
      return sanitized;
    } catch (e) {
      return { type: "object", properties, ...required ? { required } : {}, additionalProperties };
    }
  }
  const result = {
    type: "object",
    properties,
    ...required ? { required } : {},
    ...typeof additionalProperties !== "undefined" ? { additionalProperties } : {}
  };
  if (typeof cloned.description === "string") result.description = cloned.description;
  if (typeof cloned.title === "string") result.title = cloned.title;
  return result;
}
var init_tooling = __esm({
  "src/utils/tooling.ts"() {
    init_jsonRepair();
    init_id();
  }
});

// src/utils/MobileDetection.ts
var import_obsidian16, MobileDetection;
var init_MobileDetection = __esm({
  "src/utils/MobileDetection.ts"() {
    import_obsidian16 = require("obsidian");
    MobileDetection = class _MobileDetection {
      constructor() {
        this.cachedInfo = null;
        this.lastUpdate = 0;
        this.CACHE_DURATION = 3e4;
      }
      // 30 seconds
      static getInstance() {
        if (!_MobileDetection.instance) {
          _MobileDetection.instance = new _MobileDetection();
        }
        return _MobileDetection.instance;
      }
      /**
       * Get comprehensive mobile device information
       */
      getDeviceInfo() {
        const now = Date.now();
        if (this.cachedInfo && now - this.lastUpdate < this.CACHE_DURATION) {
          return this.cachedInfo;
        }
        this.cachedInfo = this.detectDeviceInfo();
        this.lastUpdate = now;
        return this.cachedInfo;
      }
      /**
       * Quick mobile detection check
       */
      isMobileDevice() {
        return this.getDeviceInfo().isMobile;
      }
      /**
       * Check if device has resource constraints
       */
      isResourceConstrained() {
        return this.getDeviceInfo().limitations.resourceConstrained;
      }
      /**
       * Check if device has functionality limitations
       */
      hasFunctionalityLimitations() {
        return this.getDeviceInfo().limitations.functionalityLimited;
      }
      detectDeviceInfo() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
        const userAgent = navigator.userAgent;
        const platform = this.detectPlatform(userAgent);
        const device = this.detectDevice(userAgent);
        const mobileUserAgent = /Mobi|Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(userAgent);
        const appAny = typeof window !== "undefined" ? window == null ? void 0 : window.app : void 0;
        const isMobileEmulation = Boolean((appAny == null ? void 0 : appAny.isMobile) && typeof (appAny == null ? void 0 : appAny.emulateMobile) === "function");
        const capabilities = this.detectCapabilities();
        const network = this.detectNetwork();
        const performance2 = this.detectPerformance();
        const limitations = this.detectLimitations(device, capabilities, network, performance2);
        const npm = this.detectNpmIssues(platform.os, device.type, limitations);
        const platformSignals = Boolean(
          ((_a = import_obsidian16.Platform) == null ? void 0 : _a.isMobileApp) || ((_b = import_obsidian16.Platform) == null ? void 0 : _b.isAndroidApp) || ((_c = import_obsidian16.Platform) == null ? void 0 : _c.isIosApp) || ((_d = import_obsidian16.Platform) == null ? void 0 : _d.isMobile) && (((_e = import_obsidian16.Platform) == null ? void 0 : _e.isDesktopApp) !== true || isMobileEmulation || mobileUserAgent) || isMobileEmulation
        );
        const isMobile = platformSignals || device.type === "smartphone" || device.type === "tablet" || platform.os === "iOS" || platform.os === "Android" || mobileUserAgent;
        try {
          console.debug("[SystemSculpt][MobileDetection] detectDeviceInfo result", {
            platformSignals,
            platformFlags: {
              isMobileApp: (_f = import_obsidian16.Platform) == null ? void 0 : _f.isMobileApp,
              isAndroidApp: (_g = import_obsidian16.Platform) == null ? void 0 : _g.isAndroidApp,
              isIosApp: (_h = import_obsidian16.Platform) == null ? void 0 : _h.isIosApp,
              isMobile: (_i = import_obsidian16.Platform) == null ? void 0 : _i.isMobile,
              isDesktopApp: (_j = import_obsidian16.Platform) == null ? void 0 : _j.isDesktopApp
            },
            deviceType: device.type,
            os: platform.os,
            uaSnippet: userAgent.slice(0, 120),
            isMobile
          });
        } catch (e) {
        }
        return {
          isMobile,
          platform,
          device,
          capabilities,
          network,
          performance: performance2,
          limitations,
          npm
        };
      }
      detectPlatform(userAgent) {
        let os = "Unknown";
        let name = "Unknown";
        let version = "Unknown";
        if (/iPhone|iPad|iPod/i.test(userAgent)) {
          os = "iOS";
          name = "iOS";
          const match = userAgent.match(/OS (\d+_\d+)/);
          if (match) {
            version = match[1].replace("_", ".");
          }
        } else if (/Android/i.test(userAgent)) {
          os = "Android";
          name = "Android";
          const match = userAgent.match(/Android (\d+\.?\d*)/);
          if (match) {
            version = match[1];
          }
        } else if (/Windows/i.test(userAgent)) {
          os = "Windows";
          name = "Windows";
          if (/Windows NT (\d+\.\d+)/i.test(userAgent)) {
            const match = userAgent.match(/Windows NT (\d+\.\d+)/i);
            if (match) version = match[1];
          }
        } else if (/Mac OS X/i.test(userAgent)) {
          os = "macOS";
          name = "macOS";
          const match = userAgent.match(/Mac OS X (\d+[_\d]*)/i);
          if (match) {
            version = match[1].replace(/_/g, ".");
          }
        } else if (/Linux/i.test(userAgent)) {
          os = "Linux";
          name = "Linux";
        }
        return { name, version, os };
      }
      detectDevice(userAgent) {
        let type = "unknown";
        let model = "Unknown";
        let vendor = "Unknown";
        if (/iPhone/i.test(userAgent)) {
          type = "smartphone";
          vendor = "Apple";
          const match = userAgent.match(/iPhone[^;]*/i);
          if (match) model = match[0];
        } else if (/iPad/i.test(userAgent)) {
          type = "tablet";
          vendor = "Apple";
          model = "iPad";
        } else if (/Android/i.test(userAgent)) {
          if (/Mobile/i.test(userAgent)) {
            type = "smartphone";
          } else {
            type = "tablet";
          }
          const samsungMatch = userAgent.match(/SM-[A-Z0-9]+/i);
          const pixelMatch = userAgent.match(/Pixel [0-9a-zA-Z ]+/i);
          if (samsungMatch) {
            vendor = "Samsung";
            model = samsungMatch[0];
          } else if (pixelMatch) {
            vendor = "Google";
            model = pixelMatch[0];
          } else if (/Huawei/i.test(userAgent)) {
            vendor = "Huawei";
          } else if (/OnePlus/i.test(userAgent)) {
            vendor = "OnePlus";
          }
        } else {
          type = "desktop";
        }
        const screenSize = `${screen.width}x${screen.height}`;
        return { type, model, vendor, screenSize };
      }
      detectCapabilities() {
        const touchSupport = "ontouchstart" in window || navigator.maxTouchPoints > 0;
        return {
          touchSupport,
          hasCamera: "mediaDevices" in navigator && "getUserMedia" in navigator.mediaDevices,
          hasGeolocation: "geolocation" in navigator,
          hasAccelerometer: "DeviceMotionEvent" in window,
          hasGyroscope: "DeviceOrientationEvent" in window,
          hasVibration: "vibrate" in navigator,
          hasServiceWorker: "serviceWorker" in navigator,
          hasWebGL: this.detectWebGL(),
          hasWebRTC: "RTCPeerConnection" in window,
          hasFileAPI: "File" in window && "FileReader" in window,
          hasClipboardAPI: "clipboard" in navigator,
          hasNotificationAPI: "Notification" in window
        };
      }
      detectWebGL() {
        try {
          const canvas = document.createElement("canvas");
          return !!(window.WebGLRenderingContext && canvas.getContext("webgl"));
        } catch (e) {
          return false;
        }
      }
      detectNetwork() {
        const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
        return {
          type: (connection == null ? void 0 : connection.type) || "unknown",
          effectiveType: (connection == null ? void 0 : connection.effectiveType) || "unknown",
          downlink: (connection == null ? void 0 : connection.downlink) || 0,
          rtt: (connection == null ? void 0 : connection.rtt) || 0,
          saveData: (connection == null ? void 0 : connection.saveData) || false
        };
      }
      detectPerformance() {
        const memory = performance.memory;
        return {
          memoryLimit: (memory == null ? void 0 : memory.usedJSHeapSize) ? Math.round(memory.usedJSHeapSize / 1024 / 1024) : 0,
          processorCores: navigator.hardwareConcurrency || 1,
          maxTouchPoints: navigator.maxTouchPoints || 0,
          pixelRatio: window.devicePixelRatio || 1
        };
      }
      detectLimitations(device, capabilities, network, performance2) {
        const reasons = [];
        let resourceConstrained = false;
        let functionalityLimited = false;
        let networkConstrained = false;
        let storageConstrained = false;
        if (performance2.memoryLimit > 0 && performance2.memoryLimit < 100) {
          resourceConstrained = true;
          reasons.push("Low memory available (< 100MB)");
        }
        if (performance2.processorCores <= 2) {
          resourceConstrained = true;
          reasons.push("Limited CPU cores (\u2264 2)");
        }
        if (device.type === "smartphone") {
          resourceConstrained = true;
          reasons.push("Smartphone has inherent resource limitations");
        }
        if (!capabilities.hasFileAPI) {
          functionalityLimited = true;
          reasons.push("File API not available");
        }
        if (!capabilities.hasClipboardAPI) {
          functionalityLimited = true;
          reasons.push("Clipboard API limited or unavailable");
        }
        if (!capabilities.hasServiceWorker) {
          functionalityLimited = true;
          reasons.push("Service Worker not supported");
        }
        if (network.effectiveType === "slow-2g" || network.effectiveType === "2g") {
          networkConstrained = true;
          reasons.push("Slow network connection detected");
        }
        if (network.saveData) {
          networkConstrained = true;
          reasons.push("Data saver mode enabled");
        }
        if (network.downlink > 0 && network.downlink < 1) {
          networkConstrained = true;
          reasons.push("Low bandwidth connection");
        }
        try {
          if ("storage" in navigator && "estimate" in navigator.storage) {
            storageConstrained = true;
            reasons.push("Storage may be limited on mobile device");
          }
        } catch (e) {
        }
        return {
          resourceConstrained,
          functionalityLimited,
          networkConstrained,
          storageConstrained,
          reasons
        };
      }
      detectNpmIssues(os, deviceType, limitations) {
        const problematicPackages = [];
        const unavailableFeatures = [];
        const recommendedAlternatives = {};
        if (os === "iOS") {
          problematicPackages.push(
            "fs-extra",
            "child_process",
            "crypto (Node.js)",
            "path",
            "os",
            "node-fetch (older versions)",
            "jsdom",
            "puppeteer",
            "playwright"
          );
          unavailableFeatures.push(
            "File system access",
            "Process spawning",
            "Node.js crypto module",
            "Server-side rendering packages",
            "Headless browsers"
          );
          recommendedAlternatives["node-fetch"] = "native fetch API";
          recommendedAlternatives["fs-extra"] = "File API / FileSystem Access API";
          recommendedAlternatives["crypto"] = "Web Crypto API";
        }
        if (os === "Android") {
          problematicPackages.push(
            "fs-extra",
            "child_process",
            "node-fetch (older versions)",
            "jsdom",
            "puppeteer",
            "playwright",
            "native modules"
          );
          unavailableFeatures.push(
            "File system access",
            "Process spawning",
            "Native module compilation",
            "Headless browsers",
            "System-level APIs"
          );
        }
        if (deviceType === "smartphone" || deviceType === "tablet") {
          problematicPackages.push(
            "webpack-dev-server",
            "nodemon",
            "pm2",
            "sharp (native)",
            "sqlite3 (native)",
            "bcrypt (native)",
            "canvas (native)"
          );
          unavailableFeatures.push(
            "Hot module replacement",
            "File watching",
            "Process management",
            "Native image processing",
            "Native database drivers"
          );
          recommendedAlternatives["sharp"] = "canvas API or browser-compatible image libraries";
          recommendedAlternatives["sqlite3"] = "IndexedDB or WebSQL";
          recommendedAlternatives["bcrypt"] = "Web Crypto API with PBKDF2";
          recommendedAlternatives["canvas"] = "HTML5 Canvas API";
        }
        if (limitations.networkConstrained) {
          problematicPackages.push("large bundled packages", "moment.js (large)", "lodash (full)");
          recommendedAlternatives["moment.js"] = "date-fns or dayjs (smaller)";
          recommendedAlternatives["lodash"] = "lodash-es with tree shaking";
        }
        if (limitations.resourceConstrained) {
          problematicPackages.push(
            "large UI frameworks",
            "heavy computation libraries",
            "memory-intensive packages",
            "large ML/AI libraries"
          );
          unavailableFeatures.push(
            "Heavy computations",
            "Large data processing",
            "Memory-intensive operations",
            "Complex ML models"
          );
        }
        return {
          problematicPackages,
          unavailableFeatures,
          recommendedAlternatives
        };
      }
      /**
       * Get a formatted summary of device information for display
       */
      getDeviceSummary() {
        const info = this.getDeviceInfo();
        const parts = [];
        if (info.isMobile) {
          parts.push(`\u{1F4F1} ${info.device.type.charAt(0).toUpperCase() + info.device.type.slice(1)}`);
        } else {
          parts.push("\u{1F5A5}\uFE0F Desktop");
        }
        parts.push(`${info.platform.name} ${info.platform.version}`);
        if (info.device.vendor !== "Unknown") {
          parts.push(info.device.vendor);
        }
        if (info.device.model !== "Unknown") {
          parts.push(info.device.model);
        }
        return parts.join(" \u2022 ");
      }
      /**
       * Get critical warnings for mobile users
       */
      getCriticalWarnings() {
        const info = this.getDeviceInfo();
        const warnings = [];
        if (info.limitations.resourceConstrained) {
          warnings.push("\u26A0\uFE0F Device has limited resources - some features may be slower");
        }
        if (info.limitations.functionalityLimited) {
          warnings.push("\u26A0\uFE0F Some browser APIs are not available on this device");
        }
        if (info.limitations.networkConstrained) {
          warnings.push("\u26A0\uFE0F Network connection may affect performance");
        }
        if (info.npm.problematicPackages.length > 5) {
          warnings.push("\u26A0\uFE0F Many NPM packages may not work properly on this platform");
        }
        return warnings;
      }
      resetCache() {
        this.cachedInfo = null;
        this.lastUpdate = 0;
      }
    };
  }
});

// src/services/PlatformContext.ts
var _PlatformContext, PlatformContext;
var init_PlatformContext = __esm({
  "src/services/PlatformContext.ts"() {
    init_MobileDetection();
    _PlatformContext = class _PlatformContext {
      constructor() {
        this.mobileDetection = MobileDetection.getInstance();
        this.fetchAvailable = typeof fetch === "function";
      }
      static initialize() {
        if (!_PlatformContext.instance) {
          _PlatformContext.instance = new _PlatformContext();
        }
        return _PlatformContext.instance;
      }
      static get() {
        return _PlatformContext.initialize();
      }
      static registerFetchAvoidSuffix(suffix) {
        if (!suffix) return;
        _PlatformContext.FETCH_AVOID_SUFFIXES.add(suffix.toLowerCase());
      }
      static clearFetchAvoidSuffixes() {
        _PlatformContext.FETCH_AVOID_SUFFIXES.clear();
      }
      isMobile() {
        return this.mobileDetection.isMobileDevice();
      }
      uiVariant() {
        return this.isMobile() ? "mobile" : "desktop";
      }
      preferredTransport(options = {}) {
        const { endpoint } = options;
        const isMobile = this.isMobile();
        const avoidFetch = this.shouldAvoidDirectFetch(endpoint);
        try {
          console.debug("[SystemSculpt][PlatformContext] preferredTransport decision", {
            endpoint,
            isMobile,
            avoidFetch,
            fetchAvailable: this.fetchAvailable
          });
        } catch (e) {
        }
        if (isMobile || avoidFetch) {
          return "requestUrl";
        }
        return "fetch";
      }
      supportsStreaming(options = {}) {
        if (!this.fetchAvailable) {
          try {
            console.debug("[SystemSculpt][PlatformContext] supportsStreaming=false (fetch unavailable)", {
              endpoint: options.endpoint,
              fetchAvailable: this.fetchAvailable
            });
          } catch (e) {
          }
          return false;
        }
        const isMobile = this.isMobile();
        if (isMobile) {
          try {
            console.debug("[SystemSculpt][PlatformContext] supportsStreaming=false (mobile)", {
              endpoint: options.endpoint
            });
          } catch (e) {
          }
          return false;
        }
        const avoidFetch = this.shouldAvoidDirectFetch(options.endpoint);
        const canStream = !avoidFetch;
        try {
          console.debug("[SystemSculpt][PlatformContext] supportsStreaming decision", {
            endpoint: options.endpoint,
            avoidFetch,
            result: canStream
          });
        } catch (e) {
        }
        return canStream;
      }
      getDeviceInfo() {
        return this.mobileDetection.getDeviceInfo();
      }
      getDetection() {
        return this.mobileDetection;
      }
      shouldAvoidDirectFetch(endpoint) {
        if (!endpoint) {
          return false;
        }
        try {
          const host = new URL(endpoint).host;
          const lcHost = host.toLowerCase();
          const avoid = Array.from(_PlatformContext.FETCH_AVOID_SUFFIXES).some((suffix) => lcHost.endsWith(suffix));
          if (avoid) {
            try {
              console.debug("[SystemSculpt][PlatformContext] avoiding direct fetch for host", { host });
            } catch (e) {
            }
          }
          return avoid;
        } catch (e) {
          return false;
        }
      }
    };
    _PlatformContext.instance = null;
    _PlatformContext.FETCH_AVOID_SUFFIXES = /* @__PURE__ */ new Set();
    PlatformContext = _PlatformContext;
  }
});

// src/utils/urlHelpers.ts
function normalizeApiUrl(serverUrl) {
  if (!serverUrl) {
    return serverUrl;
  }
  if (serverUrl.endsWith("/api/v1")) {
    return serverUrl;
  }
  let normalized = serverUrl.replace(/\/$/, "");
  return `${normalized}/api/v1`;
}
function resolveSystemSculptApiBaseUrl(serverUrl) {
  const candidate = (serverUrl || "").trim();
  if (!candidate) {
    return API_BASE_URL;
  }
  let normalized = API_BASE_URL;
  try {
    normalized = normalizeApiUrl(candidate);
    const url = new URL(normalized);
    if (SYSTEMSCULPT_MARKETING_HOSTS.has(url.hostname)) {
      url.hostname = "api.systemsculpt.com";
      url.port = "";
      return url.toString();
    }
    return url.toString();
  } catch (e) {
    return API_BASE_URL;
  }
}
var SYSTEMSCULPT_MARKETING_HOSTS, CACHE_BUSTER;
var init_urlHelpers = __esm({
  "src/utils/urlHelpers.ts"() {
    init_api();
    SYSTEMSCULPT_MARKETING_HOSTS = /* @__PURE__ */ new Set([
      "systemsculpt.com",
      "www.systemsculpt.com"
    ]);
    CACHE_BUSTER = {
      // Only apply to endpoints that might have redirect issues
      shouldApply: (endpoint) => {
        return endpoint.includes("/license/validate");
      },
      // Generate cache buster parameter
      generate: () => `_t=${Date.now()}`,
      // Apply cache buster if needed
      apply: (url) => {
        if (CACHE_BUSTER.shouldApply(url)) {
          const separator = url.includes("?") ? "&" : "?";
          return `${url}${separator}${CACHE_BUSTER.generate()}`;
        }
        return url;
      }
    };
  }
});

// src/services/api/SystemSculptEnvironment.ts
var SystemSculptEnvironment;
var init_SystemSculptEnvironment = __esm({
  "src/services/api/SystemSculptEnvironment.ts"() {
    init_api();
    init_urlHelpers();
    SystemSculptEnvironment = class {
      /**
       * Resolve the canonical base URL for the SystemSculpt API.
       * Applies marketing-domain correction, /api/v1 normalization, and
       * falls back to the compiled API_BASE_URL when the input is blank.
       */
      static resolveBaseUrl(settings, override) {
        var _a;
        const candidate = typeof override === "string" && override.trim().length > 0 ? override.trim() : ((_a = settings.serverUrl) == null ? void 0 : _a.trim()) || "";
        return resolveSystemSculptApiBaseUrl(candidate || API_BASE_URL);
      }
      /**
       * Build a reusable API environment snapshot (base URL + license key).
       */
      static createConfig(settings, override) {
        var _a;
        return {
          baseUrl: this.resolveBaseUrl(settings, override),
          licenseKey: ((_a = settings.licenseKey) == null ? void 0 : _a.trim()) || void 0
        };
      }
      /**
       * Construct headers for authorized requests. Falls back to JSON headers when
       * a license key is not present so callers do not need to special case.
       */
      static buildHeaders(licenseKey) {
        if (!licenseKey) {
          return { ...SYSTEMSCULPT_API_HEADERS.DEFAULT };
        }
        return SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(licenseKey);
      }
    };
  }
});

// src/streaming/StreamPipeline.ts
var DONE_MARKER, StreamPipeline;
var init_StreamPipeline = __esm({
  "src/streaming/StreamPipeline.ts"() {
    init_errors();
    init_jsonRepair();
    init_errorLogger();
    DONE_MARKER = "[DONE]";
    StreamPipeline = class {
      constructor(options) {
        this.decoder = new TextDecoder();
        this.buffer = "";
        this.insideThink = false;
        this.toolCalls = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Push a raw Uint8Array chunk from the network stream and convert it into
       * higher-level stream events that the rest of the pipeline can consume.
       */
      push(chunk) {
        const decoded = this.decoder.decode(chunk, { stream: true });
        this.buffer += decoded;
        const events = [];
        let done = false;
        while (true) {
          const newlineIndex = this.buffer.indexOf("\n");
          if (newlineIndex === -1) break;
          let line = this.buffer.slice(0, newlineIndex);
          this.buffer = this.buffer.slice(newlineIndex + 1);
          if (line.endsWith("\r")) line = line.slice(0, -1);
          const trimmed = line.trim();
          if (!trimmed) {
            continue;
          }
          if (trimmed.startsWith(":")) {
            continue;
          }
          if (trimmed.startsWith("event:")) continue;
          if (trimmed.startsWith("id:")) continue;
          if (trimmed.startsWith("retry:")) continue;
          let payload = trimmed;
          if (payload.startsWith("data:")) {
            payload = payload.slice("data:".length).trimStart();
          }
          if (!payload) continue;
          if (payload === DONE_MARKER) {
            done = true;
            continue;
          }
          const { events: payloadEvents, done: payloadDone } = this.processPayload(payload);
          if (payloadEvents.length > 0) {
            events.push(...payloadEvents);
          }
          if (payloadDone) {
            done = true;
          }
        }
        return { events, done };
      }
      /**
       * Flush any remaining buffered data and finalize pending tool calls.
       */
      flush() {
        const events = [];
        const trailing = this.buffer.trim();
        this.buffer = "";
        if (trailing.length > 0 && trailing !== DONE_MARKER) {
          const { events: trailingEvents } = this.processPayload(trailing, true);
          if (trailingEvents.length > 0) {
            events.push(...trailingEvents);
          }
        }
        for (const [index, state] of this.toolCalls.entries()) {
          const finalCall = this.buildToolCall(state, true);
          events.push({ type: "tool-call", phase: "final", call: finalCall });
          this.toolCalls.delete(index);
        }
        return events;
      }
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      // Internal helpers
      // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      processPayload(payload, isFinalFlush = false) {
        var _a, _b, _c, _d, _e, _f, _g;
        const events = [];
        let done = false;
        let parsed = null;
        try {
          parsed = JSON.parse(payload);
        } catch (error) {
          if (typeof payload === "string") {
            const statusCandidate = payload.trim();
            if (/^[A-Z0-9 _:-]+$/.test(statusCandidate)) {
              return { events, done };
            }
          }
          try {
            errorLogger.debug("StreamPipeline: discarding non-JSON payload", {
              source: "StreamPipeline",
              method: "processPayload",
              metadata: { preview: payload.slice(0, 160) }
            });
          } catch (e) {
          }
          return { events, done };
        }
        if (parsed == null) {
          return { events, done };
        }
        if (parsed.done === true) {
          done = true;
        }
        if (parsed.webSearchEnabled !== void 0) {
          events.push({ type: "meta", key: "web-search-enabled", value: parsed.webSearchEnabled });
        }
        if (parsed.error) {
          this.raiseStreamError(parsed);
        }
        if (Array.isArray(parsed.choices) && parsed.choices.length > 0) {
          const choice = (_a = parsed.choices[0]) != null ? _a : {};
          const delta = (_b = choice.delta) != null ? _b : {};
          const message = (_c = choice.message) != null ? _c : {};
          const reasoningText = this.normalizeText((_d = delta.reasoning) != null ? _d : message.reasoning);
          if (reasoningText) {
            events.push({ type: "reasoning", text: reasoningText });
          }
          const contentText = this.normalizeText((_f = (_e = delta.content) != null ? _e : delta.text) != null ? _f : message.content);
          if (contentText) {
            events.push(...this.splitContentByThinkTags(contentText));
          }
          if (Array.isArray(delta.tool_calls) && delta.tool_calls.length > 0) {
            for (const raw of delta.tool_calls) {
              const event = this.handleToolCallDelta(raw);
              if (event) events.push(event);
            }
          }
          if (Array.isArray(message.tool_calls) && message.tool_calls.length > 0) {
            for (const raw of message.tool_calls) {
              const event = this.handleToolCallFinal(raw);
              if (event) events.push(event);
            }
          }
          if (delta.function_call) {
            const event = this.handleFunctionCallDelta(delta.function_call);
            if (event) events.push(event);
          }
          if (message.function_call) {
            const event = this.handleFunctionCallFinal(message.function_call);
            if (event) events.push(event);
          }
          if (typeof choice.finish_reason === "string" && choice.finish_reason === "stop") {
            done = done || isFinalFlush;
          }
        } else if ((_g = parsed.message) == null ? void 0 : _g.content) {
          const contentText = this.normalizeText(parsed.message.content);
          if (contentText) {
            events.push(...this.splitContentByThinkTags(contentText));
          }
        } else if (typeof parsed.text === "string") {
          events.push(...this.splitContentByThinkTags(parsed.text));
        }
        return { events, done };
      }
      raiseStreamError(payload) {
        var _a, _b;
        const errorData = payload.error || {};
        const errorCode = errorData.code || ERROR_CODES.STREAM_ERROR;
        const message = errorData.message || getErrorMessage(errorCode, this.options.model);
        throw new SystemSculptError(message, errorCode, 500, {
          model: this.options.model,
          rawError: payload.error,
          provider: payload.provider,
          finishReason: (_b = (_a = payload.choices) == null ? void 0 : _a[0]) == null ? void 0 : _b.finish_reason
        });
      }
      normalizeText(value) {
        if (value == null) return null;
        if (typeof value === "string") return value;
        if (Array.isArray(value)) {
          const parts = value.map((entry) => this.normalizeText(entry)).filter((part) => typeof part === "string" && part.length > 0);
          return parts.length > 0 ? parts.join("") : null;
        }
        if (typeof value === "object") {
          if (typeof value.text === "string") return value.text;
          if (typeof value.output_text === "string") return value.output_text;
          if (value.content !== void 0) return this.normalizeText(value.content);
          if (value.value !== void 0) return this.normalizeText(value.value);
        }
        return null;
      }
      splitContentByThinkTags(text) {
        const events = [];
        let remaining = text;
        while (remaining.length > 0) {
          if (this.insideThink) {
            const closeIdx = remaining.indexOf("</think>");
            if (closeIdx === -1) {
              if (remaining.length > 0) {
                events.push({ type: "reasoning", text: remaining });
              }
              remaining = "";
            } else {
              const reasoningText = remaining.slice(0, closeIdx);
              if (reasoningText.length > 0) {
                events.push({ type: "reasoning", text: reasoningText });
              }
              remaining = remaining.slice(closeIdx + "</think>".length);
              this.insideThink = false;
            }
            continue;
          }
          const openIdx = remaining.indexOf("<think>");
          if (openIdx === -1) {
            if (remaining.length > 0) {
              events.push({ type: "content", text: remaining });
            }
            remaining = "";
            break;
          }
          const before = remaining.slice(0, openIdx);
          if (before.length > 0) {
            events.push({ type: "content", text: before });
          }
          remaining = remaining.slice(openIdx + "<think>".length);
          this.insideThink = true;
        }
        return events;
      }
      handleToolCallDelta(raw) {
        var _a, _b;
        const index = typeof (raw == null ? void 0 : raw.index) === "number" ? raw.index : 0;
        const id = typeof (raw == null ? void 0 : raw.id) === "string" && raw.id.length > 0 ? raw.id : void 0;
        const functionData = (_a = raw == null ? void 0 : raw.function) != null ? _a : {};
        const name = this.sanitizeToolName(functionData.name || (raw == null ? void 0 : raw.name) || "");
        const argsDelta = typeof functionData.arguments === "string" ? functionData.arguments : "";
        const state = (_b = this.toolCalls.get(index)) != null ? _b : {
          index,
          id,
          name,
          arguments: "",
          type: "function"
        };
        if (id) state.id = id;
        if (name) state.name = name;
        if (argsDelta) state.arguments += argsDelta;
        this.toolCalls.set(index, state);
        const call = this.buildToolCall(state, false);
        return { type: "tool-call", phase: "delta", call };
      }
      handleToolCallFinal(raw) {
        var _a, _b, _c, _d;
        const index = typeof (raw == null ? void 0 : raw.index) === "number" ? raw.index : 0;
        const state = (_b = this.toolCalls.get(index)) != null ? _b : {
          index,
          id: typeof (raw == null ? void 0 : raw.id) === "string" ? raw.id : void 0,
          name: this.sanitizeToolName(((_a = raw == null ? void 0 : raw.function) == null ? void 0 : _a.name) || (raw == null ? void 0 : raw.name) || ""),
          arguments: "",
          type: "function"
        };
        if (typeof (raw == null ? void 0 : raw.id) === "string" && raw.id.length > 0) {
          state.id = raw.id;
        }
        const name = this.sanitizeToolName(((_c = raw == null ? void 0 : raw.function) == null ? void 0 : _c.name) || (raw == null ? void 0 : raw.name) || "");
        if (name) state.name = name;
        if (typeof ((_d = raw == null ? void 0 : raw.function) == null ? void 0 : _d.arguments) === "string") {
          state.arguments = raw.function.arguments;
        }
        const call = this.buildToolCall(state, true);
        this.toolCalls.delete(index);
        return { type: "tool-call", phase: "final", call };
      }
      handleFunctionCallDelta(raw) {
        const synthetic = {
          index: 0,
          id: typeof (raw == null ? void 0 : raw.id) === "string" ? raw.id : void 0,
          function: raw
        };
        return this.handleToolCallDelta(synthetic);
      }
      handleFunctionCallFinal(raw) {
        const synthetic = {
          index: 0,
          id: typeof (raw == null ? void 0 : raw.id) === "string" ? raw.id : void 0,
          function: raw
        };
        return this.handleToolCallFinal(synthetic);
      }
      buildToolCall(state, normalizeArgs) {
        var _a;
        const name = state.name || "tool";
        const id = (_a = state.id) != null ? _a : `call_${state.index}`;
        const args = normalizeArgs ? this.safeNormalizeArgs(state.arguments) : state.arguments;
        return {
          id,
          index: state.index,
          type: state.type,
          function: {
            name,
            arguments: args
          }
        };
      }
      sanitizeToolName(name) {
        if (!name) return "";
        let sanitized = String(name);
        if (sanitized.startsWith("functions.")) {
          sanitized = sanitized.slice("functions.".length);
        }
        const colonIdx = sanitized.indexOf(":");
        if (colonIdx !== -1) {
          sanitized = sanitized.slice(0, colonIdx);
        }
        return sanitized.trim();
      }
      safeNormalizeArgs(args) {
        if (!args) return "";
        try {
          return normalizeJsonString(args);
        } catch (error) {
          try {
            errorLogger.debug("StreamPipeline: failed to normalize tool call args", {
              source: "StreamPipeline",
              method: "safeNormalizeArgs",
              metadata: { preview: args.slice(0, 80) }
            });
          } catch (e) {
          }
          return args;
        }
      }
    };
  }
});

// src/services/StreamingService.ts
var StreamingService;
var init_StreamingService = __esm({
  "src/services/StreamingService.ts"() {
    init_errors();
    init_errorLogger();
    init_StreamPipeline();
    StreamingService = class {
      generateRequestId() {
        try {
          if (typeof crypto !== "undefined" && typeof crypto.randomUUID === "function") {
            return crypto.randomUUID();
          }
        } catch (e) {
        }
        const timestamp = Date.now();
        const random = Math.random().toString(36).slice(2, 10);
        return `${timestamp}-${random}`;
      }
      async *streamResponse(response, options) {
        var _a;
        if (!response.body) {
          throw new SystemSculptError(
            "Missing response body from streaming API",
            ERROR_CODES.STREAM_ERROR,
            response.status
          );
        }
        const reader = response.body.getReader();
        const pipeline = new StreamPipeline({
          model: options.model,
          isCustomProvider: options.isCustomProvider
        });
        try {
          while (true) {
            if ((_a = options.signal) == null ? void 0 : _a.aborted) {
              try {
                await reader.cancel();
              } catch (e) {
              }
              break;
            }
            const { done, value } = await reader.read();
            if (done) break;
            if (!value) continue;
            const { events, done: pipelineDone } = pipeline.push(value);
            for (const event of events) {
              yield event;
            }
            if (pipelineDone) break;
          }
        } catch (error) {
          try {
            errorLogger.error("StreamResponse read failure", error, {
              source: "StreamingService",
              method: "streamResponse"
            });
          } catch (e) {
          }
          if (error instanceof DOMException && error.name === "AbortError") {
            return;
          }
          throw error;
        } finally {
          try {
            reader.releaseLock();
          } catch (e) {
          }
        }
        const trailingEvents = pipeline.flush();
        for (const event of trailingEvents) {
          yield event;
        }
      }
    };
  }
});

// src/services/StreamingErrorHandler.ts
var StreamingErrorHandler;
var init_StreamingErrorHandler = __esm({
  "src/services/StreamingErrorHandler.ts"() {
    init_errors();
    StreamingErrorHandler = class {
      /**
       * Handle streaming errors
       */
      static async handleStreamError(response, isCustomProvider = false) {
        var _a, _b, _c, _d, _e, _f;
        try {
          let data;
          try {
            const text = await response.text();
            try {
              data = JSON.parse(text);
            } catch (e) {
              data = { error: { message: typeof text === "string" && text.trim().length > 0 ? text : "Unknown error" } };
            }
          } catch (err) {
            throw new SystemSculptError(
              "Error processing response from API",
              ERROR_CODES.STREAM_ERROR,
              response.status
            );
          }
          let errorCode = ERROR_CODES.STREAM_ERROR;
          let errorMessage = "Unknown error";
          let metadata = {};
          let shouldResubmit = false;
          if (data.error) {
            if (isCustomProvider) {
              const status = response.status;
              let model = data.model;
              if (!model && typeof ((_a = data.error) == null ? void 0 : _a.message) === "string") {
                const match = data.error.message.match(/model\s+`?([\\w\\-\\.\/]+)`?/i);
                if (match && match[1]) {
                  model = match[1];
                }
              }
              if (!model) {
                model = "unknown";
              }
              if (status === 404 || ((_b = data.error.message) == null ? void 0 : _b.includes("model")) && ((_c = data.error.message) == null ? void 0 : _c.includes("does not exist"))) {
                errorCode = ERROR_CODES.MODEL_UNAVAILABLE;
                errorMessage = `Model ${model} is unavailable with this provider.`;
                shouldResubmit = true;
              } else if (status === 429) {
                errorCode = ERROR_CODES.QUOTA_EXCEEDED;
                errorMessage = data.error.message || "Rate limit or quota exceeded. Please try again later.";
              } else if (status === 401) {
                errorCode = ERROR_CODES.INVALID_LICENSE;
                errorMessage = data.error.message || "Invalid API key or authentication error.";
              } else {
                errorCode = data.error.code || ERROR_CODES.STREAM_ERROR;
                errorMessage = data.error.message || "An error occurred with the provider.";
                if (errorMessage.includes("unavailable") || errorMessage.includes("not found")) {
                  shouldResubmit = true;
                }
              }
              metadata = {
                provider: data.provider || "unknown",
                model,
                statusCode: status,
                rawError: data.error
              };
              if (shouldResubmit) {
                metadata.shouldResubmit = true;
              }
              const lcCustom = (((_d = data.error) == null ? void 0 : _d.message) || errorMessage || "").toLowerCase();
              if (lcCustom.includes("does not support tools") || lcCustom.includes("tools not supported") || lcCustom.includes("tool_calls not supported") || lcCustom.includes("function calling not supported") || lcCustom.includes("function_calling not supported") || lcCustom.includes("function_call not supported") || lcCustom.includes("additional properties are not allowed: 'tools'") || lcCustom.includes("unknown field: tools") || lcCustom.includes("input_schema does not support oneof") || lcCustom.includes("input_schema does not support anyof") || lcCustom.includes("input_schema does not support allof")) {
                metadata.shouldResubmitWithoutTools = true;
                metadata.toolSupport = false;
              }
            } else {
              const status = response.status;
              const isStringError = typeof data.error === "string";
              const upstreamCode = isStringError ? String(data.error) : String(((_e = data.error) == null ? void 0 : _e.code) || "");
              const upstreamMessage = isStringError ? data.message || "" : ((_f = data.error) == null ? void 0 : _f.message) || "";
              errorCode = isStringError ? ERROR_CODES.STREAM_ERROR : data.error.code || ERROR_CODES.STREAM_ERROR;
              errorMessage = upstreamMessage || getErrorMessage(errorCode);
              if (status === 429 || errorMessage.includes("rate-limited") || errorMessage.includes("429")) {
                errorCode = ERROR_CODES.QUOTA_EXCEEDED;
                errorMessage = errorMessage.includes("rate-limited upstream") ? errorMessage + " OpenRouter is automatically trying alternative providers." : "Rate limit exceeded. Please try again in a moment.";
                metadata = {
                  model: data.model,
                  statusCode: status,
                  rawError: data.error,
                  isRateLimited: true,
                  shouldRetry: true,
                  retryAfterSeconds: 5
                  // Suggest 5 second retry delay
                };
              } else {
                metadata = {
                  model: data.model,
                  statusCode: status,
                  rawError: data.error,
                  ...isStringError && { upstreamCode }
                };
                if (status === 404 || errorCode === ERROR_CODES.MODEL_UNAVAILABLE || errorMessage.includes("unavailable") || errorMessage.includes("not found")) {
                  metadata.shouldResubmit = true;
                }
                const lcUpstream = (errorMessage || "").toLowerCase();
                if (lcUpstream.includes("does not support tools") || lcUpstream.includes("tools not supported") || lcUpstream.includes("tool_calls not supported") || lcUpstream.includes("function calling not supported") || lcUpstream.includes("function_calling not supported") || lcUpstream.includes("function_call not supported") || lcUpstream.includes("additional properties are not allowed: 'tools'") || lcUpstream.includes("unknown field: tools")) {
                  metadata.shouldResubmitWithoutTools = true;
                  metadata.toolSupport = false;
                }
                if (lcUpstream.includes("does not support image") || lcUpstream.includes("image input not supported") || lcUpstream.includes("vision not supported") || lcUpstream.includes("unknown field: image_url") || lcUpstream.includes("additional properties are not allowed: 'image_url'") || lcUpstream.includes("unsupported type: image_url")) {
                  metadata.shouldResubmitWithoutImages = true;
                  metadata.imageSupport = false;
                }
              }
            }
          }
          throw new SystemSculptError(
            errorMessage,
            errorCode,
            response.status,
            metadata
          );
        } catch (error) {
          if (error instanceof SystemSculptError) {
            throw error;
          }
          throw new SystemSculptError(
            `Stream error (HTTP ${response.status})`,
            ERROR_CODES.STREAM_ERROR,
            response.status
          );
        }
      }
    };
  }
});

// src/services/llm/ToolSchemaSanitizer.ts
var ToolSchemaSanitizer;
var init_ToolSchemaSanitizer = __esm({
  "src/services/llm/ToolSchemaSanitizer.ts"() {
    ToolSchemaSanitizer = class _ToolSchemaSanitizer {
      /**
       * Produce a provider-safe clone of a tool definition without mutating the original schema.
       */
      static sanitizeDefinition(definition) {
        var _a;
        const cloned = _ToolSchemaSanitizer.deepClone(definition);
        if (!cloned.function) {
          return cloned;
        }
        cloned.function = {
          ...cloned.function,
          parameters: _ToolSchemaSanitizer.sanitizeSchema((_a = cloned.function.parameters) != null ? _a : {}, true)
        };
        return cloned;
      }
      /**
       * Sanitize a list of definitions. Convenience helper for request assembly code.
       */
      static sanitizeDefinitions(definitions = []) {
        return definitions.map((def) => _ToolSchemaSanitizer.sanitizeDefinition(def));
      }
      static deepClone(value) {
        try {
          return structuredClone(value);
        } catch (e) {
          return JSON.parse(JSON.stringify(value));
        }
      }
      static sanitizeSchema(schema, isRoot = false) {
        if (!schema || typeof schema !== "object" || Array.isArray(schema)) {
          return _ToolSchemaSanitizer.createObjectSchema();
        }
        const cleaned = { ...schema };
        delete cleaned.oneOf;
        delete cleaned.anyOf;
        delete cleaned.allOf;
        if (isRoot) {
          cleaned.type = "object";
          if (!cleaned.properties || typeof cleaned.properties !== "object" || Array.isArray(cleaned.properties)) {
            cleaned.properties = {};
          }
        }
        if (cleaned.properties && typeof cleaned.properties === "object") {
          for (const key of Object.keys(cleaned.properties)) {
            cleaned.properties[key] = _ToolSchemaSanitizer.sanitizeSchema(cleaned.properties[key], false);
          }
        }
        if (cleaned.items) {
          cleaned.items = _ToolSchemaSanitizer.sanitizeSchema(cleaned.items, false);
        }
        if (cleaned.additionalProperties && typeof cleaned.additionalProperties === "object") {
          cleaned.additionalProperties = _ToolSchemaSanitizer.sanitizeSchema(cleaned.additionalProperties, false);
        }
        return cleaned;
      }
      static createObjectSchema() {
        return {
          type: "object",
          properties: {}
        };
      }
    };
  }
});

// src/services/LicenseService.ts
var LicenseService;
var init_LicenseService = __esm({
  "src/services/LicenseService.ts"() {
    init_errors();
    init_api();
    init_urlHelpers();
    LicenseService = class {
      constructor(plugin, baseUrl) {
        this.plugin = plugin;
        this.baseUrl = baseUrl;
      }
      /**
       * Update the base URL
       */
      updateBaseUrl(baseUrl) {
        this.baseUrl = baseUrl;
      }
      /**
       * Get current license key from settings
       */
      get licenseKey() {
        return this.plugin.settings.licenseKey;
      }
      /**
       * Validate the current license key
       */
      async validateLicense(_forceCheck = false) {
        var _a;
        if (!((_a = this.licenseKey) == null ? void 0 : _a.trim())) {
          if (this.plugin.settings.licenseValid) {
            await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
          }
          return false;
        }
        const validationEndpoint = SYSTEMSCULPT_API_ENDPOINTS.LICENSE.VALIDATE();
        const endpointWithCacheBuster = CACHE_BUSTER.apply(validationEndpoint);
        const fullUrl = `${this.baseUrl}${endpointWithCacheBuster}`;
        const headersToSend = SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey);
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({
            url: fullUrl,
            method: "GET",
            headers: headersToSend
          });
          if (response.status !== 200) {
            throw new SystemSculptError(
              `License validation failed with status ${response.status}`,
              ERROR_CODES.INVALID_LICENSE,
              response.status
            );
          }
          const apiResponse = response.json;
          const responseData = (apiResponse == null ? void 0 : apiResponse.data) || apiResponse;
          if (responseData && typeof responseData === "object") {
            await this.plugin.getSettingsManager().updateSettings({
              licenseValid: true,
              userEmail: responseData.email,
              userName: responseData.user_name || responseData.email,
              displayName: responseData.display_name || responseData.user_name || responseData.email,
              creditsBalance: responseData.credits_balance,
              subscriptionStatus: responseData.subscription_status,
              lastValidated: Date.now()
            });
            return true;
          }
          return !!this.plugin.settings.licenseValid;
        } catch (error) {
          return !!this.plugin.settings.licenseValid;
        }
      }
      /**
       * Get current token balance
       */
      async getTokenBalance() {
        const isValid = await this.validateLicense(true);
        if (!isValid) return 0;
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({
            url: `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.LICENSE.VALIDATE()}`,
            method: "GET",
            headers: SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey)
          });
          if (response.status !== 200) {
            throw new SystemSculptError(
              `Failed to get token balance: ${response.status}`,
              ERROR_CODES.INVALID_LICENSE,
              response.status
            );
          }
          const licenseInfo = response.json;
          const responseData = (licenseInfo == null ? void 0 : licenseInfo.data) || licenseInfo;
          return responseData.credits_balance || 0;
        } catch (error) {
          return 0;
        }
      }
      /**
       * Get detailed credit breakdown
       */
      async getCreditBreakdown() {
        const isValid = await this.validateLicense(true);
        if (!isValid) {
          return null;
        }
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({
            url: `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.CREDITS.GET}`,
            method: "GET",
            headers: SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey)
          });
          if (response.status !== 200) {
            throw new Error(`Credits endpoint failed: ${response.status}`);
          }
          const json = response.json;
          const data = json && typeof json === "object" && "data" in json ? json.data : json;
          return data;
        } catch (error) {
          const total = this.plugin.settings.creditsBalance || 0;
          const fallbackBreakdown = {
            monthly: total,
            // Show total as monthly for backward compatibility
            additional: 0,
            total
          };
          return fallbackBreakdown;
        }
      }
    };
  }
});

// src/constants/agent.ts
var AGENT_CONFIG;
var init_agent = __esm({
  "src/constants/agent.ts"() {
    AGENT_CONFIG = {
      // The model ID used for agent mode operations
      MODEL_ID: "systemsculpt@@systemsculpt/ai-agent",
      // Human-readable model name for display in UI
      MODEL_DISPLAY_NAME: "SystemSculpt AI Agent",
      // Model description for user-facing information
      MODEL_DESCRIPTION: "backed by our SystemSculpt AI Agent runtime"
    };
  }
});

// src/services/ModelManagementService.ts
var _ModelManagementService, ModelManagementService;
var init_ModelManagementService = __esm({
  "src/services/ModelManagementService.ts"() {
    init_errors();
    init_api();
    init_modelUtils();
    init_agent();
    _ModelManagementService = class _ModelManagementService {
      constructor(plugin, baseUrl) {
        this.plugin = plugin;
        this.baseUrl = baseUrl;
      }
      /**
       * Update the base URL
       */
      updateBaseUrl(baseUrl) {
        this.baseUrl = baseUrl;
      }
      /**
       * Get current license key from settings
       */
      get licenseKey() {
        return this.plugin.settings.licenseKey;
      }
      /**
       * Get current settings
       */
      get settings() {
        return this.plugin.settings;
      }
      /**
       * Strip provider prefixes from model IDs
       */
      stripProviderPrefixes(modelId) {
        return modelId;
      }
      /**
       * Get all available models
       */
      async getModels() {
        var _a;
        if (!this.settings.enableSystemSculptProvider) {
          return [];
        }
        if (!((_a = this.licenseKey) == null ? void 0 : _a.trim())) {
          return [this.buildLocalAgentModel()];
        }
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({
            url: `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.MODELS.LIST}`,
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              "x-license-key": this.licenseKey
            }
          });
          if (response.status !== 200) {
            throw new SystemSculptError(
              `Failed to fetch models: ${response.status}`,
              ERROR_CODES.MODEL_REQUEST_ERROR,
              response.status
            );
          }
          const apiResponse = response.json;
          let apiModels;
          if (Array.isArray(apiResponse)) {
            apiModels = apiResponse;
          } else if (apiResponse && Array.isArray(apiResponse.models)) {
            apiModels = apiResponse.models;
          } else if (apiResponse && Array.isArray(apiResponse.data)) {
            apiModels = apiResponse.data;
          } else {
            throw new Error("Invalid API response format");
          }
          const primaryModel = apiModels[0];
          if (!primaryModel) {
            return [this.buildLocalAgentModel()];
          }
          return [this.buildAgentModelFromApi(primaryModel)];
        } catch (error) {
          return [this.buildLocalAgentModel()];
        }
      }
      /**
       * Get model information by ID
       */
      async getModelInfo(modelId) {
        const model = await this.plugin.modelService.getModelById(modelId);
        if (!model) {
          throw new SystemSculptError(
            `Model ${modelId} not found`,
            ERROR_CODES.MODEL_UNAVAILABLE,
            404
          );
        }
        const { parseCanonicalId: parseCanonicalId4 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
        const parsed = parseCanonicalId4(model.id);
        if (!parsed) {
          throw new SystemSculptError(
            `Invalid model ID format: ${model.id}`,
            ERROR_CODES.MODEL_UNAVAILABLE,
            400
          );
        }
        const { providerId, modelId: parsedModelId } = parsed;
        if (providerId === "systemsculpt") {
          const upstreamFromModel = model == null ? void 0 : model.upstream_model;
          const normalizedUpstream = typeof upstreamFromModel === "string" ? upstreamFromModel.trim() : "";
          const resolvedUpstream = normalizedUpstream.length > 0 ? normalizedUpstream : parsedModelId && !parsedModelId.toLowerCase().startsWith("systemsculpt/") ? parsedModelId : _ModelManagementService.DEFAULT_UPSTREAM_MODEL;
          return {
            isCustom: false,
            actualModelId: resolvedUpstream,
            upstreamModelId: resolvedUpstream
          };
        }
        const customProvider = this.settings.customProviders.find(
          (p) => p.isEnabled && (p.id === providerId || p.name.toLowerCase() === providerId)
        );
        if (!customProvider) {
          throw new SystemSculptError(
            `Custom provider ${providerId} not found or disabled`,
            ERROR_CODES.MODEL_UNAVAILABLE,
            404
          );
        }
        return {
          isCustom: true,
          provider: customProvider,
          actualModelId: parsedModelId,
          upstreamModelId: parsedModelId
        };
      }
      /**
       * Preload models (no-op since we're not caching)
       */
      async preloadModels() {
        return Promise.resolve();
      }
      buildLocalAgentModel() {
        const { MODEL_ID, MODEL_DISPLAY_NAME, MODEL_DESCRIPTION } = AGENT_CONFIG;
        const [, upstreamModelId] = MODEL_ID.split(MODEL_ID_SEPARATOR);
        return {
          id: MODEL_ID,
          name: MODEL_DISPLAY_NAME,
          description: MODEL_DESCRIPTION,
          provider: "systemsculpt",
          identifier: {
            providerId: "systemsculpt",
            modelId: upstreamModelId,
            displayName: MODEL_DISPLAY_NAME
          },
          upstream_model: _ModelManagementService.DEFAULT_UPSTREAM_MODEL,
          capabilities: ["tools", "function_calling"],
          supported_parameters: ["top_p", "max_tokens", "stream", "tools"],
          context_length: 2e5,
          architecture: {
            modality: "text->text",
            tokenizer: "kimi",
            instruct_type: null
          },
          pricing: {
            prompt: "0.000002",
            completion: "0.000006",
            image: "0",
            request: "0"
          }
        };
      }
      buildAgentModelFromApi(model) {
        var _a, _b, _c, _d, _e;
        const { MODEL_ID, MODEL_DISPLAY_NAME, MODEL_DESCRIPTION } = AGENT_CONFIG;
        const [, upstreamModelId] = MODEL_ID.split(MODEL_ID_SEPARATOR);
        const upstreamFromApi = typeof model.upstream_model === "string" && model.upstream_model.trim().length > 0 ? model.upstream_model : _ModelManagementService.DEFAULT_UPSTREAM_MODEL;
        return {
          ...model,
          id: MODEL_ID,
          name: MODEL_DISPLAY_NAME,
          description: model.description || MODEL_DESCRIPTION,
          provider: "systemsculpt",
          identifier: {
            providerId: "systemsculpt",
            modelId: model.id || upstreamModelId,
            displayName: MODEL_DISPLAY_NAME
          },
          upstream_model: upstreamFromApi,
          context_length: (_a = model.context_length) != null ? _a : 2e5,
          capabilities: (_b = model.capabilities) != null ? _b : ["tools", "function_calling"],
          supported_parameters: (_c = model.supported_parameters) != null ? _c : ["top_p", "max_tokens", "stream", "tools"],
          pricing: (_d = model.pricing) != null ? _d : {
            prompt: "0.000002",
            completion: "0.000006",
            image: "0",
            request: "0"
          },
          architecture: (_e = model.architecture) != null ? _e : {
            modality: "text->text",
            tokenizer: "kimi",
            instruct_type: null
          }
        };
      }
    };
    _ModelManagementService.DEFAULT_UPSTREAM_MODEL = "groq/moonshotai/kimi-k2-instruct-0905";
    ModelManagementService = _ModelManagementService;
  }
});

// src/utils/ImageProcessor.ts
var _ImageProcessor, ImageProcessor;
var init_ImageProcessor = __esm({
  "src/utils/ImageProcessor.ts"() {
    init_errors();
    _ImageProcessor = class _ImageProcessor {
      static async processImage(file, app) {
        if (!file) {
          throw new SystemSculptError("File not found", "FILE_NOT_FOUND", 404);
        }
        if (file.stat.size > _ImageProcessor.MAX_FILE_SIZE) {
          throw new SystemSculptError(
            "Image too large (max 10MB)",
            "FILE_TOO_LARGE",
            413
          );
        }
        const extension = file.extension.toLowerCase();
        if (!_ImageProcessor.SUPPORTED_FORMATS.has(extension)) {
          throw new SystemSculptError(
            "Unsupported image format",
            "UNSUPPORTED_FORMAT",
            415
          );
        }
        try {
          const arrayBuffer = await app.vault.readBinary(file);
          const base64 = await new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
              const dataUrl = reader.result;
              resolve(dataUrl);
            };
            reader.onerror = () => reject(reader.error);
            const type = `image/${extension === "jpg" ? "jpeg" : extension}`;
            const blob = new Blob([arrayBuffer], { type });
            reader.readAsDataURL(blob);
          });
          return base64;
        } catch (error) {
          throw new SystemSculptError(
            "Failed to process image",
            "PROCESSING_ERROR",
            500
          );
        }
      }
      static async processClipboardImage(clipboardData) {
        const file = clipboardData.files[0];
        if (!file || !file.type.startsWith("image/")) {
          throw new SystemSculptError("No image in clipboard", "NO_IMAGE", 400);
        }
        if (file.size > this.MAX_FILE_SIZE) {
          throw new SystemSculptError(
            "Image too large (max 10MB)",
            "FILE_TOO_LARGE",
            413
          );
        }
        return new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result);
          reader.onerror = () => reject(reader.error);
          reader.readAsDataURL(file);
        });
      }
    };
    _ImageProcessor.MAX_FILE_SIZE = 10 * 1024 * 1024;
    _ImageProcessor.SUPPORTED_FORMATS = /* @__PURE__ */ new Set([
      "jpg",
      "jpeg",
      "png",
      "gif",
      "webp"
    ]);
    ImageProcessor = _ImageProcessor;
  }
});

// src/constants/prompts/general.ts
var GENERAL_USE_PRESET;
var init_general = __esm({
  "src/constants/prompts/general.ts"() {
    GENERAL_USE_PRESET = {
      id: "general-use",
      label: "General Use Preset",
      description: "Standard balanced prompt.",
      isUserConfigurable: false,
      systemPrompt: "You are a helpful AI assistant. You help users with their questions and tasks in a clear and concise way."
    };
  }
});

// src/constants/prompts/concise.ts
var CONCISE_PRESET;
var init_concise = __esm({
  "src/constants/prompts/concise.ts"() {
    CONCISE_PRESET = {
      id: "concise",
      label: "Concise Preset",
      description: "Shorter, more direct prompt.",
      isUserConfigurable: false,
      systemPrompt: "You are a concise AI assistant. Be brief and to the point."
    };
  }
});

// src/constants/prompts/agent.ts
var AGENT_PRESET;
var init_agent2 = __esm({
  "src/constants/prompts/agent.ts"() {
    AGENT_PRESET = {
      id: "agent",
      label: "Vault Agent Preset",
      description: "Autonomous agent for vault operations.",
      isUserConfigurable: false,
      systemPrompt: `<identity>
You are the SystemSculpt Vault Agent\u2014an elite AI assistant embedded in Obsidian.
Your mission: execute the USER's requests inside their vault\u2014fast and with zero fluff.
</identity>

<scope>
You may be asked to:
\u2022 create, edit, or refactor notes, code blocks, and metadata  
\u2022 search, summarize, or transform vault content  
\u2022 answer technical questions about SystemSculpt plugins, workflows, or AI usage  
Do ONLY what the USER asks\u2014nothing more, nothing less.
</scope>

<communication>
\u2022 Speak in second person; keep sentences short and decisive.  
\u2022 No apologies unless you break something.  
\u2022 If you need clarification, ask once, then act.  
\u2022 Avoid corporate clich\xE9s or "AI-speak." Get to the point.  
\u2022 Do not reveal chain-of-thought. Provide brief, high-level reasoning only when helpful.
</communication>

<search_strategy>
\u2022 Content: break queries into words (["neon", "mcp", "install"])
\u2022 Properties: use exact names (e.g., 'blogpost:' for YAML) when crafting search terms
\u2022 YAML frontmatter: 'property: value' | Inline: 'property:: value'
\u2022 For "files with X property": combine name filters with content search (e.g., 'status: draft')
\u2022 Execute parallel searches when unsure: content search + name search + scoped directory search
\u2022 Try broader terms if exact matches fail
\u2022 Never ask for file locations\u2014find them
</search_strategy>

<tool_calling>
1. ALWAYS follow each tool's JSON schema exactly; include every required param.  
2. If multiple tools solve a step, invoke them in PARALLEL\u2014speed beats chatter.  
3. Never call tools that are unavailable.  
4. If a tool result is unclear, reflect, adjust, and call again\u2014no USER ping-pong.  
5. Clean up temp files or artifacts you create before finishing.  
6. If vault-state is needed, PREFER a tool call over asking the USER.  
7. Summarize results only after you've confirmed they satisfy the request.  
8. When editing files, prefer minimal diffs; keep changes surgical and reversible.
</tool_calling>

<efficiency>
DEFAULT TO PARALLEL execution unless output of Tool A is REQUIRED for Tool B.  
Plan searches up front: group content, name, and property searches together.  
Treat sequential calls as a last resort.
</efficiency>

<making_edits>
When modifying files:  
1. Read the file first.  
2. After edits, validate with lint/test tools; fix or report errors immediately.  
3. Never generate binary blobs or massive hashes.  
4. Do not create docs/README unless explicitly requested.  
5. Make side effects explicit; list files changed and rationale.
</making_edits>

<search_and_learning>
Unsure? Gather more data with search tools instead of stalling.  
Bias toward self-service over questioning the USER.
</search_and_learning>

<safety_and_privacy>
\u2022 Never exfiltrate secrets or credentials; redact tokens/keys in outputs.  
\u2022 Respect user-configured directories; do not traverse outside intended scope.  
\u2022 Avoid speculative legal/medical advice; request explicit confirmation for high\u2011risk actions.  
\u2022 Default to no source-code disclosure for licensed dependencies; link to their docs instead.
</safety_and_privacy>

<final_word>
Do what's asked, finish fast, stay silent about internals.
</final_word>`
    };
  }
});

// src/constants/prompts/index.ts
var LOCAL_SYSTEM_PROMPTS;
var init_prompts = __esm({
  "src/constants/prompts/index.ts"() {
    init_general();
    init_concise();
    init_agent2();
    init_general();
    init_concise();
    init_agent2();
    LOCAL_SYSTEM_PROMPTS = [
      GENERAL_USE_PRESET,
      CONCISE_PRESET,
      AGENT_PRESET
    ];
  }
});

// src/constants/prompts.ts
var init_prompts2 = __esm({
  "src/constants/prompts.ts"() {
    init_prompts();
  }
});

// src/services/SystemPromptService.ts
var SystemPromptService_exports = {};
__export(SystemPromptService_exports, {
  SystemPromptService: () => SystemPromptService
});
var import_obsidian17, _SystemPromptService, SystemPromptService;
var init_SystemPromptService = __esm({
  "src/services/SystemPromptService.ts"() {
    import_obsidian17 = require("obsidian");
    init_prompts2();
    _SystemPromptService = class _SystemPromptService {
      constructor(app, pluginSettingsGetter) {
        this.app = app;
        this.pluginSettings = pluginSettingsGetter;
      }
      /**
       * Get the singleton instance of SystemPromptService
       */
      static getInstance(app, pluginSettingsGetter) {
        if (!this.instance) {
          this.instance = new _SystemPromptService(app, pluginSettingsGetter);
        }
        this.instance.pluginSettings = pluginSettingsGetter;
        return this.instance;
      }
      /**
       * Get the content of a system prompt based on type and agent mode
       */
      async getSystemPromptContent(type, path, agentMode) {
        const settings = this.pluginSettings();
        const effectiveAgentMode = agentMode !== void 0 ? agentMode : (settings == null ? void 0 : settings.agentMode) || false;
        if (type === "general-use") {
          return GENERAL_USE_PRESET.systemPrompt;
        } else if (type === "concise") {
          return CONCISE_PRESET.systemPrompt;
        } else if (type === "agent") {
          if (effectiveAgentMode) {
            return AGENT_PRESET.systemPrompt;
          } else {
            return GENERAL_USE_PRESET.systemPrompt;
          }
        } else if (type === "custom" && path) {
          try {
            return await this.readCustomPromptFile(path);
          } catch (error) {
            return GENERAL_USE_PRESET.systemPrompt;
          }
        }
        return GENERAL_USE_PRESET.systemPrompt;
      }
      /**
       * Compose the final system prompt by prefixing the agent prompt when
       * agent mode is enabled and the selected type is not already the agent
       * preset. If basePrompt is empty, the agent prompt alone is returned.
       */
      async combineWithAgentPrefix(basePrompt, selectedType, agentMode) {
        const normalized = (selectedType || "").toLowerCase();
        const effectiveBase = basePrompt && basePrompt.length > 0 ? basePrompt : GENERAL_USE_PRESET.systemPrompt;
        if (!agentMode) return effectiveBase;
        if (normalized === "agent") return effectiveBase;
        try {
          const agentPrompt = await this.getSystemPromptContent("agent", void 0, true);
          if (agentPrompt && agentPrompt.length > 0) {
            return effectiveBase ? `${agentPrompt}

${effectiveBase}` : agentPrompt;
          }
        } catch (_) {
        }
        return effectiveBase;
      }
      /**
       * Append a concise tools hint to the end of the assembled system prompt
       * when tools are available for this turn.
       */
      appendToolsHint(prompt, hasTools) {
        if (!hasTools) return prompt;
        const hint = "You have access to filesystem tools to interact with the user's vault. Use them when asked about files or directories.";
        return prompt && prompt.length > 0 ? `${prompt}

${hint}` : hint;
      }
      /**
       * Helper to read content from a custom prompt file
       */
      async readCustomPromptFile(path) {
        let file = this.app.vault.getAbstractFileByPath(path);
        if (!file && !path.endsWith(".md")) {
          file = this.app.vault.getAbstractFileByPath(`${path}.md`);
        }
        if (!file) {
          const settings = this.pluginSettings();
          const promptsDir = (settings == null ? void 0 : settings.systemPromptsDirectory) || "SystemSculpt/System Prompts";
          const filename = path.split("/").pop();
          if (filename) {
            file = this.app.vault.getAbstractFileByPath(`${promptsDir}/${filename}`);
            if (!file && !filename.endsWith(".md")) {
              file = this.app.vault.getAbstractFileByPath(`${promptsDir}/${filename}.md`);
            }
          }
        }
        if (!file) {
          const settings = this.pluginSettings();
          const promptsDir = (settings == null ? void 0 : settings.systemPromptsDirectory) || "SystemSculpt/System Prompts";
          const filename = path.split("/").pop();
          if (filename) {
            const targetBase = filename.endsWith(".md") ? filename.slice(0, -3) : filename;
            const candidates = this.app.vault.getMarkdownFiles().filter((f) => (f.path === promptsDir || f.path.startsWith(`${promptsDir}/`)) && f.basename === targetBase).sort((a, b) => a.path.localeCompare(b.path));
            if (candidates.length > 0) {
              file = candidates[0];
            }
          }
        }
        if (file instanceof import_obsidian17.TFile) {
          return await this.app.vault.read(file);
        }
        throw new Error(`Custom prompt file not found: ${path}`);
      }
      /**
       * Get available system prompt presets
       */
      getLocalPresets() {
        return LOCAL_SYSTEM_PROMPTS;
      }
      /**
       * Get custom prompt files in the SystemSculpt/System Prompts directory
       * Now with timeout protection and better error handling
       */
      async getCustomPromptFiles() {
        const settings = this.pluginSettings();
        const promptsDir = (settings == null ? void 0 : settings.systemPromptsDirectory) || "SystemSculpt/System Prompts";
        try {
          const dirExists = await this.app.vault.adapter.exists(promptsDir);
          if (!dirExists) return [];
          const all = this.app.vault.getMarkdownFiles();
          const files = all.filter((f) => f.path === promptsDir || f.path.startsWith(`${promptsDir}/`)).map((f) => ({ path: f.path, name: f.basename })).sort((a, b) => a.name.localeCompare(b.name));
          return files;
        } catch (_) {
          return [];
        }
      }
      /**
       * Generate a bullet-list representation of all directories in the vault.
       * Example output:
       * - FolderA
       * - FolderA/SubFolderB
       * - FolderC
       */
      getVaultDirectoryStructure() {
        var _a;
        const dirSet = /* @__PURE__ */ new Set();
        const files = this.app.vault.getFiles();
        for (const file of files) {
          const pathParts = file.path.split("/");
          pathParts.pop();
          for (let i = 1; i <= pathParts.length; i++) {
            const dirPath = pathParts.slice(0, i).join("/");
            if (dirPath) {
              dirSet.add(dirPath);
            }
          }
        }
        const allDirs = Array.from(dirSet);
        const totalDirCount = allDirs.length;
        allDirs.sort((a, b) => a.localeCompare(b));
        const settings = (_a = this.pluginSettings) == null ? void 0 : _a.call(this);
        const maxEntries = settings && settings.maxVaultDirectoryEntries || 300;
        if (totalDirCount <= maxEntries) {
          return allDirs.map((dir) => `- ${dir}`).join("\n");
        }
        const topLevelMap = {};
        for (const dir of allDirs) {
          const [top] = dir.split("/");
          topLevelMap[top] = (topLevelMap[top] || 0) + 1;
        }
        const summaryLines = Object.keys(topLevelMap).sort((a, b) => a.localeCompare(b)).map((t) => `- ${t} (${topLevelMap[t] - 1} nested subdirs)`);
        const cappedSummary = summaryLines.slice(0, maxEntries);
        const ellipsisLine = summaryLines.length > cappedSummary.length ? `- \u2026and ${summaryLines.length - cappedSummary.length} more top-level folders` : void 0;
        return [
          `Total directories: ${totalDirCount}`,
          ...cappedSummary,
          ellipsisLine
        ].filter(Boolean).join("\n");
      }
    };
    _SystemPromptService.instance = null;
    SystemPromptService = _SystemPromptService;
  }
});

// src/services/ContextFileService.ts
var import_obsidian18, ContextFileService;
var init_ContextFileService = __esm({
  "src/services/ContextFileService.ts"() {
    import_obsidian18 = require("obsidian");
    init_ImageProcessor();
    init_SystemPromptService();
    init_errorLogger();
    init_cryptoUtils();
    init_tooling();
    ContextFileService = class {
      constructor(app) {
        this.app = app;
      }
      /**
       * Generate deterministic ID for context content
       */
      deterministicId(input, prefix) {
        const hash = simpleHash(input);
        const extendedHash = simpleHash(hash + input) + simpleHash(input + hash);
        return `${prefix}_${extendedHash.slice(0, 24)}`;
      }
      hydrateToolCalls(toolCalls, toolCallManager) {
        if (!Array.isArray(toolCalls) || toolCalls.length === 0) {
          return [];
        }
        return toolCalls.map((call) => {
          var _a, _b;
          if (!(toolCallManager == null ? void 0 : toolCallManager.getToolCall) || !(call == null ? void 0 : call.id)) {
            return call;
          }
          const managerCall = toolCallManager.getToolCall(call.id);
          if (!managerCall) {
            return call;
          }
          const merged = {
            ...managerCall,
            request: managerCall.request || call.request,
            messageId: managerCall.messageId || call.messageId,
            timestamp: (_a = managerCall.timestamp) != null ? _a : call.timestamp,
            autoApproved: (_b = managerCall.autoApproved) != null ? _b : call.autoApproved
          };
          if (!merged.result && call.result) {
            merged.result = call.result;
          }
          if (!merged.state && call.state) {
            merged.state = call.state;
          }
          if (!merged.executionCompletedAt && call.executionCompletedAt) {
            merged.executionCompletedAt = call.executionCompletedAt;
          }
          if (!merged.executionStartedAt && call.executionStartedAt) {
            merged.executionStartedAt = call.executionStartedAt;
          }
          try {
            errorLogger.debug("Hydrated tool call from manager", {
              source: "ContextFileService",
              method: "hydrateToolCalls",
              metadata: {
                toolCallId: merged.id,
                hasResult: !!merged.result,
                state: merged.state
              }
            });
          } catch (e) {
          }
          return merged;
        });
      }
      /**
       * Get contents of a context file
       */
      async getContextFileContents(filePath) {
        try {
          const linkText = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
          const cleanPath = linkText.replace(
            /\$begin:math:display\$\[(.*?)\$end:math:display\$]/g,
            "$1"
          );
          const resolvedFile = this.app.metadataCache.getFirstLinkpathDest(
            cleanPath,
            ""
          );
          if (resolvedFile instanceof import_obsidian18.TFile) {
            if (resolvedFile.extension.match(/^(jpg|jpeg|png|gif|webp)$/i)) {
              const base64 = await ImageProcessor.processImage(
                resolvedFile,
                this.app
              );
              return { type: "image", base64 };
            }
            const content = await this.app.vault.read(resolvedFile);
            return content;
          }
          const fileName = cleanPath.split("/").pop();
          if (fileName) {
            const allFiles = this.app.vault.getFiles();
            const matchingFile = allFiles.find((f) => f.name === fileName);
            if (matchingFile) {
              if (matchingFile.extension.match(/^(jpg|jpeg|png|gif|webp)$/i)) {
                const base64 = await ImageProcessor.processImage(
                  matchingFile,
                  this.app
                );
                return { type: "image", base64 };
              }
              const content = await this.app.vault.read(matchingFile);
              return content;
            }
          }
          return null;
        } catch (error) {
          return null;
        }
      }
      /**
       * Build a chat message from a context file
       */
      async buildContextMessageFromFile(filePath) {
        var _a;
        if (filePath === "@@vault-structure@@") {
          const activeView = this.app.workspace.getActiveViewOfType(import_obsidian18.ItemView);
          if (activeView && "contextManager" in activeView) {
            const chatView = activeView;
            const vaultStructure = (_a = chatView.contextManager) == null ? void 0 : _a.getVaultStructureContent();
            if (vaultStructure) {
              return {
                role: "user",
                content: `[VAULT STRUCTURE]
This is the current directory structure of the user's Obsidian vault:

${vaultStructure}

Note: This structure shows only directories to help you understand the vault organization. Use this to provide context-aware suggestions and navigate the user's knowledge base effectively.`,
                message_id: this.deterministicId("vault-structure", "ctx")
              };
            }
          }
          return null;
        }
        const content = await this.getContextFileContents(filePath);
        const displayName = filePath.replace(
          /\$begin:math:display\$\[(.*?)\$end:math:display\$]/g,
          "$1"
        );
        if (content) {
          if (typeof content === "string") {
            return {
              role: "user",
              content: `Context from ${displayName}:

${content}`,
              message_id: this.deterministicId(filePath, "ctx")
            };
          } else if (content.type === "image") {
            return {
              role: "user",
              content: [
                {
                  type: "text",
                  text: `Context from ${displayName}:

`
                },
                {
                  type: "image_url",
                  image_url: {
                    // Prefer preserving original data URL header if present
                    url: content.base64.startsWith("data:") ? content.base64 : (function() {
                      const lower = displayName.toLowerCase();
                      const ext = lower.includes(".") ? lower.split(".").pop() || "" : "";
                      const media = ext === "jpg" || ext === "jpeg" ? "image/jpeg" : ext === "gif" ? "image/gif" : ext === "webp" ? "image/webp" : "image/png";
                      return `data:${media};base64,${content.base64}`;
                    })()
                  }
                }
              ],
              message_id: this.deterministicId(filePath, "ctx")
            };
          }
        }
        return null;
      }
      /**
       * Prepare messages with context files and system prompt
       */
      async prepareMessagesWithContext(messages, contextFiles, systemPromptType, systemPromptPath, agentMode, toolCallManager, finalSystemPrompt) {
        var _a;
        const preparedMessages = [];
        let systemPromptContent = finalSystemPrompt;
        const normalizedType = systemPromptType == null ? void 0 : systemPromptType.toLowerCase();
        if (!systemPromptContent) {
          try {
            if (normalizedType === "custom" && systemPromptPath) {
              systemPromptContent = await SystemPromptService.getInstance(this.app, () => ({})).getSystemPromptContent("custom", systemPromptPath);
            } else if (normalizedType === "general-use" || normalizedType === "concise" || normalizedType === "agent") {
              systemPromptContent = await SystemPromptService.getInstance(this.app, () => ({})).getSystemPromptContent(normalizedType, void 0, agentMode);
            } else {
              systemPromptContent = await SystemPromptService.getInstance(this.app, () => ({})).getSystemPromptContent("general-use", void 0, agentMode);
            }
          } catch (_) {
          }
          if (!systemPromptContent) {
            systemPromptContent = "You are a helpful AI assistant. Provide clear, accurate, and relevant information.";
          }
        }
        if (systemPromptContent) {
          preparedMessages.push({
            role: "system",
            content: systemPromptContent,
            message_id: this.deterministicId(systemPromptContent, "sys")
          });
        } else {
          const fallbackPrompt = "You are a helpful AI assistant. Provide clear, accurate, and relevant information.";
          preparedMessages.push({
            role: "system",
            content: fallbackPrompt,
            message_id: this.deterministicId(fallbackPrompt, "sys")
          });
        }
        const documentIds = [];
        const contextMessages = [];
        for (const filePath of contextFiles) {
          if (filePath.startsWith("doc:")) {
            const documentId = filePath.substring(4);
            documentIds.push(documentId);
          } else {
            const contextMessage = await this.buildContextMessageFromFile(filePath);
            if (contextMessage) {
              contextMessages.push(contextMessage);
            }
          }
        }
        let lastUserIndex = -1;
        for (let i = messages.length - 1; i >= 0; i--) {
          if (((_a = messages[i]) == null ? void 0 : _a.role) === "user") {
            lastUserIndex = i;
            break;
          }
        }
        if (documentIds.length > 0 && lastUserIndex !== -1) {
          const targetUserMessage = messages[lastUserIndex];
          if (targetUserMessage) {
            targetUserMessage.documentContext = { documentIds };
          }
        }
        for (let idx = 0; idx < messages.length; idx++) {
          const msg = messages[idx];
          if (msg.role === "assistant" && Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {
            if (agentMode) {
              const enrichedToolCalls = this.hydrateToolCalls(msg.tool_calls, toolCallManager);
              msg.tool_calls = enrichedToolCalls;
              const toolCallsForApi = mapAssistantToolCallsForApi(enrichedToolCalls);
              const assistantApiMessage = {
                role: "assistant",
                message_id: msg.message_id
              };
              if (toolCallsForApi.length > 0) {
                assistantApiMessage.tool_calls = toolCallsForApi;
              }
              assistantApiMessage.content = msg.content || "";
              preparedMessages.push(assistantApiMessage);
              const toolResultMessages = buildToolResultMessagesFromToolCalls(enrichedToolCalls);
              for (const m of toolResultMessages) preparedMessages.push(m);
            } else {
              const assistantMessageWithoutTools = {
                role: "assistant",
                message_id: msg.message_id,
                content: msg.content || ""
              };
              preparedMessages.push(assistantMessageWithoutTools);
            }
          } else if (msg.role !== "tool") {
            if (idx === lastUserIndex && contextMessages.length > 0) {
              for (const cm of contextMessages) {
                preparedMessages.push(cm);
              }
            }
            const messageToPush = {
              role: msg.role,
              message_id: msg.message_id,
              documentContext: msg.documentContext,
              systemPromptType: msg.systemPromptType,
              systemPromptPath: msg.systemPromptPath,
              ...msg.tool_calls && msg.tool_calls.length > 0 && { tool_calls: msg.tool_calls }
            };
            if (msg.content) {
              messageToPush.content = msg.content;
            }
            preparedMessages.push(messageToPush);
          }
        }
        if (toolCallManager && agentMode) {
          this.optimizeToolResultsContext(preparedMessages, toolCallManager);
        }
        return preparedMessages;
      }
      /**
       * Optimize tool results context using industry best practices
       */
      optimizeToolResultsContext(preparedMessages, toolCallManager) {
        const recentToolResults = toolCallManager.getToolResultsForContext();
        const toolMessageCount = preparedMessages.filter((msg) => msg.role === "tool").length;
        if (toolMessageCount > 15) {
          const recentToolCallIds = new Set(recentToolResults.map((tc) => tc.id));
          const filtered = [];
          for (const msg of preparedMessages) {
            if (msg.role === "tool") {
              const keep = !!msg.tool_call_id && recentToolCallIds.has(msg.tool_call_id);
              if (keep) filtered.push(msg);
              continue;
            }
            if (msg.role === "assistant" && Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {
              const originalToolCalls = msg.tool_calls;
              const prunedToolCalls = originalToolCalls.filter((tc) => recentToolCallIds.has(tc.id));
              if (prunedToolCalls.length > 0) {
                const updatedMsg = {
                  ...msg,
                  tool_calls: prunedToolCalls
                };
                filtered.push(updatedMsg);
              } else {
                const hasContent = typeof msg.content === "string" ? msg.content.trim().length > 0 : Array.isArray(msg.content) && msg.content.length > 0;
                if (hasContent) {
                  const updatedMsg = {
                    ...msg,
                    tool_calls: void 0
                  };
                  filtered.push(updatedMsg);
                }
              }
              continue;
            }
            filtered.push(msg);
          }
          preparedMessages.length = 0;
          preparedMessages.push(...filtered);
        }
      }
    };
  }
});

// src/utils/FileValidator.ts
async function validateFileSize(file, app) {
  const fileSize = file.stat.size;
  if (fileSize > MAX_FILE_SIZE) {
    await showPopup(
      app,
      `The file "${file.name}" is too large (${formatFileSize(fileSize)}). The maximum allowed size is 500MB.`,
      {
        title: "File Size Limit Exceeded",
        description: "Please reduce the file size or choose a smaller file.",
        primaryButton: "OK"
      }
    );
    return false;
  }
  return true;
}
async function validateBrowserFileSize(file, app) {
  if (file.size > MAX_FILE_SIZE) {
    await showPopup(
      app,
      `The file "${file.name}" is too large (${formatFileSize(file.size)}). The maximum allowed size is 500MB.`,
      {
        title: "File Size Limit Exceeded",
        description: "Please reduce the file size or choose a smaller file.",
        primaryButton: "OK"
      }
    );
    return false;
  }
  return true;
}
function formatFileSize(bytes) {
  if (bytes < 1024) {
    return bytes + " bytes";
  } else if (bytes < 1024 * 1024) {
    return (bytes / 1024).toFixed(1) + " KB";
  } else {
    return (bytes / (1024 * 1024)).toFixed(1) + " MB";
  }
}
var MAX_FILE_SIZE;
var init_FileValidator = __esm({
  "src/utils/FileValidator.ts"() {
    init_ui();
    MAX_FILE_SIZE = 500 * 1024 * 1024;
  }
});

// src/services/DocumentUploadService.ts
var import_obsidian19, DocumentUploadService;
var init_DocumentUploadService = __esm({
  "src/services/DocumentUploadService.ts"() {
    import_obsidian19 = require("obsidian");
    init_errors();
    init_FileValidator();
    init_fileTypes();
    init_documentProcessingLog();
    DocumentUploadService = class {
      constructor(app, baseUrl, licenseKey) {
        this.app = app;
        this.baseUrl = baseUrl;
        this.licenseKey = licenseKey;
      }
      /**
       * Update the base URL and license key
       */
      updateConfig(baseUrl, licenseKey) {
        this.baseUrl = baseUrl;
        this.licenseKey = licenseKey;
      }
      /**
       * Upload a document to the server for processing
       * Returns {documentId, status: "queued" | "processing" | "completed", cached?: boolean} if successful
       */
      async uploadDocument(file) {
        var _a, _b;
        try {
          if (!((_a = this.licenseKey) == null ? void 0 : _a.trim())) {
            throw new SystemSculptError(
              "A valid license key is required for document processing",
              ERROR_CODES.PRO_REQUIRED,
              403
            );
          }
          const isValidSize = await validateFileSize(file, this.app);
          if (!isValidSize) {
            throw new SystemSculptError(
              "File size exceeds the maximum limit of 25MB",
              ERROR_CODES.FILE_TOO_LARGE,
              413
            );
          }
          const normalizedExtension = normalizeFileExtension(file.extension);
          const resolvedContentType = (_b = getDocumentMimeType(normalizedExtension)) != null ? _b : "application/octet-stream";
          logDocumentProcessingEvent(this.app, {
            stage: "uploading",
            progress: 18,
            label: "Preparing document upload payload\u2026",
            icon: "upload",
            filePath: file.path,
            fileName: file.name,
            metadata: {
              extension: normalizedExtension,
              resolvedContentType,
              usedFallback: resolvedContentType === "application/octet-stream"
            }
          });
          const data = await this.app.vault.readBinary(file);
          const blob = new Blob([data], { type: resolvedContentType });
          const boundary = "WebKitFormBoundary" + Math.random().toString(36).substring(2, 15);
          const encoder = new TextEncoder();
          const parts = [];
          parts.push(encoder.encode(`--${boundary}\r
`));
          parts.push(encoder.encode(
            `Content-Disposition: form-data; name="file"; filename="${file.name}"\r
`
          ));
          parts.push(
            encoder.encode(`Content-Type: ${resolvedContentType}\r
`)
          );
          parts.push(encoder.encode("\r\n"));
          parts.push(new Uint8Array(await blob.arrayBuffer()));
          parts.push(encoder.encode("\r\n"));
          parts.push(encoder.encode(`--${boundary}--\r
`));
          const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
          const formDataArray = new Uint8Array(totalSize);
          let offset = 0;
          for (const part of parts) {
            formDataArray.set(part, offset);
            offset += part.length;
          }
          const url = `${this.baseUrl}/documents/process`;
          const response = await (0, import_obsidian19.requestUrl)({
            url,
            method: "POST",
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`,
              "x-license-key": this.licenseKey
            },
            body: formDataArray.buffer,
            throw: false
          });
          if (response.status !== 200) {
            let errorText = "";
            try {
              errorText = response.text;
            } catch (textError) {
            }
            if (response.status === 403) {
              throw new SystemSculptError(
                "Invalid or expired license key",
                ERROR_CODES.INVALID_LICENSE,
                403
              );
            }
            throw new SystemSculptError(
              `Upload failed: ${response.status} ${errorText ? `- ${errorText}` : ""}`,
              ERROR_CODES.PROCESSING_ERROR,
              response.status
            );
          }
          try {
            const responseData = JSON.parse(response.text);
            return responseData;
          } catch (jsonError) {
            throw new SystemSculptError(
              "Invalid response format from server",
              ERROR_CODES.INVALID_RESPONSE,
              500
            );
          }
        } catch (error) {
          if (error instanceof SystemSculptError) {
            throw error;
          }
          throw new SystemSculptError(
            error instanceof Error ? error.message : String(error),
            ERROR_CODES.PROCESSING_ERROR,
            500
          );
        }
      }
    };
  }
});

// src/services/AudioUploadService.ts
var import_obsidian20, AudioUploadService;
var init_AudioUploadService = __esm({
  "src/services/AudioUploadService.ts"() {
    import_obsidian20 = require("obsidian");
    init_FileValidator();
    init_errorHandling();
    AudioUploadService = class {
      constructor(app, baseUrl) {
        this.app = app;
        this.baseUrl = baseUrl;
      }
      /**
       * Update the base URL
       */
      updateBaseUrl(baseUrl) {
        this.baseUrl = baseUrl;
      }
      /**
       * Upload an audio file to the server for speech-to-text extraction
       * Returns {documentId, status: "queued"|"processing"|"completed", cached?: boolean} if successful
       */
      async uploadAudio(file) {
        try {
          const isValidSize = await validateFileSize(file, this.app);
          if (!isValidSize) {
            throw new Error("File size exceeds the maximum limit of 25MB");
          }
          const data = await this.app.vault.readBinary(file);
          const blob = new Blob([data], { type: "application/octet-stream" });
          const boundary = "WebKitFormBoundary" + Math.random().toString(36).substring(2, 15);
          const encoder = new TextEncoder();
          const parts = [];
          parts.push(encoder.encode(`--${boundary}\r
`));
          parts.push(encoder.encode(
            `Content-Disposition: form-data; name="file"; filename="${file.name}"\r
`
          ));
          parts.push(encoder.encode(`Content-Type: application/octet-stream\r
`));
          parts.push(encoder.encode("\r\n"));
          parts.push(new Uint8Array(await blob.arrayBuffer()));
          parts.push(encoder.encode("\r\n"));
          parts.push(encoder.encode(`--${boundary}--\r
`));
          const totalSize = parts.reduce((sum, part) => sum + part.length, 0);
          const formDataArray = new Uint8Array(totalSize);
          let offset = 0;
          for (const part of parts) {
            formDataArray.set(part, offset);
            offset += part.length;
          }
          const response = await (0, import_obsidian20.requestUrl)({
            url: `${this.baseUrl}/audio/transcriptions`,
            method: "POST",
            headers: {
              "Content-Type": `multipart/form-data; boundary=${boundary}`
            },
            body: formDataArray.buffer,
            throw: false
          });
          if (response.status !== 200) {
            throw new Error(`Audio upload failed: ${response.status}`);
          }
          const result = JSON.parse(response.text);
          return result;
        } catch (error) {
          logMobileError("AudioUploadService", "Audio upload failed", error, {
            filename: file.name,
            fileSize: file.stat.size,
            endpoint: `${this.baseUrl}/audio/transcriptions`
          });
          throw error;
        }
      }
    };
  }
});

// src/constants/webSearch.ts
var WEB_SEARCH_CONFIG, MOBILE_STREAM_CONFIG;
var init_webSearch = __esm({
  "src/constants/webSearch.ts"() {
    WEB_SEARCH_CONFIG = {
      /** Maximum number of web search results to return */
      MAX_RESULTS: 5,
      /** Plugin ID for OpenRouter web search */
      PLUGIN_ID: "web",
      /** Default search context size for native web search models */
      DEFAULT_CONTEXT_SIZE: "medium"
    };
    MOBILE_STREAM_CONFIG = {
      /** Size of content chunks for mobile streaming (characters) */
      CHUNK_SIZE: 50,
      /** Delay between chunks to simulate streaming (milliseconds) */
      CHUNK_DELAY_MS: 10
    };
  }
});

// src/utils/streaming.ts
var streaming_exports = {};
__export(streaming_exports, {
  createSSEStreamFromChatCompletionJSON: () => createSSEStreamFromChatCompletionJSON,
  postJsonStreaming: () => postJsonStreaming
});
async function postJsonStreaming(url, headers, body, isMobile, signal) {
  var _a;
  const json = JSON.stringify(body);
  try {
    errorLogger.debug("postJsonStreaming request", {
      source: "streaming",
      method: "postJsonStreaming",
      metadata: { url, isMobile }
    });
  } catch (e) {
  }
  try {
    console.debug("[SystemSculpt][Streaming] postJsonStreaming called", {
      url,
      isMobile,
      hasFetch: typeof fetch === "function"
    });
  } catch (e) {
  }
  if (!isMobile && typeof fetch === "function" && !url.includes("anthropic.com")) {
    try {
      let fetchHeaders = { ...headers };
      try {
        const host = new URL(url).host;
        if (host.endsWith("openrouter.ai")) {
          const toStrip = ["HTTP-Referer", "X-Title", "Cache-Control"];
          for (const h of toStrip) {
            for (const k of Object.keys(fetchHeaders)) {
              if (k.toLowerCase() === h.toLowerCase()) delete fetchHeaders[k];
            }
          }
        }
      } catch (e) {
      }
      const resp = await fetch(url, { method: "POST", headers: fetchHeaders, body: json, signal });
      try {
        console.debug("[SystemSculpt][Streaming] fetch used for streaming", {
          url,
          status: resp.status,
          contentType: resp.headers.get("content-type") || ""
        });
      } catch (e) {
      }
      try {
        errorLogger.debug("postJsonStreaming fetch response", {
          source: "streaming",
          method: "postJsonStreaming",
          metadata: { status: resp.status, contentType: resp.headers.get("content-type") || "" }
        });
      } catch (e) {
      }
      return resp;
    } catch (e) {
      try {
        console.debug("[SystemSculpt][Streaming] fetch attempt failed, falling back", {
          url,
          error: (_a = e == null ? void 0 : e.message) != null ? _a : String(e)
        });
      } catch (e2) {
      }
    }
  }
  const result = await (0, import_obsidian21.requestUrl)({ url, method: "POST", headers, body: json, throw: false });
  try {
    console.debug("[SystemSculpt][Streaming] requestUrl fallback used", {
      url,
      status: result.status
    });
  } catch (e) {
  }
  try {
    errorLogger.debug("postJsonStreaming requestUrl response", {
      source: "streaming",
      method: "postJsonStreaming",
      metadata: { status: result.status, hasText: !!result.text, hasJson: !!result.json }
    });
  } catch (e) {
  }
  if (!result.status || result.status >= 400) {
    let errorData = {};
    try {
      errorData = result.json || {};
    } catch (e) {
      errorData = { error: result.text || "Request failed" };
    }
    return new Response(JSON.stringify(errorData), {
      status: result.status || 500,
      statusText: "Error",
      headers: { "Content-Type": "application/json" }
    });
  }
  let responseData;
  if (result.text && typeof result.text === "string" && result.text.includes("event:")) {
    responseData = result.text;
  } else {
    try {
      responseData = result.json;
    } catch (e) {
      responseData = result.text;
    }
  }
  const isSSEString = typeof responseData === "string" && (/(^|\n)event:\s*/.test(responseData) || /(^|\n)data:\s*/.test(responseData));
  const isAnthropicHost = url.includes("anthropic.com");
  if (isSSEString) {
    const encoder2 = new TextEncoder();
    const stream2 = new ReadableStream({
      start(controller) {
        controller.enqueue(encoder2.encode(responseData));
        if (!responseData.includes("[DONE]")) {
          controller.enqueue(encoder2.encode("data: [DONE]\n\n"));
        }
        controller.close();
      }
    });
    return new Response(stream2, {
      status: 200,
      statusText: "OK",
      headers: {
        "Content-Type": "text/event-stream",
        "X-Provider-Format": isAnthropicHost ? "anthropic-sse" : "openai-sse"
      }
    });
  }
  if (responseData !== null && typeof responseData === "object") {
    return new Response(JSON.stringify(responseData), {
      status: 200,
      statusText: "OK",
      headers: {
        "Content-Type": "application/json",
        "X-Provider-Format": isAnthropicHost ? "anthropic-json" : "openai-json"
      }
    });
  }
  const encoder = new TextEncoder();
  const stream = new ReadableStream({
    start(controller) {
      const sse = `data: ${JSON.stringify(String(responseData || ""))}

`;
      controller.enqueue(encoder.encode(sse));
      controller.enqueue(encoder.encode("data: [DONE]\n\n"));
      controller.close();
    }
  });
  return new Response(stream, {
    status: 200,
    statusText: "OK",
    headers: {
      "Content-Type": "text/event-stream",
      "X-Provider-Format": "openai-sse"
    }
  });
}
function createSSEStreamFromChatCompletionJSON(responseData, options) {
  var _a, _b;
  const enc = new TextEncoder();
  const chunkSize = (_a = options == null ? void 0 : options.chunkSize) != null ? _a : MOBILE_STREAM_CONFIG.CHUNK_SIZE;
  const delayMs = (_b = options == null ? void 0 : options.chunkDelayMs) != null ? _b : MOBILE_STREAM_CONFIG.CHUNK_DELAY_MS;
  return new ReadableStream({
    async start(controller) {
      var _a2, _b2, _c, _d, _e, _f;
      const enqueueSSE = (data) => {
        const sseData = typeof data === "string" ? data : `data: ${JSON.stringify(data)}

`;
        controller.enqueue(enc.encode(sseData));
      };
      let content = "";
      let reasoning = null;
      let toolCalls = null;
      let annotations = null;
      let webSearchEnabled = null;
      if ((responseData == null ? void 0 : responseData.choices) && responseData.choices[0]) {
        const choice = responseData.choices[0];
        content = ((_a2 = choice.message) == null ? void 0 : _a2.content) || "";
        reasoning = ((_b2 = choice.message) == null ? void 0 : _b2.reasoning) || null;
        toolCalls = ((_c = choice.message) == null ? void 0 : _c.tool_calls) || null;
        annotations = ((_d = choice.message) == null ? void 0 : _d.annotations) || null;
      } else if (responseData == null ? void 0 : responseData.text) {
        content = responseData.text;
        reasoning = responseData.reasoning || null;
        annotations = responseData.annotations || null;
        webSearchEnabled = responseData.webSearchEnabled || null;
      } else if (typeof responseData === "string") {
        content = responseData;
      }
      if (webSearchEnabled) {
        enqueueSSE({ webSearchEnabled: true });
        await new Promise((r) => setTimeout(r, delayMs));
      }
      if (reasoning) {
        for (let i = 0; i < reasoning.length; i += chunkSize) {
          const reasoningChunkText = reasoning.slice(i, i + chunkSize);
          const reasoningChunk = {
            choices: [
              {
                delta: {
                  reasoning: reasoningChunkText
                },
                finish_reason: null
              }
            ],
            model: responseData.model,
            id: responseData.id
          };
          enqueueSSE(reasoningChunk);
          await new Promise((r) => setTimeout(r, delayMs));
        }
      }
      for (let i = 0; i < content.length; i += chunkSize) {
        const contentChunk = content.slice(i, i + chunkSize);
        const chunk = {
          choices: [
            {
              delta: {
                content: contentChunk
              },
              finish_reason: null
            }
          ],
          model: responseData.model,
          id: responseData.id
        };
        enqueueSSE(chunk);
        await new Promise((r) => setTimeout(r, delayMs));
      }
      if (annotations && annotations.length > 0) {
        const annotationsChunk = {
          choices: [
            {
              delta: {
                annotations
              },
              finish_reason: null
            }
          ],
          model: responseData.model,
          id: responseData.id
        };
        enqueueSSE(annotationsChunk);
        await new Promise((r) => setTimeout(r, delayMs));
      }
      if (toolCalls && toolCalls.length > 0) {
        const toolCallChunk = {
          choices: [
            {
              delta: {
                tool_calls: toolCalls
              },
              finish_reason: "tool_calls"
            }
          ],
          model: responseData.model,
          id: responseData.id
        };
        enqueueSSE(toolCallChunk);
      }
      const finishReason = ((_f = (_e = responseData.choices) == null ? void 0 : _e[0]) == null ? void 0 : _f.finish_reason) || "stop";
      const finalChunk = {
        choices: [
          {
            delta: {},
            finish_reason: finishReason
          }
        ],
        model: responseData.model || "unknown",
        id: responseData.id || "mobile-response"
      };
      enqueueSSE(finalChunk);
      enqueueSSE("data: [DONE]\n\n");
      controller.close();
    }
  });
}
var import_obsidian21;
var init_streaming = __esm({
  "src/utils/streaming.ts"() {
    import_obsidian21 = require("obsidian");
    init_errorLogger();
    init_webSearch();
  }
});

// src/services/PromptBuilder.ts
var PromptBuilder_exports = {};
__export(PromptBuilder_exports, {
  PromptBuilder: () => PromptBuilder
});
var PromptBuilder;
var init_PromptBuilder = __esm({
  "src/services/PromptBuilder.ts"() {
    init_SystemPromptService();
    init_prompts2();
    PromptBuilder = class {
      static async buildSystemPrompt(app, getSettings, opts) {
        const svc = SystemPromptService.getInstance(app, getSettings);
        let base = "";
        try {
          base = await svc.getSystemPromptContent(
            opts.type || "general-use",
            opts.path,
            opts.agentMode
          );
        } catch (_) {
          base = GENERAL_USE_PRESET.systemPrompt;
        }
        let composed = await svc.combineWithAgentPrefix(base, opts.type, opts.agentMode);
        composed = svc.appendToolsHint(composed || GENERAL_USE_PRESET.systemPrompt, !!opts.hasTools);
        return composed;
      }
    };
  }
});

// src/services/SystemSculptService.ts
var import_obsidian22, _SystemSculptService, SystemSculptService;
var init_SystemSculptService = __esm({
  "src/services/SystemSculptService.ts"() {
    import_obsidian22 = require("obsidian");
    init_errors();
    init_MCPService2();
    init_debugLogger();
    init_modelUtils();
    init_tooling();
    init_PlatformContext();
    init_SystemSculptEnvironment();
    init_StreamingService();
    init_StreamingErrorHandler();
    init_ToolSchemaSanitizer();
    init_LicenseService();
    init_ModelManagementService();
    init_ContextFileService();
    init_DocumentUploadService();
    init_AudioUploadService();
    init_errorLogger();
    _SystemSculptService = class _SystemSculptService {
      get extractionsDirectory() {
        var _a;
        return (_a = this.settings.extractionsDirectory) != null ? _a : "";
      }
      constructor(plugin) {
        this.plugin = plugin;
        this.settings = plugin.settings;
        if (!plugin.customProviderService) {
          throw new Error("SystemSculptService requires CustomProviderService to be initialized first. This is likely a plugin initialization order issue.");
        }
        this.customProviderService = plugin.customProviderService;
        this.mcpService = new MCPService(plugin, plugin.app);
        this.baseUrl = this.getValidServerUrl();
        this.streamingService = new StreamingService();
        this.licenseService = new LicenseService(plugin, this.baseUrl);
        this.modelManagementService = new ModelManagementService(plugin, this.baseUrl);
        this.contextFileService = new ContextFileService(plugin.app);
        this.documentUploadService = new DocumentUploadService(plugin.app, this.baseUrl, this.settings.licenseKey);
        this.audioUploadService = new AudioUploadService(plugin.app, this.baseUrl);
      }
      /**
       * Get the singleton instance - use this instead of creating new instances
       */
      static getInstance(plugin) {
        if (!_SystemSculptService.instance) {
          _SystemSculptService.instance = new _SystemSculptService(plugin);
        } else {
          _SystemSculptService.instance.updateSettings(plugin.settings);
        }
        return _SystemSculptService.instance;
      }
      /**
       * Clear singleton instance for cleanup
       */
      static clearInstance() {
        _SystemSculptService.instance = null;
      }
      /**
       * Update settings on existing instance
       */
      updateSettings(settings) {
        this.settings = settings;
        this.refreshSettings();
      }
      getValidServerUrl() {
        const { DEVELOPMENT_MODE: DEVELOPMENT_MODE2 } = (init_api(), __toCommonJS(api_exports));
        if (DEVELOPMENT_MODE2 === "DEVELOPMENT" && (!this.settings.serverUrl || this.settings.serverUrl.trim() === "")) {
          return "http://localhost:3001/api/v1";
        }
        return SystemSculptEnvironment.resolveBaseUrl(this.settings);
      }
      refreshSettings() {
        this.settings = this.plugin.settings;
        this.baseUrl = this.getValidServerUrl();
        this.licenseService.updateBaseUrl(this.baseUrl);
        this.modelManagementService.updateBaseUrl(this.baseUrl);
        this.documentUploadService.updateConfig(this.baseUrl, this.settings.licenseKey);
        this.audioUploadService.updateBaseUrl(this.baseUrl);
      }
      /**
       * Normalize a server-facing model id to a canonical provider prefix when missing.
       * - Preserve Groq vendor-qualified IDs (e.g., 'groq/openai/gpt-4o') as-is.
       * - Preserve explicit 'openrouter/...' and 'groq/...' prefixes.
       * - If only a vendor is provided (e.g., 'openai/gpt-4o'), default to OpenRouter.
       */
      normalizeServerModelId(id) {
        if (!id) return id;
        const lower = id.toLowerCase();
        if (lower.startsWith("openrouter/") || lower.startsWith("groq/")) return id;
        const vendorPrefixes = ["openai/", "anthropic/", "google/", "perplexity/", "mistral/", "meta/", "cohere/", "xai/", "deepseek/"];
        if (vendorPrefixes.some((p) => lower.startsWith(p))) {
          return `openrouter/${id}`;
        }
        return id;
      }
      // DELEGATE TO LICENSE SERVICE
      async validateLicense(forceCheck = false) {
        this.refreshSettings();
        return this.licenseService.validateLicense(forceCheck);
      }
      async getTokenBalance() {
        return this.licenseService.getTokenBalance();
      }
      async getCreditBreakdown() {
        return this.licenseService.getCreditBreakdown();
      }
      // DELEGATE TO MODEL MANAGEMENT SERVICE
      async getModels() {
        this.refreshSettings();
        return this.modelManagementService.getModels();
      }
      async preloadModels() {
        return this.modelManagementService.preloadModels();
      }
      // DELEGATE TO DOCUMENT UPLOAD SERVICE
      async uploadDocument(file) {
        return this.documentUploadService.uploadDocument(file);
      }
      // DELEGATE TO AUDIO UPLOAD SERVICE
      async uploadAudio(file) {
        return this.audioUploadService.uploadAudio(file);
      }
      /**
       * Handle custom provider completion requests using the adapter pattern
       */
      async handleCustomProviderCompletion(provider, messages, modelId, mcpTools = [], signal, plugins, web_search_options) {
        var _a;
        try {
          const adapter = this.customProviderService.getProviderAdapter(provider);
          const platform = PlatformContext.get();
          const isMobile = platform.isMobile();
          const fullEndpoint = adapter.getChatEndpoint();
          const transportOptions = { endpoint: fullEndpoint };
          const canStream = platform.supportsStreaming(transportOptions);
          const preferredTransport = platform.preferredTransport(transportOptions);
          try {
            console.debug("[SystemSculpt][Transport] handleCustomProviderCompletion transport", {
              provider: provider.name || provider.id,
              endpoint: fullEndpoint,
              canStream,
              preferredTransport,
              isMobile
            });
          } catch (e) {
          }
          const headers = { ...adapter.getHeaders() };
          if (!Object.keys(headers).some((k) => k.toLowerCase() === "content-type")) {
            headers["Content-Type"] = "application/json";
          }
          if (canStream) {
            headers["Accept"] = headers["Accept"] || "text/event-stream";
            headers["Cache-Control"] = headers["Cache-Control"] || "no-cache";
          }
          const requestBody = adapter.buildRequestBody(
            messages,
            modelId,
            mcpTools,
            canStream,
            { plugins, web_search_options }
          );
          const logger = DebugLogger.getInstance();
          logger == null ? void 0 : logger.logAPIRequest(fullEndpoint, "POST", requestBody);
          let response;
          if (preferredTransport === "fetch" && typeof fetch === "function") {
            try {
              const fetchOptions = {
                method: "POST",
                headers,
                body: JSON.stringify(requestBody),
                signal,
                mode: "cors",
                credentials: "omit",
                cache: "no-store"
              };
              response = await fetch(fullEndpoint, fetchOptions);
            } catch (e) {
              try {
                console.debug("[SystemSculpt][Transport] fetch failed, falling back to requestUrl", {
                  endpoint: fullEndpoint,
                  error: (_a = e == null ? void 0 : e.message) != null ? _a : String(e)
                });
              } catch (e2) {
              }
              const { postJsonStreaming: postJsonStreaming2 } = await Promise.resolve().then(() => (init_streaming(), streaming_exports));
              response = await postJsonStreaming2(
                fullEndpoint,
                headers,
                requestBody,
                isMobile,
                signal
              );
            }
          } else {
            try {
              console.debug("[SystemSculpt][Transport] using resilient postJsonStreaming fallback", {
                endpoint: fullEndpoint,
                preferredTransport,
                canStream,
                isMobile
              });
            } catch (e) {
            }
            const fallbackAsMobile = isMobile || preferredTransport !== "fetch";
            const { postJsonStreaming: postJsonStreaming2 } = await Promise.resolve().then(() => (init_streaming(), streaming_exports));
            response = await postJsonStreaming2(
              fullEndpoint,
              headers,
              requestBody,
              fallbackAsMobile,
              signal
            );
          }
          if (!response.ok) {
            await StreamingErrorHandler.handleStreamError(response, true);
          }
          const { stream, headers: transformHeaders } = await adapter.transformStreamResponse(response, isMobile);
          return new Response(stream, {
            status: response.status,
            statusText: response.statusText,
            headers: transformHeaders || response.headers
          });
        } catch (error) {
          throw error;
        }
      }
      async *streamMessage({
        messages,
        model,
        onError,
        contextFiles,
        systemPromptType,
        systemPromptPath,
        agentMode,
        signal,
        toolCallManager,
        plugins,
        web_search_options
      }) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i;
        const { DEVELOPMENT_MODE: DEVELOPMENT_MODE2 } = await Promise.resolve().then(() => (init_api(), api_exports));
        this.refreshSettings();
        const platform = PlatformContext.get();
        try {
          errorLogger.debug("Starting streamMessage", {
            source: "SystemSculptService",
            method: "streamMessage",
            metadata: { model, agentMode: !!agentMode }
          });
          let mcpTools = [];
          if (agentMode) {
            if (toolCallManager && typeof toolCallManager.getOpenAITools === "function") {
              try {
                mcpTools = await toolCallManager.getOpenAITools();
              } catch (e) {
                mcpTools = await this.mcpService.getAvailableTools();
              }
            } else {
              mcpTools = await this.mcpService.getAvailableTools();
            }
          }
          const { PromptBuilder: PromptBuilder2 } = await Promise.resolve().then(() => (init_PromptBuilder(), PromptBuilder_exports));
          const finalSystemPrompt = await PromptBuilder2.buildSystemPrompt(
            this.plugin.app,
            () => this.plugin.settings,
            { type: systemPromptType || "general-use", path: systemPromptPath, agentMode: !!agentMode, hasTools: mcpTools.length > 0 }
          );
          const preparedMessages = await this.contextFileService.prepareMessagesWithContext(
            messages,
            contextFiles || /* @__PURE__ */ new Set(),
            systemPromptType,
            systemPromptPath,
            agentMode,
            toolCallManager,
            finalSystemPrompt
          );
          try {
            const debugMode = ((_a = this.plugin.settings) == null ? void 0 : _a.debugMode) || false;
            if (debugMode) {
              const sysMsg = preparedMessages.find((m) => m.role === "system");
              const content = typeof (sysMsg == null ? void 0 : sysMsg.content) === "string" ? sysMsg.content : "";
              const preview = content.slice(0, 600);
              errorLogger.debug("Prepared system prompt for request", {
                source: "SystemSculptService",
                method: "streamMessage",
                metadata: {
                  hasSystemMessage: !!sysMsg,
                  systemLength: content.length,
                  agentMode: !!agentMode,
                  systemPromptType: systemPromptType || "undefined",
                  systemPromptPath: systemPromptPath || void 0,
                  preview,
                  systemPrompt: content
                }
              });
            }
          } catch (e) {
          }
          const { isCustom, provider, actualModelId, upstreamModelId } = await this.modelManagementService.getModelInfo(model);
          const serverModelId = this.normalizeServerModelId(actualModelId);
          let compatibleTools = [];
          let attemptedWithoutTools = false;
          if (mcpTools.length > 0) {
            let modelToCheck;
            try {
              const allModels = await this.plugin.modelService.getModels();
              modelToCheck = allModels.find((m) => m.id === model || m.id === actualModelId);
            } catch (error) {
            }
            if (modelToCheck) {
              const compatibility = getToolCompatibilityInfo(modelToCheck);
              compatibleTools = mcpTools;
              if (!compatibility.isCompatible && compatibility.confidence === "high") {
              }
            } else {
              compatibleTools = mcpTools;
            }
          }
          const sanitizedTools = ToolSchemaSanitizer.sanitizeDefinitions(compatibleTools);
          const hasImageParts = (msgs) => {
            for (const m of msgs) {
              if (Array.isArray(m.content)) {
                for (const part of m.content) {
                  if (part && (part.type === "image_url" || part.type === "image")) return true;
                }
              }
            }
            return false;
          };
          const stripImagesFromMessages = (msgs) => {
            const result = [];
            for (const m of msgs) {
              if (Array.isArray(m.content)) {
                const textParts = m.content.filter((p) => p && p.type === "text" && typeof p.text === "string");
                if (textParts.length > 0) {
                  result.push({ ...m, content: textParts });
                } else {
                  result.push({ ...m, content: "[image attached]" });
                }
              } else {
                result.push(m);
              }
            }
            return result;
          };
          let messagesForRequest = preparedMessages;
          let notedImageUnsupported = false;
          let response;
          if (isCustom && provider) {
            try {
              response = await this.handleCustomProviderCompletion(
                provider,
                messagesForRequest,
                actualModelId,
                sanitizedTools,
                signal,
                plugins,
                web_search_options
              );
            } catch (err) {
              const shouldRetryWithoutTools = !!((_b = err == null ? void 0 : err.metadata) == null ? void 0 : _b.shouldResubmitWithoutTools);
              const shouldRetryWithoutImages = !!((_c = err == null ? void 0 : err.metadata) == null ? void 0 : _c.shouldResubmitWithoutImages);
              if (!attemptedWithoutTools && shouldRetryWithoutTools && sanitizedTools.length > 0) {
                attemptedWithoutTools = true;
                try {
                  yield { type: "footnote", text: "This model does not support tool calling. The answer is generated without tools. Consider a tool-capable model for better results." };
                } catch (e) {
                }
                const { PromptBuilder: PromptBuilder3 } = await Promise.resolve().then(() => (init_PromptBuilder(), PromptBuilder_exports));
                const retrySystemPrompt = await PromptBuilder3.buildSystemPrompt(
                  this.plugin.app,
                  () => this.plugin.settings,
                  { type: systemPromptType || "general-use", path: systemPromptPath, agentMode: false, hasTools: false }
                );
                let retriedMessages = await this.contextFileService.prepareMessagesWithContext(
                  messages,
                  contextFiles || /* @__PURE__ */ new Set(),
                  systemPromptType,
                  systemPromptPath,
                  false,
                  void 0,
                  retrySystemPrompt
                );
                try {
                  if (!notedImageUnsupported && hasImageParts(retriedMessages)) {
                    let modelToCheck;
                    try {
                      const allModels = await this.plugin.modelService.getModels();
                      modelToCheck = allModels.find((m) => m.id === model || m.id === actualModelId);
                    } catch (e) {
                    }
                    const imagesOk = modelToCheck ? supportsImages(modelToCheck) : false;
                    if (!imagesOk) {
                      try {
                        yield { type: "footnote", text: "This model does not support images. The image was not sent and remains attached in the chat context." };
                      } catch (e) {
                      }
                      retriedMessages = stripImagesFromMessages(retriedMessages);
                    }
                  }
                } catch (e) {
                }
                response = await this.handleCustomProviderCompletion(
                  provider,
                  retriedMessages,
                  actualModelId,
                  [],
                  signal,
                  plugins,
                  web_search_options
                );
              } else if (shouldRetryWithoutImages) {
                try {
                  yield { type: "footnote", text: "This model does not support images. The image was not sent and remains attached in the chat context." };
                } catch (e) {
                }
                const retriedMessages = stripImagesFromMessages(messagesForRequest);
                response = await this.handleCustomProviderCompletion(
                  provider,
                  retriedMessages,
                  actualModelId,
                  sanitizedTools,
                  signal,
                  plugins,
                  web_search_options
                );
              } else {
                throw err;
              }
            }
          } else {
            const { SYSTEMSCULPT_API_ENDPOINTS: SYSTEMSCULPT_API_ENDPOINTS2 } = await Promise.resolve().then(() => (init_api(), api_exports));
            const chatEndpoint = `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS2.CHAT.COMPLETIONS}`;
            const transportOptions = { endpoint: chatEndpoint };
            const canStream = platform.supportsStreaming(transportOptions);
            const preferredTransport = platform.preferredTransport(transportOptions);
            const requestBody = {
              model: serverModelId,
              messages: messagesForRequest,
              stream: canStream,
              include_reasoning: true
            };
            if (plugins && plugins.length > 0) {
              requestBody.plugins = plugins;
            }
            if (web_search_options) {
              requestBody.web_search_options = web_search_options;
            }
            requestBody.provider = {
              allow_fallbacks: true,
              // Enable fallbacks when providers are unavailable
              sort: "latency"
              // Prioritize low latency for agent interactions
            };
            if (sanitizedTools.length > 0) {
              const validTools = normalizeOpenAITools(sanitizedTools);
              if (validTools.length > 0) {
                requestBody.tools = validTools;
                requestBody.tool_choice = "auto";
              }
            }
            const logger2 = DebugLogger.getInstance();
            logger2 == null ? void 0 : logger2.logAPIRequest(chatEndpoint, "POST", requestBody);
            const requestHeaders = {
              "Content-Type": "application/json",
              "X-Request-ID": this.streamingService.generateRequestId(),
              "x-license-key": this.settings.licenseKey
            };
            if (canStream) {
              requestHeaders.Accept = "text/event-stream";
              requestHeaders["Cache-Control"] = "no-cache";
            }
            if (preferredTransport === "requestUrl") {
              try {
                const transportResponse = await (0, import_obsidian22.requestUrl)({
                  url: chatEndpoint,
                  method: "POST",
                  headers: requestHeaders,
                  body: JSON.stringify(requestBody),
                  throw: false
                });
                if (!transportResponse.status || transportResponse.status >= 400) {
                  response = new Response(JSON.stringify(transportResponse.json || {}), {
                    status: transportResponse.status || 500,
                    statusText: "Error"
                  });
                } else {
                  const responseData = transportResponse.json;
                  const { createSSEStreamFromChatCompletionJSON: createSSEStreamFromChatCompletionJSON2 } = await Promise.resolve().then(() => (init_streaming(), streaming_exports));
                  const wrappedStream = createSSEStreamFromChatCompletionJSON2(responseData);
                  response = new Response(wrappedStream, {
                    status: 200,
                    statusText: "OK",
                    headers: {
                      "Content-Type": "text/event-stream"
                    }
                  });
                }
              } catch (requestError) {
                const rawReason = typeof (requestError == null ? void 0 : requestError.message) === "string" ? requestError.message : (_e = (_d = requestError == null ? void 0 : requestError.toString) == null ? void 0 : _d.call(requestError)) != null ? _e : "Unknown transport error";
                const reason = rawReason.trim().slice(0, 200);
                const fallbackMessageBase = platform.isMobile() ? "Network request failed on mobile" : "Network request failed while using the fallback transport";
                const guidance = platform.isMobile() ? "Ensure your server URL uses HTTPS and the certificate is trusted on this device." : "Ensure the endpoint is reachable and not blocked by network policy.";
                const fallbackMessage = `${fallbackMessageBase}${reason ? ` (${reason})` : ""}. ${guidance}`;
                throw new SystemSculptError(
                  fallbackMessage,
                  ERROR_CODES.STREAM_ERROR,
                  0,
                  {
                    transport: "requestUrl",
                    endpoint: chatEndpoint,
                    reason: reason || void 0
                  }
                );
              }
            } else {
              try {
                const fetchOptions = {
                  method: "POST",
                  headers: requestHeaders,
                  body: JSON.stringify(requestBody),
                  signal,
                  mode: "cors",
                  credentials: "omit"
                };
                response = await fetch(chatEndpoint, fetchOptions);
              } catch (fetchError) {
                const errorDetails = {
                  message: fetchError.message || "Unknown fetch error",
                  name: fetchError.name || "FetchError",
                  isMobile: platform.isMobile(),
                  endpoint: chatEndpoint,
                  baseUrl: this.baseUrl,
                  isOnline: navigator.onLine
                };
                const rawReason = typeof (fetchError == null ? void 0 : fetchError.message) === "string" ? fetchError.message : (_g = (_f = fetchError == null ? void 0 : fetchError.toString) == null ? void 0 : _f.call(fetchError)) != null ? _g : "Unknown fetch error";
                const reason = rawReason.trim().slice(0, 200);
                if (errorDetails.isMobile) {
                  const base = fetchError.message === "Load failed" ? "Network request failed on mobile" : "Network request failed while using fetch on mobile";
                  const fallbackMessage = `${base}${reason ? ` (${reason})` : ""}. This may be caused by network restrictions, captive Wi-Fi, or an untrusted certificate. Please verify the server URL is reachable over HTTPS from this device.`;
                  throw new SystemSculptError(
                    fallbackMessage,
                    ERROR_CODES.STREAM_ERROR,
                    0,
                    {
                      transport: "fetch",
                      endpoint: chatEndpoint,
                      reason: reason || void 0,
                      isOnline: navigator.onLine
                    }
                  );
                }
                throw fetchError;
              }
            }
          }
          const logger = DebugLogger.getInstance();
          const endpoint = isCustom && provider ? provider.endpoint : `${this.baseUrl}${(init_api(), __toCommonJS(api_exports)).SYSTEMSCULPT_API_ENDPOINTS.CHAT.COMPLETIONS}`;
          logger == null ? void 0 : logger.logAPIResponse(endpoint, response.status);
          if (!response.ok) {
            logger == null ? void 0 : logger.logAPIResponse(endpoint, response.status, null, { message: `HTTP ${response.status}` });
            try {
              await StreamingErrorHandler.handleStreamError(response, !!provider);
            } catch (err) {
              const shouldRetryWithoutTools = !!((_h = err == null ? void 0 : err.metadata) == null ? void 0 : _h.shouldResubmitWithoutTools);
              const shouldRetryWithoutImages = !!((_i = err == null ? void 0 : err.metadata) == null ? void 0 : _i.shouldResubmitWithoutImages);
              if (!attemptedWithoutTools && shouldRetryWithoutTools && sanitizedTools.length > 0) {
                attemptedWithoutTools = true;
                try {
                  yield { type: "footnote", text: "This model does not support tool calling. The answer is generated without tools. Consider a tool-capable model for better results." };
                } catch (e) {
                }
                let retriedMessages = await this.contextFileService.prepareMessagesWithContext(
                  messages,
                  contextFiles || /* @__PURE__ */ new Set(),
                  systemPromptType,
                  systemPromptPath,
                  false,
                  void 0
                );
                try {
                  if (!notedImageUnsupported && hasImageParts(retriedMessages)) {
                    let modelToCheck;
                    try {
                      const allModels = await this.plugin.modelService.getModels();
                      modelToCheck = allModels.find((m) => m.id === model || m.id === actualModelId);
                    } catch (e) {
                    }
                    const imagesOk = modelToCheck ? supportsImages(modelToCheck) : false;
                    if (!imagesOk) {
                      try {
                        yield { type: "footnote", text: "This model does not support images. The image was not sent and remains attached in the chat context." };
                      } catch (e) {
                      }
                      retriedMessages = stripImagesFromMessages(retriedMessages);
                    }
                  }
                } catch (e) {
                }
                const retryBody = {
                  model: actualModelId,
                  messages: retriedMessages,
                  stream: true,
                  include_reasoning: true,
                  provider: { allow_fallbacks: true, sort: "latency" }
                };
                if (plugins && plugins.length > 0) retryBody.plugins = plugins;
                if (web_search_options) retryBody.web_search_options = web_search_options;
                const { SYSTEMSCULPT_API_ENDPOINTS: SYSTEMSCULPT_API_ENDPOINTS2 } = await Promise.resolve().then(() => (init_api(), api_exports));
                const retryEndpoint = `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS2.CHAT.COMPLETIONS}`;
                const retryTransportOptions = { endpoint: retryEndpoint };
                const retryCanStream = platform.supportsStreaming(retryTransportOptions);
                const retryTransport = platform.preferredTransport(retryTransportOptions);
                retryBody.stream = retryCanStream;
                const retryHeaders = {
                  "Content-Type": "application/json",
                  "X-Request-ID": this.streamingService.generateRequestId(),
                  "x-license-key": this.settings.licenseKey
                };
                if (retryCanStream) {
                  retryHeaders.Accept = "text/event-stream";
                  retryHeaders["Cache-Control"] = "no-cache";
                }
                if (retryTransport === "requestUrl") {
                  try {
                    const fallbackResponse = await (0, import_obsidian22.requestUrl)({
                      url: retryEndpoint,
                      method: "POST",
                      headers: retryHeaders,
                      body: JSON.stringify({ ...retryBody, stream: false }),
                      throw: false
                    });
                    if (!fallbackResponse.status || fallbackResponse.status >= 400) {
                      response = new Response(JSON.stringify(fallbackResponse.json || {}), {
                        status: fallbackResponse.status || 500,
                        statusText: "Error"
                      });
                    } else {
                      const responseData = fallbackResponse.json;
                      const { createSSEStreamFromChatCompletionJSON: createSSEStreamFromChatCompletionJSON2 } = await Promise.resolve().then(() => (init_streaming(), streaming_exports));
                      const mockStream = createSSEStreamFromChatCompletionJSON2(responseData);
                      response = new Response(mockStream, {
                        status: 200,
                        statusText: "OK",
                        headers: { "Content-Type": "text/event-stream" }
                      });
                    }
                  } catch (mobileErr) {
                    throw err;
                  }
                } else {
                  const fetchOptions = {
                    method: "POST",
                    headers: retryHeaders,
                    body: JSON.stringify(retryBody),
                    signal,
                    mode: "cors",
                    credentials: "omit"
                  };
                  response = await fetch(retryEndpoint, fetchOptions);
                }
                if (!response.ok) {
                  await StreamingErrorHandler.handleStreamError(response, !!provider);
                }
              } else if (shouldRetryWithoutImages) {
                try {
                  yield { type: "footnote", text: "This model does not support images. The image was not sent and remains attached in the chat context." };
                } catch (e) {
                }
                const retryBody = {
                  model: actualModelId,
                  messages: stripImagesFromMessages(messagesForRequest),
                  stream: true,
                  include_reasoning: true,
                  provider: { allow_fallbacks: true, sort: "latency" }
                };
                if (plugins && plugins.length > 0) retryBody.plugins = plugins;
                if (web_search_options) retryBody.web_search_options = web_search_options;
                const { SYSTEMSCULPT_API_ENDPOINTS: SYSTEMSCULPT_API_ENDPOINTS2 } = await Promise.resolve().then(() => (init_api(), api_exports));
                const retryEndpoint = `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS2.CHAT.COMPLETIONS}`;
                const retryTransportOptions = { endpoint: retryEndpoint };
                const retryCanStream = platform.supportsStreaming(retryTransportOptions);
                const retryTransport = platform.preferredTransport(retryTransportOptions);
                retryBody.stream = retryCanStream;
                const retryHeaders = {
                  "Content-Type": "application/json",
                  "X-Request-ID": this.streamingService.generateRequestId(),
                  "x-license-key": this.settings.licenseKey
                };
                if (retryCanStream) {
                  retryHeaders.Accept = "text/event-stream";
                  retryHeaders["Cache-Control"] = "no-cache";
                }
                if (retryTransport === "requestUrl") {
                  try {
                    const fallbackResponse = await (0, import_obsidian22.requestUrl)({
                      url: retryEndpoint,
                      method: "POST",
                      headers: retryHeaders,
                      body: JSON.stringify({ ...retryBody, stream: false }),
                      throw: false
                    });
                    if (!fallbackResponse.status || fallbackResponse.status >= 400) {
                      response = new Response(JSON.stringify(fallbackResponse.json || {}), { status: fallbackResponse.status || 500, statusText: "Error" });
                    } else {
                      const responseData = fallbackResponse.json;
                      const { createSSEStreamFromChatCompletionJSON: createSSEStreamFromChatCompletionJSON2 } = await Promise.resolve().then(() => (init_streaming(), streaming_exports));
                      const mockStream = createSSEStreamFromChatCompletionJSON2(responseData);
                      response = new Response(mockStream, { status: 200, statusText: "OK", headers: { "Content-Type": "text/event-stream" } });
                    }
                  } catch (mobileErr) {
                    throw err;
                  }
                } else {
                  const fetchOptions = { method: "POST", headers: retryHeaders, body: JSON.stringify(retryBody), signal, mode: "cors", credentials: "omit" };
                  response = await fetch(retryEndpoint, fetchOptions);
                }
                if (!response.ok) {
                  await StreamingErrorHandler.handleStreamError(response, !!provider);
                }
              } else {
                throw err;
              }
            }
          }
          if (!response.body) {
            throw new SystemSculptError(
              "Missing response body from streaming API",
              ERROR_CODES.STREAM_ERROR,
              response.status
            );
          }
          try {
            errorLogger.debug("Streaming response received", {
              source: "SystemSculptService",
              method: "streamMessage",
              metadata: {
                status: response.status,
                contentType: response.headers.get("content-type") || "unknown",
                hasBody: !!response.body
              }
            });
          } catch (e) {
          }
          const streamIterator = this.streamingService.streamResponse(response, {
            model: actualModelId,
            isCustomProvider: !!provider,
            signal
          });
          for await (const event of streamIterator) {
            yield event;
          }
        } catch (error) {
          if (error instanceof DOMException && error.name === "AbortError") {
            return;
          }
          try {
            errorLogger.error("Stream error in streamMessage", error, {
              source: "SystemSculptService",
              method: "streamMessage",
              metadata: { model }
            });
          } catch (e) {
          }
          if (onError) {
            let errorMessage = error instanceof Error ? error.message : "An unknown error occurred";
            if (error instanceof SystemSculptError && error.code === ERROR_CODES.STREAM_ERROR && error.statusCode === 400) {
              errorMessage += "\nPlease try again in a few moments. If the issue persists, try selecting a different model.";
            }
            onError(errorMessage);
          }
          throw error;
        }
      }
      /**
       * Build a faithful preview of the next chat request body without sending it
       */
      async buildRequestPreview({
        messages,
        model,
        contextFiles,
        systemPromptType,
        systemPromptPath,
        agentMode,
        toolCallManager,
        plugins,
        web_search_options
      }) {
        this.refreshSettings();
        let mcpTools = [];
        if (agentMode) {
          if (toolCallManager && typeof toolCallManager.getOpenAITools === "function") {
            try {
              mcpTools = await toolCallManager.getOpenAITools();
            } catch (e) {
              mcpTools = await this.mcpService.getAvailableTools();
            }
          } else {
            mcpTools = await this.mcpService.getAvailableTools();
          }
        }
        const { PromptBuilder: PromptBuilder2 } = await Promise.resolve().then(() => (init_PromptBuilder(), PromptBuilder_exports));
        const finalSystemPrompt = await PromptBuilder2.buildSystemPrompt(
          this.plugin.app,
          () => this.plugin.settings,
          { type: systemPromptType || "general-use", path: systemPromptPath, agentMode: !!agentMode, hasTools: mcpTools.length > 0 }
        );
        const preparedMessages = await this.contextFileService.prepareMessagesWithContext(
          messages,
          contextFiles || /* @__PURE__ */ new Set(),
          systemPromptType,
          systemPromptPath,
          agentMode,
          toolCallManager,
          finalSystemPrompt
        );
        const { actualModelId } = await this.modelManagementService.getModelInfo(model);
        const serverModelId = this.normalizeServerModelId(actualModelId);
        let compatibleTools = [];
        if (mcpTools.length > 0) compatibleTools = mcpTools;
        const sanitizedTools = ToolSchemaSanitizer.sanitizeDefinitions(compatibleTools);
        const requestBody = {
          model: serverModelId,
          messages: preparedMessages,
          stream: true,
          include_reasoning: true,
          provider: { allow_fallbacks: true, sort: "latency" }
        };
        if (plugins && plugins.length > 0) {
          requestBody.plugins = plugins;
        }
        if (web_search_options) {
          requestBody.web_search_options = web_search_options;
        }
        if (sanitizedTools.length > 0) {
          const validTools = normalizeOpenAITools(sanitizedTools);
          if (validTools.length > 0) {
            requestBody.tools = validTools;
            requestBody.tool_choice = "auto";
          }
        }
        return { requestBody, preparedMessages, actualModelId: serverModelId };
      }
      async getApiStatus() {
        this.refreshSettings();
        const endpoint = `${this.baseUrl}/status`;
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({
            url: endpoint,
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              ...this.settings.licenseKey && { "x-license-key": this.settings.licenseKey }
            }
          });
          if (!response.status || response.status >= 400) {
            return { status: "error", message: `API request failed with status ${response.status}` };
          }
          const data = response.json || (response.text ? JSON.parse(response.text) : {});
          return data;
        } catch (error) {
          return { status: "error", message: "Failed to connect to SystemSculpt API. Please check your network connection and server URL." };
        }
      }
    };
    _SystemSculptService.instance = null;
    SystemSculptService = _SystemSculptService;
  }
});

// src/constants/externalServices.ts
function getExternalUrl(productionUrl, developmentUrl) {
  return DEVELOPMENT_MODE === "DEVELOPMENT" && developmentUrl ? developmentUrl : productionUrl;
}
var GITHUB_API, AI_PROVIDERS, LOCAL_SERVICES, SYSTEMSCULPT_WEBSITE, SERVICE_HEADERS;
var init_externalServices = __esm({
  "src/constants/externalServices.ts"() {
    init_api();
    GITHUB_API = {
      BASE_URL: getExternalUrl(
        "https://api.github.com",
        "https://api.github.com"
        // GitHub API doesn't have a dev alternative
      ),
      RELEASES: (owner, repo) => `${GITHUB_API.BASE_URL}/repos/${owner}/${repo}/releases`,
      RELEASE_URL: (owner, repo) => `https://github.com/${owner}/${repo}/releases`
    };
    AI_PROVIDERS = {
      OPENAI: {
        BASE_URL: getExternalUrl("https://api.openai.com/v1"),
        AUDIO_TRANSCRIPTIONS: getExternalUrl("https://api.openai.com/v1/audio/transcriptions")
      },
      ANTHROPIC: {
        BASE_URL: getExternalUrl("https://api.anthropic.com/v1"),
        LEGACY_BASE: getExternalUrl("https://api.anthropic.com")
        // For older integrations
      },
      OPENROUTER: {
        BASE_URL: getExternalUrl("https://openrouter.ai/api/v1"),
        CHAT_COMPLETIONS: getExternalUrl("https://openrouter.ai/api/v1/chat/completions"),
        MODELS: getExternalUrl("https://openrouter.ai/api/v1/models")
      },
      GROQ: {
        BASE_URL: getExternalUrl("https://api.groq.com/openai/v1"),
        AUDIO_TRANSCRIPTIONS: getExternalUrl("https://api.groq.com/openai/v1/audio/transcriptions")
      }
    };
    LOCAL_SERVICES = {
      OLLAMA: {
        BASE_URL: "http://localhost:11434/v1"
      },
      LM_STUDIO: {
        BASE_URL: "http://localhost:1234/v1"
      },
      LOCAL_AI: {
        CHAT_COMPLETIONS: "http://localhost:8000/v1/chat/completions",
        MODELS: "http://localhost:8000/v1/models"
      },
      LOCAL_WHISPER: {
        AUDIO_TRANSCRIPTIONS: "http://localhost:9000/v1/audio/transcriptions"
      }
    };
    SYSTEMSCULPT_WEBSITE = {
      BASE_URL: getExternalUrl("https://systemsculpt.com", "http://localhost:3000"),
      // Website development server
      CREDITS: getExternalUrl("https://systemsculpt.com/credits", "http://localhost:3000/credits"),
      LIFETIME: getExternalUrl("https://systemsculpt.com/lifetime", "http://localhost:3000/lifetime"),
      MONTHLY: getExternalUrl("https://systemsculpt.com/resources/a05a7abf-b8bb-41cf-9190-8b795d117fda", "http://localhost:3000/resources/a05a7abf-b8bb-41cf-9190-8b795d117fda"),
      DOCS: getExternalUrl("https://systemsculpt.com/docs", "http://localhost:3000/docs"),
      SUPPORT: getExternalUrl("https://systemsculpt.com/contact", "http://localhost:3000/contact"),
      LICENSE: getExternalUrl("https://systemsculpt.com/resources?tab=license", "http://localhost:3000/resources?tab=license"),
      FEEDBACK: getExternalUrl(
        "https://github.com/SystemSculpt/obsidian-systemsculpt-ai/issues/new?title=SystemSculpt%20Feedback%3A%20&body=Please%20describe%20your%20feedback%3A%0A%0A-%20What%20happened%20or%20what%20would%20you%20like%20to%20see%20improved%3F%0A-%20Steps%20to%20reproduce%20%28if%20a%20bug%29%3A%0A-%20Expected%20behavior%3A%0A-%20Screenshots%20or%20logs%3A%0A%0AEnvironment%3A%0A-%20Obsidian%20version%3A%0A-%20OS%3A%0A-%20SystemSculpt%20AI%20version%3A%0A%0AAdditional%20context%3A",
        "https://github.com/SystemSculpt/obsidian-systemsculpt-ai/issues/new?title=SystemSculpt%20Feedback%3A%20&body=Please%20describe%20your%20feedback%3A%0A%0A-%20What%20happened%20or%20what%20would%20you%20like%20to%20see%20improved%3F%0A-%20Steps%20to%20reproduce%20%28if%20a%20bug%29%3A%0A-%20Expected%20behavior%3A%0A-%20Screenshots%20or%20logs%3A%0A%0AEnvironment%3A%0A-%20Obsidian%20version%3A%0A-%20OS%3A%0A-%20SystemSculpt%20AI%20version%3A%0A%0AAdditional%20context%3A"
      )
    };
    SERVICE_HEADERS = {
      OPENROUTER: {
        "HTTP-Referer": SYSTEMSCULPT_WEBSITE.BASE_URL,
        "X-Title": "SystemSculpt AI"
      }
    };
  }
});

// src/services/providers/LocalLLMScanner.ts
var LocalLLMScanner_exports = {};
__export(LocalLLMScanner_exports, {
  scanLocalLLMProviders: () => scanLocalLLMProviders
});
async function tryParseJson(text) {
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch (e) {
    return null;
  }
}
async function scanLMStudio() {
  var _a;
  const base = "http://localhost:1234";
  const modelsUrl = `${base}/v1/models`;
  try {
    const disabled = isHostTemporarilyDisabled(modelsUrl);
    if (disabled.disabled) return [];
    const resp = await httpRequest({ url: modelsUrl, method: "GET", headers: { "Content-Type": "application/json" } });
    if (!resp || resp.status !== 200) return [];
    const data = (_a = resp.json) != null ? _a : await tryParseJson(resp.text);
    const list = Array.isArray(data == null ? void 0 : data.data) ? data.data.map((m) => m.id).filter((id) => typeof id === "string") : [];
    if (list.length === 0) return [];
    return [{
      type: "lmstudio",
      endpoint: `${base}/v1`,
      models: list,
      label: `LM Studio \u2022 ${list.length} model${list.length === 1 ? "" : "s"}`
    }];
  } catch (e) {
    return [];
  }
}
async function scanOllama() {
  var _a, _b;
  const base = "http://localhost:11434";
  const modelsUrl = `${base}/v1/models`;
  const tagsFallbackUrl = `${base}/api/tags`;
  try {
    const disabledA = isHostTemporarilyDisabled(modelsUrl);
    const disabledB = isHostTemporarilyDisabled(tagsFallbackUrl);
    if (disabledA.disabled && disabledB.disabled) return [];
    let list = [];
    try {
      if (!disabledA.disabled) {
        const resp = await httpRequest({ url: modelsUrl, method: "GET", headers: { "Content-Type": "application/json" } });
        if (resp && resp.status === 200) {
          const data = (_a = resp.json) != null ? _a : await tryParseJson(resp.text);
          list = Array.isArray(data == null ? void 0 : data.data) ? data.data.map((m) => m.id).filter((id) => typeof id === "string") : [];
        }
      }
    } catch (e) {
    }
    if (list.length === 0) {
      try {
        if (!disabledB.disabled) {
          const tags = await httpRequest({ url: tagsFallbackUrl, method: "GET", headers: { "Content-Type": "application/json" } });
          if (tags && tags.status === 200) {
            const data = (_b = tags.json) != null ? _b : await tryParseJson(tags.text);
            list = Array.isArray(data == null ? void 0 : data.models) ? data.models.map((m) => m.name).filter((n) => typeof n === "string") : [];
          }
        }
      } catch (e) {
      }
    }
    if (list.length === 0) return [];
    return [{
      type: "ollama",
      endpoint: `${base}/v1`,
      models: list,
      label: `Ollama \u2022 ${list.length} model${list.length === 1 ? "" : "s"}`
    }];
  } catch (e) {
    return [];
  }
}
async function scanLocalLLMProviders() {
  const [lmstudio, ollama] = await Promise.all([scanLMStudio(), scanOllama()]);
  const seen = /* @__PURE__ */ new Set();
  const out = [];
  for (const item of [...lmstudio, ...ollama]) {
    const key = `${item.type}::${item.endpoint}`;
    if (!seen.has(key)) {
      seen.add(key);
      out.push(item);
    }
  }
  return out;
}
var init_LocalLLMScanner = __esm({
  "src/services/providers/LocalLLMScanner.ts"() {
    init_httpClient();
  }
});

// src/components/FavoriteToggle.ts
var import_obsidian25, FavoriteToggle;
var init_FavoriteToggle = __esm({
  "src/components/FavoriteToggle.ts"() {
    import_obsidian25 = require("obsidian");
    FavoriteToggle = class {
      /**
       * Create a new favorite toggle
       * @param container - Container element to append to
       * @param model - The model to toggle favorite status for
       * @param favoritesService - The favorites service instance
       * @param callback - Optional callback when favorite status changes
       */
      constructor(container, model, favoritesService, callback) {
        this.isAnimating = false;
        this.model = model;
        this.favoritesService = favoritesService;
        this.callback = callback;
        this.element = container.createDiv({
          cls: "systemsculpt-favorite-toggle",
          attr: {
            "aria-label": this.getAriaLabel(),
            "role": "button",
            "tabindex": "0",
            "aria-pressed": this.model.isFavorite === true ? "true" : "false"
          }
        });
        this.updateAppearance();
        this.addEventListeners();
      }
      /**
       * Update the appearance based on favorite status
       */
      updateAppearance() {
        this.element.empty();
        const isFavorite = this.model.isFavorite === true;
        if (isFavorite) {
          this.element.addClass("is-favorite");
          this.element.removeClass("not-favorite");
        } else {
          this.element.addClass("not-favorite");
          this.element.removeClass("is-favorite");
        }
        const iconWrapper = this.element.createDiv({
          cls: "systemsculpt-favorite-icon-wrapper"
        });
        const iconEl = iconWrapper.createSpan({
          cls: "systemsculpt-favorite-icon"
        });
        (0, import_obsidian25.setIcon)(iconEl, "star");
        this.element.setAttribute("aria-label", this.getAriaLabel());
        this.element.setAttribute("aria-pressed", isFavorite ? "true" : "false");
        this.element.setAttribute("data-tooltip", this.getAriaLabel());
        if (!this.element.querySelector(".systemsculpt-favorite-feedback")) {
          const feedbackEl = this.element.createDiv({
            cls: "systemsculpt-favorite-feedback"
          });
        }
      }
      /**
       * Get appropriate aria label based on current state
       */
      getAriaLabel() {
        return this.model.isFavorite === true ? `Remove ${this.model.name} from favorites` : `Add ${this.model.name} to favorites`;
      }
      /**
       * Add event listeners to the button
       */
      addEventListeners() {
        this.element.addEventListener("click", this.handleClick.bind(this));
        this.element.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            this.handleClick(e);
          }
        });
        this.element.addEventListener("focus", () => {
          this.element.addClass("is-focused");
        });
        this.element.addEventListener("blur", () => {
          this.element.removeClass("is-focused");
        });
        this.element.addEventListener("mouseenter", () => {
          this.element.addClass("is-hovered");
        });
        this.element.addEventListener("mouseleave", () => {
          this.element.removeClass("is-hovered");
        });
      }
      /**
       * Play animation when favorite status changes
       */
      playStatusChangeAnimation(newState) {
        if (this.isAnimating) return;
        this.isAnimating = true;
        const feedbackEl = this.element.querySelector(".systemsculpt-favorite-feedback");
        if (!feedbackEl) return;
        if (newState) {
          feedbackEl.addClass("animate-favorite");
        } else {
          feedbackEl.addClass("animate-unfavorite");
        }
        setTimeout(() => {
          feedbackEl.removeClass("animate-favorite");
          feedbackEl.removeClass("animate-unfavorite");
          this.isAnimating = false;
        }, 100);
      }
      /**
       * Handle click/keyboard activation
       */
      handleClick(e) {
        e.preventDefault();
        e.stopPropagation();
        if (this.isAnimating) return;
        this.element.addClass("is-active");
        setTimeout(() => {
          this.element.removeClass("is-active");
        }, 50);
        this.favoritesService.toggleFavorite(this.model).then(() => {
          this.updateAppearance();
          this.playStatusChangeAnimation(this.model.isFavorite === true);
          if (this.callback) {
            this.callback(this.model, this.model.isFavorite === true);
          }
          this.element.dispatchEvent(new CustomEvent("ss-list-item-favorite-toggled", {
            bubbles: true,
            detail: { modelId: this.model.id, isFavorite: this.model.isFavorite === true }
          }));
        }).catch((error) => {
        });
      }
      /**
       * Update the model reference (useful when the component is reused)
       */
      updateModel(model) {
        this.model = model;
        this.updateAppearance();
      }
    };
  }
});

// src/core/ui/modals/standard/ListSelectionModal.ts
var import_obsidian26, ListSelectionModal;
var init_ListSelectionModal = __esm({
  "src/core/ui/modals/standard/ListSelectionModal.ts"() {
    import_obsidian26 = require("obsidian");
    init_StandardModal();
    init_KeyboardNavigationService();
    init_FavoriteToggle();
    init_MobileDetection();
    ListSelectionModal = class extends StandardModal {
      constructor(app, items, options) {
        super(app);
        this.items = [];
        this.filteredItems = [];
        this.selectedIds = /* @__PURE__ */ new Set();
        this.searchInput = null;
        this.listContainer = null;
        this.emptyStateEl = null;
        this.resolvePromise = null;
        this.focusedItemIndex = -1;
        this.itemElements = [];
        this.customSearchHandler = null;
        this.favoritesService = null;
        this.items = items;
        this.filteredItems = [...items];
        this.options = {
          emptyText: "No items found",
          placeholder: "Search...",
          withSearch: true,
          withFilters: false,
          closeOnSelect: !options.multiSelect,
          multiSelect: false,
          size: "medium",
          ...options
        };
        this.favoritesService = options.favoritesService || null;
        this.items.forEach((item) => {
          if (item.selected) {
            this.selectedIds.add(item.id);
          }
        });
        if (this.options.size) {
          this.setSize(this.options.size);
        }
      }
      onOpen() {
        super.onOpen();
        this.addTitle(this.options.title, this.options.description);
        if (this.options.customContent) {
          const customContentEl = this.contentEl.createDiv("ss-modal__custom-content");
          this.options.customContent(customContentEl);
        }
        if (this.options.withSearch) {
          const debouncedSearchHandler = (0, import_obsidian26.debounce)((query) => {
            this.handleSearch(query);
          }, 300, true);
          this.searchInput = this.addSearchBar(
            this.options.placeholder || "Search...",
            debouncedSearchHandler
            // Use the debounced handler
          );
        }
        if (this.options.withFilters && this.options.filters && this.options.filters.length > 0) {
          this.addFilterButtons(
            this.options.filters,
            this.handleFilterToggle.bind(this)
          );
        }
        this.listContainer = this.contentEl.createDiv("ss-modal__list");
        this.emptyStateEl = this.contentEl.createDiv({
          cls: "ss-modal__empty-state",
          text: this.options.emptyText
        });
        this.emptyStateEl.style.display = "none";
        this.renderItems();
        if (this.options.multiSelect) {
          this.addActionButton("Cancel", () => this.close(), false);
          this.addActionButton("Select", this.handleConfirmSelection.bind(this), true);
        }
        if (this.searchInput) {
          setTimeout(() => {
            var _a;
            return (_a = this.searchInput) == null ? void 0 : _a.focus();
          }, 50);
        }
        this.keyboardNavService = new KeyboardNavigationService(this.modalEl, {
          multiSelect: this.options.multiSelect,
          closeOnSelect: this.options.closeOnSelect,
          onSelect: (index) => {
            if (index >= 0 && index < this.itemElements.length) {
              this.itemElements[index].click();
            }
          },
          onToggle: (index) => {
            if (index >= 0 && index < this.itemElements.length) {
              this.itemElements[index].click();
            }
          },
          onConfirm: () => {
            if (this.options.multiSelect) {
              this.handleConfirmSelection();
            }
          },
          onFocus: (index) => {
            this.focusItem(index);
          }
        });
        this.keyboardNavService.setItemCount(this.itemElements.length);
      }
      /**
       * Handle search input changes
       * - If a custom search handler is set, use that
       * - Otherwise, use the default filtering
       */
      handleSearch(query) {
        if (this.customSearchHandler) {
          this.customSearchHandler(query).then((items) => {
            if (!items || !Array.isArray(items)) {
              this.filteredItems = [];
            } else {
              this.filteredItems = items;
            }
            this.renderItems();
            this.keyboardNavService.setItemCount(this.itemElements.length);
            this.keyboardNavService.clearFocus();
          }).catch((error) => {
            this.filteredItems = [];
            this.renderItems();
            if (this.emptyStateEl) {
              this.emptyStateEl.textContent = "Error searching files. Please try again.";
              this.emptyStateEl.style.display = "flex";
            }
            this.keyboardNavService.setItemCount(0);
            this.keyboardNavService.clearFocus();
          });
        } else {
          if (!query) {
            this.filteredItems = [...this.items];
          } else {
            const lowerQuery = query.toLowerCase();
            this.filteredItems = this.items.filter(
              (item) => item.title.toLowerCase().includes(lowerQuery) || item.description && item.description.toLowerCase().includes(lowerQuery)
            );
          }
          this.renderItems();
          this.keyboardNavService.setItemCount(this.itemElements.length);
          this.keyboardNavService.clearFocus();
        }
      }
      /**
       * Handle filter toggle
       */
      handleFilterToggle(filterId, active) {
        this.renderItems();
        this.keyboardNavService.setItemCount(this.itemElements.length);
        this.keyboardNavService.clearFocus();
      }
      /**
       * Focus the item at the given index
       */
      focusItem(index) {
        if (index === -1 || index >= this.itemElements.length) return;
        const item = this.itemElements[index];
        if (!item) return;
        this.itemElements.forEach((el) => {
          if (el) {
            el.classList.remove("ss-focused");
          }
        });
        item.classList.add("ss-focused");
        try {
          item.scrollIntoView({ block: "nearest" });
        } catch (e) {
        }
      }
      /**
       * Handle confirm selection button click (for multi-select mode)
       */
      handleConfirmSelection() {
        const selectedItems = this.items.filter((item) => this.selectedIds.has(item.id));
        if (this.resolvePromise) {
          this.resolvePromise(selectedItems);
        }
        this.close();
      }
      /**
       * Render the filtered items
       */
      renderItems() {
        if (!this.listContainer) return;
        this.listContainer.empty();
        this.itemElements = [];
        if (this.filteredItems.length === 0) {
          if (this.emptyStateEl) {
            this.emptyStateEl.style.display = "flex";
          }
          return;
        }
        if (this.emptyStateEl) {
          this.emptyStateEl.style.display = "none";
        }
        this.removePreviewContainer();
        this.filteredItems.forEach((item, index) => {
          const itemEl = this.createListItem(
            item,
            index
          );
          if (this.selectedIds.has(item.id)) {
            itemEl.classList.add("ss-active");
          }
          itemEl.setAttribute("data-item-id", item.id);
          itemEl.setAttribute("tabindex", "0");
          this.itemElements.push(itemEl);
          this.registerDomEvent(itemEl, "click", (ev) => {
            const target = ev.target;
            if (target && target.closest && target.closest(".systemsculpt-favorite-toggle")) {
              return;
            }
            if (this.options.multiSelect) {
              if (this.selectedIds.has(item.id)) {
                this.selectedIds.delete(item.id);
                itemEl.classList.remove("ss-active");
              } else {
                this.selectedIds.add(item.id);
                itemEl.classList.add("ss-active");
              }
            } else {
              this.selectedIds.clear();
              this.selectedIds.add(item.id);
              if (this.resolvePromise) {
                this.resolvePromise([item]);
              }
              if (this.options.closeOnSelect) {
                this.close();
              } else {
                this.itemElements.forEach((el) => {
                  if (el) {
                    el.classList.remove("ss-active");
                  }
                });
                itemEl.classList.add("ss-active");
              }
            }
          });
          if (this.listContainer) {
            this.listContainer.appendChild(itemEl);
          }
        });
        if (this.listContainer) {
          this.listContainer.dispatchEvent(new CustomEvent("ss-items-rendered"));
        }
        if (this.keyboardNavService) {
          this.keyboardNavService.setItemCount(this.itemElements.length);
        }
      }
      /**
       * Create a list item component specifically for this modal,
       * handling model-specific data and favorite toggles.
       * Renamed from createItem to avoid conflict with base class signature.
       */
      createListItem(itemData, index) {
        const itemEl = document.createElement("div");
        itemEl.className = "ss-modal__item";
        if (itemData._ssModel) {
          itemEl.setAttribute("data-provider", itemData._ssModel.provider);
          if (itemData._ssModel.isFavorite) {
            itemEl.classList.add("has-favorite");
          }
        }
        if (itemData.additionalClasses) {
          itemEl.classList.add(itemData.additionalClasses);
        }
        const { title, description, icon, badge, thumbnail, fileType } = itemData;
        if (icon) {
          const iconEl = itemEl.createDiv("ss-modal__item-icon");
          (0, import_obsidian26.setIcon)(iconEl, icon);
        }
        const content = itemEl.createDiv("ss-modal__item-content");
        content.createDiv({ text: title, cls: "ss-modal__item-title" });
        if (description) {
          content.createDiv({ text: description, cls: "ss-modal__item-description" });
        }
        if (badge) {
          const badgeEl = itemEl.createSpan({ text: badge, cls: "ss-modal__item-badge" });
        }
        if (this.favoritesService && itemData._ssModel) {
          const model = itemData._ssModel;
          const buttonContainer = itemEl.createDiv("systemsculpt-favorite-button-container");
          const favoriteToggle = new FavoriteToggle(
            buttonContainer,
            model,
            this.favoritesService,
            (updatedModel, isFavorite) => {
              if (isFavorite) {
                itemEl.classList.add("has-favorite");
              } else {
                itemEl.classList.remove("has-favorite");
              }
              itemEl.dispatchEvent(new CustomEvent("ss-list-item-favorite-toggled", {
                bubbles: true,
                // Allow event to bubble up
                detail: { modelId: updatedModel.id, isFavorite, index }
              }));
            }
          );
        }
        if (thumbnail && fileType && this.isImageType(fileType)) {
          const thumbnailContainer = itemEl.createDiv("ss-modal__item-thumbnail");
          const img = document.createElement("img");
          img.src = thumbnail;
          img.alt = title;
          img.loading = "lazy";
          thumbnailContainer.appendChild(img);
          const showPreviewHandler = (e) => {
            this.showPreview(thumbnail, title, e);
            e.stopPropagation();
          };
          if (!this.isMobileDevice()) {
            this.registerDomEvent(thumbnailContainer, "mouseenter", showPreviewHandler);
            this.registerDomEvent(thumbnailContainer, "mouseleave", () => this.hidePreview());
            this.registerDomEvent(thumbnailContainer, "click", showPreviewHandler);
          } else {
            this.registerDomEvent(thumbnailContainer, "click", (e) => {
              e.stopPropagation();
              this.toggleExpandedPreview(itemEl, thumbnail, title);
            });
          }
        }
        return itemEl;
      }
      /**
       * Check if file type is an image type
       */
      isImageType(fileType) {
        const imageTypes = ["png", "jpg", "jpeg", "gif", "svg", "webp"];
        return imageTypes.includes(fileType.toLowerCase());
      }
      /**
       * Detect if the device is mobile
       */
      isMobileDevice() {
        return MobileDetection.getInstance().isMobileDevice();
      }
      /**
       * Show preview on hover (for desktop)
       */
      showPreview(imageUrl, title, event) {
        this.removePreviewContainer();
        const previewContainer = document.createElement("div");
        previewContainer.className = "ss-preview-container";
        const titleEl = document.createElement("div");
        titleEl.className = "ss-preview-title";
        titleEl.textContent = title;
        previewContainer.appendChild(titleEl);
        const previewImg = document.createElement("img");
        previewImg.src = imageUrl;
        previewImg.alt = title;
        previewImg.onload = () => {
          const aspectRatio = previewImg.naturalWidth / previewImg.naturalHeight;
          if (aspectRatio > 1.5) {
            previewContainer.style.width = "350px";
            previewContainer.style.height = "auto";
          } else if (aspectRatio < 0.7) {
            previewContainer.style.width = "auto";
            previewContainer.style.height = "350px";
          } else {
            previewContainer.style.width = "300px";
            previewContainer.style.height = "300px";
          }
        };
        previewContainer.appendChild(previewImg);
        document.body.appendChild(previewContainer);
        const offset = 20;
        const containerWidth = 300;
        const containerHeight = 300;
        let left = event.clientX + offset;
        let top = event.clientY + offset;
        if (left + containerWidth > window.innerWidth) {
          left = Math.max(0, window.innerWidth - containerWidth - offset);
        }
        if (top + containerHeight > window.innerHeight) {
          top = Math.max(0, window.innerHeight - containerHeight - offset);
        }
        previewContainer.style.left = `${left}px`;
        previewContainer.style.top = `${top}px`;
      }
      /**
       * Hide preview on mouse leave
       */
      hidePreview() {
        this.removePreviewContainer();
      }
      /**
       * Toggle expanded preview (for mobile)
       */
      toggleExpandedPreview(itemEl, imageUrl, title) {
        if (itemEl.classList.contains("expanded")) {
          itemEl.classList.remove("expanded");
          const previewEl = itemEl.querySelector(".ss-modal__item-preview");
          if (previewEl) {
            previewEl.remove();
          }
        } else {
          itemEl.classList.add("expanded");
          const previewContainer = document.createElement("div");
          previewContainer.className = "ss-modal__item-preview";
          const previewImg = document.createElement("img");
          previewImg.src = imageUrl;
          previewImg.alt = title;
          previewContainer.appendChild(previewImg);
          itemEl.appendChild(previewContainer);
        }
      }
      /**
       * Remove any existing preview container
       */
      removePreviewContainer() {
        const existingPreview = document.querySelector(".ss-preview-container");
        if (existingPreview) {
          existingPreview.remove();
        }
      }
      onClose() {
        this.removePreviewContainer();
        if (this.keyboardNavService) {
          this.keyboardNavService.unload();
        }
        if (this.options.multiSelect && this.resolvePromise) {
          const selectedItems = this.items.filter((item) => this.selectedIds.has(item.id));
          this.resolvePromise(selectedItems);
        }
        super.onClose();
      }
      /**
       * Set a custom search handler function
       */
      setCustomSearchHandler(handler) {
        this.customSearchHandler = handler;
      }
      /**
       * Update the list items and refresh the view
       * @param items New list items to display
       */
      setItems(items) {
        if (!items || !Array.isArray(items)) {
          return;
        }
        this.items = items;
        if (this.searchInput && this.searchInput.value) {
          if (this.customSearchHandler) {
            this.customSearchHandler(this.searchInput.value).then((filteredItems) => {
              if (!filteredItems || !Array.isArray(filteredItems)) {
                this.filteredItems = [];
              } else {
                this.filteredItems = filteredItems;
              }
              this.renderItems();
              if (this.keyboardNavService) {
                this.keyboardNavService.setItemCount(this.itemElements.length);
                this.keyboardNavService.clearFocus();
              }
            }).catch((error) => {
              var _a;
              const query = ((_a = this.searchInput) == null ? void 0 : _a.value.toLowerCase()) || "";
              this.filteredItems = this.items.filter(
                (item) => item.title.toLowerCase().includes(query) || item.description && item.description.toLowerCase().includes(query)
              );
              this.renderItems();
              if (this.keyboardNavService) {
                this.keyboardNavService.setItemCount(this.itemElements.length);
                this.keyboardNavService.clearFocus();
              }
            });
          } else {
            const query = this.searchInput.value.toLowerCase();
            this.filteredItems = this.items.filter(
              (item) => item.title.toLowerCase().includes(query) || item.description && item.description.toLowerCase().includes(query)
            );
            this.renderItems();
            if (this.keyboardNavService) {
              this.keyboardNavService.setItemCount(this.itemElements.length);
              this.keyboardNavService.clearFocus();
            }
          }
        } else {
          this.filteredItems = [...this.items];
          this.renderItems();
          if (this.keyboardNavService) {
            this.keyboardNavService.setItemCount(this.itemElements.length);
            this.keyboardNavService.clearFocus();
          }
        }
      }
      /**
       * Open the modal and return a promise that resolves with the selected items
       */
      openAndGetSelection() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.open();
        });
      }
    };
  }
});

// src/core/ui/modals/standard/index.ts
var init_standard = __esm({
  "src/core/ui/modals/standard/index.ts"() {
    init_StandardModal();
    init_ListSelectionModal();
  }
});

// src/services/SearchService.ts
var SearchService;
var init_SearchService = __esm({
  "src/services/SearchService.ts"() {
    SearchService = class _SearchService {
      constructor() {
        this.DEFAULT_INITIAL_RESULTS_LIMIT = 25;
        this.DEFAULT_MAX_FILTERED_RESULTS = 50;
      }
      /**
       * Get the SearchService instance (singleton)
       */
      static getInstance() {
        if (!_SearchService.instance) {
          _SearchService.instance = new _SearchService();
        }
        return _SearchService.instance;
      }
      search(items, query, getSearchableFields, options) {
        var _a, _b;
        const initialLimit = (_a = options == null ? void 0 : options.initialResultsLimit) != null ? _a : this.DEFAULT_INITIAL_RESULTS_LIMIT;
        const maxFiltered = (_b = options == null ? void 0 : options.maxFilteredResults) != null ? _b : this.DEFAULT_MAX_FILTERED_RESULTS;
        if (!query.trim()) {
          return items.slice(0, initialLimit).map((item) => ({
            item,
            matches: [],
            score: 0
          }));
        }
        const searchTerms = query.toLowerCase().split(/\s+/).filter(Boolean);
        const results = items.map((item) => {
          const fields = getSearchableFields(item);
          const matches = [];
          let totalScore = 0;
          const searchText = fields.map((f) => {
            var _a2;
            return ((_a2 = f.text) == null ? void 0 : _a2.toLowerCase()) || "";
          }).join(" ");
          const allTermsExist = searchTerms.every((term) => searchText.includes(term));
          if (!allTermsExist) {
            return { item, matches: [], score: 0 };
          }
          searchTerms.forEach((term) => {
            var _a2;
            let pos = 0;
            const termMatches = /* @__PURE__ */ new Set();
            while ((pos = searchText.indexOf(term, pos)) !== -1) {
              let currentPos = 0;
              for (const field of fields) {
                const fieldText = ((_a2 = field.text) == null ? void 0 : _a2.toLowerCase()) || "";
                const fieldEnd = currentPos + fieldText.length;
                if (pos >= currentPos && pos < fieldEnd) {
                  const relativePos = pos - currentPos;
                  const quality = this.getMatchQuality(fieldText, term, relativePos);
                  matches.push({
                    field: field.field,
                    text: field.text || "",
                    indices: Array.from({ length: term.length }, (_, i) => relativePos + i),
                    matchQuality: quality
                  });
                  totalScore += field.weight * quality;
                  break;
                }
                currentPos = fieldEnd + 1;
              }
              pos += 1;
            }
          });
          if (searchTerms.length > 1 && matches.length > 0) {
            const positions = matches.flatMap((m) => m.indices[0]);
            const maxDistance = Math.max(...positions) - Math.min(...positions);
            if (maxDistance < 50) {
              totalScore *= 1.5;
            }
          }
          return {
            item,
            matches,
            score: totalScore
          };
        });
        return results.filter((result) => result.score > 0).sort((a, b) => b.score - a.score).slice(0, maxFiltered);
      }
      getMatchQuality(text, term, position) {
        const beforeChar = position > 0 ? text[position - 1] : " ";
        const afterChar = position + term.length < text.length ? text[position + term.length] : " ";
        if ((/\s/.test(beforeChar) || /\W/.test(beforeChar)) && (/\s/.test(afterChar) || /\W/.test(afterChar))) {
          return 1;
        }
        return 0.8;
      }
      highlightText(text, matches = [], searchQuery) {
        if (!matches || matches.length === 0 || !searchQuery) {
          const fragment2 = document.createDocumentFragment();
          fragment2.textContent = text;
          return fragment2;
        }
        const fragment = document.createDocumentFragment();
        const searchTerms = searchQuery.toLowerCase().trim().split(/\s+/).filter(Boolean);
        const regex = new RegExp(`(${searchTerms.map((term) => this.escapeRegExp(term)).join("|")})`, "gi");
        let lastIndex = 0;
        let match;
        while ((match = regex.exec(text)) !== null) {
          if (match.index > lastIndex) {
            fragment.appendChild(document.createTextNode(text.slice(lastIndex, match.index)));
          }
          const span = document.createElement("span");
          span.className = "systemsculpt-search-highlight";
          span.textContent = match[0];
          fragment.appendChild(span);
          lastIndex = match.index + match[0].length;
        }
        if (lastIndex < text.length) {
          fragment.appendChild(document.createTextNode(text.slice(lastIndex)));
        }
        return fragment;
      }
      escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
      }
    };
  }
});

// src/services/FavoritesService.ts
var _FavoritesService, FavoritesService;
var init_FavoritesService = __esm({
  "src/services/FavoritesService.ts"() {
    init_modelUtils();
    _FavoritesService = class _FavoritesService {
      constructor(plugin) {
        this.plugin = plugin;
      }
      /**
       * Get the FavoritesService instance
       */
      static getInstance(plugin) {
        if (!_FavoritesService.instance) {
          _FavoritesService.instance = new _FavoritesService(plugin);
        }
        return _FavoritesService.instance;
      }
      /**
       * Clear the singleton instance to allow proper cleanup
       */
      static clearInstance() {
        _FavoritesService.instance = null;
      }
      /**
       * Add a model to favorites
       */
      async addFavorite(model) {
        if (model.isFavorite === true) {
          return;
        }
        model.isFavorite = true;
        const favorite = {
          provider: model.provider,
          modelId: model.id,
          // Should already be canonical
          addedAt: Date.now()
        };
        const existing = Array.isArray(this.plugin.settings.favoriteModels) ? this.plugin.settings.favoriteModels : [];
        const updatedFavorites = [
          ...existing.filter((f) => ensureCanonicalId(f.modelId) !== ensureCanonicalId(model.id)),
          favorite
        ];
        await this.plugin.getSettingsManager().updateSettings({ favoriteModels: updatedFavorites });
        this.emitFavoritesChanged();
      }
      /**
       * Remove a model from favorites
       */
      async removeFavorite(model) {
        if (model.isFavorite !== true) {
          return;
        }
        model.isFavorite = false;
        const updatedFavorites = (this.plugin.settings.favoriteModels || []).filter(
          (fav) => !(fav.modelId === model.id && fav.provider === model.provider)
        );
        await this.plugin.getSettingsManager().updateSettings({ favoriteModels: updatedFavorites });
        this.emitFavoritesChanged();
      }
      /**
       * Toggle favorite status for a model
       */
      async toggleFavorite(model) {
        if (model.isFavorite === true) {
          await this.removeFavorite(model);
        } else {
          await this.addFavorite(model);
        }
        await this.forceSaveSettings();
      }
      /**
       * Check if a model is a favorite
       */
      isFavorite(model) {
        return model.isFavorite === true;
      }
      /**
       * Get all favorited models
       */
      getFavorites(models) {
        return models.filter((model) => model.isFavorite === true);
      }
      /**
       * Clear all favorites
       */
      async clearAllFavorites(models) {
        models.forEach((model) => {
          model.isFavorite = false;
        });
        await this.plugin.getSettingsManager().updateSettings({ favoriteModels: [] });
        this.emitFavoritesChanged();
      }
      /**
       * Process favorites by marking models as favorites based on settings
       */
      processFavorites(models) {
        const favoriteModels = this.plugin.settings.favoriteModels || [];
        models.forEach((model) => {
          model.isFavorite = false;
        });
        const updatedFavorites = [];
        for (const favorite of favoriteModels) {
          const matchingModel = models.find((m) => {
            var _a;
            const legacyID = `${m.provider}/${(_a = m.identifier) == null ? void 0 : _a.modelId}`;
            const favoriteIDCanonical = ensureCanonicalId(favorite.modelId);
            return (
              // Direct match on ID (already canonical)
              m.id === favorite.modelId || // Match after canonicalization
              m.id === favoriteIDCanonical || // Match with legacy format
              legacyID === favorite.modelId
            );
          });
          if (matchingModel) {
            updatedFavorites.push({
              provider: matchingModel.provider,
              modelId: matchingModel.id,
              addedAt: favorite.addedAt || Date.now()
            });
            matchingModel.isFavorite = true;
          } else {
            const canonicalID = ensureCanonicalId(favorite.modelId, favorite.provider);
            updatedFavorites.push({
              provider: favorite.provider,
              modelId: canonicalID,
              addedAt: favorite.addedAt || Date.now()
            });
          }
        }
        const seen = /* @__PURE__ */ new Set();
        const deduped = updatedFavorites.filter((fav) => {
          const key = ensureCanonicalId(fav.modelId);
          if (seen.has(key)) return false;
          seen.add(key);
          return true;
        });
        this.plugin.getSettingsManager().updateSettings({ favoriteModels: deduped }).catch((_error) => {
        });
      }
      /**
       * Sort models with favorites first
       */
      sortModelsByFavorites(models) {
        const favoritesFirst = this.plugin.settings.favoritesFilterSettings.favoritesFirst;
        const sortOrder = this.plugin.settings.favoritesFilterSettings.modelSortOrder;
        if (!favoritesFirst && sortOrder === "default") {
          return models;
        }
        return [...models].sort((a, b) => {
          if (favoritesFirst) {
            const aIsFav = a.isFavorite === true;
            const bIsFav = b.isFavorite === true;
            if (aIsFav && !bIsFav) return -1;
            if (!aIsFav && bIsFav) return 1;
          }
          if (sortOrder === "alphabetical") {
            const providerCompare = a.provider.localeCompare(b.provider);
            if (providerCompare !== 0) {
              return providerCompare;
            }
            return a.name.localeCompare(b.name);
          } else {
            return 0;
          }
        });
      }
      /**
       * Filter models to show only favorites if the filter is enabled
       */
      filterModelsByFavorites(models) {
        if (!this.plugin.settings.favoritesFilterSettings.showFavoritesOnly) {
          return models;
        }
        return models.filter((model) => model.isFavorite === true);
      }
      /**
       * Toggle showing favorites only
       */
      async toggleShowFavoritesOnly() {
        const currentValue = this.plugin.settings.favoritesFilterSettings.showFavoritesOnly;
        await this.plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...this.plugin.settings.favoritesFilterSettings,
            showFavoritesOnly: !currentValue
          }
        });
        this.emitFavoritesFilterChanged();
        return !currentValue;
      }
      /**
       * Get current filter state
       */
      getShowFavoritesOnly() {
        return this.plugin.settings.favoritesFilterSettings.showFavoritesOnly;
      }
      /**
       * Set favorites first sorting
       */
      async setFavoritesFirst(value) {
        await this.plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...this.plugin.settings.favoritesFilterSettings,
            favoritesFirst: value
          }
        });
        this.emitFavoritesFilterChanged();
      }
      /**
       * Get favorites first setting
       */
      getFavoritesFirst() {
        return this.plugin.settings.favoritesFilterSettings.favoritesFirst;
      }
      /**
       * Emit an event when favorites change
       */
      emitFavoritesChanged() {
        document.dispatchEvent(new CustomEvent("systemsculpt:favorites-changed", {
          detail: {
            favorites: this.plugin.settings.favoriteModels
          }
        }));
      }
      /**
       * Helper to return a Set of canonical favorite IDs for quick checks
       */
      getFavoriteIds() {
        const list = this.plugin.settings.favoriteModels || [];
        return new Set(list.map((f) => ensureCanonicalId(f.modelId)));
      }
      /**
       * Emit an event when favorites filter changes
       */
      emitFavoritesFilterChanged() {
        document.dispatchEvent(new CustomEvent("systemsculpt:favorites-filter-changed", {
          detail: {
            showFavoritesOnly: this.plugin.settings.favoritesFilterSettings.showFavoritesOnly,
            favoritesFirst: this.plugin.settings.favoritesFilterSettings.favoritesFirst
          }
        }));
      }
      /**
       * Force save settings to ensure persistence
       * Uses the SettingsManager to ensure consistent settings handling
       */
      async forceSaveSettings() {
        try {
          await this.plugin.getSettingsManager().saveSettings();
        } catch (error) {
        }
      }
    };
    _FavoritesService.instance = null;
    FavoritesService = _FavoritesService;
  }
});

// src/components/FavoritesFilter.ts
var import_obsidian29, FavoritesFilter;
var init_FavoritesFilter = __esm({
  "src/components/FavoritesFilter.ts"() {
    import_obsidian29 = require("obsidian");
    FavoritesFilter = class {
      /**
       * Create a new favorites filter toggle
       * @param container - Container element to append to
       * @param favoritesService - The favorites service instance
       * @param callback - Optional callback when filter state changes
       */
      constructor(container, favoritesService, callback) {
        this.favoritesService = favoritesService;
        this.callback = callback;
        this.element = container.createDiv({
          cls: "systemsculpt-favorites-filter",
          attr: {
            "aria-label": "Show favorites only",
            "role": "button",
            "tabindex": "0"
          }
        });
        this.iconEl = this.element.createSpan({
          cls: "systemsculpt-favorites-icon"
        });
        (0, import_obsidian29.setIcon)(this.iconEl, "star");
        this.textEl = this.element.createSpan({
          text: "Favorites only",
          cls: "systemsculpt-favorites-label"
        });
        this.updateAppearance();
        this.addEventListeners();
        document.addEventListener("systemsculpt:favorites-filter-changed", () => {
          this.updateAppearance();
        });
      }
      /**
       * Update the appearance based on filter state
       */
      updateAppearance() {
        const showFavoritesOnly = this.favoritesService.getShowFavoritesOnly();
        if (showFavoritesOnly) {
          this.element.addClass("is-active");
          this.textEl.setText("Favorites only");
        } else {
          this.element.removeClass("is-active");
          this.textEl.setText("Show favorites");
        }
        this.element.setAttribute("aria-pressed", showFavoritesOnly ? "true" : "false");
        this.element.setAttribute("aria-label", showFavoritesOnly ? "Click to show all models" : "Click to show favorites only");
        this.element.setAttribute("data-tooltip", showFavoritesOnly ? "Click to show all models" : "Click to show favorites only");
      }
      /**
       * Add event listeners for click and keyboard interaction
       */
      addEventListeners() {
        this.element.addEventListener("click", this.handleClick.bind(this));
        this.element.addEventListener("keydown", (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            this.handleClick(e);
          }
        });
        this.element.addEventListener("focus", () => {
          this.element.addClass("is-focused");
        });
        this.element.addEventListener("blur", () => {
          this.element.removeClass("is-focused");
        });
      }
      /**
       * Handle click/keyboard activation
       */
      handleClick(e) {
        e.preventDefault();
        e.stopPropagation();
        this.element.addClass("is-clicking");
        setTimeout(() => {
          this.element.removeClass("is-clicking");
        }, 200);
        this.favoritesService.toggleShowFavoritesOnly().then((newState) => {
          this.updateAppearance();
          if (this.callback) {
            this.callback(newState);
          }
        }).catch((error) => {
        });
      }
      /**
       * Set the filter state programmatically
       */
      async setFilterState(showFavoritesOnly) {
        if (this.favoritesService.getShowFavoritesOnly() !== showFavoritesOnly) {
          await this.favoritesService.toggleShowFavoritesOnly();
          this.updateAppearance();
        }
      }
    };
  }
});

// src/components/EmptyFavoritesState.ts
var import_obsidian30, EmptyFavoritesState;
var init_EmptyFavoritesState = __esm({
  "src/components/EmptyFavoritesState.ts"() {
    import_obsidian30 = require("obsidian");
    EmptyFavoritesState = class {
      /**
       * Create a new empty favorites state component
       * @param container - Container element to append to
       * @param showingFavoritesOnly - Whether we're currently showing favorites only
       */
      constructor(container, showingFavoritesOnly = false) {
        this.element = container.createDiv({
          cls: "systemsculpt-favorites-empty-state"
        });
        const iconEl = this.element.createSpan();
        (0, import_obsidian30.setIcon)(iconEl, "star");
        const heading = this.element.createEl("h4");
        const message = this.element.createEl("p");
        if (showingFavoritesOnly) {
          heading.setText("No favorite models");
          message.setText("You haven't favorited any models yet. Try turning off the favorites filter and mark some models as favorites.");
        } else {
          heading.setText("Mark models as favorites");
          message.setText("Click the star icon next to any model to add it to your favorites. Favorite models will appear at the top of the list.");
        }
      }
      /**
       * Update the empty state based on filter status
       */
      updateForFilterState(showingFavoritesOnly) {
        const heading = this.element.querySelector("h4");
        const message = this.element.querySelector("p");
        if (!heading || !message) return;
        if (showingFavoritesOnly) {
          heading.setText("No favorite models");
          message.setText("You haven't favorited any models yet. Try turning off the favorites filter and mark some models as favorites.");
        } else {
          heading.setText("Mark models as favorites");
          message.setText("Click the star icon next to any model to add it to your favorites. Favorite models will appear at the top of the list.");
        }
      }
    };
  }
});

// src/modals/ProviderSelectionModal.ts
var import_obsidian31, ProviderSelectionModal;
var init_ProviderSelectionModal = __esm({
  "src/modals/ProviderSelectionModal.ts"() {
    import_obsidian31 = require("obsidian");
    ProviderSelectionModal = class extends import_obsidian31.Modal {
      constructor(options) {
        super(options.app);
        this.providerButtons = /* @__PURE__ */ new Map();
        this.plugin = options.plugin;
        this.onSelect = options.onSelect;
        this.onUpdate = options.onUpdate;
        this.originalSelectedProviders = new Set(options.currentSelectedProviders);
        this.selectedProviders = new Set(options.currentSelectedProviders);
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        this.titleEl.setText("Select Providers");
        contentEl.createEl("p", {
          text: "Choose which AI providers to include in your model list. At least one provider must be selected.",
          cls: "systemsculpt-provider-selection-description"
        });
        const providerContainer = contentEl.createDiv("systemsculpt-provider-selection-list");
        if (this.plugin.settings.enableSystemSculptProvider) {
          this.createProviderToggle("systemsculpt", "SystemSculpt", providerContainer);
        }
        this.plugin.settings.customProviders.filter((provider) => provider.isEnabled).forEach((provider) => {
          this.createProviderToggle(provider.id, provider.name, providerContainer);
        });
      }
      createProviderToggle(providerId, displayName, container) {
        const providerItem = container.createDiv("systemsculpt-provider-toggle-item");
        this.providerButtons.set(providerId, providerItem);
        const iconWrapper = providerItem.createDiv("systemsculpt-provider-toggle-icon");
        const icon = iconWrapper.createSpan();
        if (providerId === "systemsculpt") {
          (0, import_obsidian31.setIcon)(icon, "bot");
        } else {
          (0, import_obsidian31.setIcon)(icon, "server");
        }
        const details = providerItem.createDiv("systemsculpt-provider-toggle-details");
        const name = details.createEl("span", { text: displayName, cls: "systemsculpt-provider-toggle-name" });
        const countText = details.createEl("span", {
          text: "Loading...",
          cls: "systemsculpt-provider-toggle-count"
        });
        this.getProviderModelCount(providerId).then((modelCount) => {
          countText.textContent = `${modelCount} models`;
        });
        const toggleWrapper = providerItem.createDiv("systemsculpt-provider-toggle-control");
        const toggleButton = toggleWrapper.createEl("button", {
          cls: "systemsculpt-provider-toggle-button"
        });
        this.updateToggleState(providerId, toggleButton);
        providerItem.addEventListener("click", () => {
          this.toggleProvider(providerId, toggleButton);
          this.notifyUpdate();
        });
      }
      toggleProvider(providerId, toggleButton) {
        if (this.selectedProviders.has(providerId)) {
          if (this.selectedProviders.size <= 1) {
            return;
          }
          this.selectedProviders.delete(providerId);
        } else {
          this.selectedProviders.add(providerId);
        }
        this.updateToggleState(providerId, toggleButton);
      }
      updateToggleState(providerId, toggleButton) {
        const isSelected = this.selectedProviders.has(providerId);
        if (isSelected) {
          toggleButton.addClass("is-active");
          toggleButton.textContent = "\u2713";
        } else {
          toggleButton.removeClass("is-active");
          toggleButton.textContent = "";
        }
        const parentItem = this.providerButtons.get(providerId);
        if (parentItem) {
          if (isSelected) {
            parentItem.addClass("is-selected");
          } else {
            parentItem.removeClass("is-selected");
          }
        }
      }
      async getProviderModelCount(providerId) {
        try {
          const allModels = await this.plugin.modelService.getModels();
          return allModels.filter((model) => {
            if (providerId === "systemsculpt") {
              return model.provider === "systemsculpt";
            } else {
              const provider = this.plugin.settings.customProviders.find((p) => p.id === providerId);
              return provider && model.provider.toLowerCase() === provider.name.toLowerCase();
            }
          }).length;
        } catch (error) {
          return 0;
        }
      }
      /**
       * Notify parent of selection changes without closing the modal
       */
      notifyUpdate() {
        if (this.selectedProviders.size === 0) {
          if (this.plugin.settings.enableSystemSculptProvider) {
            this.selectedProviders.add("systemsculpt");
            this.updateAllToggleStates();
          } else {
            const firstCustomProvider = this.plugin.settings.customProviders.find((p) => p.isEnabled);
            if (firstCustomProvider) {
              this.selectedProviders.add(firstCustomProvider.id);
              this.updateAllToggleStates();
            }
          }
        }
        const result = {
          selectedProviders: new Set(this.selectedProviders)
        };
        if (this.onUpdate) {
          this.onUpdate(result);
        } else {
          this.onSelect(result);
        }
      }
      /**
       * Apply final selection when modal is closed
       */
      applyFinalSelection() {
        const result = {
          selectedProviders: new Set(this.selectedProviders)
        };
        this.onSelect(result);
      }
      /**
       * Update all toggle button states to match current selections
       */
      updateAllToggleStates() {
        this.providerButtons.forEach((buttonEl, providerId) => {
          const toggleButton = buttonEl.querySelector(".systemsculpt-provider-toggle-button");
          if (toggleButton) {
            this.updateToggleState(providerId, toggleButton);
          }
        });
      }
      onClose() {
        this.applyFinalSelection();
        const { contentEl } = this;
        contentEl.empty();
        this.providerButtons.clear();
      }
    };
  }
});

// src/modals/StandardModelSelectionModal.ts
var StandardModelSelectionModal_exports = {};
__export(StandardModelSelectionModal_exports, {
  StandardModelSelectionModal: () => StandardModelSelectionModal
});
var import_obsidian32, _StandardModelSelectionModal, StandardModelSelectionModal;
var init_StandardModelSelectionModal = __esm({
  "src/modals/StandardModelSelectionModal.ts"() {
    import_obsidian32 = require("obsidian");
    init_standard();
    init_SearchService();
    init_modelUtils();
    init_FavoritesService();
    init_FavoritesFilter();
    init_EmptyFavoritesState();
    init_ProviderSelectionModal();
    _StandardModelSelectionModal = class _StandardModelSelectionModal {
      // Updated constructor to use options object
      constructor(options) {
        this.allModels = [];
        this.filteredModels = [];
        this.selectedProviders = /* @__PURE__ */ new Set(["systemsculpt"]);
        // Default to include systemsculpt
        this.modalInstance = null;
        // Store modal instance reference
        this.listeners = [];
        this.favoritesFilter = null;
        this.emptyState = null;
        // Custom description for the modal
        this.isLoadingModels = true;
        // Track emitter unsubscribers for cleanup
        this.emitterUnsubscribers = [];
        this.app = options.app;
        this.plugin = options.plugin;
        this.selectedModelId = options.currentModelId;
        this.onSelect = options.onSelect;
        this.modalTitle = options.title || "Select AI Model";
        this.modalDescription = options.description || "Choose a model for your conversation";
        this.searchService = SearchService.getInstance();
        this.favoritesService = FavoritesService.getInstance(this.plugin);
        this.initializeSelectedProviders();
        this.plugin.modelService.getModels().then((models) => {
          this.allModels = filterChatModels(models);
          this.favoritesService.processFavorites(this.allModels);
          this.filteredModels = this.applyAllFilters(this.allModels);
        }).catch((error) => {
          this.allModels = [];
          this.filteredModels = [];
        });
      }
      /**
       * Initialize the selected providers set with saved preferences or defaults
       */
      initializeSelectedProviders() {
        this.selectedProviders.clear();
        const savedProviders = this.plugin.settings.selectedModelProviders || [];
        if (savedProviders.length > 0) {
          const availableProviders = this.getAvailableProviders();
          savedProviders.forEach((providerId) => {
            if (availableProviders.includes(providerId)) {
              this.selectedProviders.add(providerId);
            } else {
            }
          });
          if (this.selectedProviders.size === 0) {
            this.useDefaultProviders();
          } else {
          }
        } else {
          this.useDefaultProviders();
        }
      }
      /**
       * Get all available provider IDs
       */
      getAvailableProviders() {
        const availableProviders = [];
        if (this.plugin.settings.enableSystemSculptProvider) {
          availableProviders.push("systemsculpt");
        }
        this.plugin.settings.customProviders.forEach((provider) => {
          if (provider.isEnabled) {
            availableProviders.push(provider.id);
          }
        });
        return availableProviders;
      }
      /**
       * Use default provider selection logic
       */
      useDefaultProviders() {
        if (this.plugin.settings.enableSystemSculptProvider) {
          this.selectedProviders.add("systemsculpt");
        }
        this.plugin.settings.customProviders.forEach((provider) => {
          if (provider.isEnabled) {
            this.selectedProviders.add(provider.id);
          }
        });
      }
      /**
       * Register an event listener and track it for cleanup
       * (Ensure this is only used for listeners we *know* we need to clean up)
       */
      registerListener(element, type, listener) {
        element.addEventListener(type, listener);
        this.listeners.push({ element, type, listener });
      }
      /**
       * Remove all registered event listeners
       */
      removeAllListeners() {
        this.listeners.forEach(({ element, type, listener }) => {
          element.removeEventListener(type, listener);
        });
        this.listeners = [];
        this.removeAllEmitterListeners();
      }
      registerEmitterListener(unsub) {
        this.emitterUnsubscribers.push(unsub);
      }
      removeAllEmitterListeners() {
        this.emitterUnsubscribers.forEach((off) => {
          try {
            off();
          } catch (e) {
          }
        });
        this.emitterUnsubscribers = [];
      }
      /**
       * Filter models based on selected providers
       */
      filterModelsByProviders(models) {
        if (this.selectedProviders.size === 0) {
          return [];
        }
        const nameToId = {};
        const validIds = /* @__PURE__ */ new Set();
        this.plugin.settings.customProviders.forEach((p) => {
          nameToId[p.name.toLowerCase()] = p.id;
          validIds.add(p.id);
        });
        return models.filter((model) => {
          if (model.provider !== "systemsculpt") {
            const raw = (model.provider || "").toLowerCase();
            const directId = raw;
            const mappedId = nameToId[raw];
            const providerId = validIds.has(directId) ? directId : mappedId;
            if (!providerId) return false;
            return this.selectedProviders.has(providerId);
          }
          return this.selectedProviders.has(model.provider);
        });
      }
      /**
       * Apply all filters to models (providers and favorites)
       */
      applyAllFilters(models) {
        let filteredModels = models;
        filteredModels = this.filterModelsByProviders(models);
        filteredModels = this.favoritesService.filterModelsByFavorites(filteredModels);
        const currentModel = models.find((m) => this.isModelSelected(m.id));
        if (currentModel && !filteredModels.some((m) => this.isModelSelected(m.id))) {
          filteredModels.unshift(currentModel);
        }
        filteredModels = this.favoritesService.sortModelsByFavorites(filteredModels);
        this.filteredModels = filteredModels;
        return filteredModels;
      }
      /**
       * Search models based on query
       */
      searchModels(models, query) {
        if (!query || query.trim() === "") {
          return this.convertModelsToListItems(models);
        }
        const results = this.searchService.search(
          models,
          query,
          (model) => this.getSearchableFields(model),
          {
            initialResultsLimit: 25,
            maxFilteredResults: 50
          }
        );
        let filteredResults = results.filter((result) => result.matches.length > 0 && result.score > 0).sort((a, b) => b.score - a.score).map((result) => result.item);
        const currentModel = models.find((m) => this.isModelSelected(m.id));
        if (currentModel && !filteredResults.some((m) => this.isModelSelected(m.id))) {
          filteredResults.unshift(currentModel);
        }
        return this.convertModelsToListItems(filteredResults);
      }
      /**
       * Create filter controls (providers and favorites)
       */
      createFilters(containerEl) {
        const filterBar = containerEl.createDiv("ss-model-filter-bar");
        const providerSection = filterBar.createDiv("ss-model-filter-section");
        const providerButtonContainer = providerSection.createDiv("ss-model-filter-buttons");
        this.createProviderButton(providerButtonContainer);
        const controlsSection = filterBar.createDiv("ss-model-filter-controls");
        const favoritesButton = controlsSection.createDiv("ss-favorites-button");
        this.favoritesFilter = new FavoritesFilter(
          favoritesButton,
          this.favoritesService,
          () => {
            this.updateModelList();
            this.updateFavoritesButtonCount();
            this.updateEmptyState();
          }
        );
        this.updateFavoritesButtonCount();
        const refreshButton = controlsSection.createEl("button", {
          cls: "ss-model-refresh-button"
        });
        const refreshIcon = refreshButton.createSpan();
        (0, import_obsidian32.setIcon)(refreshIcon, "refresh-cw");
        const refreshText = refreshButton.createSpan();
        refreshText.textContent = "Refresh";
        refreshButton.addEventListener("click", async () => {
          refreshIcon.addClass("ss-spin");
          refreshText.textContent = "...";
          try {
            this.allModels = await this.plugin.modelService.refreshModels();
            this.favoritesService.processFavorites(this.allModels);
            this.updateModelList();
            this.updateFavoritesButtonCount();
            this.updateEmptyState();
            new import_obsidian32.Notice("Models refreshed");
          } catch (error) {
            new import_obsidian32.Notice("Failed to refresh models");
          } finally {
            refreshIcon.removeClass("ss-spin");
            refreshText.textContent = "Refresh";
          }
        });
      }
      /**
       * Create the single provider selection button
       */
      createProviderButton(container) {
        const providerButton = container.createDiv("ss-provider-selection-button");
        const iconWrapper = providerButton.createDiv("ss-provider-selection-icon");
        const icon = iconWrapper.createSpan();
        (0, import_obsidian32.setIcon)(icon, "server");
        const textWrapper = providerButton.createDiv("ss-provider-selection-text");
        const label = textWrapper.createSpan("ss-provider-selection-label");
        label.textContent = "Providers";
        const count = textWrapper.createSpan("ss-provider-selection-count");
        this.updateProviderButtonCount(count);
        const arrowWrapper = providerButton.createDiv("ss-provider-selection-arrow");
        const arrow = arrowWrapper.createSpan();
        (0, import_obsidian32.setIcon)(arrow, "chevron-right");
        providerButton.addEventListener("click", () => {
          this.openProviderSelectionModal();
        });
      }
      /**
       * Update the provider button count display
       */
      updateProviderButtonCount(countEl) {
        const selectedCount = this.selectedProviders.size;
        const totalCount = this.getTotalAvailableProviders();
        countEl.textContent = `${selectedCount}/${totalCount}`;
      }
      /**
       * Get total number of available providers
       */
      getTotalAvailableProviders() {
        let count = 0;
        if (this.plugin.settings.enableSystemSculptProvider) {
          count++;
        }
        count += this.plugin.settings.customProviders.filter((p) => p.isEnabled).length;
        return count;
      }
      /**
       * Open the provider selection modal
       */
      openProviderSelectionModal() {
        const modal = new ProviderSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentSelectedProviders: this.selectedProviders,
          onUpdate: async (result) => {
            var _a;
            this.selectedProviders = result.selectedProviders;
            await this.saveProviderPreferences();
            this.updateModelList();
            this.updateEmptyState();
            const countEl = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelector(".ss-provider-selection-count");
            if (countEl && countEl instanceof HTMLElement) {
              this.updateProviderButtonCount(countEl);
            }
          },
          onSelect: async (result) => {
            var _a;
            this.selectedProviders = result.selectedProviders;
            await this.saveProviderPreferences();
            this.updateModelList();
            this.updateEmptyState();
            const countEl = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelector(".ss-provider-selection-count");
            if (countEl && countEl instanceof HTMLElement) {
              this.updateProviderButtonCount(countEl);
            }
          }
        });
        modal.open();
      }
      /**
       * Save the current provider selections to settings
       */
      async saveProviderPreferences() {
        try {
          if (this.selectedProviders.size === 0) {
            this.useDefaultProviders();
          }
          const providersArray = Array.from(this.selectedProviders);
          this.plugin.settings.selectedModelProviders = providersArray;
          await this.plugin.saveSettings();
        } catch (error) {
        }
      }
      /**
       * Handle incremental provider model updates and refresh the UI
       */
      handleProviderModelsUpdate(providerType, models) {
        try {
          const chatModels = filterChatModels(models);
          const keepProvider = (m) => providerType === "systemsculpt" ? m.provider !== "systemsculpt" : m.provider === "systemsculpt";
          this.allModels = [
            ...this.allModels.filter(keepProvider),
            ...chatModels
          ];
          this.favoritesService.processFavorites(this.allModels);
          this.updateModelList();
          this.updateFavoritesButtonCount();
          this.updateEmptyState();
        } catch (e) {
        }
      }
      /**
       * Clean up invalid provider preferences on settings load
       * This should be called when the plugin loads to ensure saved preferences are still valid
       */
      static cleanupProviderPreferences(plugin) {
        try {
          const savedProviders = plugin.settings.selectedModelProviders || [];
          const availableProviders = [];
          if (plugin.settings.enableSystemSculptProvider) {
            availableProviders.push("systemsculpt");
          }
          plugin.settings.customProviders.forEach((provider) => {
            if (provider.isEnabled) {
              availableProviders.push(provider.id);
            }
          });
          const validProviders = savedProviders.filter((providerId) => availableProviders.includes(providerId));
          if (validProviders.length === 0 && savedProviders.length > 0) {
            plugin.settings.selectedModelProviders = [];
            plugin.saveSettings();
            if (plugin.settings.debugMode) {
            }
          } else if (validProviders.length !== savedProviders.length) {
            plugin.settings.selectedModelProviders = validProviders;
            plugin.saveSettings();
            if (plugin.settings.debugMode) {
            }
          }
        } catch (error) {
        }
      }
      /**
       * Update favorites button to show the count
       */
      updateFavoritesButtonCount() {
        var _a;
        if (!this.favoritesFilter) return;
        const favorites = this.filteredModels.filter((m) => m.isFavorite).length;
        const favoritesEl = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelector(".systemsculpt-favorites-filter");
        if (favoritesEl) {
          const existingCount = favoritesEl.querySelector(".ss-favorites-count");
          if (existingCount) {
            existingCount.remove();
          }
          if (favorites > 0) {
            const countSpan = favoritesEl.createSpan("ss-favorites-count");
            countSpan.textContent = favorites.toString();
          }
        }
      }
      /**
       * Update the model list with current filters
       */
      updateModelList() {
        if (!this.modalInstance) {
          return;
        }
        try {
          this.filteredModels = this.applyAllFilters(this.allModels);
          const items = this.convertModelsToListItems(this.filteredModels);
          this.modalInstance.setItems(items);
          this.updateEmptyState();
        } catch (error) {
        }
      }
      /**
       * Show or hide empty state based on current filters
       */
      updateEmptyState() {
        if (!this.modalInstance) return;
        const modalContent = this.modalInstance.contentEl;
        if (this.filteredModels.length === 0) {
          if (!this.emptyState) {
            this.emptyState = new EmptyFavoritesState(
              modalContent,
              this.favoritesService.getShowFavoritesOnly()
            );
          } else {
            this.emptyState.updateForFilterState(
              this.favoritesService.getShowFavoritesOnly()
            );
            modalContent.appendChild(this.emptyState.element);
          }
          const listEl = modalContent.querySelector(".ss-modal__list");
          if (listEl) {
            listEl.addClass("systemsculpt-hidden");
          }
        } else {
          if (this.emptyState && this.emptyState.element.parentNode) {
            this.emptyState.element.detach();
          }
          const listEl = modalContent.querySelector(".ss-modal__list");
          if (listEl) {
            listEl.removeClass("systemsculpt-hidden");
          }
        }
      }
      /**
       * Get searchable fields from a model
       */
      getSearchableFields(model) {
        return [
          { field: "name", text: model.name || "", weight: 2 },
          { field: "description", text: model.description || "", weight: 0.5 },
          { field: "provider", text: model.provider || "", weight: 0.8 },
          { field: "id", text: model.id || "", weight: 0.6 }
        ];
      }
      /**
       * Convert models to list items for the list selection modal
       */
      convertModelsToListItems(models) {
        const sortedModels = models.sort((a, b) => {
          const aSelected = this.isModelSelected(a.id) ? 1 : 0;
          const bSelected = this.isModelSelected(b.id) ? 1 : 0;
          const aFavorite = a.isFavorite ? 1 : 0;
          const bFavorite = b.isFavorite ? 1 : 0;
          if (aSelected !== bSelected) {
            return bSelected - aSelected;
          }
          if (aFavorite !== bFavorite) {
            return bFavorite - aFavorite;
          }
          return a.name.localeCompare(b.name);
        });
        return sortedModels.map((model) => {
          const isCurrentModel = this.isModelSelected(model.id);
          const item = {
            id: model.id,
            title: model.name,
            description: this.getModelDescription(model),
            icon: this.getModelIcon(model),
            selected: isCurrentModel,
            badge: this.getModelBadge(model),
            // Store additional data for enhanced display
            metadata: {
              provider: model.provider,
              contextLength: model.context_length,
              isFavorite: model.isFavorite || false,
              isNew: model.is_new || false,
              isBeta: model.is_beta || false,
              isDeprecated: model.is_deprecated || false,
              capabilities: this.getModelCapabilities(model),
              isCurrentModel
              // Add flag for current model
            }
          };
          item._ssModel = model;
          if (model.provider === "systemsculpt") {
            item.providerClass = "provider-systemsculpt";
          } else {
            item.providerClass = "provider-custom";
          }
          if (isCurrentModel) {
            item.additionalClasses = "ss-current-model";
          }
          return item;
        });
      }
      /**
       * Get model capabilities for display
       */
      getModelCapabilities(model) {
        const capabilities = [];
        if (model.supports_vision) capabilities.push("Vision");
        if (model.supports_functions) capabilities.push("Functions");
        if (model.supports_streaming !== false) capabilities.push("Streaming");
        if (model.context_length && model.context_length >= 1e5) capabilities.push("Long Context");
        return capabilities;
      }
      /**
       * Check if a model is selected
       */
      isModelSelected(modelId) {
        if (this.selectedModelId === modelId) {
          return true;
        }
        const normalizedSelected = ensureCanonicalId(this.selectedModelId);
        const normalizedCandidate = ensureCanonicalId(modelId);
        return normalizedSelected === normalizedCandidate;
      }
      /**
       * Get a model description for the UI
       */
      getModelDescription(model) {
        const parts = [];
        if (model.context_length) {
          const tokens = model.context_length;
          let formattedTokens;
          if (tokens >= 1e6) {
            formattedTokens = `${(tokens / 1e6).toFixed(1)}M tokens`;
          } else if (tokens >= 1e3) {
            formattedTokens = `${(tokens / 1e3).toFixed(0)}K tokens`;
          } else {
            formattedTokens = `${tokens} tokens`;
          }
          parts.push(formattedTokens);
        }
        if (model.pricing) {
          const pricing = model.pricing;
          if (pricing.input && pricing.output) {
            parts.push(`$${pricing.input}/$${pricing.output} per 1K`);
          }
        }
        const capabilities = [];
        if (model.supports_vision) capabilities.push("Vision");
        if (model.supports_functions) capabilities.push("Functions");
        if (model.supports_streaming) capabilities.push("Streaming");
        if (capabilities.length > 0) {
          parts.push(capabilities.join(" \xB7 "));
        }
        if (model.description && model.description.length > 0 && model.description.length < 100) {
          parts.push(model.description);
        }
        return parts.join(" \u2022 ");
      }
      /**
       * Get an icon for a model
       */
      getModelIcon(model) {
        const canonicalId = getCanonicalId(model);
        if (canonicalId === "systemsculpt@@vault-agent") {
          return "folder-open";
        }
        if (model.provider === "systemsculpt") {
          return "bot";
        } else {
          return "server";
        }
      }
      /**
       * Get a badge label for a model
       */
      getModelBadge(model) {
        const canonicalId = getCanonicalId(model);
        if (canonicalId === "systemsculpt@@vault-agent") {
          return "Agent";
        }
        if (model.is_new) {
          return "New";
        }
        if (model.is_beta) {
          return "Beta";
        }
        if (model.is_deprecated) {
          return "Legacy";
        }
        if (model.provider === "systemsculpt") {
          return "SystemSculpt";
        }
        const providerName = (model.provider || "").toLowerCase();
        if (!_StandardModelSelectionModal.providerNameCache[providerName]) {
          const matchingProvider = this.plugin.settings.customProviders.find(
            (p) => p.name.toLowerCase() === providerName || p.id.toLowerCase() === providerName
          );
          _StandardModelSelectionModal.providerNameCache[providerName] = matchingProvider ? matchingProvider.name : model.provider ? model.provider : "Custom";
        }
        return _StandardModelSelectionModal.providerNameCache[providerName];
      }
      /**
       * Register events for updates
       */
      registerEventsForUpdates() {
        const favChangedListener = () => this.updateModelList();
        const favFilterChangedListener = () => this.updateModelList();
        const favToggledListener = (event) => {
          const { modelId, isFavorite } = event.detail;
          const modelIndex = this.filteredModels.findIndex((m) => m.id === modelId);
          if (modelIndex !== -1) {
            this.filteredModels[modelIndex].isFavorite = isFavorite;
          }
          this.updateModelList();
          this.updateFavoritesButtonCount();
          this.updateEmptyState();
        };
        this.registerListener(document.body, "systemsculpt:favorites-changed", favChangedListener);
        this.registerListener(document.body, "systemsculpt:favorites-filter-changed", favFilterChangedListener);
        this.registerListener(document.body, "ss-list-item-favorite-toggled", favToggledListener);
      }
      /**
       * Open the modal and get selection
       */
      async open() {
        var _a;
        try {
          this.removeAllListeners();
          const initialItems = [];
          const modal = new ListSelectionModal(this.app, initialItems, {
            title: this.modalTitle,
            description: this.modalDescription,
            emptyText: "Loading models\u2026",
            placeholder: "Search by name, provider, or capabilities...",
            withSearch: true,
            size: "large",
            closeOnSelect: true,
            favoritesService: this.favoritesService,
            customContent: (containerEl) => {
              this.createFilters(containerEl);
            }
          });
          this.modalInstance = modal;
          modal.contentEl.addClass("systemsculpt-model-selection-modal");
          modal.setCustomSearchHandler((query) => {
            return this.searchModelsAsync(this.filteredModels, query);
          });
          modal.contentEl.addEventListener("ss-list-item-favorite-toggled", (_event) => {
          });
          this.registerEventsForUpdates();
          if ((_a = this.plugin) == null ? void 0 : _a.emitter) {
            const offSystem = this.plugin.emitter.onProvider("modelsUpdated", "systemsculpt", (models) => {
              this.handleProviderModelsUpdate("systemsculpt", models);
            });
            const offCustom = this.plugin.emitter.onProvider("modelsUpdated", "custom", (models) => {
              this.handleProviderModelsUpdate("custom", models);
            });
            this.registerEmitterListener(offSystem);
            this.registerEmitterListener(offCustom);
          }
          this.plugin.modelService.getModels().then((models) => {
            var _a2;
            this.allModels = filterChatModels(models);
            this.favoritesService.processFavorites(this.allModels);
            this.filteredModels = this.applyAllFilters(this.allModels);
            const items = this.convertModelsToListItems(this.filteredModels);
            (_a2 = this.modalInstance) == null ? void 0 : _a2.setItems(items);
            this.updateFavoritesButtonCount();
            this.updateEmptyState();
          }).catch(() => {
          });
          const selectedItems = await modal.openAndGetSelection();
          this.removeAllListeners();
          if (selectedItems && selectedItems.length > 0) {
            const selectedItem = selectedItems[0];
            const result = { modelId: selectedItem.id };
            this.onSelect(result);
          }
        } catch (error) {
        }
      }
      // Wrap search methods to return Promises
      async searchModelsAsync(models, query) {
        return Promise.resolve(this.searchModels(models, query));
      }
    };
    // Track loading state for lazy UI
    // Cache for provider name lookups
    _StandardModelSelectionModal.providerNameCache = {};
    StandardModelSelectionModal = _StandardModelSelectionModal;
  }
});

// src/modals/SystemPromptCreatorModal.ts
var import_obsidian34, SystemPromptCreatorModal;
var init_SystemPromptCreatorModal = __esm({
  "src/modals/SystemPromptCreatorModal.ts"() {
    import_obsidian34 = require("obsidian");
    SystemPromptCreatorModal = class extends import_obsidian34.Modal {
      constructor(options) {
        super(options.app);
        this.fileNameInput = null;
        this.contentTextArea = null;
        this.saveLocationEl = null;
        this.createButton = null;
        this.presets = [
          {
            id: "creative-writing",
            name: "Creative Writing Assistant",
            description: "For creative writing, storytelling, and content creation",
            content: `You are a creative writing assistant with expertise in storytelling, character development, and narrative structure. Your role is to help users craft compelling stories, develop interesting characters, and improve their writing style.

Key areas of assistance:
- Plot development and story structure
- Character creation and development
- Dialogue writing and improvement
- Setting and world-building
- Writing style and voice development
- Grammar and clarity suggestions

Always encourage creativity while providing constructive feedback. Ask clarifying questions to better understand the user's vision and goals.`
          },
          {
            id: "code-assistant",
            name: "Code Review Assistant",
            description: "For code review, debugging, and programming guidance",
            content: `You are a senior software engineer specializing in code review and development best practices. Your role is to help users write better code, debug issues, and follow industry standards.

Key areas of assistance:
- Code review and quality assessment
- Bug identification and debugging strategies
- Performance optimization suggestions
- Security best practices
- Clean code principles and refactoring
- Documentation and commenting standards
- Testing strategies and implementation

Provide specific, actionable feedback with examples when possible. Consider readability, maintainability, and scalability in your recommendations.`
          },
          {
            id: "research-helper",
            name: "Research Assistant",
            description: "For research, analysis, and information gathering",
            content: `You are a research assistant with expertise in information analysis, source evaluation, and academic writing. Your role is to help users conduct thorough research and present findings clearly.

Key areas of assistance:
- Research methodology and planning
- Source evaluation and credibility assessment
- Data analysis and interpretation
- Literature review and synthesis
- Citation and referencing guidance
- Academic writing structure and style
- Fact-checking and verification

Always emphasize the importance of multiple sources and critical thinking. Help users develop strong analytical skills and present well-supported arguments.`
          },
          {
            id: "meeting-notes",
            name: "Meeting Notes Assistant",
            description: "For organizing meetings, taking notes, and action items",
            content: `You are a professional meeting assistant focused on organization, clarity, and actionable outcomes. Your role is to help users prepare for meetings, take effective notes, and follow up on commitments.

Key areas of assistance:
- Meeting agenda preparation and structure
- Note-taking strategies and templates
- Action item identification and tracking
- Decision documentation and clarity
- Follow-up task organization
- Meeting summary creation
- Stakeholder communication templates

Focus on clear, concise documentation that enables effective follow-through and accountability.`
          },
          {
            id: "blank",
            name: "Blank Template",
            description: "Start with a clean slate",
            content: `You are a helpful assistant. Please provide clear, accurate, and helpful responses to user questions and requests.

Key guidelines:
- Be concise but thorough in your responses
- Ask clarifying questions when needed
- Provide examples when helpful
- Maintain a professional and friendly tone

Customize this prompt based on your specific needs and use case.`
          }
        ];
        this.plugin = options.plugin;
        this.onCreated = options.onCreated;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("systemsculpt-prompt-creator-modal");
        contentEl.createEl("h2", { text: "Create New System Prompt" });
        contentEl.createEl("p", {
          text: "Create a custom system prompt file that will be saved to your vault and available for use in chats.",
          cls: "systemsculpt-prompt-creator-description"
        });
        const fileNameSection = contentEl.createDiv("systemsculpt-prompt-creator-section");
        fileNameSection.createEl("h3", { text: "File Name" });
        new import_obsidian34.Setting(fileNameSection).setName("Prompt Name").setDesc("Enter a name for your system prompt file").addText((text) => {
          this.fileNameInput = text;
          text.setPlaceholder("My Custom Prompt").setValue("").onChange((value) => {
            this.updateSaveLocation();
            this.validateForm();
          });
          text.inputEl.addEventListener("keydown", (e) => {
            if (e.key === "Enter") {
              e.preventDefault();
              this.createPrompt();
            }
          });
        });
        this.saveLocationEl = fileNameSection.createDiv("systemsculpt-save-location");
        this.updateSaveLocation();
        const presetsSection = contentEl.createDiv("systemsculpt-prompt-creator-section");
        presetsSection.createEl("h3", { text: "Quick Start Templates" });
        presetsSection.createEl("p", {
          text: "Choose a template to get started, then customize as needed.",
          cls: "systemsculpt-section-description"
        });
        const presetsGrid = presetsSection.createDiv("systemsculpt-presets-grid");
        this.presets.forEach((preset) => {
          const presetCard = presetsGrid.createDiv("systemsculpt-preset-card systemsculpt-preset-card-clickable");
          presetCard.createEl("h4", { text: preset.name, cls: "systemsculpt-preset-card-title" });
          presetCard.createEl("p", { text: preset.description, cls: "systemsculpt-preset-card-description" });
          presetCard.addEventListener("click", () => {
            if (this.contentTextArea) {
              this.contentTextArea.setValue(preset.content);
            }
            if (this.fileNameInput && !this.fileNameInput.getValue().trim()) {
              this.fileNameInput.setValue(preset.name);
              this.updateSaveLocation();
              this.validateForm();
            }
            this.highlightSelectedPreset(presetCard);
          });
        });
        const contentSection = contentEl.createDiv("systemsculpt-prompt-creator-section");
        contentSection.createEl("h3", { text: "System Prompt Content" });
        contentSection.createEl("p", {
          text: "Write your system prompt here. This text will guide the AI's behavior and responses.",
          cls: "systemsculpt-section-description"
        });
        const textAreaContainer = contentSection.createDiv("systemsculpt-prompt-textarea-container");
        const textArea = textAreaContainer.createEl("textarea", {
          cls: "systemsculpt-prompt-textarea",
          placeholder: "Enter your system prompt here..."
        });
        this.contentTextArea = {
          getValue: () => textArea.value,
          setValue: (value) => {
            textArea.value = value;
            this.validateForm();
          },
          onChange: (callback) => {
            textArea.addEventListener("input", () => {
              callback(textArea.value);
            });
          },
          inputEl: textArea
        };
        textArea.rows = 12;
        textArea.addEventListener("input", () => {
          this.validateForm();
        });
        const actionsSection = contentEl.createDiv("systemsculpt-prompt-creator-actions");
        const cancelButton = new import_obsidian34.ButtonComponent(actionsSection);
        cancelButton.setButtonText("Cancel").onClick(() => {
          this.close();
        });
        this.createButton = new import_obsidian34.ButtonComponent(actionsSection);
        this.createButton.setButtonText("Create System Prompt").setCta().setDisabled(true).onClick(() => {
          this.createPrompt();
        });
        this.validateForm();
      }
      highlightSelectedPreset(selectedCard) {
        var _a;
        const allCards = (_a = selectedCard.parentElement) == null ? void 0 : _a.querySelectorAll(".systemsculpt-preset-card");
        allCards == null ? void 0 : allCards.forEach((card) => card.removeClass("systemsculpt-preset-card-selected"));
        selectedCard.addClass("systemsculpt-preset-card-selected");
        setTimeout(() => {
          selectedCard.removeClass("systemsculpt-preset-card-selected");
        }, 1e3);
      }
      updateSaveLocation() {
        if (!this.saveLocationEl || !this.fileNameInput) return;
        const fileName = this.fileNameInput.getValue().trim();
        const systemPromptsFolder = "SystemSculpt/System Prompts";
        if (fileName) {
          const sanitizedFileName = this.sanitizeFileName(fileName);
          const fullPath = `${systemPromptsFolder}/${sanitizedFileName}.md`;
          this.saveLocationEl.innerHTML = `
        <div class="systemsculpt-save-location-label">Will be saved to:</div>
        <div class="systemsculpt-save-location-path">${fullPath}</div>
      `;
        } else {
          this.saveLocationEl.innerHTML = `
        <div class="systemsculpt-save-location-label">Will be saved to:</div>
        <div class="systemsculpt-save-location-path systemsculpt-save-location-placeholder">${systemPromptsFolder}/[enter name].md</div>
      `;
        }
      }
      sanitizeFileName(fileName) {
        return fileName.replace(/[<>:"/\\|?*]/g, "").replace(/\s+/g, " ").trim();
      }
      validateForm() {
        if (!this.fileNameInput || !this.contentTextArea || !this.createButton) return;
        const fileName = this.fileNameInput.getValue().trim();
        const content = this.contentTextArea.getValue().trim();
        const isValid = fileName.length > 0 && content.length > 0;
        this.createButton.setDisabled(!isValid);
      }
      async createPrompt() {
        if (!this.fileNameInput || !this.contentTextArea) {
          new import_obsidian34.Notice("Missing required fields", 5e3);
          return;
        }
        const fileName = this.fileNameInput.getValue().trim();
        const content = this.contentTextArea.getValue().trim();
        if (!fileName || !content) {
          new import_obsidian34.Notice("Please fill in both the name and content fields", 5e3);
          return;
        }
        try {
          const systemPromptsFolder = "SystemSculpt/System Prompts";
          await this.ensureFolderExists(systemPromptsFolder);
          const sanitizedFileName = this.sanitizeFileName(fileName);
          const filePath = `${systemPromptsFolder}/${sanitizedFileName}.md`;
          const existingFile = this.app.vault.getAbstractFileByPath(filePath);
          if (existingFile) {
            new import_obsidian34.Notice(`A system prompt with the name "${sanitizedFileName}" already exists. Please choose a different name.`, 8e3);
            return;
          }
          const fileContent = `---
type: system-prompt
created: ${(/* @__PURE__ */ new Date()).toISOString()}
tags: [system-prompt, custom]
---

${content}`;
          await this.app.vault.create(filePath, fileContent);
          new import_obsidian34.Notice(`System prompt "${sanitizedFileName}" created successfully!`, 5e3);
          if (this.onCreated) {
            this.onCreated(filePath);
          }
          this.close();
        } catch (error) {
          new import_obsidian34.Notice("Failed to create system prompt. Please try again.", 8e3);
        }
      }
      async ensureFolderExists(folderPath) {
        const pathParts = folderPath.split("/");
        let currentPath = "";
        for (const part of pathParts) {
          currentPath = currentPath ? `${currentPath}/${part}` : part;
          const existingFolder = this.app.vault.getAbstractFileByPath(currentPath);
          if (!existingFolder) {
            await this.app.vault.createFolder(currentPath);
          }
        }
      }
      onClose() {
      }
    };
  }
});

// src/modals/StandardSystemPromptSelectionModal.ts
var StandardSystemPromptSelectionModal_exports = {};
__export(StandardSystemPromptSelectionModal_exports, {
  StandardSystemPromptSelectionModal: () => StandardSystemPromptSelectionModal
});
var import_obsidian35, StandardSystemPromptSelectionModal;
var init_StandardSystemPromptSelectionModal = __esm({
  "src/modals/StandardSystemPromptSelectionModal.ts"() {
    import_obsidian35 = require("obsidian");
    init_standard();
    init_SystemPromptService();
    init_prompts2();
    init_SearchService();
    init_SystemPromptCreatorModal();
    StandardSystemPromptSelectionModal = class {
      // Custom description for the modal
      constructor(options) {
        this.modalInstance = null;
        this.allItems = [];
        this.filteredItems = [];
        this.app = options.app;
        this.plugin = options.plugin;
        this.currentType = options.currentType;
        this.currentPath = options.currentPath;
        this.onSelect = options.onSelect;
        this.modalTitle = options.title || "Select System Prompt";
        this.modalDescription = options.description || "Choose a system prompt for this conversation";
        this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.plugin.settings);
        this.searchService = SearchService.getInstance();
      }
      /**
       * Load all available system prompt items
       */
      async loadSystemPromptItems() {
        const items = [];
        items.push({
          id: "general-use",
          name: "General Use",
          description: "A comprehensive prompt for general conversations",
          type: "general-use",
          prompt: GENERAL_USE_PRESET.systemPrompt
        });
        items.push({
          id: "concise",
          name: "Concise",
          description: "A focused prompt for brief, direct responses",
          type: "concise",
          prompt: CONCISE_PRESET.systemPrompt
        });
        try {
          const customFiles = await this.systemPromptService.getCustomPromptFiles();
          for (const file of customFiles) {
            items.push({
              id: `custom-${file.path}`,
              name: file.name,
              description: `Custom prompt from: ${file.path}`,
              type: "custom",
              path: file.path
            });
          }
        } catch (error) {
        }
        return items;
      }
      /**
       * Convert system prompt items to list items for the modal
       */
      convertToListItems(items) {
        return items.map((item) => {
          const isSelected = this.isItemSelected(item);
          return {
            id: item.id,
            title: item.name,
            description: item.description,
            icon: this.getItemIcon(item),
            selected: isSelected,
            badge: item.type === "custom" ? "Custom" : ""
          };
        });
      }
      /**
       * Check if an item is currently selected
       */
      isItemSelected(item) {
        if (item.type === "custom" && this.currentType === "custom") {
          return item.path === this.currentPath;
        }
        return item.type === this.currentType;
      }
      /**
       * Get icon for a system prompt item
       */
      getItemIcon(item) {
        switch (item.type) {
          case "general-use":
            return "message-square";
          case "concise":
            return "zap";
          case "agent":
            return "cpu";
          case "custom":
            return "file-text";
          default:
            return "file-text";
        }
      }
      /**
       * Search system prompt items
       */
      searchItems(items, query) {
        if (!query || query.trim() === "") {
          return this.convertToListItems(items);
        }
        const results = this.searchService.search(
          items,
          query,
          (item) => this.getSearchableFields(item),
          {
            initialResultsLimit: 25,
            maxFilteredResults: 50
          }
        );
        const filteredResults = results.filter((result) => result.matches.length > 0 && result.score > 0).sort((a, b) => b.score - a.score).map((result) => result.item);
        return this.convertToListItems(filteredResults);
      }
      /**
       * Get searchable fields from a system prompt item
       */
      getSearchableFields(item) {
        return [
          { field: "name", text: item.name || "", weight: 2 },
          { field: "description", text: item.description || "", weight: 1 },
          { field: "type", text: item.type || "", weight: 0.5 }
        ];
      }
      /**
       * Create filter controls
       */
      createFilters(containerEl) {
        const filtersContainer = containerEl.createDiv({ cls: "ss-modal-filters-container" });
        const actionsContainer = containerEl.createDiv({ cls: "ss-modal-actions-container" });
        const createButton2 = actionsContainer.createEl("button", {
          text: "Create New System Prompt",
          cls: "mod-cta ss-modal-create-button"
        });
        const createIconSpan = createButton2.createSpan({ cls: "ss-modal-create-icon" });
        (0, import_obsidian35.setIcon)(createIconSpan, "plus-circle");
        createButton2.addEventListener("click", () => {
          this.openSystemPromptCreator();
        });
        const refreshButton = actionsContainer.createEl("button", {
          text: "Refresh Custom Prompts",
          cls: "ss-modal-refresh-button"
        });
        const refreshIconSpan = refreshButton.createSpan({ cls: "ss-modal-refresh-icon" });
        (0, import_obsidian35.setIcon)(refreshIconSpan, "refresh-cw");
        refreshButton.addEventListener("click", async () => {
          const originalText = refreshButton.textContent || "Refresh Custom Prompts";
          refreshButton.textContent = "Refreshing...";
          refreshButton.classList.add("is-loading");
          refreshIconSpan.addClass("ss-modal-refresh-icon--spinning");
          try {
            this.allItems = await this.loadSystemPromptItems();
            this.updateItemList();
          } catch (error) {
          } finally {
            refreshButton.textContent = originalText;
            refreshButton.classList.remove("is-loading");
            refreshIconSpan.removeClass("ss-modal-refresh-icon--spinning");
          }
        });
      }
      /**
       * Open the system prompt creator modal
       */
      openSystemPromptCreator() {
        const creatorModal = new SystemPromptCreatorModal({
          app: this.app,
          plugin: this.plugin,
          onCreated: async (filePath) => {
            try {
              this.allItems = await this.loadSystemPromptItems();
              this.updateItemList();
              const newItem = this.allItems.find((item) => item.path === filePath);
              if (newItem && this.modalInstance) {
                setTimeout(() => {
                  var _a;
                  const listItems = (_a = this.modalInstance) == null ? void 0 : _a.contentEl.querySelectorAll(".ss-modal__list-item");
                  const targetItem = Array.from(listItems || []).find(
                    (el) => el.getAttribute("data-id") === newItem.id
                  );
                  if (targetItem) {
                    targetItem.click();
                  }
                }, 100);
              }
              new import_obsidian35.Notice("System prompt list updated with your new prompt!", 3e3);
            } catch (error) {
              new import_obsidian35.Notice("Created prompt successfully, but failed to refresh list. Please refresh manually.", 5e3);
            }
          }
        });
        creatorModal.open();
      }
      /**
       * Update the item list
       */
      updateItemList() {
        if (!this.modalInstance) {
          return;
        }
        const items = this.convertToListItems(this.allItems);
        this.modalInstance.setItems(items);
      }
      /**
       * Show warning when agent prompt is selected but agent mode is disabled
       */
      async showAgentModeWarning() {
        return new Promise((resolve) => {
          const modal = new import_obsidian35.Modal(this.app);
          modal.titleEl.textContent = "Agent Mode Required";
          const content = modal.contentEl;
          content.empty();
          content.createEl("p", {
            text: "The Agent prompt requires Agent Mode to be enabled for full functionality. Agent Mode provides the AI with vault exploration and file operation capabilities."
          });
          content.createEl("p", {
            text: "Would you like to enable Agent Mode now?"
          });
          const buttonContainer = content.createDiv({ cls: "ss-modal-button-container ss-modal-margin-top-16" });
          new import_obsidian35.ButtonComponent(buttonContainer).setButtonText("Cancel").onClick(() => {
            modal.close();
            resolve(false);
          });
          new import_obsidian35.ButtonComponent(buttonContainer).setButtonText("Enable Agent Mode").setCta().onClick(() => {
            modal.close();
            resolve(true);
          });
          modal.open();
        });
      }
      /**
       * Open the modal and get selection
       */
      async open() {
        try {
          this.allItems = await this.loadSystemPromptItems();
          const items = this.convertToListItems(this.allItems);
          const modal = new ListSelectionModal(this.app, items, {
            title: this.modalTitle,
            description: this.modalDescription,
            emptyText: "No system prompts found.",
            placeholder: "Search prompts...",
            withSearch: true,
            size: "medium",
            closeOnSelect: true,
            customContent: (containerEl) => {
              this.createFilters(containerEl);
            }
          });
          this.modalInstance = modal;
          modal.contentEl.addClass("systemsculpt-system-prompt-selection-modal");
          modal.setCustomSearchHandler(async (query) => {
            return this.searchItems(this.allItems, query);
          });
          const selectedItems = await modal.openAndGetSelection();
          if (selectedItems && selectedItems.length > 0) {
            const selectedItem = selectedItems[0];
            const item = this.allItems.find((i) => i.id === selectedItem.id);
            if (item) {
              let result;
              if (item.type === "custom" && item.path) {
                const customPrompt = await this.systemPromptService.getSystemPromptContent("custom", item.path);
                result = {
                  type: "custom",
                  prompt: customPrompt,
                  path: item.path
                };
              } else {
                result = {
                  type: item.type,
                  prompt: item.prompt || ""
                };
              }
              this.onSelect(result);
            }
          } else {
          }
        } catch (error) {
        }
      }
    };
  }
});

// src/components/FolderSuggester.ts
function getFolderSuggestions(app) {
  const folders = app.vault.getAllLoadedFiles().filter((file) => file instanceof import_obsidian44.TFolder);
  return new Set(folders.map((folder) => folder.path));
}
function attachFolderSuggester(inputEl, onSelect, app) {
  const suggester = new FolderSuggester(inputEl, onSelect, app);
  inputEl.addEventListener("focus", () => {
    suggester.refreshSuggestions();
  });
  return suggester;
}
var import_obsidian44, FolderSuggester, InternalSuggester;
var init_FolderSuggester = __esm({
  "src/components/FolderSuggester.ts"() {
    import_obsidian44 = require("obsidian");
    FolderSuggester = class {
      constructor(inputEl, onSelectCb, app) {
        this.onSelectCb = onSelectCb;
        this.app = app;
        this.suggestEl = inputEl;
        this.content = getFolderSuggestions(app);
        this.suggest = new InternalSuggester(app, inputEl);
        this.suggest.onSelect((value) => {
          this.onSelectCb(value);
        });
      }
      // Refresh suggestions when the input is focused
      refreshSuggestions() {
        this.content = getFolderSuggestions(this.app);
      }
      // Method to close the suggester
      close() {
        this.suggest.close();
      }
    };
    InternalSuggester = class extends import_obsidian44.AbstractInputSuggest {
      constructor(app, inputEl) {
        super(app, inputEl);
        this.inputEl = inputEl;
      }
      getSuggestions(inputStr) {
        const folders = getFolderSuggestions(this.app);
        const lowerCaseInputStr = inputStr.toLowerCase();
        return [...folders].filter(
          (content) => content.toLowerCase().includes(lowerCaseInputStr)
        );
      }
      renderSuggestion(content, el) {
        el.setText(content);
      }
      selectSuggestion(content, evt) {
        this.inputEl.value = content;
        this.inputEl.blur();
        this.close();
        super.selectSuggestion(content, evt);
      }
    };
  }
});

// src/services/ChangeLogService.ts
var GITHUB_OWNER, GITHUB_REPO, GITHUB_RELEASES_URL, cachedReleases, lastFetchTime, CACHE_DURATION, ChangeLogService;
var init_ChangeLogService = __esm({
  "src/services/ChangeLogService.ts"() {
    init_externalServices();
    init_api();
    GITHUB_OWNER = "SystemSculpt";
    GITHUB_REPO = "obsidian-systemsculpt-ai";
    GITHUB_RELEASES_URL = GITHUB_API.RELEASES(GITHUB_OWNER, GITHUB_REPO);
    cachedReleases = null;
    lastFetchTime = 0;
    CACHE_DURATION = 30 * 60 * 1e3;
    ChangeLogService = class _ChangeLogService {
      static getReleasesPageUrl() {
        return GITHUB_API.RELEASE_URL(GITHUB_OWNER, GITHUB_REPO);
      }
      static async getReleases(forceRefresh = false) {
        var _a;
        const now = Date.now();
        if (!forceRefresh && cachedReleases && now - lastFetchTime < CACHE_DURATION) {
          return cachedReleases;
        }
        let allReleases = [];
        const apiUrl = `${API_BASE_URL}${SYSTEMSCULPT_API_ENDPOINTS.PLUGINS.RELEASES("systemsculpt-ai")}?limit=50`;
        try {
          const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const response = await httpRequest2({ url: apiUrl, method: "GET" });
          if (response.status === 200) {
            const list = ((_a = response.json) == null ? void 0 : _a.data) || [];
            const entries = list.map((r) => ({
              version: r.version,
              date: r.date ? new Date(r.date).toLocaleDateString() : (/* @__PURE__ */ new Date()).toLocaleDateString(),
              notes: r.notes || "No release notes provided.",
              url: r.url || _ChangeLogService.getReleasesPageUrl()
            }));
            allReleases = entries;
          } else {
            if (cachedReleases) return cachedReleases;
            return [
              {
                version: "Unavailable",
                date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
                notes: "Changelog unavailable due to a network error.",
                url: _ChangeLogService.getReleasesPageUrl()
              }
            ];
          }
          cachedReleases = allReleases;
          lastFetchTime = now;
          return allReleases;
        } catch (error) {
          const errorMessage = error instanceof Error ? error.message : String(error);
          if (cachedReleases) return cachedReleases;
          return [
            {
              version: "Unavailable",
              date: (/* @__PURE__ */ new Date()).toLocaleDateString(),
              notes: "Changelog unavailable due to a network error.",
              url: _ChangeLogService.getReleasesPageUrl()
            }
          ];
        }
      }
      static findIndexByVersion(entries, version) {
        if (!version) return 0;
        const candidates = [version, version.startsWith("v") ? version.substring(1) : `v${version}`];
        const index = entries.findIndex((e) => candidates.includes(e.version));
        return index >= 0 ? index : 0;
      }
    };
  }
});

// src/utils/toolDisplay.ts
function formatToolDisplayName(fullName) {
  try {
    const baseName = fullName.replace(/^mcp[_-]/i, "");
    if (baseName.startsWith("filesystem_")) {
      const functionName = baseName.replace(/^filesystem_/, "");
      try {
        const { MCPFilesystemServer: MCPFilesystemServer2 } = (init_MCPFilesystemServer(), __toCommonJS(MCPFilesystemServer_exports));
        const friendly = MCPFilesystemServer2.getToolDisplayName(functionName);
        if (friendly) return `Filesystem: ${friendly}`;
      } catch (e) {
      }
      return `Filesystem: ${toTitleCase(functionName.replace(/[_-]/g, " "))}`;
    }
    return toTitleCase(baseName.replace(/[_-]/g, " "));
  } catch (e) {
    return fullName;
  }
}
function toTitleCase(text) {
  return text.replace(/\b\w/g, (l) => l.toUpperCase());
}
function getFunctionDataFromToolCall(toolCall) {
  var _a;
  try {
    const fn = (_a = toolCall.request) == null ? void 0 : _a.function;
    if (!fn) return null;
    const args = typeof fn.arguments === "string" ? safeParse(fn.arguments) : fn.arguments;
    return { name: fn.name, arguments: args != null ? args : {} };
  } catch (e) {
    return null;
  }
}
function safeParse(text) {
  try {
    return JSON.parse(text);
  } catch (e) {
    return void 0;
  }
}
function isMutatingTool(fullName) {
  const base = fullName.replace(/^mcp[-_][^_]+_/, "");
  const mutating = /* @__PURE__ */ new Set([
    "write",
    "edit",
    "move",
    "trash",
    "create_folders",
    "delete",
    "rename",
    "append",
    "replace",
    "update",
    "set",
    "create",
    "copy",
    "run",
    "run_command",
    "command",
    "execute",
    "exec",
    "shell",
    "spawn",
    "process",
    "system",
    "powershell",
    "bash",
    "sh",
    "python",
    "node",
    "eval",
    "http_request",
    "request",
    "fetch",
    "curl"
    // Context and open are treated as non-mutating for files
  ]);
  const canonical = base.toLowerCase();
  if (mutating.has(canonical)) {
    return true;
  }
  if (/^(write|edit|delete|remove|rename|create|update|set|append|move|trash|copy)/.test(canonical)) {
    return true;
  }
  return /(command|execute|exec|shell|spawn|process|system|powershell|bash|python|node|run_command|http_request|curl)/.test(canonical);
}
function extractPrimaryPathArg(toolName, args) {
  var _a;
  const base = toolName.replace(/^mcp[-_][^_]+_/, "");
  if (base === "move") {
    if (Array.isArray(args.items) && ((_a = args.items[0]) == null ? void 0 : _a.destination)) return String(args.items[0].destination);
  }
  const map = {
    read: "paths",
    write: "path",
    edit: "path",
    trash: "paths"
  };
  const key = map[base];
  if (!key) return null;
  const value = args[key];
  if (typeof value === "string") return value;
  if (Array.isArray(value) && typeof value[0] === "string") return value[0];
  return null;
}
var init_toolDisplay = __esm({
  "src/utils/toolDisplay.ts"() {
  }
});

// src/utils/diffUtils.ts
function generateDiff(oldContent, newContent, contextLines = 10) {
  const oldLines = oldContent.split("\n");
  const newLines = newContent.split("\n");
  const result = [];
  const stats = { additions: 0, deletions: 0 };
  const matrix = createLCSMatrix(oldLines, newLines);
  const diffSequence = extractDiffSequence(matrix, oldLines, newLines);
  let oldLineNum = 1;
  let newLineNum = 1;
  const fullDiff = [];
  for (const operation of diffSequence) {
    if (operation.type === "unchanged") {
      fullDiff.push({
        type: "unchanged",
        content: operation.line,
        oldLineNumber: oldLineNum,
        newLineNumber: newLineNum
      });
      oldLineNum++;
      newLineNum++;
    } else if (operation.type === "removed") {
      fullDiff.push({
        type: "removed",
        content: operation.line,
        oldLineNumber: oldLineNum
      });
      oldLineNum++;
      stats.deletions++;
    } else if (operation.type === "added") {
      fullDiff.push({
        type: "added",
        content: operation.line,
        newLineNumber: newLineNum
      });
      newLineNum++;
      stats.additions++;
    }
  }
  const { trimmedLines, wasTruncated } = trimDiffToContext(fullDiff, contextLines);
  return { lines: trimmedLines, stats, isTruncated: wasTruncated };
}
function trimDiffToContext(diffLines, contextLines) {
  if (diffLines.length === 0) return { trimmedLines: diffLines, wasTruncated: false };
  let firstChangeIndex = -1;
  let lastChangeIndex = -1;
  for (let i = 0; i < diffLines.length; i++) {
    if (diffLines[i].type !== "unchanged") {
      if (firstChangeIndex === -1) {
        firstChangeIndex = i;
      }
      lastChangeIndex = i;
    }
  }
  if (firstChangeIndex === -1) {
    return { trimmedLines: diffLines, wasTruncated: false };
  }
  const startIndex = Math.max(0, firstChangeIndex - contextLines);
  const endIndex = Math.min(diffLines.length - 1, lastChangeIndex + contextLines);
  const wasTruncated = endIndex < diffLines.length - 1;
  return {
    trimmedLines: diffLines.slice(startIndex, endIndex + 1),
    wasTruncated
  };
}
function createLCSMatrix(oldLines, newLines) {
  const m = oldLines.length;
  const n = newLines.length;
  const matrix = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0));
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      if (oldLines[i - 1] === newLines[j - 1]) {
        matrix[i][j] = matrix[i - 1][j - 1] + 1;
      } else {
        matrix[i][j] = Math.max(matrix[i - 1][j], matrix[i][j - 1]);
      }
    }
  }
  return matrix;
}
function extractDiffSequence(matrix, oldLines, newLines) {
  const result = [];
  let i = oldLines.length;
  let j = newLines.length;
  while (i > 0 || j > 0) {
    if (i > 0 && j > 0 && oldLines[i - 1] === newLines[j - 1]) {
      result.unshift({ type: "unchanged", line: oldLines[i - 1] });
      i--;
      j--;
    } else if (j > 0 && (i === 0 || matrix[i][j - 1] >= matrix[i - 1][j])) {
      result.unshift({ type: "added", line: newLines[j - 1] });
      j--;
    } else if (i > 0) {
      result.unshift({ type: "removed", line: oldLines[i - 1] });
      i--;
    }
  }
  return result;
}
var init_diffUtils = __esm({
  "src/utils/diffUtils.ts"() {
  }
});

// src/components/DiffViewer.ts
var DiffViewer_exports = {};
__export(DiffViewer_exports, {
  DiffViewer: () => DiffViewer
});
var import_obsidian61, DiffViewer;
var init_DiffViewer = __esm({
  "src/components/DiffViewer.ts"() {
    import_obsidian61 = require("obsidian");
    DiffViewer = class extends import_obsidian61.Component {
      constructor(options) {
        var _a, _b;
        super();
        this.container = options.container;
        this.diffResult = options.diffResult;
        this.fileName = options.fileName;
        this.maxContextLines = (_a = options.maxContextLines) != null ? _a : 2;
        this.showLineNumbers = (_b = options.showLineNumbers) != null ? _b : false;
      }
      render() {
        this.container.empty();
        this.container.classList.add("systemsculpt-diff-viewer");
        this.createHeader();
        this.createChangeHunks();
      }
      createHeader() {
        const header = this.container.createEl("div", {
          cls: "systemsculpt-diff-header"
        });
        const fileInfo = header.createEl("div", {
          cls: "systemsculpt-diff-file-info"
        });
        const fileName = fileInfo.createEl("span", {
          cls: "systemsculpt-diff-filename",
          text: this.fileName
        });
        const stats = fileInfo.createEl("span", {
          cls: "systemsculpt-diff-stats"
        });
        if (this.diffResult.stats.additions === 0 && this.diffResult.stats.deletions === 0) {
          stats.textContent = "No changes";
          stats.addClass("systemsculpt-diff-no-changes");
        } else {
          if (this.diffResult.stats.additions > 0) {
            const additionsSpan = stats.createEl("span", {
              cls: "systemsculpt-diff-additions",
              text: `+${this.diffResult.stats.additions}`
            });
          }
          if (this.diffResult.stats.deletions > 0) {
            if (this.diffResult.stats.additions > 0) {
              stats.createEl("span", { text: " " });
            }
            const deletionsSpan = stats.createEl("span", {
              cls: "systemsculpt-diff-deletions",
              text: `-${this.diffResult.stats.deletions}`
            });
          }
          if (this.diffResult.stats.additions > 0) {
            stats.addClass("systemsculpt-diff-has-additions");
          }
          if (this.diffResult.stats.deletions > 0) {
            stats.addClass("systemsculpt-diff-has-deletions");
          }
        }
      }
      createChangeHunks() {
        const content = this.container.createEl("div", {
          cls: "systemsculpt-diff-content"
        });
        const hunks = this.groupIntoHunks(this.diffResult.lines);
        if (hunks.length === 0) {
          const noChanges = content.createEl("div", {
            cls: "systemsculpt-diff-no-changes-notice",
            text: "No changes to display"
          });
          return;
        }
        hunks.forEach((hunk, index) => {
          this.createHunk(content, hunk, index);
        });
      }
      groupIntoHunks(lines) {
        const hunks = [];
        let currentHunk = [];
        let contextBuffer = [];
        for (let i = 0; i < lines.length; i++) {
          const line = lines[i];
          if (line.type === "unchanged") {
            contextBuffer.push(line);
            if (contextBuffer.length > this.maxContextLines * 2) {
              if (currentHunk.length > 0) {
                currentHunk.push(...contextBuffer.slice(0, this.maxContextLines));
                hunks.push([...currentHunk]);
                currentHunk = [];
              }
              contextBuffer = contextBuffer.slice(-this.maxContextLines);
            }
          } else {
            if (currentHunk.length === 0) {
              currentHunk.push(...contextBuffer.slice(-this.maxContextLines));
            } else {
              currentHunk.push(...contextBuffer);
            }
            currentHunk.push(line);
            contextBuffer = [];
          }
        }
        if (currentHunk.length > 0) {
          currentHunk.push(...contextBuffer.slice(0, this.maxContextLines));
          hunks.push(currentHunk);
        }
        return hunks;
      }
      createHunk(container, hunk, index) {
        const hunkEl = container.createEl("div", {
          cls: "systemsculpt-diff-hunk"
        });
        if (index > 0) {
          hunkEl.addClass("systemsculpt-diff-hunk-separated");
        }
        const linesContainer = hunkEl.createEl("div", {
          cls: "systemsculpt-diff-lines"
        });
        hunk.forEach((line) => {
          this.createCompactLine(linesContainer, line);
        });
      }
      createCompactLine(container, line) {
        const lineEl = container.createEl("div", {
          cls: `systemsculpt-diff-line systemsculpt-diff-line-${line.type}`
        });
        if (this.showLineNumbers) {
          const lineNumbers = lineEl.createEl("span", {
            cls: "systemsculpt-diff-line-numbers"
          });
          if (line.oldLineNumber && line.newLineNumber) {
            lineNumbers.textContent = `${line.oldLineNumber}`;
          } else if (line.oldLineNumber) {
            lineNumbers.textContent = `${line.oldLineNumber}`;
          } else if (line.newLineNumber) {
            lineNumbers.textContent = `${line.newLineNumber}`;
          }
        }
        const prefix = lineEl.createEl("span", {
          cls: "systemsculpt-diff-prefix"
        });
        switch (line.type) {
          case "added":
            prefix.textContent = "+";
            break;
          case "removed":
            prefix.textContent = "-";
            break;
          case "unchanged":
            prefix.textContent = "";
            break;
        }
        const content = lineEl.createEl("span", {
          cls: "systemsculpt-diff-line-content",
          text: line.content || ""
        });
        if (!line.content && line.content !== "") {
          content.innerHTML = "&nbsp;";
        }
      }
      updateDiff(diffResult) {
        this.diffResult = diffResult;
        this.render();
      }
      destroy() {
        this.container.empty();
        this.unload();
      }
    };
  }
});

// src/utils/toolCallPreview.ts
function isWriteOrEditTool(toolName) {
  const base = toolName.replace(/^mcp[-_][^_]+_/, "");
  return base === "write" || base === "edit";
}
async function prepareWriteEditPreview(app, toolCall) {
  var _a;
  const fn = getFunctionDataFromToolCall(toolCall);
  if (!fn) return null;
  if (!isWriteOrEditTool(fn.name)) return null;
  const path = extractPrimaryPathArg(fn.name, fn.arguments);
  if (!path) return null;
  let oldContent = "";
  const file = app.vault.getAbstractFileByPath(path);
  if (file && file instanceof import_obsidian62.TFile) {
    try {
      oldContent = await app.vault.read(file);
    } catch (e) {
    }
  }
  let newContent = "";
  const base = fn.name.replace(/^mcp[-_][^_]+_/, "");
  if (base === "write") {
    newContent = String((_a = fn.arguments.content) != null ? _a : "");
  } else if (base === "edit") {
    const edits = Array.isArray(fn.arguments.edits) ? fn.arguments.edits : [];
    newContent = applyEditsLocally(oldContent, edits);
  }
  const diff = generateDiff(oldContent != null ? oldContent : "", newContent != null ? newContent : "", 5);
  return { path, oldContent, newContent, diff };
}
function applyEditsLocally(original, edits) {
  let result = original.replace(/\r\n/g, "\n");
  for (const edit of edits) {
    try {
      result = applySingleEditPreview(result, edit);
    } catch (e) {
    }
  }
  return result;
}
function applySingleEditPreview(source, edit) {
  var _a, _b, _c;
  const text = source;
  const mode = edit.mode || "exact";
  const preserveIndent = edit.preserveIndent !== false;
  const { sliceStart, sliceEnd } = computeRange(text, edit.range);
  const head = text.slice(0, sliceStart);
  const target = text.slice(sliceStart, sliceEnd);
  const tail = text.slice(sliceEnd);
  const oldText = String((_a = edit.oldText) != null ? _a : "").replace(/\r\n/g, "\n");
  const newText = String((_b = edit.newText) != null ? _b : "").replace(/\r\n/g, "\n");
  const occurrence = (_c = edit.occurrence) != null ? _c : "first";
  let replaced = target;
  if (edit.isRegex) {
    const flags = edit.flags || "g";
    const regex = new RegExp(oldText, flags.includes("g") ? flags : flags + "g");
    replaced = replaceByOccurrenceRegex(target, regex, newText, occurrence);
  } else if (mode === "exact") {
    replaced = replaceByOccurrenceString(target, oldText, newText, occurrence);
  } else {
    replaced = replaceLoose(target, oldText, newText, preserveIndent, occurrence);
  }
  return head + replaced + tail;
}
function computeRange(text, range) {
  var _a, _b, _c, _d;
  const totalLength = text.length;
  if (!range) return { sliceStart: 0, sliceEnd: totalLength };
  if (typeof range.startIndex === "number" || typeof range.endIndex === "number") {
    const startIndex = Math.max(0, Math.min(totalLength, (_a = range.startIndex) != null ? _a : 0));
    const endIndex = Math.max(startIndex, Math.min(totalLength, (_b = range.endIndex) != null ? _b : totalLength));
    return { sliceStart: startIndex, sliceEnd: endIndex };
  }
  const lines = text.split("\n");
  const startLine = Math.max(1, (_c = range.startLine) != null ? _c : 1);
  const endLine = Math.max(startLine, (_d = range.endLine) != null ? _d : lines.length);
  let cursor = 0;
  let sliceStart = 0;
  let sliceEnd = totalLength;
  for (let i = 1; i <= lines.length; i++) {
    const line = lines[i - 1];
    const next = cursor + line.length + (i < lines.length ? 1 : 0);
    if (i === startLine) sliceStart = cursor;
    if (i === endLine) {
      sliceEnd = next;
      break;
    }
    cursor = next;
  }
  return { sliceStart, sliceEnd };
}
function replaceByOccurrenceString(target, find, replacement, occurrence) {
  if (occurrence === "all") return target.split(find).join(replacement);
  if (occurrence === "first") {
    const idx = target.indexOf(find);
    if (idx === -1) return target;
    return target.slice(0, idx) + replacement + target.slice(idx + find.length);
  }
  if (occurrence === "last") {
    const idx = target.lastIndexOf(find);
    if (idx === -1) return target;
    return target.slice(0, idx) + replacement + target.slice(idx + find.length);
  }
  if (typeof occurrence === "number") {
    let count = 0;
    let idx = -1;
    while (true) {
      idx = target.indexOf(find, idx + 1);
      if (idx === -1) return target;
      count++;
      if (count === occurrence) {
        return target.slice(0, idx) + replacement + target.slice(idx + find.length);
      }
    }
  }
  return target;
}
function replaceByOccurrenceRegex(target, pattern, replacement, occurrence) {
  if (occurrence === "all") return target.replace(pattern, replacement);
  const matches = Array.from(target.matchAll(new RegExp(pattern.source, pattern.flags.includes("g") ? pattern.flags : pattern.flags + "g")));
  if (matches.length === 0) return target;
  let which = 0;
  if (occurrence === "first") which = 0;
  else if (occurrence === "last") which = matches.length - 1;
  else if (typeof occurrence === "number") which = Math.max(0, Math.min(matches.length - 1, occurrence - 1));
  const m = matches[which];
  const start = m.index;
  const end = start + m[0].length;
  return target.slice(0, start) + m[0].replace(new RegExp(pattern.source, pattern.flags.replace("g", "")), replacement) + target.slice(end);
}
function replaceLoose(target, oldText, newText, preserveIndent, occurrence) {
  const oldLines = oldText.split("\n");
  const tgtLines = target.split("\n");
  const found = [];
  for (let i = 0; i <= tgtLines.length - oldLines.length; i++) {
    const window2 = tgtLines.slice(i, i + oldLines.length);
    const match = oldLines.every((l, idx) => {
      var _a;
      return l.trim() === ((_a = window2[idx]) != null ? _a : "").trim();
    });
    if (match) found.push(i);
  }
  if (found.length === 0) return target;
  const doReplaceAt = (pos) => {
    var _a;
    const originalIndent = ((_a = tgtLines[pos].match(/^\s*/)) == null ? void 0 : _a[0]) || "";
    const newLines = newText.split("\n").map((line, j) => {
      if (!preserveIndent) return line;
      if (j === 0) return originalIndent + line.trimStart();
      return originalIndent + line.trimStart();
    });
    tgtLines.splice(pos, oldLines.length, ...newLines);
  };
  if (occurrence === "all") {
    for (let k = found.length - 1; k >= 0; k--) doReplaceAt(found[k]);
  } else {
    let indexToUse = 0;
    if (occurrence === "last") indexToUse = found.length - 1;
    else if (typeof occurrence === "number") indexToUse = Math.max(0, Math.min(found.length - 1, occurrence - 1));
    doReplaceAt(indexToUse);
  }
  return tgtLines.join("\n");
}
async function renderWriteEditInlineDiff(app, hostElement, toolCall) {
  const preview = await prepareWriteEditPreview(app, toolCall);
  if (!preview) return null;
  const existing = hostElement.querySelector(".systemsculpt-inline-diff");
  if (existing) existing.remove();
  const container = document.createElement("div");
  container.className = "systemsculpt-inline-diff";
  hostElement.appendChild(container);
  const body = container.createDiv({ cls: "systemsculpt-inline-diff__body" });
  const { DiffViewer: DiffViewer2 } = (init_DiffViewer(), __toCommonJS(DiffViewer_exports));
  const viewer = new DiffViewer2({
    container: body,
    diffResult: preview.diff,
    fileName: preview.path,
    maxContextLines: 2,
    showLineNumbers: false
  });
  viewer.render();
  return container;
}
function getBaseToolName(fullName) {
  return fullName.replace(/^mcp[-_][^_]+_/, "");
}
function isMoveTool(toolName) {
  return getBaseToolName(toolName) === "move";
}
function isTrashTool(toolName) {
  return getBaseToolName(toolName) === "trash";
}
function isCreateFoldersTool(toolName) {
  return getBaseToolName(toolName) === "create_folders";
}
function prepareOperationsPreview(app, toolCall) {
  var _a;
  const fn = getFunctionDataFromToolCall(toolCall);
  if (!fn) return null;
  const base = getBaseToolName(fn.name);
  const args = (_a = fn.arguments) != null ? _a : {};
  if (base === "move") {
    const rawItems = Array.isArray(args.items) ? args.items : [];
    const seen = /* @__PURE__ */ new Set();
    const items = rawItems.map((it) => {
      var _a2, _b;
      return { source: String((_a2 = it == null ? void 0 : it.source) != null ? _a2 : ""), destination: String((_b = it == null ? void 0 : it.destination) != null ? _b : "") };
    }).filter((it) => it.source && it.destination).filter((it) => {
      const key = `${it.source}\0${it.destination}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
    if (items.length === 0) return null;
    return { type: "move", items };
  }
  if (base === "trash") {
    const raw = Array.isArray(args.paths) ? args.paths : [];
    const seen = /* @__PURE__ */ new Set();
    const items = raw.map((p) => ({ path: String(p) })).filter((it) => !!it.path).filter((it) => {
      if (seen.has(it.path)) return false;
      seen.add(it.path);
      return true;
    });
    if (items.length === 0) return null;
    return { type: "trash", items };
  }
  if (base === "create_folders") {
    const raw = Array.isArray(args.paths) ? args.paths : [];
    const seen = /* @__PURE__ */ new Set();
    const items = raw.map((p) => ({ path: String(p) })).filter((it) => !!it.path).filter((it) => {
      if (seen.has(it.path)) return false;
      seen.add(it.path);
      return true;
    });
    if (items.length === 0) return null;
    return { type: "create_folders", items };
  }
  return null;
}
async function renderOperationsInlinePreview(app, hostElement, toolCall) {
  const preview = prepareOperationsPreview(app, toolCall);
  if (!preview) return null;
  const existing = hostElement.querySelector(".systemsculpt-inline-ops");
  if (existing) existing.remove();
  const container = document.createElement("div");
  container.className = "systemsculpt-inline-ops";
  hostElement.appendChild(container);
  const body = container.createDiv({ cls: "systemsculpt-inline-ops__body" });
  const list = body.createEl("ul");
  if (preview.type === "move") {
    const li = list.createEl("li");
    li.createSpan({ text: "Move: " });
    preview.items.forEach((it, idx) => {
      const src = li.createEl("code", { cls: "ss-modal__inline-code" });
      src.textContent = it.source;
      src.setAttribute("title", it.source);
      li.createSpan({ text: " \u2192 " });
      const dst = li.createEl("code", { cls: "ss-modal__inline-code" });
      dst.textContent = it.destination;
      dst.setAttribute("title", it.destination);
      if (idx < preview.items.length - 1) li.appendChild(document.createTextNode(", "));
    });
  } else if (preview.type === "trash") {
    const li = list.createEl("li");
    li.createSpan({ text: "Trash: " });
    preview.items.forEach((it, idx) => {
      const code = li.createEl("code", { cls: "ss-modal__inline-code" });
      code.textContent = it.path;
      if (idx < preview.items.length - 1) li.appendChild(document.createTextNode(", "));
    });
  } else if (preview.type === "create_folders") {
    const li = list.createEl("li");
    li.createSpan({ text: "Create folders: " });
    const baseName = (p) => p.split(/[\\/]/).filter(Boolean).pop() || p;
    preview.items.forEach((it, idx) => {
      const code = li.createEl("code", { cls: "ss-modal__inline-code" });
      code.textContent = baseName(it.path);
      code.setAttribute("title", it.path);
      if (idx < preview.items.length - 1) li.appendChild(document.createTextNode(", "));
    });
  }
  return container;
}
var import_obsidian62;
var init_toolCallPreview = __esm({
  "src/utils/toolCallPreview.ts"() {
    import_obsidian62 = require("obsidian");
    init_toolDisplay();
    init_diffUtils();
  }
});

// src/editors/InlineEditorDiffManager.ts
var InlineEditorDiffManager;
var init_InlineEditorDiffManager = __esm({
  "src/editors/InlineEditorDiffManager.ts"() {
    init_inline_diff();
    InlineEditorDiffManager = class _InlineEditorDiffManager {
      constructor() {
        this.activeDiffs = /* @__PURE__ */ new Map();
      }
      static getInstance() {
        if (!_InlineEditorDiffManager.instance) {
          _InlineEditorDiffManager.instance = new _InlineEditorDiffManager();
        }
        return _InlineEditorDiffManager.instance;
      }
      /**
       * Adds or updates the record of an active diff.
       */
      addActiveDiff(filePath, diff) {
        if (this.hasDiff(filePath)) {
          this.removeActiveDiff(filePath);
        }
        this.activeDiffs.set(filePath, diff);
      }
      /**
       * Removes the record of an active diff and cleans up its UI components.
       */
      removeActiveDiff(filePath) {
        var _a;
        const activeDiff = this.activeDiffs.get(filePath);
        if (activeDiff) {
          (_a = activeDiff.notificationElement) == null ? void 0 : _a.remove();
          this.activeDiffs.delete(filePath);
        }
      }
      /**
       * Clears all active diff overlays from all editors.
       */
      clearAllDiffs(app) {
        const filePaths = Array.from(this.activeDiffs.keys());
        for (const filePath of filePaths) {
          clearDiffFromView(app, filePath);
        }
      }
      hasDiff(filePath) {
        return this.activeDiffs.has(filePath);
      }
      getDiffStats(filePath) {
        var _a, _b;
        return (_b = (_a = this.activeDiffs.get(filePath)) == null ? void 0 : _a.diffResult.stats) != null ? _b : null;
      }
      /**
       * Finds the active CodeMirror EditorView for a given file path.
       */
      findEditorViewForFile(app, filePath) {
        var _a, _b;
        const markdownView = this.findMarkdownViewForFile(app, filePath);
        return (_b = (_a = markdownView == null ? void 0 : markdownView.editor) == null ? void 0 : _a.cm) != null ? _b : null;
      }
      findMarkdownViewForFile(app, filePath) {
        var _a;
        const leaves = app.workspace.getLeavesOfType("markdown");
        for (const leaf of leaves) {
          const view = leaf.view;
          if (((_a = view.file) == null ? void 0 : _a.path) === filePath) {
            return view;
          }
        }
        return null;
      }
      /**
       * Creates and injects the notification banner above the editor.
       */
      createNotificationForView(view, filePath) {
        var _a;
        const activeDiff = this.activeDiffs.get(filePath);
        if (!activeDiff) return;
        (_a = activeDiff.notificationElement) == null ? void 0 : _a.remove();
        const stats = activeDiff.diffResult.stats;
        const banner = this.buildNotificationElement(stats, () => clearDiffFromView(view.app, filePath));
        const editorEl = view.dom;
        const parent = editorEl.parentElement;
        if (parent) {
          parent.insertBefore(banner, editorEl);
          activeDiff.notificationElement = banner;
        }
      }
      buildNotificationElement(stats, onClose) {
        const notification = document.createElement("div");
        notification.className = "cm-diff-notification";
        notification.setAttribute("role", "alert");
        const content = notification.createDiv("cm-diff-notification-content");
        content.createSpan({
          cls: "cm-diff-notification-icon",
          text: "\u26A0\uFE0F"
        });
        content.createSpan({
          cls: "cm-diff-notification-text",
          text: `Agent's Proposed Changes (+${stats.additions} / -${stats.deletions})`
        });
        const closeButton = content.createEl("button", {
          cls: "cm-diff-notification-close",
          text: "\u2715",
          attr: { "aria-label": "Dismiss changes" }
        });
        closeButton.addEventListener("click", onClose);
        return notification;
      }
    };
  }
});

// src/editors/inline-diff.ts
function buildDecorations(diff, state) {
  const builder = [];
  const doc = state.doc;
  let docLineNum = 1;
  for (const line of diff.lines) {
    if (line.type === "unchanged") {
      if (line.oldLineNumber) docLineNum = line.oldLineNumber + 1;
    } else if (line.type === "removed") {
      if (docLineNum <= doc.lines) {
        const lineInfo = doc.line(docLineNum);
        builder.push(
          import_view.Decoration.line({
            class: `cm-diff-line-original-removed`
          }).range(lineInfo.from, lineInfo.from)
        );
      }
      docLineNum++;
    } else if (line.type === "added") {
      const insertPos = docLineNum > 1 ? doc.line(docLineNum - 1).to : 0;
      builder.push(
        import_view.Decoration.widget({
          widget: new AddedLineWidget(line.content),
          block: true,
          side: 1
          // Insert after the position
        }).range(insertPos)
      );
    }
  }
  return import_view.Decoration.set(builder, true);
}
async function applyDiffToView(app, filePath, newContent) {
  const manager = InlineEditorDiffManager.getInstance();
  const view = manager.findEditorViewForFile(app, filePath);
  if (!view) {
    return false;
  }
  const originalContent = view.state.doc.toString();
  const diff = generateDiff(originalContent, newContent);
  manager.addActiveDiff(filePath, {
    view,
    diffResult: diff,
    notificationElement: null
  });
  view.dispatch({
    effects: setDiffEffect.of(diff)
  });
  manager.createNotificationForView(view, filePath);
  return true;
}
function clearDiffFromView(app, filePath) {
  const manager = InlineEditorDiffManager.getInstance();
  const view = manager.findEditorViewForFile(app, filePath);
  if (view) {
    view.dispatch({
      effects: clearDiffEffect.of(null)
    });
    manager.removeActiveDiff(filePath);
    return true;
  }
  return false;
}
var import_state, import_view, setDiffEffect, clearDiffEffect, AddedLineWidget, diffStateField, inlineDiffExtension;
var init_inline_diff = __esm({
  "src/editors/inline-diff.ts"() {
    import_state = require("@codemirror/state");
    import_view = require("@codemirror/view");
    init_diffUtils();
    init_InlineEditorDiffManager();
    setDiffEffect = import_state.StateEffect.define();
    clearDiffEffect = import_state.StateEffect.define();
    AddedLineWidget = class extends import_view.WidgetType {
      constructor(content) {
        super();
        this.content = content;
      }
      toDOM() {
        const el = document.createElement("div");
        el.className = "cm-diff-widget-added";
        const contentSpan = el.createSpan("cm-diff-widget-text");
        contentSpan.textContent = this.content || " ";
        return el;
      }
      ignoreEvent() {
        return false;
      }
    };
    diffStateField = import_state.StateField.define({
      create() {
        return import_view.Decoration.none;
      },
      update(value, tr) {
        for (const effect of tr.effects) {
          if (effect.is(setDiffEffect)) {
            if (effect.value) {
              return buildDecorations(effect.value, tr.state);
            }
            return import_view.Decoration.none;
          }
          if (effect.is(clearDiffEffect)) {
            return import_view.Decoration.none;
          }
        }
        return value.map(tr.changes);
      },
      provide: (f) => import_view.EditorView.decorations.from(f)
    });
    inlineDiffExtension = [
      diffStateField
    ];
  }
});

// src/utils/titleUtils.ts
function generateDefaultChatTitle() {
  const now = /* @__PURE__ */ new Date();
  return `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString()}`;
}
function sanitizeChatTitle(title) {
  return title.replace(/[\\/:*?"<>|]/g, "");
}
var init_titleUtils = __esm({
  "src/utils/titleUtils.ts"() {
  }
});

// src/core/TypedEventEmitter.ts
var TypedEventEmitter;
var init_TypedEventEmitter = __esm({
  "src/core/TypedEventEmitter.ts"() {
    TypedEventEmitter = class {
      constructor() {
        this.events = {};
      }
      /**
       * Register an event listener
       * @param eventName Event name (must be a key of T)
       * @param fn Function to call when event is emitted
       * @returns Unsubscribe function
       */
      on(eventName, fn) {
        if (!this.events[eventName]) {
          this.events[eventName] = [];
        }
        this.events[eventName].push(fn);
        return () => {
          this.events[eventName] = this.events[eventName].filter((l) => l !== fn);
        };
      }
      /**
       * Register a one-time event listener
       * @param eventName Event name (must be a key of T)
       * @param fn Function to call when event is emitted
       * @returns Unsubscribe function
       */
      once(eventName, fn) {
        const remove = this.on(eventName, (params) => {
          remove();
          fn(params);
        });
        return remove;
      }
      /**
       * Emit an event
       * @param eventName Event name (must be a key of T)
       * @param params Event parameters (must match T[K])
       */
      emit(eventName, params) {
        const callbacks = this.events[eventName];
        if (callbacks) {
          callbacks.forEach((callback) => callback(params));
        }
      }
      /**
       * Remove all listeners for an event
       * @param eventName Event name (must be a key of T)
       */
      off(eventName) {
        delete this.events[eventName];
      }
      /**
       * Remove all event listeners
       */
      clear() {
        this.events = {};
      }
      /**
       * Get the number of listeners for an event
       * @param eventName Event name
       * @returns Number of listeners
       */
      listenerCount(eventName) {
        var _a;
        return ((_a = this.events[eventName]) == null ? void 0 : _a.length) || 0;
      }
      /**
       * Get all event names that have listeners
       * @returns Array of event names
       */
      eventNames() {
        return Object.keys(this.events);
      }
    };
  }
});

// src/views/chatview/ToolCallManager.ts
var SAFE_READ_ONLY_TOOLS, ToolCallManager;
var init_ToolCallManager = __esm({
  "src/views/chatview/ToolCallManager.ts"() {
    init_TypedEventEmitter();
    init_toolDisplay();
    SAFE_READ_ONLY_TOOLS = /* @__PURE__ */ new Set([
      "read",
      "read_file",
      "list",
      "list_items",
      "find",
      "search",
      "open",
      "context",
      "resolve_path"
    ]);
    ToolCallManager = class {
      constructor(mcpService, chatView) {
        // Single source of truth - all tool calls by ID
        this.toolCalls = /* @__PURE__ */ new Map();
        // Tool registry - all available tools and their executors
        this.toolRegistry = /* @__PURE__ */ new Map();
        // Reference to chat view for agent mode check
        // Context management constants
        this.MAX_TOOL_RESULT_SIZE = 1e4;
        // 10KB max per tool result
        this.TRUNCATION_INDICATOR = "\n\n[... truncated for brevity ...]";
        this.mcpService = mcpService;
        this.chatView = chatView;
        this.events = new TypedEventEmitter();
      }
      /**
       * Decide whether a tool should be auto-approved, centralizing policy.
       * Mirrors previous heuristics but scoped to this chat and plugin settings.
       */
      shouldAutoApprove(toolName) {
        var _a;
        const plugin = (_a = this.chatView) == null ? void 0 : _a.plugin;
        const settings = (plugin == null ? void 0 : plugin.settings) || {};
        const { serverId, actualName } = this.extractToolNameParts(toolName);
        const canonicalName = actualName.toLowerCase();
        if (this.isExplicitlyAutoAccepted(toolName, canonicalName, serverId, settings)) {
          return true;
        }
        if (isMutatingTool(toolName)) {
          return false;
        }
        return SAFE_READ_ONLY_TOOLS.has(canonicalName);
      }
      /**
       * Provide OpenAI-compatible tools (internal registry + MCP) when Agent Mode is active.
       */
      async getOpenAITools() {
        if (this.chatView && !this.chatView.agentMode) {
          return [];
        }
        const results = [];
        for (const [name, entry] of this.toolRegistry) {
          const def = entry.definition;
          results.push({
            type: "function",
            function: {
              name: def.name,
              description: def.description,
              parameters: def.parameters
            }
          });
        }
        try {
          const mcpTools = await this.mcpService.getAvailableTools();
          results.push(...mcpTools);
        } catch (e) {
        }
        return results;
      }
      /**
       * Subscribe to tool call events
       */
      on(event, handler) {
        return this.events.on(event, handler);
      }
      /**
       * Create a new tool call from an LLM request
       */
      createToolCall(request, messageId, autoApprove = false) {
        var _a, _b;
        if (this.chatView && !this.chatView.agentMode) {
          const toolCall2 = {
            id: request.id,
            messageId,
            request,
            state: "denied",
            timestamp: Date.now(),
            autoApproved: false,
            result: {
              success: false,
              error: {
                code: "AGENT_MODE_DISABLED",
                message: "Tool call denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use tools."
              }
            }
          };
          this.toolCalls.set(toolCall2.id, toolCall2);
          this.events.emit("tool-call:created", { toolCall: toolCall2 });
          this.events.emit("tool-call:denied", { toolCallId: toolCall2.id, toolCall: toolCall2 });
          return toolCall2;
        }
        const toolName = (_b = (_a = request == null ? void 0 : request.function) == null ? void 0 : _a.name) != null ? _b : "";
        const effectiveAutoApprove = autoApprove || (toolName ? this.shouldAutoApprove(toolName) : false);
        const toolCall = {
          id: request.id,
          messageId,
          request,
          state: "pending",
          timestamp: Date.now(),
          autoApproved: effectiveAutoApprove
        };
        this.toolCalls.set(toolCall.id, toolCall);
        this.events.emit("tool-call:created", { toolCall });
        if (effectiveAutoApprove) {
          this.approveToolCall(toolCall.id);
        }
        return toolCall;
      }
      extractToolNameParts(toolName) {
        const firstUnderscoreIndex = toolName.indexOf("_");
        if (toolName.startsWith("mcp-") && firstUnderscoreIndex !== -1) {
          return {
            serverId: toolName.substring(0, firstUnderscoreIndex),
            actualName: toolName.substring(firstUnderscoreIndex + 1)
          };
        }
        return { serverId: null, actualName: toolName };
      }
      isExplicitlyAutoAccepted(originalName, canonicalName, serverId, settings) {
        const autoAcceptTools = ((settings == null ? void 0 : settings.mcpAutoAcceptTools) || []).map((entry) => entry.toLowerCase());
        if (autoAcceptTools.length === 0) {
          return false;
        }
        const normalizedOriginal = originalName.toLowerCase();
        if (autoAcceptTools.includes(normalizedOriginal) || autoAcceptTools.includes(canonicalName)) {
          return true;
        }
        if (serverId) {
          const serverKey = `${serverId.toLowerCase()}:${canonicalName}`;
          if (autoAcceptTools.includes(serverKey)) {
            return true;
          }
        }
        return false;
      }
      /**
       * Get a tool call by ID
       */
      getToolCall(id) {
        return this.toolCalls.get(id);
      }
      /**
       * Get all tool calls for a message
       */
      getToolCallsForMessage(messageId) {
        return Array.from(this.toolCalls.values()).filter((tc) => tc.messageId === messageId);
      }
      /**
       * Update tool call state
       */
      updateState(toolCallId, newState) {
        const toolCall = this.toolCalls.get(toolCallId);
        if (!toolCall) {
          return;
        }
        const previousState = toolCall.state;
        toolCall.state = newState;
        this.events.emit("tool-call:state-changed", {
          toolCallId,
          previousState,
          newState,
          toolCall
        });
      }
      /**
       * Approve a tool call
       */
      approveToolCall(toolCallId) {
        const toolCall = this.toolCalls.get(toolCallId);
        if (!toolCall || toolCall.state !== "pending") {
          return;
        }
        toolCall.approvedAt = Date.now();
        this.updateState(toolCallId, "approved");
        this.events.emit("tool-call:approved", { toolCallId, toolCall });
        void this.executeToolCall(toolCallId).catch((error) => {
          try {
            console.error(`[ToolCallManager] Execution failed for ${toolCallId}`, error);
          } catch (e) {
          }
        });
      }
      /**
       * Deny a tool call
       */
      denyToolCall(toolCallId) {
        const toolCall = this.toolCalls.get(toolCallId);
        if (!toolCall || toolCall.state !== "pending") {
          return;
        }
        toolCall.result = {
          success: false,
          error: {
            code: "USER_DENIED",
            message: "The user has explicitly denied this tool call request."
          }
        };
        this.updateState(toolCallId, "denied");
        this.events.emit("tool-call:denied", { toolCallId, toolCall });
      }
      /**
       * Cancels a pending tool call with a specific reason.
       * This is used when the user sends a follow-up message instead of approving.
       */
      cancelToolCall(toolCallId, reason) {
        const toolCall = this.toolCalls.get(toolCallId);
        if (!toolCall || toolCall.state !== "pending") {
          return;
        }
        toolCall.result = {
          success: false,
          error: {
            code: "USER_CANCELED",
            message: reason
          }
        };
        this.updateState(toolCallId, "denied");
        this.events.emit("tool-call:denied", { toolCallId, toolCall });
      }
      /**
       * Retrieves all tool calls currently in the 'pending' state.
       */
      getPendingToolCalls() {
        const pending = [];
        for (const toolCall of this.toolCalls.values()) {
          if (toolCall.state === "pending") {
            pending.push(toolCall);
          }
        }
        return pending;
      }
      /**
       * Execute a tool call
       */
      async executeToolCall(toolCallId, options) {
        var _a;
        const toolCall = this.toolCalls.get(toolCallId);
        if (!toolCall || toolCall.state !== "approved") {
          return;
        }
        try {
          toolCall.executionStartedAt = Date.now();
          this.updateState(toolCallId, "executing");
          try {
            console.log(`[ToolCallManager] Starting execution of tool call ${toolCallId}`, {
              toolName: toolCall.request.function.name,
              messageId: toolCall.messageId,
              autoApproved: toolCall.autoApproved
            });
          } catch (e) {
          }
          this.events.emit("tool-call:execution-started", { toolCallId, toolCall });
          let args;
          try {
            const { repairAndParseJson: repairAndParseJson2 } = await Promise.resolve().then(() => (init_jsonRepair(), jsonRepair_exports));
            const result2 = repairAndParseJson2(toolCall.request.function.arguments);
            if (result2.ok) {
              args = (_a = result2.value) != null ? _a : {};
            } else {
              throw new Error(result2.error || "Invalid JSON");
            }
          } catch (e) {
            throw new Error(`Invalid tool arguments: ${(e == null ? void 0 : e.message) || "Unknown parse error"}`);
          }
          const result = await this.executeTool(toolCall.request.function.name, args, options);
          toolCall.executionCompletedAt = Date.now();
          toolCall.result = result;
          this.updateState(toolCallId, result.success ? "completed" : "failed");
          if (result.success) {
            try {
              console.log(`[ToolCallManager] Tool call ${toolCallId} completed successfully`, {
                toolName: toolCall.request.function.name,
                messageId: toolCall.messageId,
                executionTime: toolCall.executionCompletedAt - (toolCall.executionStartedAt || 0),
                resultSuccess: result.success
              });
            } catch (e) {
            }
            this.events.emit("tool-call:execution-completed", {
              toolCallId,
              result,
              toolCall
            });
          } else {
            try {
              console.log(`[ToolCallManager] Tool call ${toolCallId} failed`, {
                toolName: toolCall.request.function.name,
                messageId: toolCall.messageId,
                executionTime: toolCall.executionCompletedAt - (toolCall.executionStartedAt || 0),
                error: result.error
              });
            } catch (e) {
            }
            this.events.emit("tool-call:execution-failed", {
              toolCallId,
              error: result.error,
              toolCall
            });
          }
        } catch (error) {
          const errorResult = {
            success: false,
            error: {
              code: "EXECUTION_ERROR",
              message: error.message || "Unknown error",
              details: error
            }
          };
          toolCall.executionCompletedAt = Date.now();
          toolCall.result = errorResult;
          this.updateState(toolCallId, "failed");
          this.events.emit("tool-call:execution-failed", {
            toolCallId,
            error: errorResult.error,
            toolCall
          });
        }
      }
      /**
       * Execute a tool by name
       */
      async executeTool(toolName, args, options) {
        try {
          if (this.chatView && !this.chatView.agentMode) {
            throw new Error("Tool execution denied: Agent mode is not enabled for this chat. Enable agent mode in the MCP tools modal to use tools.");
          }
          let resultData;
          if (toolName.startsWith("mcp-")) {
            resultData = await this.mcpService.executeTool(
              toolName,
              args,
              this.chatView
              // Pass chatView for additional agent mode check
            );
          } else {
            const tool = this.toolRegistry.get(toolName);
            if (tool) {
              resultData = await tool.executor(args, options);
            } else {
              throw new Error(`Tool not found: ${toolName}`);
            }
          }
          const processedData = this.processToolResult(resultData, toolName);
          return {
            success: true,
            data: processedData
          };
        } catch (error) {
          return {
            success: false,
            error: {
              code: "TOOL_EXECUTION_ERROR",
              message: error.message || "Tool execution failed",
              details: error
            }
          };
        }
      }
      /**
       * Register a tool
       */
      registerTool(definition, executor) {
        this.toolRegistry.set(definition.name, { definition, executor });
      }
      /**
       * Get all available tools (internal + MCP)
       */
      async getAvailableTools() {
        if (this.chatView && !this.chatView.agentMode) {
          return [];
        }
        const tools = [];
        for (const [name, entry] of this.toolRegistry) {
          tools.push(entry.definition);
        }
        if (this.mcpService) {
          const mcpTools = await this.mcpService.getAvailableTools();
          for (const tool of mcpTools) {
            tools.push({
              name: tool.function.name,
              description: tool.function.description,
              parameters: tool.function.parameters,
              autoApprove: false
              // MCP tools require approval by default
            });
          }
        }
        return tools;
      }
      /**
       * Serialize tool calls for persistence
       */
      serializeToolCall(toolCallId) {
        const toolCall = this.toolCalls.get(toolCallId);
        if (!toolCall) {
          return void 0;
        }
        return {
          id: toolCall.id,
          request: toolCall.request,
          state: toolCall.state,
          timestamp: toolCall.timestamp,
          approvedAt: toolCall.approvedAt,
          executionStartedAt: toolCall.executionStartedAt,
          executionCompletedAt: toolCall.executionCompletedAt,
          result: toolCall.result,
          autoApproved: toolCall.autoApproved
        };
      }
      /**
       * Deserialize and restore tool calls
       */
      restoreToolCall(serialized, messageId) {
        const toolCall = {
          ...serialized,
          messageId
        };
        this.toolCalls.set(toolCall.id, toolCall);
        return toolCall;
      }
      /**
       * Clear all tool calls (useful for cleanup)
       */
      clear() {
        this.toolCalls.clear();
        this.events.clear();
      }
      /**
       * Process and truncate tool results to prevent context bloat
       */
      processToolResult(data, toolName) {
        if (!data) return data;
        try {
          const serialized = JSON.stringify(data);
          if (serialized.length <= this.MAX_TOOL_RESULT_SIZE) {
            return data;
          }
          return this.truncateToolResult(data, toolName, serialized);
        } catch (error) {
          return {
            error: "Tool result processing failed",
            originalType: typeof data,
            toolName,
            details: error.message || "Unknown error"
          };
        }
      }
      /**
       * Intelligently truncate tool results based on tool type and content
       */
      truncateToolResult(data, toolName, serialized) {
        if (toolName.includes("read") || toolName.includes("file")) {
          return this.truncateFileResult(data);
        }
        if (toolName.includes("search") || toolName.includes("find")) {
          return this.truncateSearchResult(data);
        }
        if (toolName.includes("list") || toolName.includes("directory")) {
          return this.truncateListResult(data);
        }
        const maxLength = this.MAX_TOOL_RESULT_SIZE - this.TRUNCATION_INDICATOR.length;
        if (serialized.length > maxLength) {
          let truncated = serialized.substring(0, maxLength);
          let lastValidJson = "";
          const maxAttempts = Math.min(1e3, truncated.length);
          for (let i = truncated.length; i > truncated.length - maxAttempts && i > 0; i--) {
            try {
              const candidate = truncated.substring(0, i);
              JSON.parse(candidate);
              lastValidJson = candidate;
              break;
            } catch (e) {
            }
          }
          if (lastValidJson) {
            try {
              const parsed = JSON.parse(lastValidJson);
              if (typeof parsed === "object" && parsed !== null) {
                parsed.truncation_info = "Result truncated due to size limit.";
                return parsed;
              }
            } catch (e) {
            }
          }
          return {
            truncated_content: truncated.substring(0, maxLength - 100),
            truncation_info: "Result truncated due to size limit. Original format could not be preserved.",
            original_length: serialized.length
          };
        }
        return data;
      }
      /**
       * Truncate file reading results - keep metadata, truncate content
       */
      truncateFileResult(data) {
        if (typeof data === "object" && data.content) {
          const maxContentLength = this.MAX_TOOL_RESULT_SIZE - 500;
          return {
            ...data,
            content: data.content.length > maxContentLength ? data.content.substring(0, maxContentLength) + this.TRUNCATION_INDICATOR : data.content,
            truncated: data.content.length > maxContentLength,
            originalLength: data.content.length
          };
        }
        return data;
      }
      /**
       * Truncate search results - limit number of matches
       */
      truncateSearchResult(data) {
        if (Array.isArray(data)) {
          const maxResults = 10;
          return {
            results: data.slice(0, maxResults),
            totalFound: data.length,
            truncated: data.length > maxResults,
            showingFirst: maxResults
          };
        }
        if (typeof data === "object" && data.results && Array.isArray(data.results)) {
          const maxResults = 10;
          return {
            ...data,
            results: data.results.slice(0, maxResults),
            totalFound: data.results.length,
            truncated: data.results.length > maxResults,
            showingFirst: maxResults
          };
        }
        return data;
      }
      /**
       * Truncate list results - limit items and show summary
       */
      truncateListResult(data) {
        if (Array.isArray(data)) {
          const maxItems = 20;
          return {
            items: data.slice(0, maxItems),
            totalCount: data.length,
            truncated: data.length > maxItems,
            showingFirst: maxItems
          };
        }
        if (typeof data === "object" && data.files && Array.isArray(data.files)) {
          const maxFiles = 20;
          return {
            ...data,
            files: data.files.slice(0, maxFiles),
            totalFiles: data.files.length,
            truncated: data.files.length > maxFiles,
            showingFirst: maxFiles
          };
        }
        return data;
      }
      /**
       * Get tool results for context, applying the "last N" strategy
       */
      getToolResultsForContext() {
        const completedCalls = Array.from(this.toolCalls.values()).filter((tc) => {
          var _a;
          return tc.state === "completed" && ((_a = tc.result) == null ? void 0 : _a.success) && tc.executionCompletedAt;
        }).sort((a, b) => (b.executionCompletedAt || 0) - (a.executionCompletedAt || 0));
        return completedCalls;
      }
    };
  }
});

// src/views/chatview/utils/ToolCallFallback.ts
var ToolCallFallback_exports = {};
__export(ToolCallFallback_exports, {
  deriveChunkedToolCallsFromSchemaError: () => deriveChunkedToolCallsFromSchemaError
});
function safeParseJSON(input) {
  try {
    return JSON.parse(input);
  } catch (e) {
    return void 0;
  }
}
function deriveChunkedToolCallsFromSchemaError(err) {
  var _a;
  try {
    const rawError = ((_a = err == null ? void 0 : err.metadata) == null ? void 0 : _a.rawError) || (err == null ? void 0 : err.cause) || (err == null ? void 0 : err.rawError) || {};
    const message = String((rawError == null ? void 0 : rawError.message) || (err == null ? void 0 : err.message) || "");
    const lc = message.toLowerCase();
    if (!lc.includes("tool call validation failed") && !lc.includes("did not match schema")) {
      return null;
    }
    const failedGenStr = typeof (rawError == null ? void 0 : rawError.failed_generation) === "string" ? rawError.failed_generation : void 0;
    const failedGen = failedGenStr ? safeParseJSON(failedGenStr) : void 0;
    if (!failedGen || typeof failedGen !== "object") return null;
    const toolName = String((failedGen == null ? void 0 : failedGen.name) || "");
    if (!toolName || !toolName.startsWith("mcp-")) return null;
    const args = failedGen.arguments || {};
    const arrayKey = Array.isArray(args.items) ? "items" : Array.isArray(args.paths) ? "paths" : void 0;
    if (!arrayKey) return null;
    const arr = args[arrayKey];
    if (!Array.isArray(arr) || arr.length === 0) return null;
    const m = message.match(/maximum\s+(\d+)\s+items?\s+required/i);
    const chunkSize = Math.max(1, parseInt((m == null ? void 0 : m[1]) || "5", 10));
    if (arr.length <= chunkSize) return null;
    const chunks = [];
    for (let i = 0; i < arr.length; i += chunkSize) {
      const slice = arr.slice(i, i + chunkSize);
      chunks.push({ [arrayKey]: slice });
    }
    return { toolName, chunkSize, chunks };
  } catch (e) {
    return null;
  }
}
var init_ToolCallFallback = __esm({
  "src/views/chatview/utils/ToolCallFallback.ts"() {
  }
});

// src/utils/textUtils.ts
var textUtils_exports = {};
__export(textUtils_exports, {
  trimOuterBlankLines: () => trimOuterBlankLines
});
function trimOuterBlankLines(input) {
  if (input == null) return "";
  let text = String(input);
  text = text.replace(/^(?:[ \t]*\r?\n)+/, "");
  text = text.replace(/(?:\r?\n[ \t]*)+$/, "");
  return text;
}
var init_textUtils = __esm({
  "src/utils/textUtils.ts"() {
  }
});

// src/views/chatview/handlers/AgentMode.ts
var AgentMode_exports = {};
__export(AgentMode_exports, {
  disableAgentModeForChat: () => disableAgentModeForChat,
  enableAgentModeForChat: () => enableAgentModeForChat
});
async function enableAgentModeForChat(ctx) {
  var _a;
  const { plugin, chatView } = ctx;
  if (!chatView) return;
  chatView.agentMode = true;
  try {
    await plugin.getSettingsManager().updateSettings({ defaultAgentMode: true });
  } catch (e) {
  }
  try {
    if (chatView.contextManager && !chatView.contextManager.isVaultStructureIncluded()) {
      await chatView.contextManager.toggleVaultStructure();
    }
  } catch (e) {
  }
  const { SystemPromptService: SystemPromptService2 } = await Promise.resolve().then(() => (init_SystemPromptService(), SystemPromptService_exports));
  const service = SystemPromptService2.getInstance(plugin.app, () => plugin.settings);
  chatView.currentPrompt = await service.getSystemPromptContent("agent", void 0, true);
  try {
    const currentModelId = chatView.selectedModelId || plugin.settings.selectedModelId;
    if (currentModelId) {
      const compatibility = await plugin.modelService.checkToolCompatibility(currentModelId);
      if (!compatibility.isCompatible && compatibility.confidence === "high") {
        new import_obsidian83.Notice(`The current model may not support tools. Agent Mode works best with tool-capable models.`, 6e3);
        const { StandardModelSelectionModal: StandardModelSelectionModal2 } = await Promise.resolve().then(() => (init_StandardModelSelectionModal(), StandardModelSelectionModal_exports));
        const modal = new StandardModelSelectionModal2({
          app: plugin.app,
          plugin,
          currentModelId,
          onSelect: async (result) => {
            await chatView.setSelectedModelId(result.modelId);
            new import_obsidian83.Notice("Switched to a tool-capable model (recommended for Agent Mode)", 4e3);
          }
        });
        modal.open();
      }
    }
  } catch (e) {
  }
  new import_obsidian83.Notice("Agent Mode enabled", 3e3);
  await chatView.saveChat();
  if (chatView.updateSystemPromptIndicator) await chatView.updateSystemPromptIndicator();
  if (chatView.updateModelIndicator) await chatView.updateModelIndicator();
  try {
    if (((_a = chatView.messages) == null ? void 0 : _a.length) === 0) chatView.displayChatStatus();
  } catch (e) {
  }
}
async function disableAgentModeForChat(ctx) {
  var _a, _b, _c;
  const { plugin, chatView } = ctx;
  if (!chatView) return;
  chatView.agentMode = false;
  try {
    await plugin.getSettingsManager().updateSettings({ defaultAgentMode: false });
  } catch (e) {
  }
  const defaultType = ((_a = plugin.settings) == null ? void 0 : _a.systemPromptType) || "general-use";
  const defaultPath = ((_b = plugin.settings) == null ? void 0 : _b.systemPromptPath) || void 0;
  if (chatView.systemPromptType === "agent") {
    chatView.systemPromptType = defaultType === "agent" ? "general-use" : defaultType;
    chatView.systemPromptPath = chatView.systemPromptType === "custom" ? defaultPath : void 0;
  }
  try {
    if (chatView.contextManager && chatView.contextManager.isVaultStructureIncluded()) {
      await chatView.contextManager.toggleVaultStructure();
    }
  } catch (e) {
  }
  new import_obsidian83.Notice("Agent Mode disabled - Model and system prompt changes are now available", 3e3);
  await chatView.saveChat();
  if (chatView.updateSystemPromptIndicator) await chatView.updateSystemPromptIndicator();
  if (chatView.updateModelIndicator) await chatView.updateModelIndicator();
  try {
    if (((_c = chatView.messages) == null ? void 0 : _c.length) === 0) chatView.displayChatStatus();
  } catch (e) {
  }
}
var import_obsidian83;
var init_AgentMode = __esm({
  "src/views/chatview/handlers/AgentMode.ts"() {
    import_obsidian83 = require("obsidian");
  }
});

// src/utils/messages/toApiMessages.ts
var toApiMessages_exports = {};
__export(toApiMessages_exports, {
  toApiBaseMessages: () => toApiBaseMessages
});
function toApiBaseMessages(messages) {
  return messages.map((m) => {
    const cleaned = {
      role: m.role,
      content: m.content,
      message_id: m.message_id
    };
    if (m.tool_call_id) cleaned.tool_call_id = m.tool_call_id;
    if (m.name) cleaned.name = m.name;
    if (m.tool_calls) cleaned.tool_calls = m.tool_calls;
    if (m.documentContext) cleaned.documentContext = m.documentContext;
    if (m.systemPromptType) cleaned.systemPromptType = m.systemPromptType;
    if (m.systemPromptPath) cleaned.systemPromptPath = m.systemPromptPath;
    return cleaned;
  });
}
var init_toApiMessages = __esm({
  "src/utils/messages/toApiMessages.ts"() {
  }
});

// src/services/TitleGenerationService.ts
var import_obsidian89, TitleGenerationService;
var init_TitleGenerationService = __esm({
  "src/services/TitleGenerationService.ts"() {
    init_SystemSculptService();
    init_types();
    import_obsidian89 = require("obsidian");
    init_titleUtils();
    init_modelUtils();
    init_errors();
    init_PopupModal();
    init_StandardModelSelectionModal();
    TitleGenerationService = class _TitleGenerationService {
      constructor(plugin) {
        this.plugin = plugin;
        this.defaultModelId = null;
        this.sculptService = SystemSculptService.getInstance(plugin);
      }
      /**
       * Get the singleton instance of the TitleGenerationService
       * @param plugin The SystemSculptPlugin instance
       * @returns The TitleGenerationService instance
       */
      static getInstance(plugin) {
        if (!_TitleGenerationService.instance) {
          _TitleGenerationService.instance = new _TitleGenerationService(plugin);
        }
        return _TitleGenerationService.instance;
      }
      /**
       * Sanitizes a title to ensure it doesn't contain characters that are invalid in filenames
       * @param title The title to sanitize
       * @returns A sanitized title safe for use as a filename
       */
      sanitizeTitle(title) {
        return sanitizeChatTitle(title);
      }
      /**
       * Helper method to determine if we're in note context
       */
      isNoteContext(messages) {
        return messages instanceof import_obsidian89.TFile;
      }
      /**
       * Get the prompt content to use for title generation
       * Handles different prompt types and custom prompts from files
       * @param isNoteContext Whether the content is a note (true) or chat (false)
       * @returns The prompt content to use
       */
      async getTitleGenerationPrompt(isNoteContext = false) {
        const { titleGenerationPromptType, titleGenerationPrompt, titleGenerationPromptPath } = this.plugin.settings;
        if (titleGenerationPrompt) {
          return this.adaptPromptToContext(titleGenerationPrompt, isNoteContext);
        }
        if (titleGenerationPromptType === "precise") {
          return this.adaptPromptToContext(DEFAULT_TITLE_GENERATION_PROMPT, isNoteContext);
        }
        if (titleGenerationPromptType === "movie-style") {
          const movieStylePrompt = `You are a creative title generation assistant focused on creating engaging, movie-style titles.

Your task is to analyze the provided ${isNoteContext ? "note" : "conversation"} and generate a single, attention-grabbing title that:
- Has a cinematic, dramatic quality similar to movie titles
- Uses creative, evocative language that captures the essence of the ${isNoteContext ? "note" : "conversation"}
- Is between 2-6 words long
- May use metaphors, wordplay, or allusions when appropriate
- Maintains proper capitalization (typically capitalize all major words)
- NEVER includes characters that are invalid in filenames: \\ / : * ? " < > |
- Uses proper spacing between all words

The title should be memorable and distinctive while still reflecting the actual content of the ${isNoteContext ? "note" : "conversation"}.
Respond with ONLY the title, nothing else.`;
          return movieStylePrompt;
        }
        if (titleGenerationPromptType === "custom" && titleGenerationPromptPath) {
          try {
            const file = this.plugin.app.vault.getAbstractFileByPath(titleGenerationPromptPath);
            if (file instanceof import_obsidian89.TFile) {
              const promptContent = await this.plugin.app.vault.read(file);
              return this.adaptPromptToContext(promptContent, isNoteContext);
            }
          } catch (error) {
          }
        }
        return this.adaptPromptToContext(DEFAULT_TITLE_GENERATION_PROMPT, isNoteContext);
      }
      /**
       * Adapt a prompt to the current context (note or chat)
       * @param prompt The original prompt
       * @param isNoteContext Whether the content is a note (true) or chat (false)
       * @returns The adapted prompt
       */
      adaptPromptToContext(prompt, isNoteContext) {
        if (isNoteContext) {
          return prompt.replace(/conversation/gi, "note").replace(/chat/gi, "note").replace(/messages/gi, "content");
        }
        return prompt;
      }
      /**
       * Generate a title based on the content of messages or a file
       * @param messages The chat messages or file to generate a title for
       * @param onProgress Optional callback for progress updates with the current title
       * @param onStatusUpdate Optional callback for status updates
       * @param additionalContext Optional additional context from user to help with title generation
       * @param retryCount Internal retry counter to prevent infinite loops
       * @returns The generated title
       */
      async generateTitle(messages, onProgress, onStatusUpdate, additionalContext, retryCount = 0) {
        var _a;
        let canonicalModelId = "";
        let usedFallback = false;
        try {
          const useLatestEverywhere = (_a = this.plugin.settings.useLatestModelEverywhere) != null ? _a : true;
          const isStandardMode = this.plugin.settings.settingsMode !== "advanced";
          const tgId = useLatestEverywhere || isStandardMode ? "" : this.plugin.settings.titleGenerationModelId;
          const tgProvider = useLatestEverywhere || isStandardMode ? "" : this.plugin.settings.titleGenerationProviderId;
          if (tgId) {
            if (tgId.includes("@@")) {
              canonicalModelId = tgId;
            } else if (tgProvider) {
              canonicalModelId = createCanonicalId(tgProvider, tgId);
            } else {
              canonicalModelId = ensureCanonicalId(tgId);
            }
          } else {
            const globalDefault = this.plugin.settings.selectedModelId;
            if (globalDefault) {
              canonicalModelId = ensureCanonicalId(globalDefault);
            }
          }
          if (!canonicalModelId) {
            throw new Error("Failed to determine a valid model for title generation.");
          }
          try {
            const { isAvailable, alternativeModel } = await this.plugin.modelService.validateSpecificModel(canonicalModelId);
            if (!isAvailable && alternativeModel) {
              canonicalModelId = alternativeModel.id;
              usedFallback = true;
            }
          } catch (_) {
          }
          let contentXml = "";
          if (messages instanceof import_obsidian89.TFile) {
            onStatusUpdate == null ? void 0 : onStatusUpdate(20, "Reading note content...");
            const content = await this.plugin.app.vault.read(messages);
            contentXml = `<content_to_generate_title_from>
<note_title>${messages.basename}</note_title>
<note_content>
${content}
</note_content>
${additionalContext ? `<user_provided_context>
${additionalContext}
</user_provided_context>` : ""}
</content_to_generate_title_from>`;
          } else {
            onStatusUpdate == null ? void 0 : onStatusUpdate(20, "Processing chat messages...");
            if (!messages.length) {
              throw new Error("No chat messages to generate a title from.");
            }
            const messagesToUse = messages.slice(0, 25);
            contentXml = `<content_to_generate_title_from>
${messagesToUse.map((msg) => {
              let contentStr = "";
              if (typeof msg.content === "string") {
                contentStr = msg.content;
              } else if (Array.isArray(msg.content)) {
                contentStr = msg.content.filter((part) => part.type === "text").map((part) => part.text).join("\n");
              }
              return `[${msg.role}]: ${contentStr}`;
            }).join("\n")}
${additionalContext ? `
<user_provided_context>
${additionalContext}
</user_provided_context>` : ""}
</content_to_generate_title_from>`;
          }
          onStatusUpdate == null ? void 0 : onStatusUpdate(40, "Analyzing content...");
          const isNoteContext = messages instanceof import_obsidian89.TFile;
          const systemPromptContent = await this.getTitleGenerationPrompt(isNoteContext);
          const promptMessages = [
            {
              role: "system",
              content: systemPromptContent,
              message_id: crypto.randomUUID()
            },
            {
              role: "user",
              content: contentXml,
              message_id: crypto.randomUUID()
            }
          ];
          let generatedTitle = "";
          const parsedForStatus = parseCanonicalId(canonicalModelId);
          const statusModelId = (parsedForStatus == null ? void 0 : parsedForStatus.modelId) || canonicalModelId;
          onStatusUpdate == null ? void 0 : onStatusUpdate(60, `Generating title using ${statusModelId}${usedFallback ? " (fallback)" : ""}...`);
          const timeoutPromise = new Promise((_, reject) => {
            setTimeout(() => reject(new Error("Title generation timed out after 30 seconds")), 3e4);
          });
          const streamingPromise = (async () => {
            const stream = this.sculptService.streamMessage({
              messages: promptMessages,
              model: canonicalModelId
            });
            for await (const event of stream) {
              if (event.type === "content") {
                generatedTitle += event.text;
                if (onProgress) {
                  onProgress(generatedTitle.trim());
                }
              }
            }
            return generatedTitle;
          })();
          generatedTitle = await Promise.race([streamingPromise, timeoutPromise]);
          onStatusUpdate == null ? void 0 : onStatusUpdate(80, "Finalizing title...");
          const finalTitle = this.sanitizeTitle(generatedTitle.trim());
          if (!finalTitle) {
            return "Untitled Chat";
          }
          return finalTitle;
        } catch (error) {
          if (error instanceof SystemSculptError && (error.code === ERROR_CODES.MODEL_UNAVAILABLE || error.code === ERROR_CODES.MODEL_REQUEST_ERROR)) {
            if (retryCount >= 2) {
              new import_obsidian89.Notice("Unable to generate title after multiple attempts. Using default title.", 5e3);
              return this.isNoteContext(messages) ? "Untitled Note" : "Untitled Chat";
            }
            try {
              const parsedModel = parseCanonicalId(canonicalModelId);
              const modelDisplayName = (parsedModel == null ? void 0 : parsedModel.modelId) || canonicalModelId;
              const errorMessage = `The model "${modelDisplayName}" is not available for title generation. This could be because the model is not found, the provider is unavailable, or the model requires different configuration.`;
              const wantToSelectModel = await showPopup(
                this.plugin.app,
                errorMessage + "\n\nWould you like to select a different model for title generation?",
                {
                  title: "Title Generation Failed",
                  primaryButton: "Select Model",
                  secondaryButton: "Cancel",
                  icon: "alert-circle"
                }
              );
              if (wantToSelectModel == null ? void 0 : wantToSelectModel.confirmed) {
                const modelSelectionResult = await new Promise((resolve) => {
                  const modelSelectionModal = new StandardModelSelectionModal({
                    app: this.plugin.app,
                    plugin: this.plugin,
                    currentModelId: this.plugin.settings.titleGenerationModelId || this.plugin.settings.selectedModelId || "",
                    onSelect: async (result) => {
                      if (result && result.modelId) {
                        const parsed = parseCanonicalId(result.modelId);
                        if (parsed) {
                          await this.plugin.getSettingsManager().updateSettings({
                            titleGenerationProviderId: parsed.providerId,
                            titleGenerationModelId: result.modelId
                          });
                          new import_obsidian89.Notice(`Title generation model set to: ${parsed.providerId} / ${parsed.modelId}`);
                        }
                        resolve(result);
                      } else {
                        resolve(null);
                      }
                    }
                  });
                  modelSelectionModal.open();
                });
                if (modelSelectionResult && modelSelectionResult.modelId) {
                  return await this.generateTitle(messages, onProgress, onStatusUpdate, additionalContext, retryCount + 1);
                } else {
                  new import_obsidian89.Notice("Title generation cancelled. Using default title.", 3e3);
                  return this.isNoteContext(messages) ? "Untitled Note" : "Untitled Chat";
                }
              } else {
                new import_obsidian89.Notice("Title generation cancelled. Using default title.", 3e3);
                return this.isNoteContext(messages) ? "Untitled Note" : "Untitled Chat";
              }
            } catch (modalError) {
              new import_obsidian89.Notice(`Title generation failed: ${error.message}`, 5e3);
              throw error;
            }
          } else {
            const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
            new import_obsidian89.Notice(`Title generation failed: ${errorMessage}`, 5e3);
            throw error;
          }
        }
      }
    };
  }
});

// src/modals/DefaultChatPresetsModal.ts
var DefaultChatPresetsModal_exports = {};
__export(DefaultChatPresetsModal_exports, {
  DefaultChatPresetsModal: () => DefaultChatPresetsModal
});
var import_obsidian90, CustomPromptFileSuggestModal, DefaultChatPresetsModal;
var init_DefaultChatPresetsModal = __esm({
  "src/modals/DefaultChatPresetsModal.ts"() {
    import_obsidian90 = require("obsidian");
    init_modelUtils();
    init_StandardModelSelectionModal();
    init_SystemPromptService();
    CustomPromptFileSuggestModal = class extends import_obsidian90.SuggestModal {
      constructor(app, systemPromptService, onSelect) {
        super(app);
        this.systemPromptService = systemPromptService;
        this.onSelectCallback = onSelect;
        this.setPlaceholder("Select a custom system prompt file...");
      }
      async getSuggestions(query) {
        const files = await this.systemPromptService.getCustomPromptFiles();
        if (!query) {
          return files;
        }
        return files.filter((file) => file.name.toLowerCase().includes(query.toLowerCase()));
      }
      renderSuggestion(file, el) {
        el.createEl("div", { text: file.name });
        el.createEl("small", { text: file.path, cls: "ss-suggestion-path" });
      }
      onChooseSuggestion(file, evt) {
        this.onSelectCallback(file);
      }
    };
    DefaultChatPresetsModal = class extends import_obsidian90.Modal {
      constructor(app, plugin) {
        super(app);
        this.promptTypeBtns = {};
        this.plugin = plugin;
        this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.plugin.settings);
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Default Chat Presets" });
        contentEl.createEl("p", {
          text: "Set your default AI model and system prompt type for new chats. These presets will be used every time you start a new, fresh chat."
        });
        const modelSection = contentEl.createDiv("modal-section");
        modelSection.createEl("h3", { text: "Default AI Model" });
        new import_obsidian90.Setting(modelSection).setName("AI Model").setDesc("Select the default model for new chats").addText((text) => {
          text.setPlaceholder("Model").setValue(this.plugin.settings.selectedModelId ? getModelLabelWithProvider(ensureCanonicalId(this.plugin.settings.selectedModelId)) : "No model selected").setDisabled(true);
        }).addButton((button) => {
          button.setButtonText("Change Model").setCta().onClick(() => this.openModelSelectModal());
        });
        const titleGenModelSection = contentEl.createDiv("modal-section");
        titleGenModelSection.createEl("h3", { text: "Default Title Generation Model" });
        new import_obsidian90.Setting(titleGenModelSection).setName("Title Generation Model").setDesc("Select the default model for generating chat titles").addText((text) => {
          text.setPlaceholder("Model").setValue(this.plugin.settings.titleGenerationModelId ? getModelLabelWithProvider(ensureCanonicalId(this.plugin.settings.titleGenerationModelId)) : "Same as chat model").setDisabled(true);
        }).addButton((button) => {
          button.setButtonText("Change Model").setCta().onClick(() => this.openTitleGenModelSelectModal());
        });
        const promptSection = contentEl.createDiv("modal-section");
        promptSection.createEl("h3", { text: "Default System Prompt Type" });
        this.defaultInfoEl = promptSection.createEl("div", {
          cls: "setting-item-description"
        });
        await this.updateDefaultInfo();
        const promptSetting = new import_obsidian90.Setting(promptSection).setName("System Prompt").setDesc("Choose the default system prompt type for new chats");
        const buttonContainer = promptSetting.controlEl.createDiv({ cls: "ss-modal-button-container--grid" });
        ["general-use", "concise", "custom"].forEach((type) => {
          const displayText = type === "general-use" ? "General Use" : type.charAt(0).toUpperCase() + type.slice(1);
          const button = buttonContainer.createEl("button", {
            text: displayText,
            cls: this.plugin.settings.systemPromptType === type ? "mod-cta" : ""
          });
          this.promptTypeBtns[type] = button;
          button.onclick = async () => {
            if (type !== "custom") {
              await this.plugin.getSettingsManager().updateSettings({
                systemPromptType: type,
                systemPromptPath: ""
              });
              await this.saveAndNotify(displayText);
            } else {
              await this.plugin.getSettingsManager().updateSettings({
                systemPromptType: type
              });
              this.updateButtonStyles();
              this.openCustomPromptPicker();
            }
          };
        });
        this.customPromptInfo = promptSection.createDiv("custom-prompt-info ss-modal-custom-prompt-info");
        this.updateCustomPromptInfo();
      }
      async saveAndNotify(promptName) {
        var _a, _b;
        await this.plugin.getSettingsManager().saveSettings();
        (_b = (_a = this.plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
        new import_obsidian90.Notice(`Default system prompt set to ${promptName}`, 2e3);
        this.updateButtonStyles();
        this.updateCustomPromptInfo();
        await this.updateDefaultInfo();
      }
      async updateDefaultInfo() {
        const type = this.plugin.settings.systemPromptType;
        let displayText = "";
        if (type === "agent") {
          await this.plugin.getSettingsManager().updateSettings({
            systemPromptType: "general-use",
            systemPromptPath: ""
          });
          displayText = "General Use (auto-switched from Agent Mode - now per-chat only)";
        } else if (type === "general-use") {
          displayText = "General Use";
        } else if (type === "concise") {
          displayText = "Concise";
        } else if (type === "custom") {
          if (this.plugin.settings.systemPromptPath) {
            const file = this.app.vault.getAbstractFileByPath(this.plugin.settings.systemPromptPath);
            if (!file) {
              await this.plugin.getSettingsManager().updateSettings({
                systemPromptType: "general-use",
                systemPromptPath: ""
              });
              displayText = "General Use (auto-switched from missing custom file)";
            } else {
              const pathParts = this.plugin.settings.systemPromptPath.split("/");
              const fileName = pathParts[pathParts.length - 1];
              displayText = `Custom: ${fileName}`;
            }
          } else {
            displayText = "Custom (no file selected)";
          }
        } else {
          const validDefaultTypes = ["general-use", "concise", "custom"];
          if (!validDefaultTypes.includes(type)) {
            await this.plugin.getSettingsManager().updateSettings({
              systemPromptType: "general-use",
              systemPromptPath: ""
            });
            displayText = "General Use (auto-switched from invalid type)";
          } else {
            displayText = "General Use";
          }
        }
        this.defaultInfoEl.setText(`Current default for new chats: ${displayText}`);
      }
      updateButtonStyles() {
        Object.values(this.promptTypeBtns).forEach((btn) => {
          btn.removeClass("mod-cta");
          btn.removeClass("mod-primary");
        });
        const currentType = this.plugin.settings.systemPromptType;
        if (this.promptTypeBtns[currentType]) {
          this.promptTypeBtns[currentType].addClass("mod-cta");
        }
      }
      updateCustomPromptInfo() {
        this.customPromptInfo.empty();
        if (this.plugin.settings.systemPromptType === "custom") {
          this.customPromptInfo.addClass("ss-modal-custom-prompt-info--visible");
          if (this.plugin.settings.systemPromptPath) {
            const pathParts = this.plugin.settings.systemPromptPath.split("/");
            const fileName = pathParts[pathParts.length - 1];
            this.customPromptInfo.createEl("div", {
              text: `Selected custom prompt: ${fileName}`,
              cls: "setting-item-description"
            });
            const changeBtn = this.customPromptInfo.createEl("button", {
              text: "Change Custom Prompt",
              cls: "mod-warning ss-modal-button--small"
            });
            changeBtn.onclick = () => this.openCustomPromptPicker();
          } else {
            this.customPromptInfo.createEl("div", {
              text: "No custom prompt selected. Please choose one.",
              cls: "setting-item-description mod-warning"
            });
            const selectBtn = this.customPromptInfo.createEl("button", {
              text: "Select Custom Prompt",
              cls: "mod-cta ss-modal-button--small"
            });
            selectBtn.onclick = () => this.openCustomPromptPicker();
          }
        } else {
          this.customPromptInfo.removeClass("ss-modal-custom-prompt-info--visible");
        }
      }
      openCustomPromptPicker() {
        new CustomPromptFileSuggestModal(
          this.app,
          this.systemPromptService,
          async (file) => {
            await this.plugin.getSettingsManager().updateSettings({
              systemPromptPath: file.path
            });
            await this.saveAndNotify(`Custom: ${file.name}`);
          }
        ).open();
      }
      openModelSelectModal() {
        const modal = new StandardModelSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentModelId: this.plugin.settings.selectedModelId || "",
          onSelect: async (result) => {
            var _a, _b;
            try {
              const canonicalId = ensureCanonicalId(result.modelId);
              await this.plugin.getSettingsManager().updateSettings({
                selectedModelId: canonicalId
              });
              (_b = (_a = this.plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
              new import_obsidian90.Notice("Default model updated successfully.", 3e3);
              const input = this.contentEl.querySelector("input[type='text']");
              if (input) {
                input.value = getModelLabelWithProvider(canonicalId);
              }
            } catch (error) {
              new import_obsidian90.Notice("Failed to update default model", 1e4);
            }
          }
        });
        modal.open();
      }
      openTitleGenModelSelectModal() {
        const modal = new StandardModelSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentModelId: this.plugin.settings.titleGenerationModelId || this.plugin.settings.selectedModelId || "",
          onSelect: async (result) => {
            var _a, _b;
            try {
              const canonicalId = ensureCanonicalId(result.modelId);
              const parsed = parseCanonicalId(canonicalId);
              if (parsed) {
                await this.plugin.getSettingsManager().updateSettings({
                  titleGenerationModelId: canonicalId,
                  titleGenerationProviderId: parsed.providerId
                });
              } else {
                await this.plugin.getSettingsManager().updateSettings({
                  titleGenerationModelId: canonicalId
                });
              }
              (_b = (_a = this.plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
              new import_obsidian90.Notice("Title generation model updated successfully.", 3e3);
              const titleGenModelInput = this.contentEl.querySelectorAll("input[type='text']")[1];
              if (titleGenModelInput) {
                titleGenModelInput.value = getModelLabelWithProvider(canonicalId);
              }
            } catch (error) {
              new import_obsidian90.Notice("Failed to update title generation model", 1e4);
            }
          }
        });
        modal.open();
      }
    };
  }
});

// src/modals/SystemSculptSearchModal.ts
var SystemSculptSearchModal_exports = {};
__export(SystemSculptSearchModal_exports, {
  SystemSculptSearchModal: () => SystemSculptSearchModal
});
var import_obsidian101, SystemSculptSearchModal;
var init_SystemSculptSearchModal = __esm({
  "src/modals/SystemSculptSearchModal.ts"() {
    import_obsidian101 = require("obsidian");
    init_StandardModal();
    init_searchScoring();
    init_utils();
    SystemSculptSearchModal = class extends StandardModal {
      constructor(plugin) {
        super(plugin.app);
        this.searchInputEl = null;
        this.listEl = null;
        this.currentQuery = "";
        this.debounceHandle = null;
        this.querySerial = 0;
        this.lastRenderedSerial = 0;
        this.plugin = plugin;
        this.setSize("large");
      }
      onOpen() {
        super.onOpen();
        this.addTitle("SystemSculpt Search", "Type anything \u2013 we'll find the most relevant notes across your vault.");
        this.searchInputEl = this.addSearchBar("Search your vault (lexical + semantic)...", (query) => {
          this.onSearchChange(query);
        });
        this.listEl = this.contentEl.createDiv({ cls: "ss-modal__list" });
        this.addActionButton("Copy Results", () => this.copyResults(), false);
        this.addActionButton("Close", () => this.close(), false);
        this.registerDomEvent(this.modalEl, "keydown", (e) => {
          var _a;
          const ev = e;
          if (ev.key === "Enter" && !ev.shiftKey) {
            const first = (_a = this.listEl) == null ? void 0 : _a.querySelector(".ss-modal__item");
            if (first) {
              first.click();
              ev.preventDefault();
            }
          }
        });
        setTimeout(() => {
          var _a;
          return (_a = this.searchInputEl) == null ? void 0 : _a.focus();
        }, 0);
        this.renderRecentFiles();
      }
      onClose() {
        if (this.debounceHandle) {
          window.clearTimeout(this.debounceHandle);
          this.debounceHandle = null;
        }
        super.onClose();
      }
      onSearchChange(query) {
        this.currentQuery = query;
        if (this.debounceHandle) {
          window.clearTimeout(this.debounceHandle);
          this.debounceHandle = null;
        }
        this.debounceHandle = window.setTimeout(() => {
          this.executeSearch(query).catch(() => {
          });
        }, 200);
      }
      async executeSearch(query) {
        const trimmed = query.trim();
        const serial = ++this.querySerial;
        if (!trimmed) {
          this.renderRecentFiles();
          return;
        }
        this.renderLoading("Searching...");
        const [lexResults, semResults] = await Promise.all([
          this.runLexicalSearch(trimmed, 75).catch(() => []),
          this.runSemanticSearch(trimmed, 50).catch(() => [])
        ]);
        if (serial < this.querySerial) {
          return;
        }
        const merged = this.mergeAndRank(lexResults, semResults, trimmed);
        const enhanced = await this.enhanceWithExcerpts(merged.slice(0, 50), trimmed).catch(() => merged.slice(0, 50));
        if (serial < this.querySerial) return;
        this.renderResults(enhanced);
        this.lastRenderedSerial = serial;
      }
      async runLexicalSearch(query, limit) {
        var _a, _b;
        const app = this.app;
        const allFiles = ((_b = (_a = this.plugin.vaultFileCache) == null ? void 0 : _a.getMarkdownFiles) == null ? void 0 : _b.call(_a)) || app.vault.getMarkdownFiles();
        const files = allFiles.filter((f) => !shouldExcludeFromSearch(f, this.plugin));
        const lowerQuery = query.toLowerCase();
        const originalTerms = query.toLowerCase().split(/\s+/).filter(Boolean);
        const terms = extractSearchTerms(query);
        const ranked = files.map((f) => {
          const hay = `${f.basename} ${f.path}`;
          const score = fuzzyMatchScore(lowerQuery, hay.toLowerCase());
          return { file: f, rank: score === null ? Number.MAX_SAFE_INTEGER : score };
        }).sort((a, b) => a.rank - b.rank).slice(0, Math.min(files.length, 500)).map((r) => r.file);
        const context = { searchTerms: terms, originalQuery: query };
        const scored = await runWithConcurrency(ranked.map((f) => f.path), async (path) => {
          const f = app.vault.getAbstractFileByPath(path);
          if (!(f instanceof import_obsidian101.TFile)) return null;
          try {
            const content = await app.vault.read(f);
            const limited = content.length > 2e4 ? content.substring(0, 2e4) : content;
            const result = calculateScore(f.path, limited, context);
            if (result.score <= 0) return null;
            return {
              path: f.path,
              title: f.basename,
              score: Math.max(0, Math.min(1, result.score / 100)),
              lexScore: Math.max(0, Math.min(1, result.score / 100))
            };
          } catch (e) {
            return null;
          }
        }, 10);
        const filtered = scored.filter(Boolean).sort((a, b) => (b.lexScore || 0) - (a.lexScore || 0)).slice(0, limit);
        return filtered;
      }
      async runSemanticSearch(query, limit) {
        try {
          if (!this.plugin.settings.embeddingsEnabled) return [];
          const manager = this.plugin.getOrCreateEmbeddingsManager();
          if (typeof manager.awaitReady === "function") {
            await manager.awaitReady();
          }
          const results = await manager.searchSimilar(query, limit);
          return results.map((r) => {
            var _a, _b, _c;
            return {
              path: r.path,
              title: this.extractBasename(r.path),
              score: Math.max(0, Math.min(1, (_a = r.score) != null ? _a : 0)),
              semScore: Math.max(0, Math.min(1, (_b = r.score) != null ? _b : 0)),
              excerpt: (_c = r == null ? void 0 : r.metadata) == null ? void 0 : _c.excerpt
            };
          });
        } catch (e) {
          return [];
        }
      }
      mergeAndRank(lex, sem, query) {
        var _a;
        const byPath = /* @__PURE__ */ new Map();
        for (const r of lex) {
          byPath.set(r.path, { ...r });
        }
        for (const r of sem) {
          const existing = byPath.get(r.path);
          if (existing) {
            existing.semScore = (_a = r.semScore) != null ? _a : existing.semScore;
            if (!existing.excerpt && r.excerpt) existing.excerpt = r.excerpt;
          } else {
            byPath.set(r.path, { ...r });
          }
        }
        const hasSemantic = sem.length > 0;
        let wLex = 0.6;
        let wSem = hasSemantic ? 0.7 : 0;
        const denom = wLex + wSem || 1;
        const merged = Array.from(byPath.values()).map((r) => {
          var _a2, _b;
          const lexScore = (_a2 = r.lexScore) != null ? _a2 : 0;
          const semScore = (_b = r.semScore) != null ? _b : 0;
          const combined = (wLex * lexScore + wSem * semScore) / denom;
          return { ...r, score: combined };
        });
        const lowerQuery = query.toLowerCase();
        merged.sort((a, b) => {
          const diff = b.score - a.score;
          if (Math.abs(diff) > 0.02) return diff;
          const aBonus = this.softBonusForName(a, lowerQuery);
          const bBonus = this.softBonusForName(b, lowerQuery);
          return bBonus - aBonus;
        });
        return merged;
      }
      softBonusForName(r, lowerQuery) {
        const name = r.title.toLowerCase();
        if (name.includes(lowerQuery)) return 0.02;
        return 0;
      }
      async enhanceWithExcerpts(results, query) {
        const app = this.app;
        const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
        const enhanced = await runWithConcurrency(results.map((r) => r.path), async (path) => {
          const r = results.find((x) => x.path === path);
          if (r.excerpt) return r;
          const file = app.vault.getAbstractFileByPath(path);
          if (!(file instanceof import_obsidian101.TFile)) return r;
          try {
            const content = await app.vault.read(file);
            const excerpt = this.getMatchContext(content, terms, 85);
            return { ...r, excerpt };
          } catch (e) {
            return r;
          }
        }, 8);
        return enhanced;
      }
      renderLoading(text) {
        if (!this.listEl) return;
        this.listEl.empty();
        const loading = this.listEl.createDiv("ss-modal__loading");
        loading.createDiv({ text });
      }
      renderEmpty(text) {
        if (!this.listEl) return;
        this.listEl.empty();
        const empty = this.listEl.createDiv("ss-modal__empty-state");
        empty.createDiv({ text });
      }
      renderResults(results) {
        if (!this.listEl) return;
        this.listEl.empty();
        if (results.length === 0) {
          this.renderEmpty("No results found.");
          return;
        }
        results.forEach((r) => {
          const item = this.createItem(r.title, r.path, "file-text", `${Math.round((r.score || 0) * 100)}%`);
          const titleEl = item.querySelector(".ss-modal__item-title");
          const descEl = item.querySelector(".ss-modal__item-description");
          if (titleEl) {
            titleEl.innerHTML = this.getHighlightedText(r.title, this.currentQuery);
          }
          if (descEl && r.excerpt) {
            const highlightedExcerpt = this.getHighlightedText(r.excerpt, this.currentQuery);
            descEl.innerHTML = `${r.path} \u2022 ${highlightedExcerpt}`;
          }
          this.registerDomEvent(item, "click", async () => {
            try {
              await this.app.workspace.openLinkText(r.path, "");
              this.close();
            } catch (e) {
              new import_obsidian101.Notice(`Failed to open: ${r.path}`);
            }
          });
          this.listEl.appendChild(item);
        });
        this.makeDraggableForContext(results);
      }
      makeDraggableForContext(results) {
        if (!this.listEl) return;
        const el = this.listEl;
        el.draggable = true;
        el.addClass("scs-draggable");
        this.registerDomEvent(el, "dragstart", (e) => {
          const ev = e;
          if (!ev.dataTransfer) return;
          const payload = {
            type: "search-results",
            query: this.currentQuery,
            results: results.slice(0, 50).map((r) => ({ path: r.path, score: r.score }))
          };
          const text = results.map((r) => r.path).join("\n");
          ev.dataTransfer.setData("text/plain", JSON.stringify(payload));
          ev.dataTransfer.setData("application/json", JSON.stringify(payload));
          ev.dataTransfer.setData("text/uri-list", text);
        });
      }
      async copyResults() {
        var _a;
        try {
          const items = Array.from(((_a = this.listEl) == null ? void 0 : _a.querySelectorAll(".ss-modal__item")) || []);
          if (items.length === 0) {
            new import_obsidian101.Notice("No results to copy.");
            return;
          }
          const paths = items.map((el) => {
            var _a2, _b;
            return ((_b = (_a2 = el.querySelector(".ss-modal__item-description")) == null ? void 0 : _a2.textContent) == null ? void 0 : _b.split(" \u2022 ")[0]) || "";
          }).filter(Boolean).join("\n");
          await navigator.clipboard.writeText(paths);
          new import_obsidian101.Notice("Search results copied to clipboard", 3e3);
        } catch (e) {
          new import_obsidian101.Notice("Failed to copy results", 4e3);
        }
      }
      extractBasename(path) {
        const base = path.substring(path.lastIndexOf("/") + 1);
        return base.replace(/\.md$/i, "");
      }
      getMatchContext(text, searchTerms, contextSize = 75) {
        if (!text) return "";
        if (!searchTerms || searchTerms.length === 0) {
          const trimmed = text.replace(/^---[\s\S]*?---\n/, "");
          return trimmed.substring(0, 200).trim() + (trimmed.length > 200 ? "..." : "");
        }
        const lower = text.toLowerCase();
        const matches = [];
        for (const term of searchTerms) {
          let idx = 0;
          while ((idx = lower.indexOf(term, idx)) > -1) {
            matches.push({ term, index: idx });
            idx += term.length;
          }
        }
        if (matches.length === 0) {
          const trimmed = text.replace(/^---[\s\S]*?---\n/, "");
          return trimmed.substring(0, 200).trim() + (trimmed.length > 200 ? "..." : "");
        }
        matches.sort((a, b) => a.index - b.index);
        let bestStart = matches[0].index;
        let bestEnd = matches[0].index + matches[0].term.length;
        for (let i = 0; i < matches.length; i++) {
          let windowStart = matches[i].index;
          let windowEnd = matches[i].index + matches[i].term.length;
          for (let j = i + 1; j < matches.length; j++) {
            if (matches[j].index - windowEnd > contextSize) break;
            windowEnd = matches[j].index + matches[j].term.length;
          }
          if (windowEnd - windowStart < bestEnd - bestStart) {
            bestStart = windowStart;
            bestEnd = windowEnd;
          }
        }
        const start = Math.max(0, bestStart - contextSize);
        const end = Math.min(text.length, bestEnd + contextSize);
        let previewStart = start;
        while (previewStart > 0 && !/[\s.!?\n]/.test(text[previewStart - 1])) previewStart--;
        let previewEnd = end;
        while (previewEnd < text.length && !/[\s.!?\n]/.test(text[previewEnd])) previewEnd++;
        let preview = text.slice(previewStart, previewEnd).trim();
        if (previewStart > 0) preview = "..." + preview;
        if (previewEnd < text.length) preview = preview + "...";
        return preview;
      }
      // Recent 25 updated files view
      async renderRecentFiles() {
        var _a, _b;
        if (!this.listEl) return;
        this.listEl.empty();
        const app = this.app;
        let files = ((_b = (_a = this.plugin.vaultFileCache) == null ? void 0 : _a.getAllFiles) == null ? void 0 : _b.call(_a)) || app.vault.getFiles();
        files = files.filter((f) => !shouldExcludeFromSearch(f, this.plugin));
        files.sort((a, b) => {
          var _a2, _b2;
          return (((_a2 = b.stat) == null ? void 0 : _a2.mtime) || 0) - (((_b2 = a.stat) == null ? void 0 : _b2.mtime) || 0);
        });
        const top = files.slice(0, 25);
        const results = top.map((f) => ({
          path: f.path,
          title: f.basename,
          score: 0.5
          // neutral score for recents; CSS will not over-emphasize
        }));
        const enriched = await runWithConcurrency(results.map((r) => r.path), async (p) => {
          const f = app.vault.getAbstractFileByPath(p);
          if (!(f instanceof import_obsidian101.TFile)) return results.find((x) => x.path === p);
          if (!/(md|markdown|txt)$/i.test(f.extension)) return results.find((x) => x.path === p);
          try {
            const content = await app.vault.read(f);
            const trimmed = content.replace(/^---[\s\S]*?---\n/, "").slice(0, 200).trim();
            const target = results.find((x) => x.path === p);
            target.excerpt = trimmed.length > 0 ? trimmed + (content.length > 200 ? "..." : "") : void 0;
            return target;
          } catch (e) {
            return results.find((x) => x.path === p);
          }
        }, 8);
        this.currentQuery = "";
        this.renderResults(enriched);
      }
      getHighlightedText(text, query) {
        if (!query || !query.trim()) {
          return text;
        }
        const terms = query.toLowerCase().split(/\s+/).filter(Boolean);
        const lc = text.toLowerCase();
        const matches = [];
        terms.forEach((t) => {
          let idx = 0;
          while ((idx = lc.indexOf(t, idx)) > -1) {
            matches.push({ start: idx, end: idx + t.length });
            idx += t.length;
          }
        });
        if (matches.length === 0) {
          return text;
        }
        matches.sort((a, b) => a.start - b.start);
        let result = "";
        let last = 0;
        matches.forEach((m) => {
          if (m.start > last) {
            result += text.slice(last, m.start);
          }
          result += `<mark class="ss-hl">${text.slice(m.start, m.end)}</mark>`;
          last = m.end;
        });
        if (last < text.length) {
          result += text.slice(last);
        }
        return result;
      }
    };
  }
});

// src/modals/TitleGenerationModal.ts
var TitleGenerationModal_exports = {};
__export(TitleGenerationModal_exports, {
  TitleGenerationModal: () => TitleGenerationModal,
  TitleGenerationNotice: () => TitleGenerationNotice,
  showTitleGenerationModal: () => showTitleGenerationModal
});
async function showTitleGenerationModal(app, plugin, initialValue, content) {
  const modal = new TitleGenerationModal(app, plugin, initialValue, content);
  return await modal.openAndGetTitle();
}
var import_obsidian105, TitleGenerationNotice, TitleGenerationModal;
var init_TitleGenerationModal = __esm({
  "src/modals/TitleGenerationModal.ts"() {
    import_obsidian105 = require("obsidian");
    init_TitleGenerationService();
    init_StandardModal();
    TitleGenerationNotice = class {
      constructor() {
        this.autoCloseTimer = null;
        this.countdownEl = null;
        this.countdownInterval = null;
        this.countdownSeconds = 5;
        this.noticeEl = document.createElement("div");
        this.noticeEl.addClass("systemsculpt-title-notice");
        const header = this.noticeEl.createDiv({ cls: "systemsculpt-title-notice-header" });
        const title = header.createDiv({ text: "Generating Title", cls: "systemsculpt-title-notice-title" });
        this.closeButton = header.createDiv({ cls: "systemsculpt-title-notice-close" });
        this.closeButton.addEventListener("click", () => {
          this.hide();
        });
        (0, import_obsidian105.setIcon)(this.closeButton, "x");
        const progressContainer = this.noticeEl.createDiv();
        this.textEl = progressContainer.createDiv({ cls: "systemsculpt-title-notice-progress-text" });
        this.textEl.textContent = "Analyzing content...";
        const progressBarBg = progressContainer.createDiv({ cls: "systemsculpt-title-notice-progress-bg" });
        this.progressEl = progressBarBg.createDiv({ cls: "systemsculpt-title-notice-progress-bar" });
        this.countdownEl = this.noticeEl.createDiv({ cls: "systemsculpt-title-notice-countdown" });
        document.body.appendChild(this.noticeEl);
        setTimeout(() => {
          this.noticeEl.addClass("systemsculpt-title-notice--visible");
        }, 10);
      }
      /**
       * Update the progress bar and status text
       * @param progress Progress percentage (0-100)
       * @param text Status text to display
       */
      updateProgress(progress, text) {
        this.progressEl.style.setProperty("width", `${progress}%`);
        if (text) {
          this.textEl.textContent = text;
        }
      }
      /**
       * Show completion state with auto-close countdown
       */
      showCompletion(message = "Title generated successfully!") {
        this.progressEl.style.setProperty("width", "100%");
        this.textEl.textContent = message;
        if (this.countdownEl) {
          this.countdownEl.addClass("systemsculpt-title-notice-countdown--visible");
          this.countdownEl.textContent = `Closing in ${this.countdownSeconds} seconds...`;
          this.countdownInterval = window.setInterval(() => {
            this.countdownSeconds--;
            if (this.countdownEl) {
              this.countdownEl.textContent = `Closing in ${this.countdownSeconds} seconds...`;
            }
            if (this.countdownSeconds <= 0) {
              this.hide();
            }
          }, 1e3);
        }
        this.autoCloseTimer = window.setTimeout(() => {
          this.hide();
        }, this.countdownSeconds * 1e3);
      }
      /**
       * Show error state
       * @param errorMessage Error message to display
       */
      showError(errorMessage) {
        this.progressEl.style.setProperty("width", "100%");
        this.progressEl.addClass("systemsculpt-title-notice-progress-bar--error");
        this.textEl.textContent = errorMessage;
        this.autoCloseTimer = window.setTimeout(() => {
          this.hide();
        }, 5e3);
      }
      /**
       * Hide the notice with animation
       */
      hide() {
        if (this.autoCloseTimer) {
          clearTimeout(this.autoCloseTimer);
          this.autoCloseTimer = null;
        }
        if (this.countdownInterval) {
          clearInterval(this.countdownInterval);
          this.countdownInterval = null;
        }
        this.noticeEl.removeClass("systemsculpt-title-notice--visible");
        setTimeout(() => {
          this.noticeEl.remove();
        }, 300);
      }
    };
    TitleGenerationModal = class extends StandardModal {
      constructor(app, plugin, initialValue, content) {
        super(app);
        this.plugin = plugin;
        this.initialValue = initialValue;
        this.content = content;
        this.result = null;
        this.resolvePromise = null;
        this.isGenerating = false;
        this.progressAnimation = null;
        this.titleGenerationService = TitleGenerationService.getInstance(plugin);
        this.isNoteContext = this.content instanceof import_obsidian105.TFile;
      }
      onOpen() {
        super.onOpen();
        this.setSize("medium");
        this.modalEl.addClass("ss-title-modal");
        this.addTitle(
          this.isNoteContext ? "Generate Note Title" : "Generate Chat Title",
          this.isNoteContext ? "Enter a title or generate one based on your note content." : "Enter a title or generate one based on your chat content."
        );
        const contextSection = this.contentEl.createDiv({ cls: "ss-modal__section" });
        const contextHeader = contextSection.createDiv({ cls: "ss-modal__section-header" });
        contextHeader.createEl("h3", { text: "Optional context" });
        this.contextInput = contextSection.createEl("textarea", {
          placeholder: "Briefly describe the main topic or purpose...",
          cls: "ss-title-modal__context-textarea"
        });
        this.contextInput.rows = 2;
        const titleSection = this.contentEl.createDiv({ cls: "ss-modal__section" });
        const titleHeader = titleSection.createDiv({ cls: "ss-modal__section-header" });
        titleHeader.createEl("h3", { text: "Title" });
        const inputContainer = titleSection.createDiv({ cls: "ss-modal__title-input-container" });
        this.titleInput = inputContainer.createEl("input", {
          type: "text",
          placeholder: "Enter title...",
          value: this.initialValue,
          cls: "ss-modal__title-input"
        });
        this.progressContainer = this.contentEl.createDiv({ cls: "ss-title-modal__progress" });
        this.progressText = this.progressContainer.createDiv({
          text: "Generating title...",
          cls: "ss-title-modal__progress-text"
        });
        const progressBarContainer = this.progressContainer.createDiv({ cls: "ss-title-modal__progress-bar-container" });
        this.progressBar = progressBarContainer.createDiv({ cls: "ss-title-modal__progress-bar" });
        this.addActionButton("Cancel", () => this.cancel(), false);
        this.generateButton = this.addActionButton("Generate", () => {
          if (!this.isGenerating) {
            this.generateTitle();
          }
        }, false);
        const shortcutHint = document.createElement("span");
        shortcutHint.textContent = import_obsidian105.Platform.isMacOS ? " (\u2318+G)" : " (Ctrl+G)";
        shortcutHint.className = "ss-title-modal__shortcut";
        this.generateButton.appendChild(shortcutHint);
        this.addActionButton("Save", () => this.save(), true);
        this.registerDocumentKeydown();
        setTimeout(() => {
          this.contextInput.focus();
        }, 10);
      }
      /**
       * Register keyboard shortcuts
       */
      registerDocumentKeydown() {
        this.scope.register([], "Enter", (evt) => {
          if (!evt.isComposing && !evt.shiftKey && !evt.altKey && !evt.ctrlKey && !evt.metaKey) {
            evt.preventDefault();
            this.save();
            return false;
          }
          return true;
        });
        this.scope.register([], "Escape", (evt) => {
          evt.preventDefault();
          this.cancel();
          return false;
        });
        this.scope.register(["Mod"], "g", (evt) => {
          evt.preventDefault();
          if (!this.isGenerating) {
            this.generateTitle();
          }
          return false;
        });
      }
      /**
       * Update the generate button state
       */
      updateGenerateButton() {
        if (!this.generateButton) return;
        if (this.isGenerating) {
          this.generateButton.textContent = "Generating...";
          this.generateButton.setAttribute("disabled", "true");
        } else {
          this.generateButton.textContent = "Generate";
          this.generateButton.removeAttribute("disabled");
          const shortcutHint = document.createElement("span");
          shortcutHint.textContent = import_obsidian105.Platform.isMacOS ? " (\u2318+G)" : " (Ctrl+G)";
          shortcutHint.className = "ss-title-modal__shortcut";
          const existingHints = this.generateButton.querySelectorAll(".ss-title-modal__shortcut");
          existingHints.forEach((hint) => hint.remove());
          this.generateButton.appendChild(shortcutHint);
        }
      }
      /**
       * Start the progress animation
       */
      startProgressAnimation() {
        this.progressContainer.addClass("ss-title-modal__progress--visible");
        let width = 0;
        const frame = () => {
          if (width >= 90) {
            return;
          }
          width += (90 - width) / 100;
          this.progressBar.style.setProperty("width", `${width}%`);
          this.progressAnimation = requestAnimationFrame(frame);
        };
        this.progressAnimation = requestAnimationFrame(frame);
      }
      /**
       * Stop the progress animation
       */
      stopProgressAnimation() {
        if (this.progressAnimation) {
          cancelAnimationFrame(this.progressAnimation);
          this.progressAnimation = null;
        }
      }
      /**
       * Sanitize the title and provide appropriate defaults based on context
       */
      sanitizeTitle(title) {
        const trimmedTitle = title.trim();
        if (trimmedTitle) return trimmedTitle;
        return this.isNoteContext ? "Untitled Note" : "Untitled Chat";
      }
      /**
       * Generate a title based on the content
       */
      async generateTitle() {
        if (Array.isArray(this.content) && this.content.length === 0) {
          new import_obsidian105.Notice("No chat messages to generate a title from.");
          return;
        }
        this.isGenerating = true;
        this.updateGenerateButton();
        this.startProgressAnimation();
        try {
          const additionalContext = this.contextInput.value.trim();
          await this.titleGenerationService.generateTitle(
            this.content,
            (title) => {
              this.titleInput.value = title;
            },
            (progress, status) => {
              if (progress > 0) {
                this.progressBar.style.setProperty("width", `${progress}%`);
                this.progressText.textContent = status || "Generating title...";
              }
            },
            additionalContext || void 0
          );
          this.progressBar.style.setProperty("width", "100%");
          this.progressText.textContent = "Title generated!";
          setTimeout(() => {
            this.progressContainer.style.setProperty("opacity", "0");
            setTimeout(() => {
              this.progressContainer.removeClass("ss-title-modal__progress--visible");
              this.progressContainer.style.removeProperty("opacity");
            }, 300);
          }, 1500);
          this.titleInput.focus();
          this.titleInput.select();
        } catch (error) {
          this.progressBar.style.setProperty("width", "100%");
          this.progressBar.addClass("ss-title-modal__progress-bar--error");
          this.progressText.textContent = "Failed to generate title";
          new import_obsidian105.Notice("Failed to generate title", 5e3);
        } finally {
          this.isGenerating = false;
          this.updateGenerateButton();
          this.stopProgressAnimation();
        }
      }
      /**
       * Save the title and close the modal
       */
      save() {
        this.result = this.sanitizeTitle(this.titleInput.value);
        this.close();
      }
      /**
       * Cancel and close the modal
       */
      cancel() {
        this.result = null;
        this.close();
      }
      onClose() {
        this.stopProgressAnimation();
        if (this.resolvePromise) {
          this.resolvePromise(this.result);
          this.resolvePromise = null;
        }
      }
      /**
       * Open the modal and return a promise that resolves with the title
       */
      async openAndGetTitle() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.open();
        });
      }
    };
  }
});

// src/components/FloatingWidget.ts
var FloatingWidget;
var init_FloatingWidget = __esm({
  "src/components/FloatingWidget.ts"() {
    init_MobileDetection();
    FloatingWidget = class {
      constructor(app, plugin, options) {
        // UI elements
        this.widgetEl = null;
        this.titleBarEl = null;
        this.contentEl = null;
        this.app = app;
        this.plugin = plugin;
        this.mobileDetection = new MobileDetection();
        this.options = {
          draggable: true,
          position: { top: "50px", right: "20px" },
          width: "300px",
          ...options
        };
      }
      /**
       * Show the floating widget
       */
      show() {
        this.hide();
        const isMobile = this.mobileDetection.isMobileDevice();
        if (isMobile) {
          this.showMobileVersion();
        } else {
          this.showDesktopWidget();
        }
      }
      /**
       * Hide the floating widget
       */
      hide() {
        if (this.widgetEl) {
          this.widgetEl.classList.remove("visible");
          setTimeout(() => {
            if (this.widgetEl && this.widgetEl.parentNode) {
              this.widgetEl.parentNode.removeChild(this.widgetEl);
            }
            this.widgetEl = null;
            this.titleBarEl = null;
            this.contentEl = null;
          }, 300);
        }
      }
      /**
       * Check if the widget is currently visible
       */
      isVisible() {
        return this.widgetEl !== null && this.widgetEl.parentNode !== null;
      }
      /**
       * Show desktop floating widget
       */
      showDesktopWidget() {
        var _a, _b, _c, _d;
        this.widgetEl = document.createElement("div");
        this.widgetEl.className = `systemsculpt-floating-widget ${this.options.className || ""}`;
        if ((_a = this.options.position) == null ? void 0 : _a.top) this.widgetEl.style.top = this.options.position.top;
        if ((_b = this.options.position) == null ? void 0 : _b.right) this.widgetEl.style.right = this.options.position.right;
        if ((_c = this.options.position) == null ? void 0 : _c.bottom) this.widgetEl.style.bottom = this.options.position.bottom;
        if ((_d = this.options.position) == null ? void 0 : _d.left) this.widgetEl.style.left = this.options.position.left;
        if (this.options.width) this.widgetEl.style.width = this.options.width;
        this.createDesktopUI();
        document.body.appendChild(this.widgetEl);
        setTimeout(() => {
          if (this.widgetEl) {
            this.widgetEl.classList.add("visible");
          }
        }, 10);
      }
      /**
       * Create desktop UI elements
       */
      createDesktopUI() {
        if (!this.widgetEl) return;
        this.titleBarEl = document.createElement("div");
        this.titleBarEl.className = "systemsculpt-floating-widget-title";
        if (this.options.icon) {
          this.titleBarEl.innerHTML = `
        <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"
             stroke-linecap="round" stroke-linejoin="round">
          ${this.options.icon}
        </svg>
        ${this.options.title}
      `;
        } else {
          this.titleBarEl.textContent = this.options.title;
        }
        if (this.options.draggable) {
          this.makeDraggable(this.widgetEl, this.titleBarEl);
        }
        this.widgetEl.appendChild(this.titleBarEl);
        this.contentEl = document.createElement("div");
        this.contentEl.className = "systemsculpt-floating-widget-content";
        this.widgetEl.appendChild(this.contentEl);
        this.createContent(this.contentEl);
      }
      /**
       * Make the widget draggable
       */
      makeDraggable(element, handle) {
        let isDragging = false;
        let offsetX = 0;
        let offsetY = 0;
        const onMouseDown = (e) => {
          isDragging = true;
          offsetX = e.clientX - element.offsetLeft;
          offsetY = e.clientY - element.offsetTop;
          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
          e.preventDefault();
        };
        const onMouseMove = (e) => {
          if (!isDragging) return;
          const x = Math.max(0, Math.min(e.clientX - offsetX, window.innerWidth - element.offsetWidth));
          const y = Math.max(0, Math.min(e.clientY - offsetY, window.innerHeight - element.offsetHeight));
          element.style.left = `${x}px`;
          element.style.top = `${y}px`;
          element.style.right = "auto";
          element.style.bottom = "auto";
        };
        const onMouseUp = () => {
          isDragging = false;
          document.removeEventListener("mousemove", onMouseMove);
          document.removeEventListener("mouseup", onMouseUp);
        };
        handle.addEventListener("mousedown", onMouseDown);
      }
      /**
       * Show mobile version - subclasses can override this
       */
      showMobileVersion() {
        console.warn("Mobile version not implemented for this widget");
      }
      /**
       * Update the widget title
       */
      updateTitle(title) {
        if (this.titleBarEl) {
          if (this.options.icon) {
            this.titleBarEl.innerHTML = `
          <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"
               stroke-linecap="round" stroke-linejoin="round">
            ${this.options.icon}
          </svg>
          ${title}
        `;
          } else {
            this.titleBarEl.textContent = title;
          }
        }
      }
      /**
       * Get the content container for subclasses to use
       */
      getContentContainer() {
        return this.contentEl;
      }
    };
  }
});

// src/components/QuickEditWidget.ts
var QuickEditWidget_exports = {};
__export(QuickEditWidget_exports, {
  QuickEditWidget: () => QuickEditWidget,
  showQuickEditWidget: () => showQuickEditWidget
});
function showQuickEditWidget(app, plugin) {
  const widget = new QuickEditWidget(app, plugin);
  widget.show();
  return widget;
}
var import_obsidian106, QuickEditWidget;
var init_QuickEditWidget = __esm({
  "src/components/QuickEditWidget.ts"() {
    import_obsidian106 = require("obsidian");
    init_FloatingWidget();
    init_MCPService();
    init_jsonRepair();
    init_inline_diff();
    init_toolCallPreview();
    init_errorLogger();
    init_ToolCallManager();
    init_toolDisplay();
    QuickEditWidget = class extends FloatingWidget {
      constructor(app, plugin) {
        super(app, plugin, {
          title: "Quick Edit",
          icon: '<path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="m18.5 2.5-8.5 8.5v3h3l8.5-8.5"></path><path d="m16 4 2 2"></path>',
          className: "systemsculpt-quick-edit-widget",
          position: { bottom: "20px", right: "20px" },
          width: "350px",
          draggable: true
        });
        // Input and UI elements
        this.inputEl = null;
        this.submitButtonEl = null;
        this.streamSectionEl = null;
        this.streamTextEl = null;
        this.toolEventsListEl = null;
        // State
        this.inputText = "";
        this.isStreaming = false;
        this.hasShownThinking = false;
        this.toolCallManager = null;
        this.toolEventMap = /* @__PURE__ */ new Map();
      }
      /**
       * Create the content for the quick edit widget
       */
      createContent(container) {
        const inputSection = container.createDiv("quick-edit-input-section");
        this.inputEl = inputSection.createEl("input", {
          type: "text",
          placeholder: "Describe the change\u2026 (e.g., 'Rewrite intro for clarity')",
          cls: "quick-edit-input"
        });
        this.submitButtonEl = inputSection.createEl("button", {
          text: "Apply",
          cls: "quick-edit-submit-btn"
        });
        this.inputEl.addEventListener("input", (e) => {
          this.inputText = e.target.value;
        });
        this.inputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && !e.isComposing && !e.shiftKey) {
            e.preventDefault();
            this.submit();
          }
        });
        this.submitButtonEl.addEventListener("click", () => {
          this.submit();
        });
        this.streamSectionEl = container.createDiv("quick-edit-stream-section");
        this.streamSectionEl.style.display = "none";
        const streamHeader = this.streamSectionEl.createDiv("quick-edit-stream-header");
        streamHeader.textContent = "Live output";
        const streamBody = this.streamSectionEl.createDiv("quick-edit-stream-body");
        this.streamTextEl = streamBody.createDiv("quick-edit-stream-text");
        const toolHeader = streamBody.createDiv("quick-edit-tool-header");
        toolHeader.textContent = "Actions";
        this.toolEventsListEl = streamBody.createEl("ul", { cls: "quick-edit-tool-list" });
        setTimeout(() => {
          if (this.inputEl) {
            this.inputEl.focus();
          }
        }, 100);
      }
      /**
       * Submit the edit request
       */
      async submit() {
        var _a;
        console.info("[QuickEditWidget] Submit triggered");
        const prompt = (this.inputText || "").trim();
        if (!prompt) {
          console.warn("[QuickEditWidget] Empty prompt; hiding widget");
          this.hide();
          return;
        }
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian106.MarkdownView);
        const activeFile = (_a = activeView == null ? void 0 : activeView.file) != null ? _a : null;
        if (!activeFile) {
          console.error("[QuickEditWidget] No active file detected; cannot run quick edit");
          new import_obsidian106.Notice("No active file to edit.", 4e3);
          this.hide();
          return;
        }
        const modelId = this.plugin.settings.selectedModelId || "";
        if (!modelId) {
          console.error("[QuickEditWidget] No model selected in settings");
          new import_obsidian106.Notice("Select a default model in SystemSculpt settings.", 6e3);
          this.hide();
          return;
        }
        const progress = this.createProgressNotice(activeFile.path);
        progress.update("Preparing\u2026", 8);
        this.isStreaming = true;
        this.hasShownThinking = false;
        if (this.streamSectionEl) this.streamSectionEl.style.display = "block";
        if (this.inputEl) this.inputEl.disabled = true;
        if (this.submitButtonEl) this.submitButtonEl.disabled = true;
        try {
          console.debug("[QuickEditWidget] Starting processEdit", { file: activeFile.path, modelId });
          await this.processEdit(prompt, activeFile, modelId, progress);
          progress.complete();
          setTimeout(() => {
            try {
              this.hide();
            } catch (e) {
            }
          }, 1500);
        } catch (error) {
          console.error("[QuickEditWidget] processEdit failed", { error });
          try {
            errorLogger.error("QuickEditWidget submit failed", error, {
              source: "QuickEditWidget",
              method: "submit",
              metadata: { filePath: activeFile.path }
            });
          } catch (e) {
          }
          progress.fail((error == null ? void 0 : error.message) || String(error));
          new import_obsidian106.Notice(`Quick edit failed: ${(error == null ? void 0 : error.message) || String(error)}`, 6e3);
          if (this.inputEl) this.inputEl.disabled = false;
          if (this.submitButtonEl) this.submitButtonEl.disabled = false;
          this.isStreaming = false;
        }
      }
      /**
       * Process the edit request with streaming
       */
      async processEdit(prompt, file, modelId, progress) {
        var _a;
        const filePath = file.path;
        const contextFiles = /* @__PURE__ */ new Set([filePath]);
        const userMessage = {
          role: "user",
          content: [
            {
              type: "text",
              text: [
                `You are an autonomous code editor with full tool access. Your task is to update ONE file thoroughly and correctly.`,
                `File details:`,
                `- Path: ${filePath}`,
                `- Filename: ${file.name}`,
                `- Note: The file's full contents are attached as context. Do NOT ask for more context.`,
                `Instructions:`,
                `- Use filesystem tools to modify exactly this file. Prefer 'edit' for targeted edits; use 'write' only to replace the entire file.`,
                `- Make complete, consistent updates across the whole file. Preserve frontmatter and formatting.`,
                `- If multiple edits are required, issue multiple 'edit' steps until the change is complete.`,
                `- Do not modify any other files unless explicitly requested.`,
                `
User request:
${prompt}`
              ].join("\n")
            }
          ],
          message_id: crypto.randomUUID()
        };
        const fakeChatContext = { agentMode: true, plugin: this.plugin };
        const mcpService = new MCPService(this.plugin, this.app);
        this.toolCallManager = new ToolCallManager(mcpService, fakeChatContext);
        this.setupToolCallDiagnostics();
        const systemMessage = {
          role: "system",
          content: [
            {
              type: "text",
              text: [
                "You are SystemSculpt's file-editing agent with full tool access.",
                "Your goal is to produce correct, complete edits to the specified file.",
                "Use tools autonomously and iteratively until the change is fully implemented.",
                "Prefer targeted 'edit' steps over whole-file rewrites unless a full replacement is required.",
                "Preserve file formatting, indentation, and frontmatter.",
                "Respond only with tool calls and minimal confirmations; do not output the entire file unless writing."
              ].join("\n")
            }
          ],
          message_id: crypto.randomUUID()
        };
        const stream = this.plugin.aiService.streamMessage({
          messages: [systemMessage, userMessage],
          model: modelId,
          contextFiles,
          systemPromptType: "agent",
          agentMode: true,
          toolCallManager: this.toolCallManager
        });
        const executedIds = /* @__PURE__ */ new Set();
        let appliedAnyChange = false;
        const pendingToolCalls = /* @__PURE__ */ new Map();
        const collectedToolCalls = [];
        const rawToSanitized = /* @__PURE__ */ new Map();
        const usedSanitized = /* @__PURE__ */ new Set();
        const ensureToolCallId = (call) => {
          var _a2;
          const baseKey = (_a2 = call.id) != null ? _a2 : `index_${typeof (call == null ? void 0 : call.index) === "number" ? call.index : "0"}`;
          if (rawToSanitized.has(baseKey)) {
            return rawToSanitized.get(baseKey);
          }
          const makeCandidate = () => {
            const seed = (call.id || crypto.randomUUID()).replace(/[^a-zA-Z0-9]/g, "");
            const suffix = seed.slice(-12) || crypto.randomUUID().replace(/[^a-zA-Z0-9]/g, "").slice(-12);
            return `call_${suffix}`;
          };
          let candidate = makeCandidate();
          while (usedSanitized.has(candidate)) {
            candidate = makeCandidate();
          }
          usedSanitized.add(candidate);
          rawToSanitized.set(baseKey, candidate);
          return candidate;
        };
        for await (const event of stream) {
          if (event.type === "reasoning") {
            console.debug("[QuickEditWidget] Stream reasoning chunk received");
            progress.update("Thinking\u2026", 20);
            if (!this.hasShownThinking) {
              this.appendStream("reasoning", "");
              this.hasShownThinking = true;
            }
          } else if (event.type === "content") {
            console.debug("[QuickEditWidget] Stream content chunk", { preview: String(event.text || "").slice(0, 120) });
            progress.update("Processing\u2026", 40);
            this.appendStream("content", (_a = event.text) != null ? _a : "");
          } else if (event.type === "tool-call") {
            const sanitizedId = ensureToolCallId(event.call);
            if (event.phase === "delta") {
              const existing = pendingToolCalls.get(sanitizedId);
              const merged = {
                ...existing != null ? existing : {},
                ...event.call,
                id: sanitizedId,
                function: {
                  name: event.call.function.name || (existing == null ? void 0 : existing.function.name) || "",
                  arguments: event.call.function.arguments || (existing == null ? void 0 : existing.function.arguments) || ""
                }
              };
              pendingToolCalls.set(sanitizedId, merged);
            } else {
              const aggregated = pendingToolCalls.get(sanitizedId);
              pendingToolCalls.delete(sanitizedId);
              const functionName = event.call.function.name || (aggregated == null ? void 0 : aggregated.function.name);
              if (!functionName) continue;
              let args = event.call.function.arguments || (aggregated == null ? void 0 : aggregated.function.arguments) || "";
              if (args) {
                try {
                  args = normalizeJsonString(args);
                } catch (e) {
                }
              }
              collectedToolCalls.push({
                id: sanitizedId,
                type: "function",
                function: {
                  name: functionName,
                  arguments: args
                }
              });
            }
          }
        }
        if (collectedToolCalls.length === 0) {
          console.info("[QuickEditWidget] No applicable edit/write tool calls were produced by the model");
          new import_obsidian106.Notice("No changes were applied. Try a more specific instruction or ensure your selected model supports tools.", 6e3);
          return;
        }
        progress.update("Applying changes\u2026", 70);
        const seenIds = /* @__PURE__ */ new Set();
        for (const tc of collectedToolCalls) {
          const id = tc.id || crypto.randomUUID();
          if (seenIds.has(id)) continue;
          seenIds.add(id);
          if (executedIds.has(id)) continue;
          executedIds.add(id);
          const fn = tc.function;
          if (!fn || typeof fn.name !== "string") {
            console.warn("[QuickEditWidget] Skipping tool call with invalid function", { tc });
            continue;
          }
          const toolName = String(fn.name);
          const base = toolName.replace(/^mcp[-_][^_]+_/, "");
          if (base !== "edit" && base !== "write") {
            console.debug("[QuickEditWidget] Ignoring non-edit/write tool call", { toolName });
            continue;
          }
          let argsRaw = String(fn.arguments || "{}");
          try {
            argsRaw = normalizeJsonString(argsRaw);
          } catch (e) {
          }
          let args = {};
          try {
            args = JSON.parse(argsRaw || "{}");
          } catch (parseErr) {
            console.error("[QuickEditWidget] Failed to parse tool arguments; using empty object", { parseErr, argsRaw });
            args = {};
          }
          if (!args.path || typeof args.path !== "string") {
            args.path = filePath;
          }
          const toolEl = this.addToolEvent(id, toolName, args);
          if (toolEl) this.toolEventMap.set(id, toolEl);
          try {
            progress.update("Previewing changes\u2026", 75);
            await this.previewLocally(toolName, args, filePath);
          } catch (previewErr) {
            console.warn("[QuickEditWidget] Preview failed (will still attempt execution)", { previewErr });
          }
          try {
            const autoApprove = true;
            console.debug("[QuickEditWidget] Creating tool call", { id, toolName, autoApprove, argsPreview: JSON.stringify(args).slice(0, 200) });
            const toolCall = this.toolCallManager.createToolCall(tc, userMessage.message_id, autoApprove);
            if (toolCall && toolCall.state === "pending") {
              this.toolCallManager.approveToolCall(toolCall.id);
            }
            appliedAnyChange = true;
            progress.update("Finalizing\u2026", 95);
          } catch (execErr) {
            console.error("[QuickEditWidget] Tool execution failed", { execErr });
            this.updateToolEvent(toolEl, "failed", (execErr == null ? void 0 : execErr.message) || String(execErr));
            new import_obsidian106.Notice(`Edit tool failed: ${(execErr == null ? void 0 : execErr.message) || String(execErr)}`, 6e3);
          }
        }
        if (!appliedAnyChange) {
          console.info("[QuickEditWidget] No applicable edit/write tool calls were produced by the model");
          new import_obsidian106.Notice("No changes were applied. Try a more specific instruction or ensure your selected model supports tools.", 6e3);
        }
      }
      /**
       * Preview changes locally before execution
       */
      async previewLocally(toolName, args, filePath) {
        var _a;
        const base = toolName.replace(/^mcp[-_][^_]+_/, "");
        let newContent = "";
        if (base === "write") {
          newContent = String((_a = args.content) != null ? _a : "");
        } else if (base === "edit") {
          try {
            const file = this.app.vault.getAbstractFileByPath(filePath);
            const original = file instanceof import_obsidian106.TFile ? await this.app.vault.read(file) : "";
            const edits = Array.isArray(args.edits) ? args.edits : [];
            newContent = applyEditsLocally(original, edits);
          } catch (err) {
            console.warn("[QuickEditWidget] Failed to compute local preview", { err });
            newContent = "";
          }
        }
        if (newContent && typeof newContent === "string") {
          try {
            await applyDiffToView(this.app, filePath, newContent);
          } catch (e) {
            console.warn("[QuickEditWidget] Failed to show inline diff", e);
          }
        }
      }
      /**
       * Create a progress notice for the edit operation
       */
      createProgressNotice(filePath) {
        const fragment = document.createDocumentFragment();
        const wrap = document.createElement("div");
        wrap.style.display = "flex";
        wrap.style.flexDirection = "column";
        wrap.style.gap = "6px";
        wrap.style.minWidth = "260px";
        const title = document.createElement("div");
        title.textContent = `Updating: ${filePath}`;
        title.style.fontWeight = "600";
        title.style.fontSize = "13px";
        wrap.appendChild(title);
        const status = document.createElement("div");
        status.textContent = "Starting\u2026";
        status.style.fontSize = "12px";
        status.style.opacity = "0.9";
        wrap.appendChild(status);
        const bar = document.createElement("div");
        bar.style.height = "6px";
        bar.style.borderRadius = "999px";
        bar.style.background = "var(--background-modifier-border)";
        bar.style.overflow = "hidden";
        const fill = document.createElement("div");
        fill.style.width = "8%";
        fill.style.height = "100%";
        fill.style.borderRadius = "999px";
        fill.style.background = "linear-gradient(90deg, var(--color-accent) 0%, var(--text-accent) 100%)";
        fill.style.transition = "width 160ms ease";
        bar.appendChild(fill);
        wrap.appendChild(bar);
        fragment.appendChild(wrap);
        const notice = new import_obsidian106.Notice(fragment, 12e4);
        const clamp = (n) => Math.max(0, Math.min(100, Math.floor(n)));
        const api = {
          update: (text, pct) => {
            try {
              status.textContent = text;
              if (typeof pct === "number") fill.style.width = clamp(pct) + "%";
            } catch (e) {
            }
          },
          complete: () => {
            try {
              fill.style.width = "100%";
              status.textContent = "Done";
            } catch (e) {
            }
            setTimeout(() => {
              var _a;
              try {
                (_a = notice.hide) == null ? void 0 : _a.call(notice);
              } catch (e) {
              }
            }, 600);
          },
          fail: (msg) => {
            try {
              status.textContent = msg ? `Failed: ${msg}` : "Failed";
              fill.style.background = "#d9534f";
            } catch (e) {
            }
            setTimeout(() => {
              var _a;
              try {
                (_a = notice.hide) == null ? void 0 : _a.call(notice);
              } catch (e) {
              }
            }, 2e3);
          }
        };
        return api;
      }
      /**
       * Append streaming text to the output area
       */
      appendStream(kind, text) {
        if (!this.streamTextEl || !text) return;
        const prefix = kind === "reasoning" ? "[thinking] " : kind === "status" ? "[status] " : "";
        this.streamTextEl.textContent = (this.streamTextEl.textContent || "") + prefix + text;
        const container = this.streamTextEl.parentElement;
        if (container) {
          container.scrollTop = container.scrollHeight;
        }
      }
      /**
       * Add a tool event to the UI
       */
      addToolEvent(id, name, args) {
        if (!this.toolEventsListEl) return null;
        const li = document.createElement("li");
        li.className = "quick-edit-tool-item";
        const badge = document.createElement("span");
        badge.textContent = "pending";
        badge.className = "quick-edit-tool-badge";
        const text = document.createElement("span");
        const shortArgs = (() => {
          try {
            return JSON.stringify(args).slice(0, 100);
          } catch (e) {
            return "{}";
          }
        })();
        text.textContent = `${name} ${shortArgs}`;
        text.className = "quick-edit-tool-text";
        li.appendChild(badge);
        li.appendChild(text);
        li._badge = badge;
        this.toolEventsListEl.appendChild(li);
        return li;
      }
      /**
       * Update a tool event's status
       */
      updateToolEvent(el, status, message) {
        if (!el) return;
        const badge = el._badge;
        if (badge) {
          badge.textContent = status;
          badge.className = `quick-edit-tool-badge quick-edit-tool-badge--${status}`;
        }
        if (message) {
          const msg = document.createElement("span");
          msg.textContent = ` \u2013 ${message}`;
          msg.className = "quick-edit-tool-message";
          el.appendChild(msg);
        }
      }
      /**
       * Setup tool call diagnostics and event handlers
       */
      setupToolCallDiagnostics() {
        if (!this.toolCallManager) return;
        this.toolCallManager.on("tool-call:state-changed", ({ toolCall }) => {
          try {
            const fn = getFunctionDataFromToolCall(toolCall);
            const path = fn ? extractPrimaryPathArg(fn.name, fn.arguments || {}) : void 0;
            if (path) {
              clearDiffFromView(this.app, path);
            }
          } catch (e) {
          }
          console.debug("[QuickEditWidget] Tool state", { id: toolCall == null ? void 0 : toolCall.id, state: toolCall == null ? void 0 : toolCall.state });
        });
        this.toolCallManager.on("tool-call:execution-started", ({ toolCall }) => {
          const fn = getFunctionDataFromToolCall(toolCall);
          console.info("[QuickEditWidget] Execution started", { id: toolCall.id, tool: fn == null ? void 0 : fn.name, args: fn == null ? void 0 : fn.arguments });
        });
        this.toolCallManager.on("tool-call:execution-completed", ({ toolCall, result }) => {
          const fn = getFunctionDataFromToolCall(toolCall);
          console.info("[QuickEditWidget] Execution completed", { id: toolCall.id, tool: fn == null ? void 0 : fn.name, success: result == null ? void 0 : result.success });
          try {
            const li = this.toolEventMap.get(toolCall.id);
            if (li) this.updateToolEvent(li, "completed");
          } catch (e) {
          }
          try {
            const path = fn ? extractPrimaryPathArg(fn.name, fn.arguments || {}) : void 0;
            if (path) {
              clearDiffFromView(this.app, path);
            }
          } catch (e) {
          }
          try {
            new import_obsidian106.Notice(`Updated ${extractPrimaryPathArg((fn == null ? void 0 : fn.name) || "", (fn == null ? void 0 : fn.arguments) || {}) || ""}`, 2e3);
          } catch (e) {
          }
        });
        this.toolCallManager.on("tool-call:execution-failed", ({ toolCall, error }) => {
          const fn = getFunctionDataFromToolCall(toolCall);
          console.error("[QuickEditWidget] Execution failed", { id: toolCall.id, tool: fn == null ? void 0 : fn.name, error });
          try {
            const li = this.toolEventMap.get(toolCall.id);
            if (li) this.updateToolEvent(li, "failed", (error == null ? void 0 : error.message) || String(error));
          } catch (e) {
          }
          try {
            const path = fn ? extractPrimaryPathArg(fn.name, fn.arguments || {}) : void 0;
            if (path) {
              clearDiffFromView(this.app, path);
            }
          } catch (e) {
          }
        });
        this.toolCallManager.on("tool-call:denied", ({ toolCall }) => {
          const fn = getFunctionDataFromToolCall(toolCall);
          console.warn("[QuickEditWidget] Tool call denied", { id: toolCall.id, tool: fn == null ? void 0 : fn.name });
        });
      }
    };
  }
});

// src/modals/ImproveResponseModal.ts
var import_obsidian109, ImproveResponseModal;
var init_ImproveResponseModal = __esm({
  "src/modals/ImproveResponseModal.ts"() {
    import_obsidian109 = require("obsidian");
    ImproveResponseModal = class extends import_obsidian109.Modal {
      constructor(app, promptText, defaultValue, onSubmit) {
        super(app);
        this.promptText = promptText;
        this.defaultValue = defaultValue;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Improve Response" });
        contentEl.createEl("p", { text: this.promptText });
        const presetContainer = contentEl.createDiv();
        presetContainer.style.display = "flex";
        presetContainer.style.flexWrap = "wrap";
        presetContainer.style.gap = "8px";
        presetContainer.style.marginTop = "8px";
        const presets = ["Shorter", "Longer", "Simpler", "More professional", "More creative"];
        presets.forEach((preset) => {
          const btn = presetContainer.createEl("button", { text: preset });
          btn.onclick = () => {
            this.inputEl.value = preset;
            this.inputEl.focus();
          };
        });
        this.inputEl = contentEl.createEl("input", {
          type: "text",
          placeholder: "E.g., shorter, longer, simpler, professional, creative, or custom instruction",
          value: this.defaultValue
        });
        this.inputEl.style.width = "100%";
        this.inputEl.style.marginTop = "10px";
        this.inputEl.style.marginBottom = "20px";
        const buttonContainer = contentEl.createDiv();
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.gap = "10px";
        const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        cancelButton.addClass("mod-muted");
        cancelButton.style.flex = "0 0 auto";
        cancelButton.onclick = () => {
          this.close();
        };
        const confirmButton = buttonContainer.createEl("button", { text: "Improve" });
        confirmButton.addClass("mod-cta");
        confirmButton.style.flex = "0 0 auto";
        confirmButton.onclick = () => {
          const value = this.inputEl.value.trim();
          if (!value) {
            this.inputEl.focus();
            return;
          }
          this.onSubmit(value);
          this.close();
        };
        this.inputEl.addEventListener("keydown", (e) => {
          if (e.key === "Enter" && !e.isComposing) {
            confirmButton.click();
          }
        });
        this._globalKeyHandler = (e) => {
          if (e.metaKey && e.key === "Enter") {
            e.preventDefault();
            confirmButton.click();
          }
        };
        document.addEventListener("keydown", this._globalKeyHandler);
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
        if (this._globalKeyHandler) {
          document.removeEventListener("keydown", this._globalKeyHandler);
        }
      }
    };
  }
});

// src/modals/SaveAsNoteModal.ts
var import_obsidian110, SaveAsNoteModal;
var init_SaveAsNoteModal = __esm({
  "src/modals/SaveAsNoteModal.ts"() {
    import_obsidian110 = require("obsidian");
    init_FolderSuggester();
    SaveAsNoteModal = class extends import_obsidian110.Modal {
      constructor(app, plugin, defaultFolder, defaultFileName, content, onSaveSuccess) {
        super(app);
        this.plugin = plugin;
        this.defaultFolder = defaultFolder;
        this.defaultFileName = defaultFileName;
        this.content = content;
        this.onSaveSuccess = onSaveSuccess;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Save as Note" });
        contentEl.createEl("p", { text: "Choose a location and name for your note" });
        const folderLabel = contentEl.createEl("label", { text: "Folder" });
        folderLabel.style.marginBottom = "12px";
        this.folderInput = contentEl.createEl("input", {
          type: "text",
          value: this.defaultFolder,
          placeholder: "Folder path"
        });
        this.folderInput.style.width = "100%";
        this.folderInput.style.marginBottom = "12px";
        attachFolderSuggester(this.folderInput, (folder) => {
          this.folderInput.value = folder;
        }, this.app);
        const fileNameLabel = contentEl.createEl("label", { text: "File name" });
        this.fileNameInput = contentEl.createEl("input", {
          type: "text",
          value: this.defaultFileName,
          placeholder: "File name (without extension)"
        });
        this.fileNameInput.style.width = "100%";
        const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
        buttonContainer.style.display = "flex";
        buttonContainer.style.justifyContent = "flex-end";
        buttonContainer.style.gap = "10px";
        buttonContainer.style.marginTop = "20px";
        this.cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
        this.saveButton = buttonContainer.createEl("button", { text: "Save" });
        this.saveButton.addClass("mod-cta");
        this.cancelButton.addEventListener("click", () => this.close());
        this.saveButton.addEventListener("click", () => this.handleSave());
      }
      async handleSave() {
        const folderPath = this.folderInput.value.trim();
        const fileName = this.fileNameInput.value.trim();
        if (!folderPath) {
          new import_obsidian110.Notice("Please enter a folder path.");
          return;
        }
        if (!fileName) {
          new import_obsidian110.Notice("Please enter a file name.");
          return;
        }
        const sanitizedFileName = fileName.replace(/[/\\?%*:|"<>]/g, "").trim();
        if (!sanitizedFileName) {
          new import_obsidian110.Notice("Invalid file name.");
          return;
        }
        const fullPath = `${folderPath}/${sanitizedFileName}.md`;
        try {
          if (this.plugin.directoryManager) {
            await this.plugin.directoryManager.ensureDirectoryByPath(folderPath);
          } else {
            await this.plugin.app.vault.createFolder(folderPath).catch(() => {
            });
          }
          const existingFile = this.plugin.app.vault.getAbstractFileByPath(fullPath);
          if (existingFile instanceof import_obsidian110.TFile) {
            new import_obsidian110.Notice("File already exists. Please choose a different name.");
            return;
          }
          await this.plugin.app.vault.create(fullPath, this.content);
          new import_obsidian110.Notice(`Note saved to "${fullPath}"`);
          const file = this.plugin.app.vault.getAbstractFileByPath(fullPath);
          if (file) {
            await this.plugin.app.workspace.openLinkText(file.path, "", true);
          }
          if (this.onSaveSuccess) {
            this.onSaveSuccess(fullPath);
          }
          await this.plugin.updateLastSaveAsNoteFolder(folderPath);
          this.close();
        } catch (error) {
          new import_obsidian110.Notice("Failed to save note. Please try again.");
        }
      }
    };
  }
});

// src/modals/StandardAIResponseModal.ts
async function showAIResponseModal(app, options) {
  const modal = new StandardAIResponseModal(app, options);
  modal.open();
}
var import_obsidian111, StandardAIResponseModal;
var init_StandardAIResponseModal = __esm({
  "src/modals/StandardAIResponseModal.ts"() {
    import_obsidian111 = require("obsidian");
    init_ImproveResponseModal();
    init_StandardModal();
    init_SaveAsNoteModal();
    StandardAIResponseModal = class _StandardAIResponseModal extends StandardModal {
      // Reference to the parent modal
      constructor(app, options) {
        super(app);
        this.fullResponse = "";
        this.isGenerating = false;
        this.setSize("large");
        this.plugin = options.plugin;
        this.modelId = options.modelId;
        this.messages = options.messages;
        this.onInsert = options.onInsert || (() => {
        });
        this.commandText = options.commandText;
        this.parentModal = options.parentModal;
      }
      onOpen() {
        super.onOpen();
        this.addTitle("AI Response");
        this.responseContainer = this.contentEl.createDiv("ss-modal__response-container");
        this.responseContainer.style.padding = "20px";
        this.responseContainer.style.backgroundColor = "var(--background-secondary)";
        this.responseContainer.style.borderRadius = "8px";
        this.responseContainer.style.whiteSpace = "pre-wrap";
        this.responseContainer.style.maxHeight = "60vh";
        this.responseContainer.style.minHeight = "250px";
        this.responseContainer.style.overflow = "auto";
        this.responseContainer.style.marginBottom = "20px";
        this.responseContainer.style.boxShadow = "0 2px 8px rgba(0, 0, 0, 0.1)";
        this.responseContainer.style.display = "flex";
        this.responseContainer.style.flexDirection = "column";
        this.responseContainer.style.justifyContent = "center";
        this.responseContainer.style.fontSize = "15px";
        this.responseContainer.style.lineHeight = "1.5";
        this.buttonContainer = this.footerEl.createDiv("ss-button-container");
        this.buttonContainer.style.display = "flex";
        this.buttonContainer.style.flexWrap = "wrap";
        this.buttonContainer.style.gap = "10px";
        this.buttonContainer.style.justifyContent = "center";
        this.buttonContainer.style.alignItems = "center";
        this.buttonContainer.style.marginTop = "12px";
        if (!document.getElementById("ss-airesponse-redesign-styles")) {
          const styleEl = document.createElement("style");
          styleEl.id = "ss-airesponse-redesign-styles";
          styleEl.textContent = `
        .ss-button {
          min-width: 120px;
          max-width: 200px;
          flex: 1 1 auto;
        }
      `;
          document.head.appendChild(styleEl);
        }
        this.generateResponse();
      }
      createLoadingIndicator() {
        if (this.loadingEl) {
          this.loadingEl.remove();
        }
        this.loadingEl = this.responseContainer.createDiv("ss-modal__loading");
        this.loadingEl.style.display = "flex";
        this.loadingEl.style.alignItems = "center";
        this.loadingEl.style.justifyContent = "center";
        this.loadingEl.style.height = "100%";
        this.loadingEl.style.width = "100%";
        this.loadingEl.style.minHeight = "200px";
        this.loadingEl.style.boxSizing = "border-box";
        const loadingTextEl = this.loadingEl.createDiv("ss-modal__loading-text");
        loadingTextEl.setText("Processing with AI...");
        loadingTextEl.style.fontWeight = "600";
        loadingTextEl.style.color = "var(--text-accent)";
        loadingTextEl.style.fontSize = "20px";
        loadingTextEl.style.letterSpacing = "0.5px";
        loadingTextEl.style.textAlign = "center";
        if (!document.getElementById("systemsculpt-pulse-keyframes")) {
          const styleEl = document.createElement("style");
          styleEl.id = "systemsculpt-pulse-keyframes";
          styleEl.textContent = `
        @keyframes pulse {
          0% { opacity: 0.4; }
          50% { opacity: 1; }
          100% { opacity: 0.4; }
        }
        .ss-modal__loading-text {
          animation: pulse 2.5s infinite ease-in-out;
        }
      `;
          document.head.appendChild(styleEl);
        }
      }
      async generateResponse() {
        if (this.isGenerating) return;
        this.isGenerating = true;
        try {
          this.responseContainer.empty();
          this.buttonContainer.empty();
          this.fullResponse = "";
          this.createLoadingIndicator();
          try {
            const streamGenerator = this.plugin.aiService.streamMessage({
              messages: this.messages,
              model: this.modelId
            });
            for await (const event of streamGenerator) {
              if (event.type === "content") {
                if (this.loadingEl && this.fullResponse === "") {
                  this.loadingEl.remove();
                  this.loadingEl = void 0;
                  this.responseContainer.style.display = "block";
                  this.responseContainer.style.justifyContent = "initial";
                }
                this.fullResponse += event.text;
                this.responseContainer.setText(this.fullResponse);
                this.responseContainer.scrollTop = this.responseContainer.scrollHeight;
              }
            }
            this.createButtons();
          } catch (error) {
            if (this.loadingEl) {
              this.loadingEl.remove();
              this.responseContainer.style.display = "block";
              this.responseContainer.style.justifyContent = "initial";
            }
            this.responseContainer.setText(`Error: ${error.message || "Failed to get response from AI"}`);
            this.createButtons();
          }
        } catch (error) {
          new import_obsidian111.Notice("Failed to process with AI. Please try again.");
        } finally {
          this.isGenerating = false;
        }
      }
      // Helper method to close all modals and clean up command text
      closeAllModals() {
        if (this.commandText) {
          const activeView2 = this.app.workspace.getActiveViewOfType(import_obsidian111.MarkdownView);
          if (activeView2) {
            const editor = activeView2.editor;
            const content = editor.getValue();
            const commandIndex = content.indexOf(this.commandText);
            if (commandIndex >= 0) {
              const startPos = editor.offsetToPos(commandIndex);
              const endPos = editor.offsetToPos(commandIndex + this.commandText.length);
              editor.replaceRange("", startPos, endPos);
            }
          }
        }
        this.close();
        if (this.parentModal) {
          this.parentModal.close();
        }
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian111.MarkdownView);
        if (activeView) {
          activeView.editor.focus();
        }
      }
      createButtons() {
        this.buttonContainer.empty();
        const createButtonWithIcon = (text, iconName, buttonClass = "ss-button") => {
          const button = this.buttonContainer.createEl("button", { cls: buttonClass });
          const icon = button.createSpan("ss-button__icon");
          (0, import_obsidian111.setIcon)(icon, iconName);
          button.appendChild(document.createTextNode(text));
          return button;
        };
        const regenerateButton = createButtonWithIcon("Regenerate", "refresh-ccw", "ss-button mod-warning");
        this.registerDomEvent(regenerateButton, "click", () => this.generateResponse());
        const copyButton = createButtonWithIcon("Copy", "copy");
        this.registerDomEvent(copyButton, "click", async () => {
          await navigator.clipboard.writeText(this.fullResponse);
          new import_obsidian111.Notice("Response copied to clipboard");
          copyButton.textContent = "Copied!";
          setTimeout(() => {
            copyButton.innerHTML = "";
            const text = document.createTextNode("Copy");
            copyButton.appendChild(text);
            const newIcon = copyButton.createSpan("ss-button__icon");
            (0, import_obsidian111.setIcon)(newIcon, "copy");
          }, 2e3);
        });
        const insertButton = createButtonWithIcon("Insert", "text-cursor-input", "ss-button ss-button--primary");
        insertButton.addClass("mod-cta");
        this.registerDomEvent(insertButton, "click", () => {
          this.onInsert(this.fullResponse);
          this.closeAllModals();
        });
        const saveAsNoteButton = createButtonWithIcon("Save as Note", "file-plus");
        this.registerDomEvent(saveAsNoteButton, "click", () => {
          const now = /* @__PURE__ */ new Date();
          const defaultFileName = `AI Response ${now.toLocaleDateString()} ${now.toLocaleTimeString().replace(/:/g, ".")}`;
          const modal = new SaveAsNoteModal(
            this.app,
            this.plugin,
            this.plugin.settings.lastSaveAsNoteFolder || "SystemSculpt/AI Responses",
            defaultFileName,
            this.fullResponse,
            () => this.closeAllModals()
          );
          modal.open();
        });
        const improveButton = createButtonWithIcon("Improve", "sparkles");
        this.registerDomEvent(improveButton, "click", () => {
          const promptText = "Choose how to improve the response:";
          const improveModal = new ImproveResponseModal(
            this.app,
            promptText,
            "shorter",
            (inputValue) => {
              const improvementPrompt = "The user has requested that this text should be improved upon, and they provided these improvement details / requirements: " + inputValue;
              const assistantMsg = {
                role: "assistant",
                content: this.fullResponse,
                message_id: `assistant_${Date.now()}`
              };
              const userMsg = {
                role: "user",
                content: improvementPrompt,
                message_id: `user_${Date.now()}`
              };
              const modal = new _StandardAIResponseModal(this.app, {
                plugin: this.plugin,
                modelId: this.modelId,
                messages: [...this.messages, assistantMsg, userMsg],
                onInsert: this.onInsert,
                commandText: this.commandText,
                parentModal: this.parentModal
              });
              this.close();
              modal.open();
            }
          );
          improveModal.open();
        });
        const closeButton = createButtonWithIcon("Close", "x");
        this.registerDomEvent(closeButton, "click", () => this.closeAllModals());
      }
    };
  }
});

// src/modals/StandardTemplateModal.ts
var StandardTemplateModal_exports = {};
__export(StandardTemplateModal_exports, {
  StandardTemplateModal: () => StandardTemplateModal,
  showStandardTemplateModal: () => showStandardTemplateModal
});
async function showStandardTemplateModal(app, title, content, options = {}) {
  const modal = new StandardTemplateModal(app, title, content, options);
  return await modal.openAndGetValue();
}
var import_obsidian112, StandardTemplateModal;
var init_StandardTemplateModal = __esm({
  "src/modals/StandardTemplateModal.ts"() {
    import_obsidian112 = require("obsidian");
    init_StandardModelSelectionModal();
    init_StandardAIResponseModal();
    init_StandardModal();
    init_modelUtils();
    StandardTemplateModal = class extends StandardModal {
      constructor(app, title, initialContent, options = {}) {
        super(app);
        this.result = null;
        this.originalFile = null;
        this.selectedModelId = "";
        this.currentNoteContent = "";
        this.commandText = "";
        this.isPreviewMode = true;
        this.modelDropdown = null;
        this.templateTextArea = null;
        this.previewContainer = null;
        this.finalPromptTextArea = null;
        this.setSize("large");
        this.title = title;
        this.templateContent = initialContent;
        this.plugin = options.plugin;
        this.commandText = options.commandText || "";
        if (this.plugin) {
          this.selectedModelId = this.plugin.settings.selectedModelId || "";
        }
        this.loadCurrentNoteContent();
        if (this.plugin) {
          const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
          const possiblePath = `${systemPromptsDir}/${this.title}.md`;
          this.originalFile = this.app.vault.getAbstractFileByPath(possiblePath);
        }
      }
      async loadCurrentNoteContent() {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian112.MarkdownView);
        if (activeView) {
          this.currentNoteContent = activeView.getViewData();
          if (this.commandText && this.currentNoteContent.includes(this.commandText)) {
            this.currentNoteContent = this.currentNoteContent.replace(this.commandText, "");
          }
        }
      }
      async onOpen() {
        super.onOpen();
        this.registerDomEvent(this.modalEl, "keydown", (event) => {
          if (event.key === "Enter" && !event.isComposing && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            if (this.plugin) {
              this.processWithAI();
            } else {
            }
          }
        });
        if (this.plugin) {
          try {
            await this.plugin.modelService.validateSelectedModel();
            this.selectedModelId = this.plugin.settings.selectedModelId || "";
          } catch (e) {
          }
        }
        this.addTitle(`System Prompt: ${this.title}`, "Preview and edit template for processing notes");
        this.createModelSection();
        this.createNotePreviewSection();
        const titleEl = document.createElement("h3");
        titleEl.textContent = "Final System Prompt Preview & Edit";
        titleEl.addClass("ss-modal-title--large");
        this.contentEl.appendChild(titleEl);
        const labelEl = document.createElement("div");
        labelEl.textContent = "Review and edit the final system prompt before sending to AI";
        labelEl.addClass("ss-modal-label--small");
        this.contentEl.appendChild(labelEl);
        const textarea = document.createElement("textarea");
        textarea.value = this.templateContent;
        textarea.addClass("ss-modal-textarea");
        textarea.rows = 12;
        this.contentEl.appendChild(textarea);
        this.registerDomEvent(textarea, "keydown", (event) => {
          if (event.key === "Enter" && !event.isComposing && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            event.stopPropagation();
            if (this.plugin) {
              this.processWithAI();
            }
          }
        });
        this.finalPromptTextArea = textarea;
        this.addActionButton("Cancel", () => {
          this.result = null;
          this.close();
        }, false);
        if (this.plugin) {
          const processButton = this.addActionButton("Process with AI", async () => {
            await this.processWithAI();
          }, true, "send");
          processButton.addClass("mod-cta");
          this.registerDomEvent(processButton, "click", async () => {
            if (this.plugin) {
              await this.processWithAI();
            }
          });
          const shortcutEl = processButton.createSpan({
            cls: "systemsculpt-shortcut-hint",
            text: import_obsidian112.Platform.isMacOS ? " (\u2318+Enter)" : " (Ctrl+Enter)"
          });
        }
      }
      createModelSection() {
        const setting = new import_obsidian112.Setting(this.contentEl).setName("AI Model To Be Used");
        setting.addDropdown(async (dropdown) => {
          dropdown.selectEl.disabled = true;
          dropdown.addOption("", "Loading...");
          if (!this.plugin) return;
          try {
            const models = await this.plugin.modelService.getModels();
            dropdown.selectEl.innerHTML = "";
            for (const model of models) {
              const provider = model.provider || "";
              const prefix = provider.toLowerCase() === "systemsculpt" ? "[SS AI] " : `[${provider.toUpperCase()}] `;
              dropdown.addOption(model.id, `${prefix}${model.name}`);
            }
            dropdown.setValue(this.selectedModelId);
            dropdown.selectEl.disabled = false;
          } catch (e) {
            dropdown.selectEl.innerHTML = "";
            dropdown.addOption("", "Failed to load models");
          }
          dropdown.onChange((value) => {
            this.selectedModelId = value;
          });
          this.modelDropdown = dropdown.selectEl;
        });
        const changeDefaultTemplateModelButton = this.contentEl.createEl("button", {
          text: "Change Default Template Model...",
          cls: "ss-template-modal__model-change-default-btn ss-modal-button--small"
        });
        changeDefaultTemplateModelButton.addEventListener("click", async () => {
          if (!this.plugin) {
            new import_obsidian112.Notice("Cannot change default template model: plugin instance not available", 1e4);
            return;
          }
          const modelSelectionOptions = {
            app: this.app,
            plugin: this.plugin,
            currentModelId: this.plugin.settings.defaultTemplateModelId || "",
            onSelect: async (result) => {
              try {
                const canonicalId = ensureCanonicalId(result.modelId);
                this.plugin.settings.defaultTemplateModelId = canonicalId;
                this.plugin.settings.selectedModelId = canonicalId;
                await this.plugin.saveSettings();
                this.selectedModelId = canonicalId;
                if (this.modelDropdown) {
                  this.modelDropdown.value = canonicalId;
                }
                new import_obsidian112.Notice("Default template model updated and set as active model.", 3e3);
              } catch (error) {
                new import_obsidian112.Notice("Failed to update default template model", 1e4);
              }
            }
          };
          const modal = new StandardModelSelectionModal(modelSelectionOptions);
          modal.open();
        });
      }
      createNotePreviewSection() {
        if (!this.currentNoteContent) return;
        const maxPreviewLength = 500;
        const displayContent = this.currentNoteContent.length > maxPreviewLength ? this.currentNoteContent.substring(0, maxPreviewLength) + "..." : this.currentNoteContent;
        new import_obsidian112.Setting(this.contentEl).setName("Current Note Content").setDesc(displayContent);
      }
      async processWithAI() {
        var _a;
        if (!this.plugin) return;
        try {
          const finalPrompt = ((_a = this.finalPromptTextArea) == null ? void 0 : _a.value) || this.templateContent;
          if (!finalPrompt.trim()) {
            new import_obsidian112.Notice("System prompt cannot be empty", 1e4);
            return;
          }
          if (!this.currentNoteContent.trim()) {
            try {
              const skipWarning = this.plugin.settings.skipEmptyNoteWarning;
              if (!skipWarning) {
                const result = await new Promise((resolve) => {
                  const modal = new class extends import_obsidian112.Modal {
                    constructor(app) {
                      super(app);
                      this.confirmed = false;
                      this.checkboxChecked = false;
                    }
                    onOpen() {
                      const { contentEl } = this;
                      contentEl.empty();
                      contentEl.createEl("h3", { text: "Empty Note Detected" });
                      contentEl.createEl("p", { text: "The current note is empty. Are you sure you want to proceed?" });
                      const checkboxContainer = contentEl.createDiv({ cls: "empty-note-checkbox-container" });
                      const checkbox = document.createElement("input");
                      checkbox.type = "checkbox";
                      checkbox.id = "skip-empty-note-warning-checkbox";
                      const label = document.createElement("label");
                      label.htmlFor = "skip-empty-note-warning-checkbox";
                      label.textContent = "Do not show this notice again";
                      checkboxContainer.appendChild(checkbox);
                      checkboxContainer.appendChild(label);
                      const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
                      const cancelButton = buttonContainer.createEl("button", { text: "Cancel" });
                      cancelButton.addEventListener("click", () => {
                        this.close();
                      });
                      const proceedButton = buttonContainer.createEl("button", { text: "Proceed" });
                      proceedButton.addClass("mod-cta");
                      proceedButton.addEventListener("click", () => {
                        this.confirmed = true;
                        this.checkboxChecked = checkbox.checked;
                        this.close();
                      });
                      this.onClose = () => {
                        resolve({ confirmed: this.confirmed, checkboxChecked: this.checkboxChecked });
                      };
                    }
                  }(this.app);
                  modal.open();
                });
                if (!result || !result.confirmed) {
                  return;
                }
                if (result.checkboxChecked) {
                  try {
                    await this.plugin.getSettingsManager().updateSettings({ skipEmptyNoteWarning: true });
                  } catch (e) {
                  }
                }
              }
            } catch (e) {
              new import_obsidian112.Notice("Note content is empty", 1e4);
              return;
            }
          }
          if (!this.selectedModelId) {
            new import_obsidian112.Notice("Please select a model first", 1e4);
            return;
          }
          this.close();
          const messages = [
            {
              role: "system",
              content: finalPrompt,
              message_id: this.generateMessageId()
            },
            {
              role: "user",
              content: this.currentNoteContent,
              message_id: this.generateMessageId()
            }
          ];
          showAIResponseModal(this.app, {
            plugin: this.plugin,
            modelId: this.selectedModelId,
            messages,
            commandText: this.commandText,
            // Fix for issue where the "Insert" button did not insert the AI response into the editor.
            // This callback now correctly inserts the AI-generated response at the current cursor position
            // in the active Obsidian editor, resolving the previous bug.
            // Expected behavior: clicking "Insert" places the AI response directly into the note at the cursor.
            onInsert: (response) => {
              const activeView = this.app.workspace.getActiveViewOfType(import_obsidian112.MarkdownView);
              if (activeView) {
                const editor = activeView.editor;
                editor.replaceRange(response, editor.getCursor());
              } else {
                new import_obsidian112.Notice("No active editor to insert AI response");
              }
              this.result = response;
              this.close();
            }
          });
        } catch (error) {
          new import_obsidian112.Notice("Failed to process note with AI. Please try again.", 1e4);
        }
      }
      generateMessageId() {
        return Date.now().toString() + Math.random().toString().substring(2, 8);
      }
      onClose() {
        if (this.resolvePromise) {
          this.resolvePromise(this.result);
        }
        super.onClose();
      }
      async openAndGetValue() {
        return new Promise((resolve) => {
          this.resolvePromise = resolve;
          this.open();
        });
      }
    };
  }
});

// src/modals/ChangeLogModal.ts
var ChangeLogModal_exports = {};
__export(ChangeLogModal_exports, {
  ChangeLogModal: () => ChangeLogModal
});
var import_obsidian115, ChangeLogModal;
var init_ChangeLogModal = __esm({
  "src/modals/ChangeLogModal.ts"() {
    import_obsidian115 = require("obsidian");
    init_standard();
    init_ChangeLogService();
    ChangeLogModal = class extends StandardModal {
      constructor(app, options = {}) {
        super(app);
        this.entries = [];
        this.currentIndex = 0;
        this.notesContainer = null;
        this.headerMetaEl = null;
        this.prevButton = null;
        this.nextButton = null;
        this.viewOnGitHubButton = null;
        this.versionSelectEl = null;
        this.scrollContainer = null;
        this.touchStartX = null;
        this.touchStartY = null;
        this.touchStartTime = null;
        this.options = options;
        this.setSize("large");
        this.component = new import_obsidian115.Component();
        this.modalEl.addClass("ss-changelog-modal");
      }
      async onOpen() {
        super.onOpen();
        this.addTitle("What's New", "Plugin change log");
        const headerMeta = this.headerEl.createDiv({ cls: "ss-modal__subtitle" });
        this.headerMetaEl = headerMeta;
        const controlsRow = this.headerEl.createDiv({ cls: "ss-changelog-header-controls" });
        const versionSelect = controlsRow.createEl("select", { cls: "ss-changelog-version-select" });
        this.registerDomEvent(versionSelect, "change", () => {
          const idx = parseInt(versionSelect.value, 10);
          if (!Number.isNaN(idx)) {
            this.currentIndex = Math.min(Math.max(idx, 0), this.entries.length - 1);
            this.renderCurrent();
          }
        });
        this.versionSelectEl = versionSelect;
        const container = this.contentEl.createDiv({ cls: "systemsculpt-changelog-modal" });
        this.scrollContainer = container;
        const notesContainer = container.createDiv({ cls: "markdown-preview-view systemsculpt-changelog-notes" });
        this.notesContainer = notesContainer;
        const leftGroup = this.footerEl.createDiv({ cls: "ss-modal__footer-group" });
        const rightGroup = this.footerEl.createDiv({ cls: "ss-modal__footer-group" });
        const prevBtn = leftGroup.createEl("button", { cls: "ss-button ss-button--secondary" });
        (0, import_obsidian115.setIcon)(prevBtn.createSpan("ss-button__icon"), "chevron-left");
        prevBtn.appendChild(document.createTextNode("Previous"));
        prevBtn.addEventListener("click", () => this.goPrevious());
        this.prevButton = prevBtn;
        const nextBtn = leftGroup.createEl("button", { cls: "ss-button ss-button--secondary" });
        nextBtn.appendChild(document.createTextNode("Next"));
        (0, import_obsidian115.setIcon)(nextBtn.createSpan("ss-button__icon"), "chevron-right");
        nextBtn.addEventListener("click", () => this.goNext());
        this.nextButton = nextBtn;
        const githubBtn = rightGroup.createEl("button", { cls: "ss-button ss-button--secondary" });
        (0, import_obsidian115.setIcon)(githubBtn.createSpan("ss-button__icon"), "external-link");
        githubBtn.appendChild(document.createTextNode("View on GitHub"));
        githubBtn.addEventListener("click", () => this.openOnGitHub());
        this.viewOnGitHubButton = githubBtn;
        this.addActionButton("Close", () => this.close(), true);
        this.modalEl.setAttr("tabindex", "-1");
        this.modalEl.focus();
        this.registerDomEvent(this.modalEl, "keydown", (e) => {
          var _a;
          const ke = e;
          const target = ke.target;
          const tag = (_a = target == null ? void 0 : target.tagName) == null ? void 0 : _a.toLowerCase();
          if (tag === "input" || tag === "textarea" || tag === "select" || (target == null ? void 0 : target.isContentEditable)) return;
          if (ke.key === "ArrowLeft") this.goPrevious();
          if (ke.key === "ArrowRight") this.goNext();
          if (ke.key === "Home") {
            this.currentIndex = 0;
            this.renderCurrent();
          }
          if (ke.key === "End") {
            this.currentIndex = Math.max(0, this.entries.length - 1);
            this.renderCurrent();
          }
        });
        this.registerDomEvent(this.modalEl, "touchstart", (e) => {
          const te = e;
          if (te.touches.length !== 1) return;
          const t = te.touches[0];
          this.touchStartX = t.clientX;
          this.touchStartY = t.clientY;
          this.touchStartTime = Date.now();
        });
        this.registerDomEvent(this.modalEl, "touchend", (e) => {
          const te = e;
          if (this.touchStartX == null || this.touchStartY == null || this.touchStartTime == null) return;
          const t = te.changedTouches && te.changedTouches[0];
          if (!t) return;
          const dx = t.clientX - this.touchStartX;
          const dy = t.clientY - this.touchStartY;
          const dt = Date.now() - this.touchStartTime;
          this.touchStartX = this.touchStartY = this.touchStartTime = null;
          if (dt > 600) return;
          if (Math.abs(dx) > 60 && Math.abs(dy) < 40) {
            if (dx < 0) this.goNext();
            else this.goPrevious();
          }
        });
        await this.loadEntries();
        this.populateVersionSelect();
        await this.renderCurrent();
      }
      async loadEntries() {
        this.entries = await ChangeLogService.getReleases();
        this.currentIndex = ChangeLogService.findIndexByVersion(this.entries, this.options.startVersion);
        if (this.currentIndex < 0 || this.currentIndex >= this.entries.length) {
          this.currentIndex = 0;
        }
      }
      async renderCurrent() {
        if (!this.notesContainer || !this.headerMetaEl) return;
        const entry = this.entries[this.currentIndex];
        this.headerMetaEl.empty();
        const versionEl = this.headerMetaEl.createSpan({ cls: "systemsculpt-changelog-version", text: entry ? `Version ${entry.version}` : "Version" });
        const dotEl = this.headerMetaEl.createSpan({ text: " \u2022 " });
        const dateEl = this.headerMetaEl.createSpan({ cls: "systemsculpt-changelog-date", text: (entry == null ? void 0 : entry.date) || "" });
        this.notesContainer.empty();
        const notesHost = this.notesContainer.createDiv({ cls: "systemsculpt-changelog-notes-inner" });
        const markdown = (entry == null ? void 0 : entry.notes) || "No release notes available.";
        await import_obsidian115.MarkdownRenderer.renderMarkdown(
          markdown,
          notesHost,
          "systemsculpt-changelog.md",
          this.component
        );
        this.updateControls();
        if (this.scrollContainer) {
          this.scrollContainer.scrollTop = 0;
        }
      }
      updateControls() {
        if (!this.prevButton || !this.nextButton || !this.viewOnGitHubButton) return;
        const atStart = this.currentIndex <= 0;
        const atEnd = this.currentIndex >= this.entries.length - 1;
        this.prevButton.disabled = atStart;
        this.nextButton.disabled = atEnd;
        if (this.versionSelectEl) {
          this.versionSelectEl.value = String(this.currentIndex);
        }
      }
      goPrevious() {
        if (this.currentIndex > 0) {
          this.currentIndex--;
          this.renderCurrent();
        }
      }
      goNext() {
        if (this.currentIndex < this.entries.length - 1) {
          this.currentIndex++;
          this.renderCurrent();
        }
      }
      openOnGitHub() {
        const entry = this.entries[this.currentIndex];
        if (entry == null ? void 0 : entry.url) {
          window.open(entry.url, "_blank");
        } else {
          window.open(ChangeLogService.getReleasesPageUrl(), "_blank");
        }
      }
      populateVersionSelect() {
        if (!this.versionSelectEl) return;
        const select = this.versionSelectEl;
        select.empty();
        this.entries.forEach((e, i) => {
          const option = document.createElement("option");
          option.value = String(i);
          option.text = `${e.version} \u2014 ${e.date}`;
          select.appendChild(option);
        });
        select.value = String(this.currentIndex);
      }
      onClose() {
        super.onClose();
        try {
          this.component.unload();
        } catch (e) {
        }
      }
    };
  }
});

// src/constants/embeddings.ts
var embeddings_exports = {};
__export(embeddings_exports, {
  DEFAULT_EMBEDDING_MODEL: () => DEFAULT_EMBEDDING_MODEL,
  EMBEDDING_SCHEMA_VERSION: () => EMBEDDING_SCHEMA_VERSION,
  LEGACY_EMBEDDING_MODELS: () => LEGACY_EMBEDDING_MODELS,
  MAX_EMBEDDING_BATCH: () => MAX_EMBEDDING_BATCH,
  SUPPORTED_EMBEDDING_MODELS: () => SUPPORTED_EMBEDDING_MODELS
});
var DEFAULT_EMBEDDING_MODEL, SUPPORTED_EMBEDDING_MODELS, LEGACY_EMBEDDING_MODELS, MAX_EMBEDDING_BATCH, EMBEDDING_SCHEMA_VERSION;
var init_embeddings = __esm({
  "src/constants/embeddings.ts"() {
    DEFAULT_EMBEDDING_MODEL = "text-embedding-004";
    SUPPORTED_EMBEDDING_MODELS = [
      "text-embedding-004",
      "text-embedding-004-multilingual"
    ];
    LEGACY_EMBEDDING_MODELS = [
      // OpenAI legacy
      "text-embedding-ada-002",
      "text-embedding-3-small",
      "text-embedding-3-large",
      // Early Gemini embedding model
      "gemini-embedding-001",
      // Misc older aliases seen in the wild
      "text-embedding-002"
    ];
    MAX_EMBEDDING_BATCH = 50;
    EMBEDDING_SCHEMA_VERSION = 1;
  }
});

// src/commands/RunAudioAnalysis.ts
var RunAudioAnalysis_exports = {};
__export(RunAudioAnalysis_exports, {
  runAudioAnalysis: () => runAudioAnalysis
});
async function runAudioAnalysis(plugin) {
  try {
    new import_obsidian122.Notice(`Running audio chunking analysis...`);
    const report = "Audio chunking analysis functionality is disabled (test files not available)";
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const filePath = `AudioChunkingAnalysis-${timestamp}.md`;
    await plugin.app.vault.create(filePath, report);
    new import_obsidian122.Notice(`Analysis complete. Results saved to ${filePath}`);
    const file = plugin.app.vault.getAbstractFileByPath(filePath);
    if (file && file instanceof import_obsidian122.TFile) {
      plugin.app.workspace.getLeaf().openFile(file);
    }
  } catch (error) {
    new import_obsidian122.Notice(`Error running analysis: ${error instanceof Error ? error.message : String(error)}`);
  }
}
var import_obsidian122;
var init_RunAudioAnalysis = __esm({
  "src/commands/RunAudioAnalysis.ts"() {
    import_obsidian122 = require("obsidian");
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SystemSculptPlugin
});
module.exports = __toCommonJS(main_exports);

// src/services/ErrorCollectorService.ts
var _ErrorCollectorService = class _ErrorCollectorService {
  /**
   * Create a new ErrorCollectorService
   * @param maxLogs Maximum number of logs to store
   */
  constructor(maxLogs = 50) {
    this.logs = [];
    this.captureAllLogs = false;
    this.maxLogs = maxLogs;
    const c = console;
    this.originalConsoleLog = c["log"];
    this.originalConsoleInfo = c["info"];
    this.originalConsoleWarn = c["warn"];
    this.originalConsoleError = c["error"];
    this.originalConsoleDebug = c["debug"];
    this.importEarlyLogs();
    console["log"] = (...args) => {
      this.originalConsoleLog.apply(console, args);
      this.captureIfSystemSculpt("log", args);
    };
    console["info"] = (...args) => {
      this.originalConsoleInfo.apply(console, args);
      this.captureIfSystemSculpt("info", args);
    };
    console["warn"] = (...args) => {
      this.originalConsoleWarn.apply(console, args);
      this.captureIfSystemSculpt("warn", args);
    };
    console["error"] = (...args) => {
      this.originalConsoleError.apply(console, args);
      this.captureIfSystemSculpt("error", args);
    };
    console["debug"] = (...args) => {
      this.originalConsoleDebug.apply(console, args);
      this.captureIfSystemSculpt("debug", args);
    };
  }
  /**
   * Static method to initialize early logs capturing
   * Should be called before plugin initialization
   */
  static initializeEarlyLogsCapture() {
    const c = console;
    const originalLog = c["log"];
    const originalInfo = c["info"];
    const originalWarn = c["warn"];
    const originalError = c["error"];
    const originalDebug = c["debug"];
    const isSystemSculptLog = (args) => {
      return args.some((arg) => {
        if (typeof arg !== "string") return false;
        const str = arg.toString();
        return (
          // Direct mentions
          str.includes("SystemSculpt") || str.includes("systemsculpt") || // Plugin ID references
          str.includes("plugin:systemsculpt-ai") || str.includes("systemsculpt-ai") || // Short references
          str.includes("[SS]") || // Directory-related logs
          str.includes("Directory") && str.includes("SystemSculpt") || // Any early initialization messages that might not explicitly mention SystemSculpt
          str.includes("Starting directory initialization") || str.includes("directory structure initialized") || str.includes("Directory marked as available:") || // Template related early logs
          str.includes("Template manager initialized") || str.includes("Preloading models") || str.includes("template preload")
        );
      });
    };
    c["log"] = (...args) => {
      originalLog.apply(c, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: /* @__PURE__ */ new Date(),
        level: "log",
        args
      });
    };
    c["info"] = (...args) => {
      originalInfo.apply(c, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: /* @__PURE__ */ new Date(),
        level: "info",
        args
      });
    };
    c["warn"] = (...args) => {
      originalWarn.apply(c, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: /* @__PURE__ */ new Date(),
        level: "warn",
        args
      });
    };
    c["error"] = (...args) => {
      originalError.apply(c, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: /* @__PURE__ */ new Date(),
        level: "error",
        args
      });
    };
    c["debug"] = (...args) => {
      originalDebug.apply(c, args);
      _ErrorCollectorService.earlyLogs.push({
        timestamp: /* @__PURE__ */ new Date(),
        level: "debug",
        args
      });
    };
  }
  /**
   * Enable capturing ALL console logs (not just SystemSculpt)
   * Useful for comprehensive debugging
   */
  enableCaptureAllLogs() {
    this.captureAllLogs = true;
  }
  /**
   * Import early logs that were captured before this service was initialized
   */
  importEarlyLogs() {
    _ErrorCollectorService.earlyLogs.forEach((earlyLog) => {
      const { timestamp, level, args } = earlyLog;
      const message = args.map((arg) => {
        if (arg instanceof Error) {
          return `Error: ${arg.message}`;
        }
        if (typeof arg === "object" && arg !== null) {
          try {
            return JSON.stringify(arg, null, 2);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(" ");
      const errorArg = args.find((arg) => arg instanceof Error);
      const stack = errorArg instanceof Error ? errorArg.stack : void 0;
      this.logs.push({
        timestamp,
        level,
        context: "SystemSculpt",
        message,
        stack
      });
    });
    _ErrorCollectorService.earlyLogs = [];
  }
  /**
   * Check if args contain SystemSculpt references and capture if they do
   */
  captureIfSystemSculpt(level, args) {
    const isSystemSculptLog = (args2) => {
      if (this.captureAllLogs) return true;
      return args2.some((arg) => {
        if (typeof arg !== "string") return false;
        const str = arg.toString();
        return (
          // Direct mentions
          str.includes("SystemSculpt") || str.includes("systemsculpt") || // Plugin ID references
          str.includes("plugin:systemsculpt-ai") || str.includes("systemsculpt-ai") || // Short references
          str.includes("[SS]") || // Directory-related logs
          str.includes("Directory") && str.includes("SystemSculpt") || // Any early initialization messages that might not explicitly mention SystemSculpt
          str.includes("Starting directory initialization") || str.includes("directory structure initialized") || str.includes("Directory marked as available:") || // Template related early logs
          str.includes("Template manager initialized") || str.includes("Preloading models") || str.includes("template preload")
        );
      });
    };
    if (isSystemSculptLog(args)) {
      const message = args.map((arg) => {
        if (arg instanceof Error) {
          return `Error: ${arg.message}`;
        }
        if (typeof arg === "object" && arg !== null) {
          try {
            return JSON.stringify(arg, null, 2);
          } catch (e) {
            return String(arg);
          }
        }
        return String(arg);
      }).join(" ");
      const errorArg = args.find((arg) => arg instanceof Error);
      const stack = errorArg instanceof Error ? errorArg.stack : void 0;
      this.captureLog(level, "SystemSculpt", message, stack);
    }
  }
  /**
   * Capture a log entry
   * @param level Log level
   * @param context Context where the log occurred
   * @param message Log message
   * @param stack Optional stack trace
   */
  captureLog(level, context, message, stack) {
    this.logs.push({
      timestamp: /* @__PURE__ */ new Date(),
      level,
      context,
      message,
      stack
    });
    if (this.logs.length > this.maxLogs) {
      this.logs.shift();
    }
  }
  /**
   * Legacy method for backward compatibility
   */
  captureError(context, error, stack) {
    const message = error instanceof Error ? error.message : error;
    const errorStack = error instanceof Error ? error.stack : stack;
    this.captureLog("error", context, message, errorStack);
  }
  /**
   * Get all collected logs as formatted strings
   */
  getAllLogs() {
    return this.logs.map((log) => {
      const time = log.timestamp.toISOString();
      const base = `[${time}] [${log.level.toUpperCase()}] [${log.context}] ${log.message}`;
      if (log.stack) {
        const stackLines = log.stack.split("\n").slice(0, 3);
        return `${base}
    ${stackLines.join("\n    ")}`;
      }
      return base;
    });
  }
  /**
   * Get formatted logs since a given epoch millisecond timestamp.
   * Useful for extracting logs around a freeze window.
   */
  getLogsSince(sinceEpochMs) {
    return this.logs.filter((log) => log.timestamp.getTime() >= sinceEpochMs).map((log) => {
      const time = log.timestamp.toISOString();
      const base = `[${time}] [${log.level.toUpperCase()}] [${log.context}] ${log.message}`;
      if (log.stack) {
        const stackLines = log.stack.split("\n").slice(0, 3);
        return `${base}
    ${stackLines.join("\n    ")}`;
      }
      return base;
    });
  }
  /**
   * Get only error logs as formatted strings (for backward compatibility)
   */
  getErrorLogs() {
    return this.logs.filter((log) => log.level === "error").map((log) => {
      const time = log.timestamp.toISOString();
      const base = `[${time}] [${log.context}] ${log.message}`;
      if (log.stack) {
        const stackLines = log.stack.split("\n").slice(0, 3);
        return `${base}
    ${stackLines.join("\n    ")}`;
      }
      return base;
    });
  }
  /**
   * Clear all collected logs
   */
  clearLogs() {
    this.logs = [];
  }
  /**
   * Clean up when the service is no longer needed
   */
  unload() {
    console["log"] = this.originalConsoleLog;
    console["info"] = this.originalConsoleInfo;
    console["warn"] = this.originalConsoleWarn;
    console["error"] = this.originalConsoleError;
    console["debug"] = this.originalConsoleDebug;
  }
};
// Static array to temporarily store logs that happen very early during initialization
// Before the ErrorCollectorService is instantiated
_ErrorCollectorService.earlyLogs = [];
var ErrorCollectorService = _ErrorCollectorService;

// src/main.ts
var import_obsidian123 = require("obsidian");
init_notifications();
init_types();
init_SystemSculptService();

// src/settings/SystemSculptSettingTab.ts
var import_obsidian52 = require("obsidian");
init_ui();
init_SystemSculptService();

// src/settings/SettingsSearchIndex.ts
function buildSettingsIndexFromRoot(contentRootEl, tabsDef) {
  const all = [];
  const sections = Array.from(
    contentRootEl.querySelectorAll(".systemsculpt-tab-content")
  );
  sections.forEach((section) => {
    var _a, _b, _c;
    const tabId = section.dataset.tab || "";
    const tabLabel = ((_a = tabsDef.find((t) => t.id === tabId)) == null ? void 0 : _a.label) || tabId;
    const settings = Array.from(section.querySelectorAll(".setting-item"));
    for (const setting of settings) {
      const title = (((_b = setting.querySelector(".setting-item-name")) == null ? void 0 : _b.textContent) || "").trim();
      const description = (((_c = setting.querySelector(".setting-item-description")) == null ? void 0 : _c.textContent) || "").trim();
      if (!title && !description) continue;
      all.push({ tabId, tabLabel, title, description, element: setting });
    }
    const anchors = Array.from(section.querySelectorAll("[data-ss-search='true']"));
    for (const anchor of anchors) {
      const title = (anchor.getAttribute("data-ss-title") || anchor.textContent || "").trim();
      const description = (anchor.getAttribute("data-ss-desc") || "").trim();
      if (!title && !description) continue;
      all.push({ tabId, tabLabel, title, description, element: anchor });
    }
  });
  return all;
}

// src/settings/SetupTabContent.ts
var import_obsidian28 = require("obsidian");

// src/modals/CustomProviderModal.ts
var import_obsidian23 = require("obsidian");
init_StandardModal();
init_externalServices();
var CustomProviderModal = class extends StandardModal {
  constructor(app, plugin, options) {
    super(app);
    this.plugin = plugin;
    this.options = options;
    this.isToggleEnabled = options.isEnabled !== void 0 ? options.isEnabled : true;
    this.modalEl.addClass("systemsculpt-custom-provider-modal");
  }
  onOpen() {
    super.onOpen();
    this.setSize("small");
    const isEditing = !!this.options.existingId;
    this.addTitle(
      isEditing ? "Edit Provider" : "Add Provider",
      isEditing ? "Update your API provider connection" : "Connect to a new API provider"
    );
    this.createForm();
    this.addActionButton("Cancel", () => {
      if (this.options.onCancel) {
        this.options.onCancel();
      }
      this.close();
    }, false);
    this.addActionButton(isEditing ? "Update" : "Add Provider", () => {
      this.saveProvider();
    }, true);
  }
  createForm() {
    const formContainer = this.contentEl.createDiv("systemsculpt-custom-provider-form");
    if (!this.options.existingId) {
      this.createPresetSection(formContainer);
    }
    const nameGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group");
    nameGroup.createEl("label", { text: "Provider Name" });
    this.nameInput = nameGroup.createEl("input", {
      type: "text",
      placeholder: "e.g., OpenAI, Anthropic, etc.",
      value: this.options.name || ""
    });
    const endpointGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group");
    endpointGroup.createEl("label", { text: "API Endpoint" });
    this.endpointInput = endpointGroup.createEl("input", {
      type: "text",
      placeholder: "https://api.example.com/v1",
      value: this.options.endpoint || ""
    });
    const apiKeyGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group");
    const apiKeyLabel = apiKeyGroup.createEl("label");
    apiKeyLabel.setText("API Key");
    const apiKeyContainer = apiKeyGroup.createDiv("systemsculpt-api-key-input-container");
    this.apiKeyInput = apiKeyContainer.createEl("input", {
      type: "password",
      placeholder: "Enter your API key",
      // Initial placeholder
      value: this.options.apiKey || ""
    });
    const showHideButton = apiKeyContainer.createEl("button", {
      cls: "mod-small systemsculpt-api-key-toggle-visibility",
      // Use class from settings.css
      attr: { "aria-label": "Show/Hide API Key" }
    });
    (0, import_obsidian23.setIcon)(showHideButton, "eye-off");
    showHideButton.addEventListener("click", (e) => {
      e.preventDefault();
      if (this.apiKeyInput.type === "password") {
        this.apiKeyInput.type = "text";
        (0, import_obsidian23.setIcon)(showHideButton, "eye");
      } else {
        this.apiKeyInput.type = "password";
        (0, import_obsidian23.setIcon)(showHideButton, "eye-off");
      }
    });
    const updateApiKeyAppearance = () => {
      const name = this.nameInput.value.trim();
      const endpoint = this.endpointInput.value.trim().toLowerCase();
      const isLocal = endpoint.includes("localhost") || endpoint.includes("127.0.0.1");
      const isOptionalPreset = name === "Ollama" || name === "LM Studio";
      const isGenericCustom = name === "Custom Provider";
      const isEffectivelyOptional = isLocal || isOptionalPreset || isGenericCustom && !this.apiKeyInput.value;
      this.apiKeyInput.placeholder = isEffectivelyOptional ? "Enter your API key (optional)" : "Enter your API key";
      const currentOptionalSpan = apiKeyLabel.querySelector(".systemsculpt-optional-field-text");
      if (isEffectivelyOptional && !currentOptionalSpan) {
        apiKeyLabel.createSpan({
          text: " (optional)",
          cls: "systemsculpt-optional-field-text"
        });
      } else if (!isEffectivelyOptional && currentOptionalSpan) {
        currentOptionalSpan.remove();
      }
    };
    this.registerDomEvent(this.nameInput, "input", updateApiKeyAppearance);
    this.registerDomEvent(this.endpointInput, "input", updateApiKeyAppearance);
    updateApiKeyAppearance();
    const enabledGroup = formContainer.createDiv("systemsculpt-custom-provider-form-group systemsculpt-setting-item");
    const settingItemInfo = enabledGroup.createDiv("setting-item-info");
    settingItemInfo.createDiv({ text: "Enable Provider", cls: "setting-item-name" });
    settingItemInfo.createDiv({ text: "Make this provider available for use in the plugin.", cls: "setting-item-description" });
    const controlContainer = enabledGroup.createDiv("setting-item-control");
    this.providerToggleComponent = new import_obsidian23.ToggleComponent(controlContainer).setValue(this.isToggleEnabled).onChange((value) => {
      this.isToggleEnabled = value;
    });
  }
  createPresetSection(container) {
    const presetsSection = container.createDiv("systemsculpt-custom-provider-presets");
    presetsSection.createEl("label", { text: "Quick Setup" });
    const presetButtons = presetsSection.createDiv("systemsculpt-custom-provider-preset-buttons");
    this.createPresetButton(presetButtons, "OpenAI", AI_PROVIDERS.OPENAI.BASE_URL, "sparkles");
    this.createPresetButton(presetButtons, "Anthropic", AI_PROVIDERS.ANTHROPIC.BASE_URL, "bot");
    this.createPresetButton(presetButtons, "OpenRouter", AI_PROVIDERS.OPENROUTER.BASE_URL, "network");
    this.createPresetButton(presetButtons, "Groq", AI_PROVIDERS.GROQ.BASE_URL, "gauge");
    this.createPresetButton(presetButtons, "Ollama", LOCAL_SERVICES.OLLAMA.BASE_URL, "layers");
    this.createPresetButton(presetButtons, "LM Studio", LOCAL_SERVICES.LM_STUDIO.BASE_URL, "cpu");
    const detectBtn = presetButtons.createEl("button", {
      text: "Detect Local Providers",
      cls: "mod-small systemsculpt-preset-button"
    });
    const iconSpan = detectBtn.createSpan({ cls: "systemsculpt-preset-icon" });
    (0, import_obsidian23.setIcon)(iconSpan, "radar");
    detectBtn.prepend(iconSpan);
    detectBtn.addEventListener("click", async (e) => {
      e.preventDefault();
      try {
        detectBtn.setAttribute("disabled", "true");
        detectBtn.textContent = "Scanning\u2026";
        const { scanLocalLLMProviders: scanLocalLLMProviders2 } = await Promise.resolve().then(() => (init_LocalLLMScanner(), LocalLLMScanner_exports));
        const options = await scanLocalLLMProviders2();
        detectBtn.textContent = "Detect Local Providers";
        detectBtn.removeAttribute("disabled");
        if (!options || options.length === 0) {
          return;
        }
        const preferred = options.find((o) => o.type === "lmstudio") || options[0];
        this.nameInput.value = preferred.type === "ollama" ? "Ollama" : "LM Studio";
        this.endpointInput.value = preferred.endpoint;
        this.nameInput.dispatchEvent(new Event("input"));
        this.endpointInput.dispatchEvent(new Event("input"));
        this.apiKeyInput.focus();
      } catch (_) {
        detectBtn.textContent = "Detect Local Providers";
        detectBtn.removeAttribute("disabled");
      }
    });
  }
  createPresetButton(container, name, endpoint, icon) {
    const buttonEl = container.createEl("button", {
      text: name,
      cls: "mod-small systemsculpt-preset-button"
      // Added specific class for styling presets
    });
    const iconSpan = buttonEl.createSpan({ cls: "systemsculpt-preset-icon" });
    (0, import_obsidian23.setIcon)(iconSpan, icon);
    buttonEl.prepend(iconSpan);
    buttonEl.addEventListener("click", (e) => {
      e.preventDefault();
      this.nameInput.value = name;
      this.endpointInput.value = endpoint;
      this.nameInput.dispatchEvent(new Event("input"));
      this.endpointInput.dispatchEvent(new Event("input"));
      this.apiKeyInput.focus();
    });
  }
  saveProvider() {
    const name = this.nameInput.value.trim();
    const endpoint = this.endpointInput.value.trim();
    const apiKey = this.apiKeyInput.value.trim();
    if (!name) {
      this.showValidationError(this.nameInput, "Provider name is required");
      return;
    }
    if (!endpoint) {
      this.showValidationError(this.endpointInput, "API endpoint is required");
      return;
    }
    const isLocal = endpoint.toLowerCase().includes("localhost") || endpoint.toLowerCase().includes("127.0.0.1");
    const isOptionalPreset = name === "Ollama" || name === "LM Studio";
    const isGenericCustom = name === "Custom Provider";
    const isApiKeyEffectivelyOptional = isLocal || isOptionalPreset || isGenericCustom;
    if (!apiKey && !isApiKeyEffectivelyOptional) {
      this.showValidationError(this.apiKeyInput, "API key is required for this provider/endpoint");
      return;
    }
    const existingProviders = this.plugin.settings.customProviders || [];
    const otherProviders = this.options.existingId ? existingProviders.filter((p) => p.id !== this.options.existingId) : existingProviders;
    const duplicateName = otherProviders.find((p) => p.name.toLowerCase() === name.toLowerCase());
    if (duplicateName) {
      this.showValidationError(this.nameInput, `A provider with the name "${name}" already exists`);
      return;
    }
    const commonLocalEndpoints = [LOCAL_SERVICES.OLLAMA.BASE_URL, LOCAL_SERVICES.LM_STUDIO.BASE_URL];
    if (!commonLocalEndpoints.some((e) => e.toLowerCase() === endpoint.toLowerCase())) {
      const duplicateEndpoint = otherProviders.find((p) => p.endpoint.toLowerCase() === endpoint.toLowerCase());
      if (duplicateEndpoint) {
        this.showValidationError(this.endpointInput, `A provider with this endpoint already exists`);
        return;
      }
    }
    const provider = {
      id: this.options.existingId || `custom-${name.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}`,
      name,
      endpoint,
      apiKey,
      isEnabled: this.isToggleEnabled
    };
    this.options.onSave(provider);
    this.close();
  }
  showValidationError(inputEl, message) {
    const formGroup = inputEl.closest(".systemsculpt-custom-provider-form-group");
    if (!formGroup) return;
    formGroup.addClass("error");
    let validationEl = formGroup.querySelector(".systemsculpt-custom-provider-form-validation");
    if (!validationEl) {
      validationEl = formGroup.createDiv({ cls: "systemsculpt-custom-provider-form-validation" });
    }
    validationEl.textContent = message;
    inputEl.focus();
    const clearError = () => {
      formGroup.removeClass("error");
      if (validationEl) {
        validationEl.remove();
      }
      inputEl.removeEventListener("input", clearError);
    };
    this.registerDomEvent(inputEl, "input", clearError);
  }
};
function showCustomProviderModal(app, plugin, options) {
  return new Promise((resolve) => {
    const modal = new CustomProviderModal(app, plugin, {
      ...options,
      onSave: (provider) => {
        resolve(provider);
      },
      onCancel: () => {
        resolve(null);
      }
    });
    modal.open();
  });
}

// src/utils/licenseUtils.ts
var import_obsidian24 = require("obsidian");
function checkPremiumUserStatus(settings) {
  const isPremium = settings.licenseValid === true;
  const creditsBalance = settings.creditsBalance || 0;
  const hasCredits = creditsBalance > 0;
  const displayName = settings.displayName || settings.userName || settings.userEmail || "User";
  let status = {
    isPremium,
    hasCredits,
    displayName,
    creditsBalance
  };
  if (isPremium && displayName.toLowerCase().includes("daughter")) {
    status.greeting = `Welcome back, cherished family member ${displayName}! Your premium pro access is active with ${creditsBalance.toLocaleString()} credits.`;
  } else if (isPremium) {
    status.greeting = `Welcome ${displayName}! Premium Pro active \u2022 ${creditsBalance.toLocaleString()} credits`;
  }
  return status;
}
function formatCreditsDisplay(credits) {
  if (credits >= 1e6) {
    return `${(credits / 1e6).toFixed(1)}M`;
  } else if (credits >= 1e3) {
    return `${(credits / 1e3).toFixed(1)}K`;
  }
  return credits.toLocaleString();
}

// src/settings/SetupTabContent.ts
init_externalServices();
init_LocalLLMScanner();
init_ListSelectionModal();

// src/settings/uiHelpers.ts
var import_obsidian27 = require("obsidian");
var RESTORE_DEFAULTS_DESCRIPTION = "Restore the recommended defaults";
var RESTORE_DEFAULTS_LABEL = "Restore Recommended Defaults";
function createExternalHelpLink(container, options) {
  var _a;
  const link = document.createElement("a");
  link.textContent = options.text;
  link.href = options.href;
  link.classList.add("ss-help-link");
  if (options.className) {
    link.classList.add(options.className);
  }
  link.target = "_blank";
  link.rel = "noopener";
  const ariaLabel = (_a = options.ariaLabel) != null ? _a : `${options.text} (opens in new tab)`;
  link.setAttribute("aria-label", ariaLabel);
  link.title = ariaLabel;
  if (options.datasetTestId) {
    link.dataset.testId = options.datasetTestId;
  }
  const icon = document.createElement("span");
  icon.classList.add("ss-help-link-icon");
  (0, import_obsidian27.setIcon)(icon, "external-link");
  link.appendChild(icon);
  container.appendChild(link);
  return link;
}
function decorateRestoreDefaultsButton(button) {
  button.textContent = RESTORE_DEFAULTS_LABEL;
  button.setAttribute("aria-label", RESTORE_DEFAULTS_DESCRIPTION);
  button.title = RESTORE_DEFAULTS_DESCRIPTION;
  button.dataset.testId = "restore-defaults-btn";
  button.classList.add("ss-restore-defaults-btn");
  return button;
}
var RESTORE_DEFAULTS_COPY = {
  description: RESTORE_DEFAULTS_DESCRIPTION,
  label: RESTORE_DEFAULTS_LABEL
};

// src/settings/SetupTabContent.ts
var PROVIDER_PRESETS = [
  {
    id: "openai",
    name: "OpenAI",
    endpoint: AI_PROVIDERS.OPENAI.BASE_URL,
    description: "ChatGPT, GPT-4o, GPT-4.1, and latest OpenAI APIs"
  },
  {
    id: "anthropic",
    name: "Anthropic",
    endpoint: AI_PROVIDERS.ANTHROPIC.BASE_URL,
    description: "Claude 3 family with fast and reliable reasoning"
  },
  {
    id: "openrouter",
    name: "OpenRouter",
    endpoint: AI_PROVIDERS.OPENROUTER.BASE_URL,
    description: "One API for many frontier models (Meta, Mistral, Perplexity)"
  },
  {
    id: "groq",
    name: "Groq",
    endpoint: AI_PROVIDERS.GROQ.BASE_URL,
    description: "Groq LPU hosted models with ultra-low latency"
  },
  {
    id: "ollama",
    name: "Ollama (Local)",
    endpoint: LOCAL_SERVICES.OLLAMA.BASE_URL,
    description: "Run open models locally with Ollama"
  },
  {
    id: "lmstudio",
    name: "LM Studio (Local)",
    endpoint: LOCAL_SERVICES.LM_STUDIO.BASE_URL,
    description: "Connect to LM Studio on localhost"
  },
  {
    id: "custom",
    name: "Custom Provider",
    endpoint: "",
    description: "Manually configure any OpenAI-compatible endpoint"
  }
];
function displaySetupTabContent(containerEl, tabInstance, isProActive) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "setup";
  }
  renderAccountSection(containerEl, tabInstance, isProActive);
  renderSystemSculptSection(containerEl, tabInstance, isProActive);
  renderProvidersSection(containerEl, tabInstance);
  renderSupportSection(containerEl, tabInstance, isProActive);
}
function renderAccountSection(root, tabInstance, isProActive) {
  root.createEl("h3", { text: "Account & License" });
  const { plugin } = tabInstance;
  const userStatus = checkPremiumUserStatus(plugin.settings);
  const statusSetting = new import_obsidian28.Setting(root).setName("SystemSculpt account").setDesc(isProActive ? userStatus.greeting || "Pro features enabled." : "Activate a license to unlock SystemSculpt hosted models.");
  if (!isProActive) {
    statusSetting.addButton((button) => {
      button.setButtonText("View plans").setCta().onClick(() => window.open(SYSTEMSCULPT_WEBSITE.LIFETIME, "_blank"));
    });
  } else {
    statusSetting.addExtraButton((button) => {
      button.setIcon("external-link").setTooltip("Manage subscription").onClick(() => window.open(SYSTEMSCULPT_WEBSITE.LICENSE, "_blank"));
    });
  }
  const licenseSetting = new import_obsidian28.Setting(root).setName("License key").setDesc(isProActive ? "License validated. Credits update automatically." : "Paste your license key to enable SystemSculpt Pro.");
  let licenseInput = null;
  licenseSetting.addText((text) => {
    licenseInput = text;
    text.setPlaceholder("skss-...").setValue(plugin.settings.licenseKey || "").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ licenseKey: value });
    });
    text.inputEl.type = "password";
    tabInstance.registerListener(text.inputEl, "focus", () => {
      text.inputEl.type = "text";
    });
    tabInstance.registerListener(text.inputEl, "blur", () => {
      text.inputEl.type = "password";
    });
  });
  licenseSetting.addButton((button) => {
    button.setButtonText(isProActive ? "Deactivate" : "Activate");
    if (!isProActive) {
      button.setCta();
    }
    button.onClick(async () => {
      if (!licenseInput) return;
      const currentValue = (licenseInput.getValue() || "").trim();
      try {
        button.setDisabled(true);
        button.setButtonText("Working...");
        if (isProActive) {
          await plugin.getSettingsManager().updateSettings({ licenseValid: false });
          await plugin.getSettingsManager().updateSettings({ enableSystemSculptProvider: false });
          new import_obsidian28.Notice("License deactivated.");
          tabInstance.display();
          return;
        }
        if (!currentValue) {
          new import_obsidian28.Notice("Please enter a license key first.");
          return;
        }
        await plugin.getSettingsManager().updateSettings({ licenseKey: currentValue });
        const validatingNotice = new import_obsidian28.Notice("Validating license key...", 0);
        try {
          const success = await plugin.getLicenseManager().validateLicenseKey(true, false);
          validatingNotice.hide();
          if (success) {
            new import_obsidian28.Notice("License activated successfully.");
            tabInstance.display();
          } else {
            new import_obsidian28.Notice("Invalid license key. Please check and try again.");
          }
        } catch (error) {
          validatingNotice.hide();
          new import_obsidian28.Notice(`License validation failed: ${(error == null ? void 0 : error.message) || error}`);
        }
      } finally {
        button.setDisabled(false);
        button.setButtonText(isProActive ? "Deactivate" : "Activate");
      }
    });
  });
  if (isProActive && (plugin.settings.licenseKey || "").length > 0) {
    licenseSetting.addExtraButton((button) => {
      button.setIcon("copy").setTooltip("Copy license key").onClick(async () => {
        if (!plugin.settings.licenseKey) return;
        await navigator.clipboard.writeText(plugin.settings.licenseKey);
        new import_obsidian28.Notice("License key copied to clipboard.");
      });
    });
  }
  const creditsTarget = licenseSetting.descEl.createSpan({ cls: "ss-inline-note" });
  displayCreditBreakdown(creditsTarget, tabInstance);
}
function renderSystemSculptSection(root, tabInstance, isProActive) {
  root.createEl("h3", { text: "SystemSculpt provider" });
  const { plugin } = tabInstance;
  const providerSetting = new import_obsidian28.Setting(root).setName("Enable SystemSculpt models").setDesc(isProActive ? "Use hosted SystemSculpt models alongside your own providers." : "Activate a Pro license to enable SystemSculpt hosted models.");
  providerSetting.addToggle((toggle) => {
    toggle.setDisabled(!isProActive).setValue(isProActive && !!plugin.settings.enableSystemSculptProvider).onChange(async (value) => {
      if (!isProActive) {
        toggle.setValue(false);
        return;
      }
      await plugin.getSettingsManager().updateSettings({ enableSystemSculptProvider: value });
      plugin.customProviderService.clearCache();
      await plugin.modelService.refreshModels();
      new import_obsidian28.Notice(`SystemSculpt ${value ? "enabled" : "disabled"}.`);
      tabInstance.display();
    });
  });
  if (isProActive) {
    providerSetting.addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip("Refresh available models").onClick(async () => {
        button.setDisabled(true);
        try {
          await plugin.modelService.refreshModels();
          new import_obsidian28.Notice("SystemSculpt models refreshed.");
        } finally {
          button.setDisabled(false);
        }
      });
    });
    new import_obsidian28.Setting(root).setName("Use as fallback provider").setDesc("Automatically fall back to SystemSculpt when other providers fail.").addToggle((toggle) => {
      toggle.setValue(!!plugin.settings.useSystemSculptAsFallback).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ useSystemSculptAsFallback: value });
        new import_obsidian28.Notice(`Fallback ${value ? "enabled" : "disabled"}.`);
      });
    });
  }
}
function renderProvidersSection(root, tabInstance) {
  root.createEl("h3", { text: "Custom providers" });
  const { plugin } = tabInstance;
  const providers = [...plugin.settings.customProviders || []];
  const isAdvancedMode = plugin.settings.settingsMode === "advanced";
  const addSetting = new import_obsidian28.Setting(root).setName("Add provider").setDesc("Connect OpenAI, Anthropic, Groq, OpenRouter, or any OpenAI-compatible service.");
  addSetting.addButton((button) => {
    button.setButtonText("New provider").setCta().onClick(async () => {
      const items = PROVIDER_PRESETS.map((preset2, index) => ({
        id: `preset-${index}`,
        title: preset2.name,
        description: preset2.description,
        icon: preset2.id === "custom" ? "settings" : "network",
        metadata: preset2
      }));
      const modal = new ListSelectionModal(tabInstance.app, items, {
        title: "Add provider",
        description: "Choose a provider template to pre-fill the connection details.",
        withSearch: true,
        size: "medium"
      });
      const [selection] = await modal.openAndGetSelection();
      if (!(selection == null ? void 0 : selection.metadata)) return;
      const preset = selection.metadata;
      await openCustomProviderSetup(tabInstance, preset.name, preset.endpoint);
    });
  });
  addSetting.addButton((button) => {
    button.setButtonText("Scan local").onClick(async () => {
      await scanLocalProviders(tabInstance, button);
    });
  });
  if (!isAdvancedMode) {
    const summary = new import_obsidian28.Setting(root).setName("Advanced management").setDesc("Switch to Advanced mode to edit providers.");
    summary.addButton((button) => {
      button.setButtonText("Switch to Advanced").onClick(async () => {
        await plugin.getSettingsManager().updateSettings({ settingsMode: "advanced" });
        tabInstance.display();
      });
    });
    return;
  }
  if (providers.length === 0) {
    root.createEl("p", {
      text: "No custom providers configured yet. Add a provider to use your own API keys.",
      cls: "setting-item-description"
    });
    return;
  }
  providers.forEach((provider) => {
    const providerSetting = new import_obsidian28.Setting(root).setName(provider.name || "Custom provider").setDesc(provider.endpoint || "No endpoint configured");
    providerSetting.addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = provider.isEnabled) != null ? _a : true).onChange(async (value) => {
        var _a2;
        if (!value) {
          provider.isEnabled = false;
          await saveProviders(tabInstance, provider);
          plugin.customProviderService.clearCache();
          await plugin.modelService.refreshModels();
          new import_obsidian28.Notice(`${provider.name} disabled.`);
          tabInstance.display();
          return;
        }
        const enableNotice = new import_obsidian28.Notice(`Testing ${provider.name}...`, 0);
        try {
          const result = await plugin.customProviderService.testConnection(provider);
          enableNotice.hide();
          if (result.success) {
            provider.isEnabled = true;
            provider.failureCount = 0;
            delete provider.lastFailureTime;
            provider.lastTested = Date.now();
            await saveProviders(tabInstance, provider);
            plugin.customProviderService.clearCache();
            await plugin.modelService.refreshModels();
            new import_obsidian28.Notice(`${provider.name} enabled (${((_a2 = result.models) == null ? void 0 : _a2.length) || 0} models).`);
            tabInstance.display();
          } else {
            new import_obsidian28.Notice(`Failed to enable ${provider.name}: ${result.error || "Connection failed"}`, 6e3);
            toggle.setValue(false);
          }
        } catch (error) {
          enableNotice.hide();
          new import_obsidian28.Notice(`Failed to enable ${provider.name}: ${(error == null ? void 0 : error.message) || error}`);
          toggle.setValue(false);
        }
      });
    });
    providerSetting.addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip("Test connection").onClick(async () => {
        var _a;
        button.setDisabled(true);
        try {
          const result = await plugin.customProviderService.testConnection(provider);
          provider.lastTested = Date.now();
          await saveProviders(tabInstance, provider);
          new import_obsidian28.Notice(
            result.success ? `\u2705 ${provider.name}: ${((_a = result.models) == null ? void 0 : _a.length) || 0} model(s) available.` : `\u274C ${provider.name}: ${result.error || "Connection failed."}`
          );
          tabInstance.display();
        } finally {
          button.setDisabled(false);
        }
      });
    });
    providerSetting.addExtraButton((button) => {
      button.setIcon("settings").setTooltip("Edit provider").onClick(() => {
        openCustomProviderSetup(tabInstance, provider.name, provider.endpoint, provider.id, provider.apiKey, provider.isEnabled);
      });
    });
    providerSetting.addExtraButton((button) => {
      button.setIcon("trash").setTooltip("Remove provider").onClick(async () => {
        if (!confirm(`Remove '${provider.name}'?`)) return;
        const updated = (plugin.settings.customProviders || []).filter((p) => p.id !== provider.id);
        await plugin.getSettingsManager().updateSettings({ customProviders: updated });
        plugin.customProviderService.clearCache();
        await plugin.modelService.refreshModels();
        new import_obsidian28.Notice(`${provider.name} removed.`);
        tabInstance.display();
      });
    });
  });
}
function renderSupportSection(root, tabInstance, isProActive) {
  root.createEl("h3", { text: "Help & resources" });
  const linksSetting = new import_obsidian28.Setting(root).setName("Documentation").setDesc("Guides, troubleshooting, and ways to contact support.");
  const linkContainer = linksSetting.controlEl.createDiv({ cls: "ss-help-links" });
  createExternalHelpLink(linkContainer, {
    text: "Docs",
    href: SYSTEMSCULPT_WEBSITE.DOCS,
    ariaLabel: "Open the SystemSculpt documentation (opens in new tab)"
  });
  linkContainer.createSpan({ text: "\u2022", cls: "ss-help-separator" });
  createExternalHelpLink(linkContainer, {
    text: "Support",
    href: SYSTEMSCULPT_WEBSITE.SUPPORT,
    ariaLabel: "Contact SystemSculpt support (opens in new tab)"
  });
  linkContainer.createSpan({ text: "\u2022", cls: "ss-help-separator" });
  createExternalHelpLink(linkContainer, {
    text: "Report an issue",
    href: SYSTEMSCULPT_WEBSITE.FEEDBACK,
    ariaLabel: "Open the feedback form on GitHub (opens in new tab)"
  });
  const releaseSetting = new import_obsidian28.Setting(root).setName("Release notes").setDesc("See what changed in the latest release and the roadmap.");
  releaseSetting.addButton((button) => {
    button.setButtonText("View changelog").onClick(() => window.open(`${SYSTEMSCULPT_WEBSITE.BASE_URL}/changelog`, "_blank"));
  });
}
async function scanLocalProviders(tabInstance, trigger) {
  try {
    if (trigger) {
      trigger.setDisabled(true);
      trigger.setButtonText("Scanning...");
    }
    const options = await scanLocalLLMProviders();
    if (!options || options.length === 0) {
      new import_obsidian28.Notice("No local providers detected on the default ports.");
      return;
    }
    const items = options.map((opt, index) => ({
      id: `local-${index}`,
      title: opt.label,
      description: `${opt.endpoint} \u2022 ${opt.models.length} model${opt.models.length === 1 ? "" : "s"}`,
      icon: opt.type === "ollama" ? "layers" : "cpu",
      metadata: { index }
    }));
    const modal = new ListSelectionModal(tabInstance.app, items, {
      title: "Local providers",
      description: "Choose local endpoints to add or enable.",
      withSearch: false,
      multiSelect: true,
      size: "medium"
    });
    const selection = await modal.openAndGetSelection();
    if (!selection || selection.length === 0) return;
    const chosenIndexes = new Set(selection.map((item) => {
      var _a, _b;
      return (_b = (_a = item.metadata) == null ? void 0 : _a.index) != null ? _b : -1;
    }));
    const chosen = options.filter((_, idx) => chosenIndexes.has(idx));
    const existing = tabInstance.plugin.settings.customProviders || [];
    const updated = [...existing];
    for (const opt of chosen) {
      const baseName = opt.type === "ollama" ? "Ollama" : "LM Studio";
      const normalizedEndpoint = (opt.endpoint || "").replace(/\/$/, "");
      const already = updated.find((p) => (p.endpoint || "").replace(/\/$/, "") === normalizedEndpoint);
      if (already) {
        already.isEnabled = true;
        continue;
      }
      const newProvider = {
        id: `local-${baseName.toLowerCase()}-${Date.now()}-${Math.random().toString(16).slice(2)}`,
        name: baseName,
        endpoint: opt.endpoint,
        apiKey: "",
        isEnabled: true
      };
      updated.push(newProvider);
    }
    await tabInstance.plugin.getSettingsManager().updateSettings({ customProviders: updated });
    tabInstance.plugin.customProviderService.clearCache();
    await tabInstance.plugin.modelService.refreshModels();
    new import_obsidian28.Notice(`Added or enabled ${chosen.length} local provider${chosen.length === 1 ? "" : "s"}.`);
    tabInstance.display();
  } catch (error) {
    new import_obsidian28.Notice(`Scan failed: ${(error == null ? void 0 : error.message) || error}`);
  } finally {
    if (trigger) {
      trigger.setDisabled(false);
      trigger.setButtonText("Scan local");
    }
  }
}
async function saveProviders(tabInstance, provider) {
  const providers = [...tabInstance.plugin.settings.customProviders || []];
  const updated = providers.map((p) => p.id === provider.id ? provider : p);
  await tabInstance.plugin.getSettingsManager().updateSettings({ customProviders: updated });
}
async function openCustomProviderSetup(tabInstance, name, endpoint, existingId, apiKey, isEnabled) {
  const { app, plugin } = tabInstance;
  const provider = await showCustomProviderModal(app, plugin, {
    name,
    endpoint,
    existingId,
    apiKey,
    isEnabled: existingId ? isEnabled : true
  });
  if (!provider) return;
  let updatedProviders = [...plugin.settings.customProviders || []];
  if (existingId) {
    updatedProviders = updatedProviders.map((p) => p.id === existingId ? provider : p);
  } else {
    updatedProviders.push(provider);
  }
  await plugin.getSettingsManager().updateSettings({ customProviders: updatedProviders });
  if (provider.isEnabled) {
    try {
      plugin.customProviderService.clearCache();
      await plugin.modelService.refreshModels();
      new import_obsidian28.Notice(`\u2705 ${provider.name} is ready and models have been loaded.`);
    } catch (error) {
      new import_obsidian28.Notice(`\u26A0\uFE0F ${provider.name} added but model refresh failed. Check credentials and connection.`);
    }
  } else {
    new import_obsidian28.Notice(`${existingId ? "Updated" : "Added"} ${provider.name}.`);
  }
  tabInstance.display();
}
function displayCreditBreakdown(containerEl, tabInstance) {
  try {
    containerEl.setText("Credits: \u2026");
    tabInstance.systemSculptService.getCreditBreakdown().then((breakdown) => {
      if (!breakdown) {
        containerEl.setText("");
        return;
      }
      containerEl.setText(`Credits: ${formatCreditsDisplay(breakdown.total)}`);
    }).catch(() => {
      tabInstance.systemSculptService.getTokenBalance().then((balance) => {
        containerEl.setText(`Credits: ${formatCreditsDisplay(balance)}`);
      }).catch(() => containerEl.setText(""));
    });
  } catch (error) {
    containerEl.setText("");
  }
}

// src/settings/ModelSettingsTabContent.ts
var import_obsidian33 = require("obsidian");
init_StandardModelSelectionModal();
async function displayModelSettingsTabContent(containerEl, tabInstance) {
  var _a;
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "model-settings";
  }
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Model settings" });
  containerEl.createEl("p", {
    text: "Configure how AI models are chosen across SystemSculpt.",
    cls: "setting-item-description"
  });
  const isAdvancedMode = plugin.settings.settingsMode === "advanced";
  const useLatestEverywhere = (_a = plugin.settings.useLatestModelEverywhere) != null ? _a : true;
  const globalToggle = new import_obsidian33.Setting(containerEl).setName("Use your latest choices");
  if (isAdvancedMode) {
    globalToggle.setDesc("New chats, title generation, and post-processing use the most recent model you selected. Turn off to pick fixed defaults.").addToggle((toggle) => {
      toggle.setValue(useLatestEverywhere).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ useLatestModelEverywhere: value });
        tabInstance.display();
      });
    });
  } else {
    globalToggle.setDesc("Standard mode always uses the most recent model you selected.").addToggle((toggle) => toggle.setValue(true).setDisabled(true));
  }
  const availableModels = await plugin.modelService.getModels();
  const { ensureCanonicalId: ensureCanonicalId2, findModelById: findModelById2, getModelLabelWithProvider: getModelLabelWithProvider2 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
  const createSummary = (modelId, emptyFallback) => {
    if (!modelId) {
      return emptyFallback;
    }
    const canonical = ensureCanonicalId2(modelId);
    const label = getModelLabelWithProvider2(canonical);
    const stored = findModelById2(availableModels, canonical);
    return stored ? label : `${label} (unavailable)`;
  };
  const renderModelSetting = ({
    name,
    description,
    getModelId,
    defaultMessage,
    modalTitle,
    modalDescription,
    applySelection,
    successMessage
  }) => {
    const setting = new import_obsidian33.Setting(containerEl).setName(name).setDesc(description);
    const detail = setting.descEl.createDiv({ cls: "ss-setting-subtext" });
    const updateSummary = () => {
      if (!isAdvancedMode || useLatestEverywhere) {
        detail.setText(defaultMessage);
        return;
      }
      if (availableModels.length === 0) {
        detail.setText("No models available \u2014 set up providers in Overview & Setup.");
        return;
      }
      detail.setText(createSummary(getModelId(), 'Click "Change..." to pick a model.'));
    };
    updateSummary();
    if (!isAdvancedMode || useLatestEverywhere) {
      setting.addExtraButton((button) => {
        button.setIcon("lock").setTooltip('Controlled by "Use your latest choices".');
        button.setDisabled(true);
      });
      return;
    }
    if (availableModels.length === 0) {
      setting.addExtraButton((button) => {
        button.setIcon("info").setTooltip("No models available");
        button.setDisabled(true);
      });
      return;
    }
    setting.addButton((button) => {
      button.setButtonText("Change...").onClick(async () => {
        const modal = new StandardModelSelectionModal({
          app,
          plugin,
          currentModelId: getModelId() || "",
          title: modalTitle,
          description: modalDescription,
          onSelect: async (result) => {
            var _a2, _b;
            try {
              const canonicalId = ensureCanonicalId2(result.modelId);
              const parsed = parseCanonicalId3(canonicalId);
              if (!parsed) {
                throw new Error("Invalid model identifier");
              }
              await applySelection(parsed.providerId, canonicalId);
              (_b = (_a2 = plugin.emitter) == null ? void 0 : _a2.emit) == null ? void 0 : _b.call(_a2, "settingsChanged");
              updateSummary();
              new import_obsidian33.Notice(successMessage, 3e3);
            } catch (error) {
              new import_obsidian33.Notice("Failed to update model. Please try again.", 5e3);
            }
          }
        });
        modal.open();
      });
    });
  };
  renderModelSetting({
    name: "Default chat model",
    description: "Used for new chat conversations.",
    getModelId: () => plugin.settings.selectedModelId,
    defaultMessage: "Follows your latest selection",
    modalTitle: "Select default chat model",
    modalDescription: "Choose the model used for all new chats.",
    applySelection: async (_providerId, canonicalId) => {
      await plugin.getSettingsManager().updateSettings({ selectedModelId: canonicalId });
    },
    successMessage: "Default chat model updated successfully."
  });
  renderModelSetting({
    name: "Title generation model",
    description: "Generates chat titles when automatic titles are enabled.",
    getModelId: () => plugin.settings.titleGenerationModelId,
    defaultMessage: "Same as current chat model",
    modalTitle: "Select title generation model",
    modalDescription: "Choose the model used for generating chat titles.",
    applySelection: async (providerId, canonicalId) => {
      await plugin.getSettingsManager().updateSettings({
        titleGenerationProviderId: providerId,
        titleGenerationModelId: canonicalId
      });
    },
    successMessage: "Title generation model updated successfully."
  });
  renderModelSetting({
    name: "Post-processing model",
    description: "Optional model used to refine audio transcription output.",
    getModelId: () => plugin.settings.postProcessingModelId,
    defaultMessage: "Same as current chat model",
    modalTitle: "Select post-processing model",
    modalDescription: "Choose the model used for post-processing transcriptions.",
    applySelection: async (providerId, canonicalId) => {
      await plugin.getSettingsManager().updateSettings({
        postProcessingProviderId: providerId,
        postProcessingModelId: canonicalId
      });
    },
    successMessage: "Post-processing model updated successfully."
  });
  if (availableModels.length === 0) {
    containerEl.createEl("p", {
      text: '\u{1F4A1} Set up at least one AI provider in the "Overview & Setup" tab to start choosing models.',
      cls: "setting-item-description ss-inline-note"
    });
  }
  if (!isAdvancedMode) {
    containerEl.createEl("h3", { text: "Chat basics" });
    new import_obsidian33.Setting(containerEl).setName("Default chat font size").setDesc("Select the default text size for new chat messages.").addDropdown((dropdown) => {
      dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(plugin.settings.chatFontSize || "medium").onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ chatFontSize: value });
        new import_obsidian33.Notice(`Default chat font size set to ${value}.`);
      });
    });
  }
  if (isAdvancedMode) {
    containerEl.createEl("h3", { text: "Model preferences" });
    new import_obsidian33.Setting(containerEl).setName("Model list sort order").setDesc("Choose how models are sorted in selection lists.").addDropdown((dropdown) => {
      dropdown.addOption("default", "Default (natural order)").addOption("alphabetical", "Alphabetical (provider/name)").setValue(plugin.settings.favoritesFilterSettings.modelSortOrder).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...plugin.settings.favoritesFilterSettings,
            modelSortOrder: value
          }
        });
        new import_obsidian33.Notice(`Model sort order set to ${value === "default" ? "default" : "alphabetical"}.`);
      });
    });
    new import_obsidian33.Setting(containerEl).setName("Always show favorites first").setDesc("Pinned models stay at the top of selectors when enabled.").addToggle((toggle) => {
      toggle.setValue(!!plugin.settings.favoritesFilterSettings.favoritesFirst).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...plugin.settings.favoritesFilterSettings,
            favoritesFirst: value
          }
        });
        new import_obsidian33.Notice(`Favorites first ${value ? "enabled" : "disabled"}.`);
      });
    });
    new import_obsidian33.Setting(containerEl).setName('Default to "Favorites only" filter').setDesc("When enabled, the model selector opens with only favorites shown.").addToggle((toggle) => {
      toggle.setValue(!!plugin.settings.favoritesFilterSettings.showFavoritesOnly).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({
          favoritesFilterSettings: {
            ...plugin.settings.favoritesFilterSettings,
            showFavoritesOnly: value
          }
        });
        new import_obsidian33.Notice(`Favorites-only default ${value ? "enabled" : "disabled"}.`);
      });
    });
  }
  if (isAdvancedMode && plugin.settings.transcriptionProvider === "custom") {
    containerEl.createEl("h3", { text: "Transcription model settings" });
    const transcriptionSetting = new import_obsidian33.Setting(containerEl).setName("Transcription model").setDesc("Used when the custom transcription provider is active.");
    transcriptionSetting.descEl.createDiv({
      cls: "ss-setting-subtext",
      text: plugin.settings.customTranscriptionModel || "Not configured"
    });
    containerEl.createEl("p", {
      text: "Configure custom transcription providers in the Audio & Transcription tab.",
      cls: "setting-item-description"
    });
  }
}
function parseCanonicalId3(canonicalId) {
  const parts = canonicalId.split("@@");
  if (parts.length === 2) {
    return { providerId: parts[0], modelId: parts[1] };
  }
  return null;
}

// src/settings/SystemPromptSettingsTabContent.ts
var import_obsidian39 = require("obsidian");
init_StandardSystemPromptSelectionModal();

// src/modals/TitleGenerationPromptModal.ts
var import_obsidian37 = require("obsidian");

// src/components/FileSuggester.ts
var import_obsidian36 = require("obsidian");
var FileSuggester = class extends import_obsidian36.AbstractInputSuggest {
  constructor(inputEl, onSelectCb, app, directory) {
    super(app, inputEl);
    this.inputEl = inputEl;
    this.onSelectCb = onSelectCb;
    this.directory = directory;
    this.content = getFileSuggestions(app, directory);
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    return [...this.content].filter(
      (content) => content.toLowerCase().includes(lowerCaseInputStr)
    );
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content, evt) {
    this.onSelectCb(content);
    this.inputEl.value = content;
    this.inputEl.blur();
    this.close();
  }
};
function getFileSuggestions(app, directory) {
  const files = app.vault.getAllLoadedFiles().filter((file) => {
    var _a;
    if (!(file instanceof import_obsidian36.TFile)) return false;
    if (directory) {
      const normalizedDir = directory.replace(/\/$/, "");
      const inDirOrSubdir = ((_a = file.parent) == null ? void 0 : _a.path) === normalizedDir || file.path.startsWith(`${normalizedDir}/`);
      return inDirOrSubdir && file.extension === "md";
    } else {
      return true;
    }
  });
  return new Set(files.map((file) => file.path));
}
function attachFileSuggester(inputEl, onSelect, app, directory) {
  return new FileSuggester(inputEl, onSelect, app, directory);
}

// src/modals/TitleGenerationPromptModal.ts
init_StandardModal();
init_types();
var TitleGenerationPromptModal = class extends StandardModal {
  constructor(app, plugin, contentPreview, isDocument, onSubmit) {
    super(app);
    this.result = null;
    this.settingsChanged = false;
    this.presets = [
      {
        id: "precise",
        name: "Precise",
        content: DEFAULT_TITLE_GENERATION_PROMPT
      },
      {
        id: "movie-style",
        name: "Movie-Style",
        content: `You are a creative title generation assistant focused on creating engaging, movie-style titles.

Your task is to analyze the provided conversation and generate a single, attention-grabbing title that:
- Has a cinematic, dramatic quality similar to movie titles
- Uses creative, evocative language that captures the essence of the conversation
- Is between 2-6 words long
- May use metaphors, wordplay, or allusions when appropriate
- Maintains proper capitalization (typically capitalize all major words)
- NEVER includes characters that are invalid in filenames: \\ / : * ? " < > |
- Uses proper spacing between all words

The title should be memorable and distinctive while still reflecting the actual content of the conversation.
Respond with ONLY the title, nothing else.`
      }
    ];
    this.modalEl.addClass("ss-chat-settings-modal");
    this.setSize("medium");
    this.plugin = plugin;
    this.contentPreview = contentPreview;
    this.isDocument = isDocument;
    this.onSubmit = onSubmit;
    this.selectedPresetId = plugin.settings.titleGenerationPromptType === "precise" ? "precise" : plugin.settings.titleGenerationPromptType === "movie-style" ? "movie-style" : null;
    this.filePath = plugin.settings.titleGenerationPromptPath || "";
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Title Generation Prompt", "Configure how your titles should be generated");
    this.createPresetSection();
    this.createFileSection();
    this.createPromptEditorSection();
    this.addActionButton("Close", () => {
      this.close();
    }, true);
    await this.initializeContent();
  }
  createPresetSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Preset Prompts",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Choose from predefined title generation styles.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    const buttonContainer = section.createDiv("ss-chat-settings-modal__prompt-type-buttons");
    this.presets.forEach((preset) => {
      const button = buttonContainer.createEl("button", {
        text: preset.name,
        cls: "ss-preset-button cursor-pointer"
      });
      if (preset.id === this.selectedPresetId) {
        button.addClass("is-active");
      }
      button.addEventListener("click", async () => {
        this.selectedPresetId = preset.id;
        this.promptTextarea.value = preset.content;
        buttonContainer.querySelectorAll(".ss-preset-button").forEach((btn) => {
          btn.removeClass("is-active");
        });
        button.addClass("is-active");
        await this.saveSettings("preset", preset.id);
      });
    });
  }
  createFileSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Custom File",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Use a custom prompt from a file in your vault.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    new import_obsidian37.Setting(section).setName("Prompt File").setDesc("Select a file to use as your title generation prompt").addText((text) => {
      this.fileInputEl = text.inputEl;
      text.setPlaceholder("Select a file...").setValue(this.filePath);
      attachFileSuggester(
        text.inputEl,
        async (selectedPath) => {
          this.filePath = selectedPath;
          await this.loadFileContent(selectedPath);
          await this.saveSettings("file", void 0, selectedPath);
        },
        this.app,
        this.plugin.settings.systemPromptsDirectory
      );
    }).addButton((button) => {
      button.setButtonText("Browse").setIcon("folder").onClick(() => {
        this.fileInputEl.focus();
      });
    });
    new import_obsidian37.Setting(section).setName("Create New").setDesc("Create a new prompt file").addButton((button) => {
      button.setButtonText("Create New Prompt File").setIcon("file-plus").onClick(async () => {
        await this.createNewPromptFile();
      });
    });
  }
  createPromptEditorSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Prompt Content",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Review and edit the prompt content below.",
      cls: "ss-chat-settings-modal__prompt-editor-note"
    });
    this.promptTextarea = section.createEl("textarea", {
      cls: "ss-chat-settings-modal__prompt-textarea",
      attr: {
        placeholder: "Enter your title generation prompt here...",
        rows: "8"
      }
    });
    this.promptTextarea.value = this.contentPreview || DEFAULT_TITLE_GENERATION_PROMPT;
  }
  async initializeContent() {
    if (this.plugin.settings.titleGenerationPromptType === "custom" && this.filePath) {
      await this.loadFileContent(this.filePath);
    } else if (this.selectedPresetId) {
      const preset = this.presets.find((p) => p.id === this.selectedPresetId);
      if (preset) {
        this.promptTextarea.value = preset.content;
      }
    }
  }
  async loadFileContent(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian37.TFile) {
        const content = await this.app.vault.read(file);
        this.promptTextarea.value = content;
      }
    } catch (error) {
      this.promptTextarea.value = "Error loading file content.";
    }
  }
  async createNewPromptFile() {
    const name = await this.showTextInputModal("Create New Prompt", "Enter a name for your prompt file:");
    if (!name) return;
    try {
      const fileName = name.replace(/[^a-zA-Z0-9-_ ]/g, "").replace(/ /g, "-");
      const filePath = `${this.plugin.settings.systemPromptsDirectory}/${fileName}.md`;
      const content = DEFAULT_TITLE_GENERATION_PROMPT;
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(
          this.plugin.settings.systemPromptsDirectory
        );
      }
      await this.app.vault.create(filePath, content);
      this.filePath = filePath;
      this.promptTextarea.value = content;
      const fileInput = this.contentEl.querySelector("input[type='text']");
      if (fileInput) {
        fileInput.value = filePath;
      }
      await this.saveSettings("file", void 0, filePath);
      new import_obsidian37.Notice(`Created prompt file: ${fileName}.md`, 3e3);
    } catch (error) {
      new import_obsidian37.Notice("Failed to create prompt file", 3e3);
    }
  }
  async showTextInputModal(title, placeholder) {
    return new Promise((resolve) => {
      const modal = new class extends StandardModal {
        constructor(app) {
          super(app);
          this.result = null;
          this.setSize("small");
        }
        onOpen() {
          super.onOpen();
          this.addTitle(title);
          this.input = this.contentEl.createEl("input", {
            type: "text",
            placeholder,
            cls: "ss-chat-settings-modal__title-input"
          });
          this.addActionButton("Cancel", () => {
            this.close();
          }, false);
          this.addActionButton("Create", () => {
            this.result = this.input.value.trim();
            this.close();
          }, true);
          setTimeout(() => this.input.focus(), 10);
        }
        onClose() {
          resolve(this.result);
          super.onClose();
        }
      }(this.app);
      modal.open();
    });
  }
  async saveSettings(source, presetId, filePath) {
    const content = this.promptTextarea.value;
    const settingsUpdate = {
      titleGenerationPrompt: content
    };
    if (source === "preset" && presetId) {
      settingsUpdate.titleGenerationPromptType = presetId;
    } else if (source === "file" && filePath) {
      settingsUpdate.titleGenerationPromptType = "custom";
      settingsUpdate.titleGenerationPromptPath = filePath;
    }
    await this.plugin.getSettingsManager().updateSettings(settingsUpdate);
    this.settingsChanged = true;
    this.result = {
      content,
      source,
      presetId,
      filePath
    };
  }
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(this.result);
    }
    super.onClose();
  }
  async openAndGetValue() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};
async function showTitleGenerationPromptModal(app, plugin, currentPrompt, options) {
  const modal = new TitleGenerationPromptModal(
    app,
    plugin,
    currentPrompt,
    true,
    () => {
    }
  );
  return await modal.openAndGetValue();
}

// src/modals/PostProcessingPromptModal.ts
var import_obsidian38 = require("obsidian");
init_ui();
init_StandardModal();
var PostProcessingPromptModal = class extends StandardModal {
  constructor(app, plugin, initialPrompt, systemPromptsDirectory = "SystemSculpt/System Prompts") {
    super(app);
    this.result = null;
    this.presets = [
      {
        id: "transcript-cleaner",
        name: "Transcript Cleaner",
        description: "Clean up transcription errors and improve readability",
        content: `You are a transcription post-processor. Your task is to fix any transcription errors, correct grammar and punctuation, and ensure the text is properly formatted. Keep the original meaning intact while making the text more readable.

Please process the following raw transcript to:
- Fix grammar, punctuation, and capitalization
- Remove filler words (um, uh, like, you know)
- Format into clear paragraphs
- Maintain the original meaning and speaker's voice

Raw transcript:`
      },
      {
        id: "meeting-summarizer",
        name: "Meeting Summarizer",
        description: "Summarize meeting transcripts into key points and action items",
        content: `You are a meeting transcript processor. Transform the raw transcript into a structured summary that captures the essential information.

Please process the following meeting transcript to create:
- Executive summary (2-3 sentences)
- Key discussion points
- Decisions made
- Action items with responsible parties (if mentioned)
- Follow-up items

Format the output in clear sections with appropriate headings.

Raw transcript:`
      },
      {
        id: "interview-formatter",
        name: "Interview Formatter",
        description: "Format interview transcripts with proper speaker attribution",
        content: `You are an interview transcript formatter. Your task is to clean up and properly format interview transcripts with clear speaker attribution and improved readability.

Please process the following interview transcript to:
- Identify and label speakers consistently (Interviewer, Interviewee, etc.)
- Remove filler words and false starts
- Correct grammar and punctuation
- Break into clear question-and-answer segments
- Maintain the natural flow of conversation

Raw transcript:`
      }
    ];
    this.modalEl.addClass("ss-chat-settings-modal");
    this.setSize("medium");
    this.plugin = plugin;
    this.systemPromptsDirectory = systemPromptsDirectory;
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Post-Processing Prompt", "Configure how your transcriptions should be processed");
    this.createPresetSection();
    this.createFileSection();
    this.createPromptEditorSection();
    this.addActionButton("Close", () => {
      this.close();
    }, true);
    await this.loadCurrentState();
  }
  createPresetSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Preset Prompts",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Choose from predefined post-processing styles.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    this.presetButtonContainer = section.createDiv("ss-chat-settings-modal__prompt-type-buttons");
    this.presets.forEach((preset) => {
      const button = this.presetButtonContainer.createEl("button", {
        text: preset.name,
        cls: "ss-preset-button cursor-pointer"
      });
      button.setAttribute("data-preset-id", preset.id);
      button.addEventListener("click", async () => {
        await this.selectPreset(preset.id);
      });
    });
    this.presetDescriptionEl = section.createEl("div", {
      cls: "ss-chat-settings-modal__prompt-type-details",
      attr: { style: "display: none;" }
    });
  }
  createFileSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Custom File",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Use a custom prompt from a file in your vault.",
      cls: "ss-chat-settings-modal__prompt-type-details"
    });
    new import_obsidian38.Setting(section).setName("Prompt File").setDesc("Select a file to use as your post-processing prompt").addText((text) => {
      this.fileInputEl = text.inputEl;
      text.setPlaceholder("Select a file...");
      attachFileSuggester(
        text.inputEl,
        async (selectedPath) => {
          await this.selectFile(selectedPath);
        },
        this.app,
        this.systemPromptsDirectory
      );
    }).addButton((button) => {
      button.setButtonText("Browse").setIcon("folder").onClick(() => {
        this.fileInputEl.focus();
      });
    });
    new import_obsidian38.Setting(section).setName("Create New").setDesc("Create a new prompt file").addButton((button) => {
      button.setButtonText("Create New Prompt File").setIcon("file-plus").onClick(async () => {
        await this.createNewPromptFile();
      });
    });
  }
  createPromptEditorSection() {
    const section = this.contentEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", {
      text: "Prompt Content",
      cls: "ss-chat-settings-modal__section-title"
    });
    section.createEl("div", {
      text: "Review and edit the prompt content below.",
      cls: "ss-chat-settings-modal__prompt-editor-note"
    });
    this.promptTextarea = section.createEl("textarea", {
      cls: "ss-chat-settings-modal__prompt-textarea",
      attr: {
        placeholder: "Enter your post-processing prompt here...",
        rows: "8"
      }
    });
  }
  async loadCurrentState() {
    const settings = this.plugin.settings;
    if (settings.postProcessingPromptType === "preset" && settings.postProcessingPromptPresetId) {
      await this.selectPreset(settings.postProcessingPromptPresetId);
    } else if (settings.postProcessingPromptType === "file" && settings.postProcessingPromptFilePath) {
      await this.selectFile(settings.postProcessingPromptFilePath);
    } else if (settings.postProcessingPrompt) {
      this.promptTextarea.value = settings.postProcessingPrompt;
    } else {
      await this.selectPreset(this.presets[0].id);
    }
  }
  async selectPreset(presetId) {
    const preset = this.presets.find((p) => p.id === presetId);
    if (!preset) return;
    this.promptTextarea.value = preset.content;
    this.updatePresetButtons(presetId);
    this.updatePresetDescription(preset);
    this.clearFileSelection();
    await this.saveToSettings("preset", preset.content, presetId, "");
  }
  async selectFile(filePath) {
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian38.TFile)) {
        throw new Error("File not found");
      }
      const content = await this.app.vault.read(file);
      this.promptTextarea.value = content;
      this.fileInputEl.value = filePath;
      this.clearPresetSelection();
      await this.saveToSettings("file", content, "", filePath);
    } catch (error) {
      new import_obsidian38.Notice("Failed to load file. Please check the file path and try again.", 3e3);
    }
  }
  async createNewPromptFile() {
    const name = await this.showTextInputModal("Create New Prompt", "Enter a name for your prompt file:");
    if (!name) return;
    try {
      const fileName = name.replace(/[^a-zA-Z0-9-_ ]/g, "").replace(/ /g, "-");
      const filePath = `${this.systemPromptsDirectory}/${fileName}.md`;
      const content = `You are a transcription post-processor. Your task is to fix any transcription errors, correct grammar and punctuation, and ensure the text is properly formatted. Keep the original meaning intact while making the text more readable.

Please process the following raw transcript to:
- Fix grammar, punctuation, and capitalization
- Remove filler words (um, uh, like, you know)
- Format into clear paragraphs
- Maintain the original meaning and speaker's voice

Raw transcript:`;
      const existingFile = this.app.vault.getAbstractFileByPath(filePath);
      if (existingFile) {
        const confirmOverwrite = await showPopup(this.app, "", {
          title: "File Already Exists",
          description: `A file named "${fileName}.md" already exists. Do you want to overwrite it?`,
          primaryButton: "Overwrite",
          secondaryButton: "Cancel"
        });
        if (!confirmOverwrite) {
          return;
        }
      }
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(this.systemPromptsDirectory);
      } else {
        try {
          await this.app.vault.createFolder(this.systemPromptsDirectory);
        } catch (error) {
          if (!error.message.includes("already exists")) {
            throw error;
          }
        }
      }
      if (existingFile) {
        await this.app.vault.modify(existingFile, content);
      } else {
        await this.app.vault.create(filePath, content);
      }
      await this.selectFile(filePath);
      new import_obsidian38.Notice(`${existingFile ? "Updated" : "Created"} prompt file: ${fileName}.md`, 3e3);
    } catch (error) {
      new import_obsidian38.Notice("Failed to create prompt file", 3e3);
    }
  }
  updatePresetButtons(selectedId) {
    this.presetButtonContainer.querySelectorAll(".ss-preset-button").forEach((btn) => {
      btn.removeClass("is-active");
      if (btn.getAttribute("data-preset-id") === selectedId) {
        btn.addClass("is-active");
      }
    });
  }
  updatePresetDescription(preset) {
    this.presetDescriptionEl.textContent = preset.description;
    this.presetDescriptionEl.style.display = "block";
  }
  clearPresetSelection() {
    this.presetButtonContainer.querySelectorAll(".ss-preset-button").forEach((btn) => {
      btn.removeClass("is-active");
    });
    this.presetDescriptionEl.style.display = "none";
  }
  clearFileSelection() {
    this.fileInputEl.value = "";
  }
  async saveToSettings(type, content, presetId, filePath) {
    await this.plugin.getSettingsManager().updateSettings({
      postProcessingPromptType: type,
      postProcessingPrompt: content,
      postProcessingPromptPresetId: presetId,
      postProcessingPromptFilePath: filePath
    });
  }
  async showTextInputModal(title, placeholder) {
    return new Promise((resolve) => {
      const modal = new class extends StandardModal {
        constructor(app) {
          super(app);
          this.result = null;
          this.setSize("small");
        }
        onOpen() {
          super.onOpen();
          this.addTitle(title);
          this.input = this.contentEl.createEl("input", {
            type: "text",
            placeholder,
            cls: "ss-chat-settings-modal__title-input"
          });
          this.addActionButton("Cancel", () => {
            this.close();
          }, false);
          this.addActionButton("Create", () => {
            this.result = this.input.value.trim();
            this.close();
          }, true);
          setTimeout(() => this.input.focus(), 10);
        }
        onClose() {
          resolve(this.result);
          super.onClose();
        }
      }(this.app);
      modal.open();
    });
  }
  async onClose() {
    if (this.promptTextarea) {
      await this.plugin.getSettingsManager().updateSettings({
        postProcessingPrompt: this.promptTextarea.value
      });
    }
    if (this.resolvePromise) {
      this.result = {
        content: this.promptTextarea.value,
        source: this.plugin.settings.postProcessingPromptType,
        presetId: this.plugin.settings.postProcessingPromptPresetId || void 0,
        filePath: this.plugin.settings.postProcessingPromptFilePath || void 0
      };
      this.resolvePromise(this.result);
    }
    super.onClose();
  }
  async openAndGetResult() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};

// src/settings/SystemPromptSettingsTabContent.ts
async function displaySystemPromptSettingsTabContent(containerEl, tabInstance) {
  var _a;
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "system-prompt-settings";
  }
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "System prompts" });
  containerEl.createEl("p", {
    text: "Choose the presets or files used for chats, title generation, and post-processing.",
    cls: "setting-item-description"
  });
  const isAdvancedMode = plugin.settings.settingsMode === "advanced";
  const useLatestPrompt = (_a = plugin.settings.useLatestSystemPromptForNewChats) != null ? _a : true;
  if (isAdvancedMode) {
    new import_obsidian39.Setting(containerEl).setName("Use your latest selection").setDesc("When enabled, new chats start with whichever prompt you last picked.").addToggle((toggle) => {
      toggle.setValue(useLatestPrompt).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ useLatestSystemPromptForNewChats: value });
        tabInstance.display();
      });
    });
  } else {
    new import_obsidian39.Setting(containerEl).setName("Use your latest selection").setDesc("Always enabled in Standard mode.").addToggle((toggle) => {
      toggle.setValue(true).setDisabled(true);
    });
  }
  const chatPromptSummary = describeChatPrompt(app, plugin);
  const chatPromptSetting = new import_obsidian39.Setting(containerEl).setName("Default chat prompt").setDesc(chatPromptSummary.text);
  if (chatPromptSummary.missing) {
    chatPromptSetting.descEl.addClass("ss-inline-note");
  }
  chatPromptSetting.addButton((button) => {
    button.setButtonText("Change...").onClick(() => {
      const modal = new StandardSystemPromptSelectionModal({
        app,
        plugin,
        currentType: plugin.settings.systemPromptType || "general-use",
        currentPath: plugin.settings.systemPromptPath,
        title: "Select default system prompt",
        description: "Pick the system prompt applied to new chat conversations.",
        onSelect: async (result) => {
          var _a2, _b;
          try {
            const updates = { systemPromptType: result.type };
            if (result.type === "custom" && result.path) {
              updates.systemPromptPath = result.path;
            } else {
              updates.systemPromptPath = "";
            }
            if (result.type === "custom" && !result.path && result.prompt) {
              updates.systemPrompt = result.prompt;
            }
            await plugin.getSettingsManager().updateSettings(updates);
            (_b = (_a2 = plugin.emitter) == null ? void 0 : _a2.emit) == null ? void 0 : _b.call(_a2, "settingsChanged");
            const displayName = formatPromptSelection(result);
            new import_obsidian39.Notice(`Default system prompt set to ${displayName}.`, 3e3);
            tabInstance.display();
          } catch (error) {
            new import_obsidian39.Notice("Failed to update default system prompt. Please try again.", 4e3);
          }
        }
      });
      modal.open();
    });
  });
  if (shouldShowManualPromptInput(plugin)) {
    const manualSetting = new import_obsidian39.Setting(containerEl).setName("Custom prompt text").setDesc('Used when the default prompt is set to "Custom text".');
    manualSetting.addTextArea((text) => {
      text.setValue(plugin.settings.systemPrompt || "").onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ systemPrompt: value });
      });
      text.inputEl.rows = 6;
    });
  }
  const titlePromptSummary = describeTitlePrompt(app, plugin);
  const titleSetting = new import_obsidian39.Setting(containerEl).setName("Title generation prompt").setDesc(titlePromptSummary.text);
  if (titlePromptSummary.missing) {
    titleSetting.descEl.addClass("ss-inline-note");
  }
  titleSetting.addButton((button) => {
    button.setButtonText("Change...").onClick(async () => {
      var _a2, _b;
      try {
        const result = await showTitleGenerationPromptModal(app, plugin, plugin.settings.titleGenerationPrompt, {
          systemPromptsDirectory: plugin.settings.systemPromptsDirectory
        });
        if (result) {
          (_b = (_a2 = plugin.emitter) == null ? void 0 : _a2.emit) == null ? void 0 : _b.call(_a2, "settingsChanged");
          new import_obsidian39.Notice("Title generation prompt updated.", 3e3);
          tabInstance.display();
        }
      } catch (error) {
        new import_obsidian39.Notice("Failed to update title generation prompt.", 4e3);
      }
    });
  });
  const postProcessingSummary = describePostProcessingPrompt(app, plugin);
  const postProcessingSetting = new import_obsidian39.Setting(containerEl).setName("Post-processing prompt").setDesc(postProcessingSummary.text);
  if (postProcessingSummary.missing) {
    postProcessingSetting.descEl.addClass("ss-inline-note");
  }
  postProcessingSetting.addButton((button) => {
    button.setButtonText("Change...").onClick(async () => {
      var _a2, _b;
      try {
        const modal = new PostProcessingPromptModal(app, plugin, plugin.settings.postProcessingPrompt, plugin.settings.systemPromptsDirectory);
        const result = await modal.openAndGetResult();
        if (result) {
          (_b = (_a2 = plugin.emitter) == null ? void 0 : _a2.emit) == null ? void 0 : _b.call(_a2, "settingsChanged");
          new import_obsidian39.Notice("Post-processing prompt updated.", 3e3);
          tabInstance.display();
        }
      } catch (error) {
        new import_obsidian39.Notice("Failed to update post-processing prompt.", 4e3);
      }
    });
  });
}
function describeChatPrompt(app, plugin) {
  const type = plugin.settings.systemPromptType;
  const path = plugin.settings.systemPromptPath;
  switch (type) {
    case "general-use":
      return { text: "General use preset" };
    case "concise":
      return { text: "Concise preset" };
    case "agent":
      return { text: "Agent mode preset" };
    case "custom":
      if (path) {
        return describeCustomFile(app, path, "Custom prompt");
      }
      return { text: "Custom prompt (manual text)" };
    default:
      return { text: "General use preset" };
  }
}
function describeTitlePrompt(app, plugin) {
  const type = plugin.settings.titleGenerationPromptType;
  const path = plugin.settings.titleGenerationPromptPath;
  switch (type) {
    case "precise":
      return { text: "Precise preset" };
    case "movie-style":
      return { text: "Movie style preset" };
    case "custom":
      if (path) {
        return describeCustomFile(app, path, "Custom prompt");
      }
      return { text: "Custom prompt (manual text)" };
    default:
      return { text: "Precise preset" };
  }
}
function describePostProcessingPrompt(app, plugin) {
  const type = plugin.settings.postProcessingPromptType;
  const path = plugin.settings.postProcessingPromptFilePath;
  const presetId = plugin.settings.postProcessingPromptPresetId;
  if (type === "file" && path) {
    return describeCustomFile(app, path, "Custom prompt");
  }
  if (type === "preset") {
    return { text: `Preset (${presetId || "default"})` };
  }
  return { text: "Preset (default)" };
}
function describeCustomFile(app, path, fallback) {
  var _a;
  const file = app.vault.getAbstractFileByPath(path);
  if (file) {
    const fileName = ((_a = path.split("/").pop()) == null ? void 0 : _a.replace(/\.md$/, "")) || fallback;
    return { text: `Custom file: ${fileName}` };
  }
  const missingName = path.split("/").pop() || path;
  return { text: `Custom file missing: ${missingName}`, missing: true };
}
function shouldShowManualPromptInput(plugin) {
  return plugin.settings.systemPromptType === "custom" && !plugin.settings.systemPromptPath;
}
function formatPromptSelection(result) {
  switch (result.type) {
    case "general-use":
      return "General use";
    case "concise":
      return "Concise";
    case "agent":
      return "Agent mode";
    case "custom":
      if (result.path) {
        const fileName = result.path.split("/").pop() || result.path;
        return `Custom file (${fileName})`;
      }
      return "Custom text";
    default:
      return result.type;
  }
}

// src/settings/TitleGenerationTabContent.ts
var import_obsidian40 = require("obsidian");
function displayTitleGenerationTabContent(containerEl, tabInstance) {
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Title Generation Settings" });
  const modelSettingsNote = containerEl.createEl("p", {
    text: "Tip: configure the title generation model and prompt in \u201CModels & Prompts\u201D.",
    cls: "setting-item-description"
  });
  new import_obsidian40.Setting(containerEl).setName("Automatic Title Generation").setDesc("Automatically generate titles for new chats without showing the modal").addToggle(
    (toggle) => toggle.setValue(plugin.settings.automaticTitleGeneration).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ automaticTitleGeneration: value });
    })
  );
}

// src/settings/ChatTabContent.ts
var import_obsidian41 = require("obsidian");
init_SystemPromptService();
init_FavoritesService();
init_StandardModelSelectionModal();
init_StandardSystemPromptSelectionModal();
init_MCPService2();
init_MCPFilesystemServer();
init_modelUtils();
async function getCurrentDefaultPresetDisplayName(plugin, app) {
  const type = plugin.settings.systemPromptType;
  const path = plugin.settings.systemPromptPath;
  if (type === "agent") {
    await plugin.getSettingsManager().updateSettings({
      systemPromptType: "general-use",
      systemPromptPath: ""
    });
    return "General Use Preset (auto-switched from Agent Mode - now per-chat only)";
  }
  if (type === "general-use") return "General Use Preset";
  if (type === "concise") return "Concise Preset";
  if (type === "custom") {
    if (path) {
      try {
        const spService = SystemPromptService.getInstance(app, () => plugin.settings);
        const file = app.vault.getAbstractFileByPath(path);
        if (!file) {
          await plugin.getSettingsManager().updateSettings({
            systemPromptType: "general-use",
            systemPromptPath: ""
          });
          return "General Use Preset (auto-switched from missing custom file)";
        }
        const fileName = path.split("/").pop() || path;
        return `Custom Preset File: ${fileName}`;
      } catch (error) {
        await plugin.getSettingsManager().updateSettings({
          systemPromptType: "general-use",
          systemPromptPath: ""
        });
        return "General Use Preset (auto-switched due to custom file error)";
      }
    } else {
      return "Custom (Manually Entered Text)";
    }
  }
  const validDefaultTypes = ["general-use", "concise", "custom"];
  if (!validDefaultTypes.includes(type)) {
    await plugin.getSettingsManager().updateSettings({
      systemPromptType: "general-use",
      systemPromptPath: ""
    });
    return "General Use Preset (auto-switched from invalid type)";
  }
  return "General Use Preset";
}
function formatPromptSelection2(result) {
  switch (result.type) {
    case "general-use":
      return "General use";
    case "concise":
      return "Concise";
    case "agent":
      return "Agent mode";
    case "custom":
      if (result.path) {
        const fileName = result.path.split("/").pop() || result.path;
        return `Custom: ${fileName}`;
      }
      return "Custom text";
    default:
      return result.type;
  }
}
async function displayChatTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "chat";
  }
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Chat settings" });
  containerEl.createEl("p", {
    text: "Tip: adjust models and prompts in the \u201CModels & Prompts\u201D tab.",
    cls: "setting-item-description"
  });
  const presetLabel = await getCurrentDefaultPresetDisplayName(plugin, app);
  const promptSetting = new import_obsidian41.Setting(containerEl).setName("Default system prompt").setDesc(presetLabel);
  promptSetting.addButton((button) => {
    button.setButtonText("Change...").onClick(() => {
      const modal = new StandardSystemPromptSelectionModal({
        app,
        plugin,
        currentType: plugin.settings.systemPromptType || "general-use",
        currentPath: plugin.settings.systemPromptPath,
        title: "Select default system prompt",
        description: "Choose the default system prompt for new chat conversations.",
        onSelect: async (result) => {
          var _a, _b;
          try {
            const updates = {
              systemPromptType: result.type
            };
            if (result.type === "custom" && result.path) {
              updates.systemPromptPath = result.path;
            } else {
              updates.systemPromptPath = "";
            }
            if (result.type === "custom" && !result.path && result.prompt) {
              updates.systemPrompt = result.prompt;
            }
            await plugin.getSettingsManager().updateSettings(updates);
            (_b = (_a = plugin.emitter) == null ? void 0 : _a.emit) == null ? void 0 : _b.call(_a, "settingsChanged");
            const displayName = formatPromptSelection2(result);
            new import_obsidian41.Notice(`Default system prompt set to ${displayName}.`, 3e3);
            tabInstance.display();
          } catch (error) {
            new import_obsidian41.Notice("Failed to update default system prompt. Please try again.", 4e3);
          }
        }
      });
      modal.open();
    });
  });
  if (plugin.settings.systemPromptType === "custom" && !plugin.settings.systemPromptPath) {
    new import_obsidian41.Setting(containerEl).setName("Custom prompt text").setDesc("Used when the default prompt is set to custom text.").addTextArea((text) => {
      text.setValue(plugin.settings.systemPrompt).setPlaceholder("Enter your custom default system prompt here...").onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ systemPrompt: value });
      });
      text.inputEl.rows = 6;
    });
  }
  new import_obsidian41.Setting(containerEl).setName("Default Chat Font Size").setDesc("Select the default text size for new chat messages.").addDropdown((dropdown) => {
    dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(plugin.settings.chatFontSize || "medium").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ chatFontSize: value });
      new import_obsidian41.Notice(`Default chat font size set to: ${value}`);
    });
  });
  new import_obsidian41.Setting(containerEl).setName("Default Agent Mode").setDesc("When enabled, new chats will start with Agent Mode activated. Agent Mode enables autonomous vault exploration and tool usage.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.defaultAgentMode).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ defaultAgentMode: value });
      new import_obsidian41.Notice(`Default Agent Mode ${value ? "enabled" : "disabled"}. ${value ? "New chats will start with Agent Mode active." : "New chats will start with Agent Mode disabled."}`);
    });
  });
  containerEl.createEl("h3", { text: "Favorites" });
  const favoritesService = FavoritesService.getInstance(plugin);
  const favoritesSetting = new import_obsidian41.Setting(containerEl).setName("Favorite models").setDesc("Star models to pin them in pickers and quick lists.");
  const favoritesSummaryEl = favoritesSetting.descEl.createDiv({ cls: "ss-inline-note" });
  const refreshFavoritesSummary = async () => {
    favoritesSummaryEl.setText(await buildFavoritesSummary(plugin));
  };
  await refreshFavoritesSummary();
  favoritesSetting.addButton((button) => {
    button.setButtonText("Manage\u2026").onClick(() => {
      const modal = new StandardModelSelectionModal({
        app,
        plugin,
        currentModelId: plugin.settings.selectedModelId || "",
        title: "Manage favorite models",
        description: "Star models to add or remove favorites.",
        onSelect: () => {
        }
      });
      void modal.open().finally(() => {
        void refreshFavoritesSummary();
      });
    });
  });
  favoritesSetting.addExtraButton((button) => {
    button.setIcon("trash").setTooltip("Remove all favorites").onClick(async () => {
      const favorites = plugin.settings.favoriteModels || [];
      if (favorites.length === 0) {
        new import_obsidian41.Notice("No favorite models to remove.");
        return;
      }
      if (!confirm("Remove all favorite models? This cannot be undone.")) {
        return;
      }
      try {
        const models = await plugin.modelService.getModels();
        await favoritesService.clearAllFavorites(models);
        new import_obsidian41.Notice("All favorite models removed.");
      } catch (error) {
        new import_obsidian41.Notice(`Failed to clear favorites: ${(error == null ? void 0 : error.message) || error}`);
      } finally {
        await refreshFavoritesSummary();
      }
    });
  });
  containerEl.createEl("h3", { text: "Agent Tools" });
  const toolsSection = containerEl.createDiv();
  const isAdvancedMode = plugin.settings.settingsMode === "advanced";
  const readOnlyToolNames = /* @__PURE__ */ new Set([
    "read",
    "list_items",
    "find",
    "search",
    "open",
    "context"
  ]);
  const categorize = (toolName) => readOnlyToolNames.has(toolName) ? "read" : "write";
  const renderWriteTools = async () => {
    toolsSection.empty();
    const header = toolsSection.createDiv();
    header.createEl("p", {
      text: "Tools are always available when Agent Mode is ON. Toggle auto-run to let the agent execute a tool without your confirmation.",
      cls: "setting-item-description"
    });
    try {
      const mcpService = new MCPService(plugin, app);
      const servers = plugin.settings.mcpServers || [];
      const enabledServers = servers.filter((s) => s.isEnabled);
      const toolsByServer = {};
      await Promise.all(enabledServers.map(async (server) => {
        let tools = [];
        if (server.id === "mcp-filesystem") {
          const fs = new MCPFilesystemServer(plugin, app);
          tools = await fs.getTools();
        } else {
          const result = await mcpService.testConnection(server);
          if (result.success && result.tools) tools = result.tools;
        }
        const writeTools = tools.filter((t) => categorize(t.name) === "write");
        if (writeTools.length === 0) return;
        const list = writeTools.map((t) => {
          const key = `${server.id}:${t.name}`;
          const desc = server.id === "mcp-filesystem" ? MCPFilesystemServer.getToolDisplayDescription(t.name) : (t.description || "").split("\n")[0].slice(0, 120);
          const name = server.id === "mcp-filesystem" ? MCPFilesystemServer.getToolDisplayName(t.name) : t.name.replace(/[_-]/g, " ").replace(/\b\w/g, (l) => l.toUpperCase());
          return { key, name, desc };
        });
        toolsByServer[server.id] = { serverName: server.name, tools: list };
      }));
      const serverIds = Object.keys(toolsByServer);
      if (serverIds.length === 0) {
        toolsSection.createEl("p", { text: "No write tools available. Enable an MCP server to configure tools.", cls: "setting-item-description" });
        return;
      }
      serverIds.forEach((serverId) => {
        const { serverName, tools } = toolsByServer[serverId];
        if (serverIds.length > 1) {
          toolsSection.createEl("h4", { text: serverName });
        }
        tools.forEach(({ key, name, desc }) => {
          const auto = (plugin.settings.mcpAutoAcceptTools || []).includes(key);
          const row = new import_obsidian41.Setting(toolsSection).setName(name).setDesc(desc || "");
          row.addToggle((t) => {
            t.setValue(auto).setTooltip("Allow this tool to run automatically").onChange(async (value) => {
              if (value) {
                const confirmed = confirm("Hey, toggling this on is going to allow the agent to do this without your confirmation.");
                if (!confirmed) {
                  t.setValue(false);
                  return;
                }
              }
              const autoSet = new Set(plugin.settings.mcpAutoAcceptTools || []);
              if (value) {
                autoSet.add(key);
              } else {
                autoSet.delete(key);
              }
              await plugin.getSettingsManager().updateSettings({
                mcpAutoAcceptTools: Array.from(autoSet)
              });
            });
          });
        });
      });
    } catch (e) {
      toolsSection.createEl("p", { text: "Failed to load tools. Check your MCP servers.", cls: "setting-item-description" });
    }
  };
  await renderWriteTools();
}
async function buildFavoritesSummary(plugin) {
  const favorites = plugin.settings.favoriteModels || [];
  if (!favorites.length) {
    return "No favorite models yet. Use Manage to star models.";
  }
  try {
    const models = await plugin.modelService.getModels().catch(() => []);
    const names = favorites.map((favorite) => {
      const canonicalId = ensureCanonicalId(favorite.modelId, favorite.provider);
      const match = models.find((model) => ensureCanonicalId(model.id) === canonicalId);
      if (match == null ? void 0 : match.name) {
        return match.name;
      }
      const [, simpleId] = favorite.modelId.split("@@");
      return simpleId || favorite.modelId;
    }).filter(Boolean);
    const uniqueNames = Array.from(new Set(names));
    if (uniqueNames.length === 0) {
      return `Favorites (${favorites.length}) saved.`;
    }
    const preview = uniqueNames.slice(0, 3).join(", ");
    if (uniqueNames.length <= 3) {
      return `Favorites: ${preview}`;
    }
    return `Favorites (${uniqueNames.length}): ${preview}, \u2026`;
  } catch (error) {
    console.warn("Failed to summarize favorite models", error);
    return `Favorites (${favorites.length}) saved.`;
  }
}

// src/settings/TemplatesTabContent.ts
var import_obsidian42 = require("obsidian");
function displayTemplatesTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "templates";
  }
  const { plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Templates Settings" });
  new import_obsidian42.Setting(containerEl).setName("Enable Template Hotkey").setDesc("Enable the template hotkey to quickly access system prompts").addToggle(
    (toggle) => toggle.setValue(plugin.settings.enableTemplateHotkey).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ enableTemplateHotkey: value });
    })
  );
  new import_obsidian42.Setting(containerEl).setName("Template Hotkey").setDesc("Set the hotkey that will trigger the system prompts list when typed at the beginning of a new line").addText(
    (text) => text.setPlaceholder("/").setValue(plugin.settings.templateHotkey).onChange(async (value) => {
      if (value.length > 1) {
        value = value.charAt(0);
        text.setValue(value);
      }
      await plugin.getSettingsManager().updateSettings({ templateHotkey: value });
    })
  );
  containerEl.createEl("div", {
    text: "When the template hotkey is pressed at the beginning of a new line, a list of all system prompts in your system prompts directory will be shown.",
    cls: "setting-item-description"
  });
}

// src/settings/RecorderTabContent.ts
var import_obsidian43 = require("obsidian");
init_MobileDetection();
init_externalServices();
async function displayRecorderTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "recorder";
  }
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Recording" });
  await renderMicrophoneSetting(containerEl, tabInstance);
  new import_obsidian43.Setting(containerEl).setName("Auto-transcribe recordings").setDesc("Transcribe recordings automatically when they finish.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.autoTranscribeRecordings).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ autoTranscribeRecordings: value });
    });
  });
  new import_obsidian43.Setting(containerEl).setName("Auto-paste transcription").setDesc("Paste the transcription into the active document when it completes.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.autoPasteTranscription).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ autoPasteTranscription: value });
    });
  });
  new import_obsidian43.Setting(containerEl).setName("Keep recordings after transcription").setDesc("Retain the source audio file after a successful transcription.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.keepRecordingsAfterTranscription).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ keepRecordingsAfterTranscription: value });
    });
  });
  new import_obsidian43.Setting(containerEl).setName("Clean output only").setDesc("Strip timestamps and metadata from transcription output.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.cleanTranscriptionOutput).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ cleanTranscriptionOutput: value });
    });
  });
  new import_obsidian43.Setting(containerEl).setName("Auto-submit after transcription").setDesc("Send the message automatically once transcription or post-processing finishes in chat views.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.autoSubmitAfterTranscription).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ autoSubmitAfterTranscription: value });
    });
  });
  new import_obsidian43.Setting(containerEl).setName("Enable post-processing").setDesc("Apply your post-processing prompt after transcription completes.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.postProcessingEnabled).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ postProcessingEnabled: value });
    });
  });
  containerEl.createEl("h3", { text: "Transcription" });
  const providerSetting = new import_obsidian43.Setting(containerEl).setName("Transcription provider").setDesc("Choose the service used to transcribe recordings.");
  providerSetting.addDropdown((dropdown) => {
    dropdown.addOption("systemsculpt", "SystemSculpt API").addOption("custom", "Custom").setValue(plugin.settings.transcriptionProvider).onChange(async (value) => {
      if (plugin.settings.settingsMode !== "advanced" && value === "custom") {
        new import_obsidian43.Notice("Switch to Advanced mode to configure custom transcription providers.");
        dropdown.setValue("systemsculpt");
        return;
      }
      await plugin.getSettingsManager().updateSettings({ transcriptionProvider: value });
      tabInstance.display();
    });
  });
  const mobileDetection = MobileDetection.getInstance();
  if (!mobileDetection.isMobileDevice() && plugin.settings.settingsMode === "advanced") {
    new import_obsidian43.Setting(containerEl).setName("Automatic audio format conversion").setDesc("Convert incompatible audio files before transcription.").addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = plugin.settings.enableAutoAudioResampling) != null ? _a : true).onChange(async (value) => {
        await plugin.getSettingsManager().updateSettings({ enableAutoAudioResampling: value });
        new import_obsidian43.Notice(value ? "Audio conversion enabled" : "Audio conversion disabled");
      });
    });
  }
  const isAdvancedMode = plugin.settings.settingsMode === "advanced";
  const usingCustomProvider = plugin.settings.transcriptionProvider === "custom" && isAdvancedMode;
  if (usingCustomProvider) {
    renderCustomTranscriptionSettings(containerEl, tabInstance);
  }
}
async function renderMicrophoneSetting(containerEl, tabInstance) {
  const { plugin } = tabInstance;
  const setting = new import_obsidian43.Setting(containerEl).setName("Preferred microphone").setDesc("Select which microphone to use for recordings.");
  let dropdownComponent = null;
  let dropdownEl = null;
  setting.addDropdown((dropdown) => {
    dropdownComponent = dropdown;
    dropdownEl = dropdown.selectEl;
    dropdown.addOption("default", "Default microphone");
    dropdown.setValue(plugin.settings.preferredMicrophoneId || "default");
    dropdown.onChange(async (value) => {
      var _a, _b;
      await plugin.getSettingsManager().updateSettings({ preferredMicrophoneId: value });
      const label = ((_b = (_a = dropdown.selectEl) == null ? void 0 : _a.selectedOptions[0]) == null ? void 0 : _b.text) || value;
      new import_obsidian43.Notice(`Microphone preference saved: ${label}`);
    });
  });
  const statusEl = setting.descEl.createDiv({ cls: "ss-inline-note" });
  const loadDevices = async () => {
    var _a;
    if (!dropdownComponent || !dropdownEl) return;
    dropdownEl.innerHTML = "";
    const dropdown = dropdownComponent;
    const addOption = (value, label) => {
      dropdown.addOption(value, label);
    };
    if (typeof navigator === "undefined" || !((_a = navigator.mediaDevices) == null ? void 0 : _a.enumerateDevices)) {
      addOption("default", "Default microphone");
      dropdown.setValue(plugin.settings.preferredMicrophoneId || "default");
      statusEl.setText("Microphone selection unavailable in this environment.");
      return;
    }
    try {
      statusEl.setText("Loading microphones...");
      const devices = await navigator.mediaDevices.enumerateDevices();
      const labeled = devices.some((device) => device.kind === "audioinput" && device.label);
      if (!labeled) {
        try {
          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
          stream.getTracks().forEach((track) => track.stop());
        } catch (error) {
          statusEl.setText("Microphone access denied; using default device list.");
        }
      }
      const refreshed = await navigator.mediaDevices.enumerateDevices();
      const microphones = refreshed.filter((device) => device.kind === "audioinput");
      addOption("default", "Default microphone");
      microphones.forEach((mic) => {
        addOption(mic.deviceId, mic.label || `Microphone ${mic.deviceId.slice(0, 8)}`);
      });
      const current = plugin.settings.preferredMicrophoneId || "default";
      dropdown.setValue(current);
      statusEl.setText(microphones.length ? "" : "No microphones detected.");
    } catch (error) {
      statusEl.setText(`Unable to load microphones: ${(error == null ? void 0 : error.message) || error}`);
      addOption("default", "Default microphone");
      dropdown.setValue("default");
    }
  };
  setting.addExtraButton((button) => {
    button.setIcon("refresh-cw").setTooltip("Refresh microphones").onClick(() => {
      loadDevices();
    });
  });
  await loadDevices();
}
function renderCustomTranscriptionSettings(containerEl, tabInstance) {
  const { plugin } = tabInstance;
  new import_obsidian43.Setting(containerEl).setName("Custom endpoint URL").setDesc("OpenAI-compatible transcription endpoint.").addText((text) => {
    text.setPlaceholder("https://api.example.com/v1/audio/transcriptions").setValue(plugin.settings.customTranscriptionEndpoint).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ customTranscriptionEndpoint: value });
    });
  });
  new import_obsidian43.Setting(containerEl).setName("API key").setDesc("Only required if your endpoint needs authentication.").addText((text) => {
    text.setPlaceholder("sk-...").setValue(plugin.settings.customTranscriptionApiKey).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ customTranscriptionApiKey: value });
    });
    text.inputEl.type = "password";
  });
  new import_obsidian43.Setting(containerEl).setName("Model name").setDesc("Identifier sent to your transcription endpoint.").addText((text) => {
    text.setPlaceholder("whisper-large-v3").setValue(plugin.settings.customTranscriptionModel).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ customTranscriptionModel: value });
    });
  });
  const presetSetting = new import_obsidian43.Setting(containerEl).setName("Presets").setDesc("Quickly configure common services.");
  presetSetting.addButton((button) => {
    button.setButtonText("Groq").onClick(async () => {
      await plugin.getSettingsManager().updateSettings({
        customTranscriptionEndpoint: AI_PROVIDERS.GROQ.AUDIO_TRANSCRIPTIONS,
        customTranscriptionModel: "whisper-large-v3"
      });
      new import_obsidian43.Notice("Groq endpoint configured.");
      tabInstance.display();
    });
  });
  presetSetting.addButton((button) => {
    button.setButtonText("OpenAI").onClick(async () => {
      await plugin.getSettingsManager().updateSettings({
        customTranscriptionEndpoint: AI_PROVIDERS.OPENAI.AUDIO_TRANSCRIPTIONS,
        customTranscriptionModel: "whisper-1"
      });
      new import_obsidian43.Notice("OpenAI endpoint configured.");
      tabInstance.display();
    });
  });
  presetSetting.addButton((button) => {
    button.setButtonText("Local").onClick(async () => {
      await plugin.getSettingsManager().updateSettings({
        customTranscriptionEndpoint: LOCAL_SERVICES.LOCAL_WHISPER.AUDIO_TRANSCRIPTIONS,
        customTranscriptionModel: "whisper-large-v3"
      });
      new import_obsidian43.Notice("Local Whisper endpoint configured.");
      tabInstance.display();
    });
  });
}

// src/settings/DirectoriesTabContent.ts
var import_obsidian45 = require("obsidian");
init_FolderSuggester();
init_ui();
function validateDirectory(path) {
  if (!path) return true;
  return !path.includes("..") && !path.startsWith("/") && !path.startsWith("\\");
}
async function handleDirectoryChange(tabInstance, value, settingKey, createFolder = false) {
  const { app, plugin } = tabInstance;
  if (!validateDirectory(value)) {
    showPopup(
      app,
      "Invalid directory path. Please use relative paths without '..' or leading slashes."
    );
    return;
  }
  await plugin.getSettingsManager().updateSettings({ [settingKey]: value });
  if (createFolder && plugin.directoryManager) {
    try {
      await plugin.directoryManager.handleDirectorySettingChange(settingKey, value);
    } catch (error) {
    }
  }
}
function createDirectorySetting(containerEl, tabInstance, name, desc, settingKey, placeholder) {
  const { app, plugin } = tabInstance;
  new import_obsidian45.Setting(containerEl).setName(name).setDesc(desc).addText((text) => {
    text.setPlaceholder(placeholder).setValue(plugin.settings[settingKey]).onChange(async (value) => {
      await handleDirectoryChange(tabInstance, value, settingKey, false);
    });
    text.inputEl.addEventListener("blur", async () => {
      await handleDirectoryChange(tabInstance, text.inputEl.value, settingKey, true);
    });
    attachFolderSuggester(
      text.inputEl,
      async (selectedPath) => {
        if (validateDirectory(selectedPath)) {
          text.setValue(selectedPath);
          await handleDirectoryChange(tabInstance, selectedPath, settingKey, true);
        } else {
          showPopup(
            app,
            "Invalid directory path. Please use relative paths without '..' or leading slashes."
          );
        }
      },
      app
    );
    return text;
  });
}
function displayDirectoriesTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "directories";
  }
  const { plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Directory Settings" });
  createDirectorySetting(
    containerEl,
    tabInstance,
    "Chats Directory",
    "Select the directory for your chat history",
    "chatsDirectory",
    "Path relative to vault root (empty = SystemSculpt/Chats)"
  );
  createDirectorySetting(
    containerEl,
    tabInstance,
    "Saved Chats Directory",
    'Select the directory where notes created via "Save chat as note" are stored',
    "savedChatsDirectory",
    "Path relative to vault root (empty = SystemSculpt/Saved Chats)"
  );
  createDirectorySetting(
    containerEl,
    tabInstance,
    "Recordings Directory",
    "Select the directory for your recordings",
    "recordingsDirectory",
    "Path relative to vault root (empty = SystemSculpt/Recordings)"
  );
  createDirectorySetting(
    containerEl,
    tabInstance,
    "System Prompts Directory",
    "Select the directory for your custom system prompts",
    "systemPromptsDirectory",
    "Path relative to vault root (empty = SystemSculpt/System Prompts)"
  );
  createDirectorySetting(
    containerEl,
    tabInstance,
    "Attachments Directory",
    "Select the directory for saved images and attachments",
    "attachmentsDirectory",
    "Path relative to vault root (empty = Attachments)"
  );
  createDirectorySetting(
    containerEl,
    tabInstance,
    "Extractions Directory",
    "Select the directory where extracted PDFs/docs will be placed",
    "extractionsDirectory",
    "Path relative to vault root (empty = file's parent folder)"
  );
  containerEl.createEl("h3", { text: "Directory Diagnostics" });
  const diagnosticsSetting = new import_obsidian45.Setting(containerEl).setName("Directory diagnostics").setDesc("Check that required directories exist or repair them if something looks off.");
  const statusEl = diagnosticsSetting.descEl.createDiv({ cls: "ss-inline-note" });
  diagnosticsSetting.addButton((button) => {
    button.setButtonText("Verify directories").onClick(async () => {
      var _a;
      statusEl.setText("Checking directories...");
      try {
        const result = await plugin.checkDirectoryHealth();
        if (result.valid) {
          statusEl.setText("All directories are properly configured.");
        } else {
          const messages = ((_a = result.issues) == null ? void 0 : _a.length) ? result.issues.join("\n\u2022 ") : "Issues detected.";
          statusEl.setText(`Issues found:
\u2022 ${messages}`);
        }
      } catch (error) {
        statusEl.setText(`Verification failed: ${(error == null ? void 0 : error.message) || error}`);
      }
    });
  });
  diagnosticsSetting.addButton((button) => {
    button.setButtonText("Repair directories").setCta().onClick(async () => {
      statusEl.setText("Repairing directories...");
      try {
        const success = await plugin.repairDirectoryStructure();
        statusEl.setText(success ? "Directory structure repaired. Restart Obsidian to ensure changes apply." : "Repair did not complete. Check the console for details.");
      } catch (error) {
        statusEl.setText(`Repair failed: ${(error == null ? void 0 : error.message) || error}`);
      }
    });
  });
}

// src/settings/BackupTabContent.ts
var import_obsidian47 = require("obsidian");
init_ui();

// src/core/settings/BackupRestoreModal.ts
var import_obsidian46 = require("obsidian");
init_ListSelectionModal();
var BackupRestoreModal = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Opens the backup restore modal and returns the selected backup file path,
   * or null if cancelled
   */
  async open() {
    try {
      const backups = await this.getAvailableBackups();
      if (backups.length === 0) {
        new import_obsidian46.Notice("No settings backups found", 3e3);
        return null;
      }
      const items = backups.map((backup) => ({
        id: backup.path,
        title: backup.name,
        description: "",
        // We'll handle description specially
        icon: "save",
        // Store details in a custom property
        _backupDetails: backup.details || backup.date
      }));
      const modal = new ListSelectionModal(this.app, items, {
        title: "Restore Settings from Backup",
        description: "Select a backup to restore. This will replace your current settings.",
        placeholder: "Search backups...",
        emptyText: "No backups found",
        size: "medium",
        closeOnSelect: true,
        // Add custom content handler to display details properly and add create backup button
        customContent: (containerEl) => {
          const styleEl = document.createElement("style");
          styleEl.textContent = `
                        .backup-details {
                            font-size: 12px;
                            color: var(--text-muted);
                            white-space: normal !important;
                            overflow: visible !important;
                            text-overflow: clip !important;
                            line-height: 1.5;
                            margin-top: 4px;
                        }
                        .backup-detail-item {
                            display: inline-block;
                            margin-right: 8px;
                            background: var(--background-secondary);
                            padding: 2px 6px;
                            border-radius: 4px;
                            margin-bottom: 4px;
                        }
                        .create-backup-button {
                            display: flex;
                            padding: 10px;
                            margin-bottom: 10px;
                            background: var(--background-secondary);
                            border-radius: 5px;
                            align-items: center;
                            cursor: pointer;
                            transition: background-color 0.2s;
                        }
                        .create-backup-button:hover {
                            background: var(--background-modifier-hover);
                        }
                        .create-backup-icon {
                            margin-right: 8px;
                            color: var(--text-accent);
                        }
                        .create-backup-text {
                            flex-grow: 1;
                        }
                        .create-backup-text-main {
                            font-weight: 500;
                            margin-bottom: 2px;
                        }
                        .create-backup-text-sub {
                            font-size: 12px;
                            color: var(--text-muted);
                        }
                        .manual-backup-container {
                            margin-bottom: 10px;
                            padding: 10px;
                            background: var(--background-secondary);
                            border-radius: 5px;
                        }
                    `;
          containerEl.appendChild(styleEl);
          const manualBackupContainer = containerEl.createDiv({ cls: "manual-backup-container" });
          manualBackupContainer.style.marginBottom = "10px";
          manualBackupContainer.style.padding = "10px";
          manualBackupContainer.style.background = "var(--background-secondary)";
          manualBackupContainer.style.borderRadius = "5px";
          const inputPromptEl = manualBackupContainer.createEl("p", { text: "Enter a name for the new manual backup:" });
          inputPromptEl.style.marginBottom = "5px";
          const backupNameInput = new import_obsidian46.TextComponent(manualBackupContainer).setPlaceholder(`Manual backup ${(/* @__PURE__ */ new Date()).toLocaleString()}`).setValue(`Manual backup ${(/* @__PURE__ */ new Date()).toLocaleString()}`);
          backupNameInput.inputEl.style.width = "100%";
          backupNameInput.inputEl.style.marginBottom = "8px";
          const createBackupButton = manualBackupContainer.createEl("button", {
            text: "Create Manual Backup",
            cls: "mod-cta"
            // Obsidian's call-to-action button style
          });
          createBackupButton.style.width = "100%";
          createBackupButton.addEventListener("click", async () => {
            const backupName = backupNameInput.getValue().trim();
            if (!backupName) {
              new import_obsidian46.Notice("Please enter a name for the backup.", 3e3);
              return;
            }
            try {
              await this.saveManualBackup(backupName);
              new import_obsidian46.Notice("Manual backup created successfully.", 3e3);
              modal.close();
              this.open();
            } catch (error) {
            }
          });
          if (containerEl.firstChild) {
            containerEl.insertBefore(manualBackupContainer, containerEl.firstChild);
          } else {
            containerEl.appendChild(manualBackupContainer);
          }
          const originalCreateListItem = modal.createListItem.bind(modal);
          modal.createListItem = (itemData, index) => {
            const itemEl = originalCreateListItem(itemData, index);
            if (itemData._backupDetails) {
              const defaultDesc = itemEl.querySelector(".ss-modal__item-description");
              if (defaultDesc) {
                defaultDesc.remove();
              }
              const content = itemEl.querySelector(".ss-modal__item-content");
              if (content) {
                const detailsEl = content.createDiv({ cls: "backup-details" });
                const details = itemData._backupDetails;
                if (details.includes("\n")) {
                  const detailItems = details.split("\n");
                  detailItems.forEach((item) => {
                    detailsEl.createSpan({
                      text: item,
                      cls: "backup-detail-item"
                    });
                  });
                } else {
                  detailsEl.setText(details);
                }
              }
            }
            return itemEl;
          };
        }
      });
      const selectedItems = await modal.openAndGetSelection();
      if (selectedItems.length === 0) {
        return null;
      }
      return selectedItems[0].id;
    } catch (error) {
      new import_obsidian46.Notice("Error loading backups: " + error, 3e3);
      return null;
    }
  }
  /**
   * Save a manual backup with the given name
   */
  async saveManualBackup(backupName) {
    try {
      const safeNamePart = backupName.replace(/[^a-z0-9]/gi, "-").toLowerCase();
      const timestamp = Date.now();
      const fileName = `settings-manual-${safeNamePart}-${timestamp}.json`;
      const backupDir = ".systemsculpt/settings-backups";
      try {
        await this.plugin.app.vault.createFolder(backupDir);
      } catch (e) {
        if (!e.message || !e.message.includes("already exists")) {
          throw e;
        }
      }
      const currentSettings = this.plugin.getSettingsManager().getSettings();
      const backupData = {
        ...currentSettings,
        _backupMeta: {
          type: "manual",
          name: backupName,
          timestamp,
          createdAt: (/* @__PURE__ */ new Date()).toISOString()
        }
      };
      const backupPath = `.systemsculpt/settings-backups/${fileName}`;
      await this.plugin.app.vault.adapter.write(
        backupPath,
        JSON.stringify(backupData, null, 2)
      );
      new import_obsidian46.Notice(`Manual backup "${backupName}" created successfully`, 3e3);
    } catch (error) {
      new import_obsidian46.Notice("Error saving backup: " + error, 3e3);
      throw error;
    }
  }
  /**
   * Get all available backup files
   */
  async getAvailableBackups() {
    try {
      const backupDir = ".systemsculpt/settings-backups";
      const exists = await this.plugin.app.vault.adapter.exists(backupDir);
      if (!exists) {
        return [];
      }
      const files = await this.plugin.app.vault.adapter.list(backupDir);
      const backupFiles = files.files.filter((f) => f.includes("settings-") && f.endsWith(".json")).sort((a, b) => {
        const aMatch = a.match(/(\d{4}-\d{2}-\d{2})|(\d+)/);
        const bMatch = b.match(/(\d{4}-\d{2}-\d{2})|(\d+)/);
        if (aMatch && bMatch) {
          if (aMatch[2] && bMatch[2]) {
            return parseInt(bMatch[2]) - parseInt(aMatch[2]);
          }
          if (aMatch[1] && bMatch[1]) {
            return bMatch[1].localeCompare(aMatch[1]);
          }
        }
        return b.localeCompare(a);
      });
      const backupsPromises = backupFiles.map(async (filePath) => {
        let name = filePath.split("/").pop() || "";
        let date = "Unknown date";
        let details = "";
        let backupSettings = null;
        try {
          const backupData = await this.plugin.app.vault.adapter.read(filePath);
          backupSettings = JSON.parse(backupData);
          if (backupSettings) {
            const customProviders = Array.isArray(backupSettings.customProviders) ? backupSettings.customProviders.length : 0;
            const favoriteModels = Array.isArray(backupSettings.favoriteModels) ? backupSettings.favoriteModels.length : 0;
            const selectedModel = backupSettings.selectedModelId || "None";
            const hasLicense = backupSettings.licenseValid === true ? "Yes" : "No";
            details = `\u{1F464} ${customProviders} provider${customProviders !== 1 ? "s" : ""}
\u2B50 ${favoriteModels} favorite${favoriteModels !== 1 ? "s" : ""}
\u{1F916} ${selectedModel.split(":").pop()}
\u{1F511} License: ${hasLicense}`;
          }
        } catch (error) {
          details = "Could not read backup contents";
        }
        if (backupSettings && backupSettings._backupMeta && backupSettings._backupMeta.type === "manual") {
          const meta = backupSettings._backupMeta;
          const backupDate = new Date(meta.timestamp);
          return {
            path: filePath,
            name: `\u{1F4DD} ${meta.name}`,
            date: backupDate.toLocaleString(),
            details
          };
        }
        if (name === "settings-backup-latest.json") {
          return {
            path: filePath,
            name: "Latest Automatic Backup",
            date: "Most recent save",
            details
          };
        }
        const dateMatch = name.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
        if (dateMatch) {
          const [, dateStr] = dateMatch;
          const dateObj = new Date(dateStr);
          date = dateObj.toLocaleDateString(void 0, {
            weekday: "long",
            year: "numeric",
            month: "long",
            day: "numeric"
          });
          return {
            path: filePath,
            name: `Backup from ${date}`,
            date: dateStr,
            details
          };
        }
        const emergencyMatch = name.match(/settings-emergency-(\d+)\.json/);
        if (emergencyMatch) {
          const [, timestamp] = emergencyMatch;
          const dateObj = new Date(parseInt(timestamp));
          date = dateObj.toLocaleString();
          return {
            path: filePath,
            name: `Emergency Backup`,
            date,
            details
          };
        }
        const manualMatch = name.match(/settings-manual-(.*)-(\d+)\.json/);
        if (manualMatch) {
          const [, safeName, timestamp] = manualMatch;
          const dateObj = new Date(parseInt(timestamp));
          const readableName = safeName.replace(/-/g, " ");
          return {
            path: filePath,
            name: `\u{1F4DD} ${readableName}`,
            date: dateObj.toLocaleString(),
            details
          };
        }
        return {
          path: filePath,
          name,
          date,
          details
        };
      });
      const processedBackups = await Promise.all(backupsPromises);
      return processedBackups.sort((a, b) => {
        if (a.name.includes("Latest")) return -1;
        if (b.name.includes("Latest")) return 1;
        let dateA = 0;
        let dateB = 0;
        const aManualMatch = a.path.match(/settings-manual-.*-(\d+)\.json/);
        if (aManualMatch) {
          dateA = parseInt(aManualMatch[1]);
        }
        const bManualMatch = b.path.match(/settings-manual-.*-(\d+)\.json/);
        if (bManualMatch) {
          dateB = parseInt(bManualMatch[1]);
        }
        const aAutoMatch = a.path.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
        if (aAutoMatch && !aManualMatch) {
          dateA = new Date(aAutoMatch[1]).getTime();
        }
        const bAutoMatch = b.path.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
        if (bAutoMatch && !bManualMatch) {
          dateB = new Date(bAutoMatch[1]).getTime();
        }
        if (dateA && dateB) {
          return dateB - dateA;
        }
        if (dateA && !dateB) return -1;
        if (!dateA && dateB) return 1;
        return b.path.localeCompare(a.path);
      });
    } catch (error) {
      return [];
    }
  }
  /**
   * Restore settings from the selected backup
   * @param backupPath The path to the backup file
   */
  async restoreFromBackup(backupPath) {
    try {
      const exists = await this.plugin.app.vault.adapter.exists(backupPath);
      if (!exists) {
        new import_obsidian46.Notice("Backup file not found", 3e3);
        return false;
      }
      const backupData = await this.plugin.app.vault.adapter.read(backupPath);
      const backupSettings = JSON.parse(backupData);
      if (!backupSettings || typeof backupSettings !== "object") {
        new import_obsidian46.Notice("Invalid backup file format", 3e3);
        return false;
      }
      await this.plugin.getSettingsManager().updateSettings(backupSettings);
      new import_obsidian46.Notice("Settings restored successfully", 3e3);
      return true;
    } catch (error) {
      new import_obsidian46.Notice("Error restoring settings: " + error, 3e3);
      return false;
    }
  }
};

// src/settings/BackupTabContent.ts
function displayBackupTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "backup";
  }
  const { app, plugin } = tabInstance;
  containerEl.createEl("h3", { text: "Settings backup" });
  new import_obsidian47.Setting(containerEl).setName("Automatic backups").setDesc("Create a backup every 24 hours. Backups include providers, favorites, and preferences.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.automaticBackupsEnabled).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ automaticBackupsEnabled: value });
      const backupService = plugin.getSettingsManager().getAutomaticBackupService();
      if (value) {
        backupService.start();
        new import_obsidian47.Notice("Automatic backups enabled");
      } else {
        backupService.stop();
        new import_obsidian47.Notice("Automatic backups disabled");
      }
    });
  });
  new import_obsidian47.Setting(containerEl).setName("Manual backups").setDesc("Create or restore backups on demand. Files live in .systemsculpt/settings-backups inside your vault.");
  const restoreSetting = new import_obsidian47.Setting(containerEl).setName("Restore from backup").setDesc("Replace your current settings with a saved backup.").addButton((button) => {
    button.setButtonText("Select backup").onClick(async () => {
      const backupModal = new BackupRestoreModal(app, plugin);
      const selectedBackupPath = await backupModal.open();
      if (!selectedBackupPath) return;
      const confirmRestore = async (details) => {
        const description = details ? `This will replace your current settings.

${details}

Continue?` : "This will replace your current settings with the selected backup. Continue?";
        const confirmed = await showPopup(app, "Restore settings from backup", {
          description,
          primaryButton: "Restore",
          secondaryButton: "Cancel"
        });
        if (confirmed == null ? void 0 : confirmed.confirmed) {
          const success = await backupModal.restoreFromBackup(selectedBackupPath);
          if (success) {
            tabInstance.display();
          }
        }
      };
      try {
        const backupData = await plugin.app.vault.adapter.read(selectedBackupPath);
        const backupSettings = JSON.parse(backupData);
        const customProviders = Array.isArray(backupSettings.customProviders) ? backupSettings.customProviders.length : 0;
        const favoriteModels = Array.isArray(backupSettings.favoriteModels) ? backupSettings.favoriteModels.length : 0;
        const selectedModel = backupSettings.selectedModelId ? String(backupSettings.selectedModelId).split(":").pop() : "Default";
        const details = `This backup contains:
\u2022 ${customProviders} custom provider${customProviders === 1 ? "" : "s"}
\u2022 ${favoriteModels} favorite model${favoriteModels === 1 ? "" : "s"}
\u2022 Selected model: ${selectedModel}
\u2022 License status: ${backupSettings.licenseValid ? "Active" : "Inactive"}`;
        await confirmRestore(details);
      } catch (error) {
        await confirmRestore(null);
      }
    });
  });
  new import_obsidian47.Setting(containerEl).setName("Backup folder").setDesc("Open the folder where backups are stored.").addButton((button) => {
    button.setButtonText("Open folder").onClick(async () => {
      try {
        const backupDir = ".systemsculpt/settings-backups";
        try {
          await plugin.app.vault.createFolder(backupDir);
        } catch (_) {
        }
        if (typeof plugin.app.vault.adapter.revealInFolder === "function") {
          plugin.app.vault.adapter.revealInFolder(backupDir);
        } else {
          new import_obsidian47.Notice(`Backups are stored in: ${backupDir}`);
        }
      } catch (error) {
        new import_obsidian47.Notice("Failed to open backup folder");
      }
    });
  });
  new import_obsidian47.Setting(containerEl).setName("Tips").setDesc("Automatic backups run in the background. Manual backups with custom names are useful before big changes. You can copy backup files to other devices to share configurations.");
}

// src/settings/EmbeddingsTabContent.ts
var import_obsidian48 = require("obsidian");
init_FolderSuggester();

// src/services/embeddings/LocalEmbeddingsScanner.ts
init_httpClient();
var isLikelyEmbeddingModel = (modelId) => {
  const id = modelId.toLowerCase();
  return id.includes("embed") || id.includes("nomic") || id.includes("bge") || id.includes("e5") || id.includes("gte") || id.includes("minilm") || id.includes("mpnet") || id.includes("text-embedding");
};
async function tryParseJson2(text) {
  if (!text) return null;
  try {
    return JSON.parse(text);
  } catch (e) {
    return null;
  }
}
async function scanLMStudio2() {
  var _a, _b, _c;
  const base = "http://localhost:1234";
  const modelsUrl = `${base}/v1/models`;
  const embeddingsUrl = `${base}/v1/embeddings`;
  try {
    const resp = await httpRequest({ url: modelsUrl, method: "GET", headers: { "Content-Type": "application/json" } });
    if (!resp || resp.status !== 200) return [];
    const data = (_a = resp.json) != null ? _a : await tryParseJson2(resp.text);
    const list = Array.isArray(data == null ? void 0 : data.data) ? data.data.map((m) => m.id).filter((id) => typeof id === "string") : [];
    const candidates = list.filter(isLikelyEmbeddingModel).slice(0, 6);
    const results = [];
    for (const model of candidates) {
      try {
        const test = await httpRequest({
          url: embeddingsUrl,
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model, input: "hello", encoding_format: "float" })
        });
        if (test.status === 200) {
          const tj = (_b = test.json) != null ? _b : await tryParseJson2(test.text);
          const vec = Array.isArray(tj == null ? void 0 : tj.data) && ((_c = tj.data[0]) == null ? void 0 : _c.embedding);
          const dim = Array.isArray(vec) ? vec.length : void 0;
          results.push({
            type: "lmstudio",
            endpoint: embeddingsUrl,
            model,
            dimension: dim,
            label: `LM Studio \u2022 ${model}${dim ? ` \u2022 ${dim}d` : ""}`
          });
        }
      } catch (e) {
      }
    }
    return results;
  } catch (e) {
    return [];
  }
}
async function scanOllama2() {
  var _a, _b, _c;
  const base = "http://localhost:11434";
  const tagsUrl = `${base}/api/tags`;
  const embeddingsUrl = `${base}/api/embeddings`;
  try {
    const resp = await httpRequest({ url: tagsUrl, method: "GET", headers: { "Content-Type": "application/json" } });
    if (!resp || resp.status !== 200) return [];
    const data = (_a = resp.json) != null ? _a : await tryParseJson2(resp.text);
    const list = Array.isArray(data == null ? void 0 : data.models) ? data.models.map((m) => m.name).filter((n) => typeof n === "string") : [];
    const candidates = list.filter(isLikelyEmbeddingModel);
    const limited = candidates.length > 0 ? candidates.slice(0, 6) : ["nomic-embed-text", "all-minilm"];
    const results = [];
    for (const model of limited) {
      try {
        const test = await httpRequest({
          url: embeddingsUrl,
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ model, prompt: "hello" })
        });
        if (test.status === 200) {
          const tj = (_b = test.json) != null ? _b : await tryParseJson2(test.text);
          const vec = Array.isArray(tj == null ? void 0 : tj.embedding) ? tj.embedding : Array.isArray(tj == null ? void 0 : tj.data) ? (_c = tj.data[0]) == null ? void 0 : _c.embedding : void 0;
          const dim = Array.isArray(vec) ? vec.length : void 0;
          results.push({
            type: "ollama",
            endpoint: embeddingsUrl,
            model,
            dimension: dim,
            label: `Ollama \u2022 ${model}${dim ? ` \u2022 ${dim}d` : ""}`
          });
        }
      } catch (e) {
      }
    }
    return results;
  } catch (e) {
    return [];
  }
}
async function scanLocalEmbeddingProviders() {
  const [lmstudio, ollama] = await Promise.all([scanLMStudio2(), scanOllama2()]);
  const seen = /* @__PURE__ */ new Set();
  const out = [];
  for (const item of [...lmstudio, ...ollama]) {
    const key = `${item.endpoint}::${item.model}`;
    if (!seen.has(key)) {
      seen.add(key);
      out.push(item);
    }
  }
  return out;
}

// src/settings/EmbeddingsTabContent.ts
init_ListSelectionModal();
async function displayEmbeddingsTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "embeddings";
  }
  containerEl.createEl("h3", { text: "Embeddings" });
  containerEl.createEl("p", {
    text: "Enable semantic search to find similar notes by meaning instead of keywords.",
    cls: "setting-item-description"
  });
  const isEnabled = await renderCoreSettingsSection(containerEl, tabInstance);
  if (isEnabled) {
    const refreshStatus = await renderProcessingSection(containerEl, tabInstance);
    await refreshStatus();
  }
  await renderExclusionsSection(containerEl, tabInstance);
}
async function renderCoreSettingsSection(containerEl, tabInstance) {
  var _a;
  const { plugin } = tabInstance;
  const embeddingsSetting = new import_obsidian48.Setting(containerEl).setName("Enable embeddings").setDesc("Turn on semantic search for your vault.").addToggle((toggle) => {
    toggle.setValue(plugin.settings.embeddingsEnabled || false).onChange(async (value) => {
      var _a2, _b;
      await plugin.getSettingsManager().updateSettings({ embeddingsEnabled: value });
      if (value) {
        new import_obsidian48.Notice("Embeddings enabled.");
        (_a2 = plugin.embeddingsStatusBar) == null ? void 0 : _a2.startMonitoring();
        plugin.getOrCreateEmbeddingsManager();
      } else {
        new import_obsidian48.Notice("Embeddings disabled.");
        (_b = plugin.embeddingsStatusBar) == null ? void 0 : _b.stopMonitoring();
      }
      tabInstance.display();
    });
  });
  const enabled = plugin.settings.embeddingsEnabled;
  if (!enabled) {
    return false;
  }
  const providerSetting = new import_obsidian48.Setting(containerEl).setName("Embeddings provider").setDesc("Choose the service that generates embeddings.");
  providerSetting.addDropdown((dropdown) => {
    dropdown.addOption("systemsculpt", "SystemSculpt (Default)").addOption("custom", "Custom provider").setValue(plugin.settings.embeddingsProvider || "systemsculpt").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ embeddingsProvider: value });
      tabInstance.display();
    });
  });
  if ((plugin.settings.embeddingsProvider || "systemsculpt") === "systemsculpt" && !((_a = plugin.settings.licenseKey) == null ? void 0 : _a.trim())) {
    providerSetting.setDesc("SystemSculpt requires an active license. Switch to custom provider if you want to use your own API.");
  }
  if ((plugin.settings.embeddingsProvider || "systemsculpt") === "custom") {
    await renderCustomEmbeddingsProviderSettings(containerEl, tabInstance);
  }
  return true;
}
async function renderProcessingSection(containerEl, tabInstance) {
  const { plugin } = tabInstance;
  const statusSetting = new import_obsidian48.Setting(containerEl).setName("Processing status");
  const statusText = statusSetting.descEl.createSpan();
  const refreshStatus = async () => {
    statusText.setText(await buildStatusSummary(plugin));
  };
  statusSetting.addExtraButton((button) => {
    button.setIcon("refresh-cw").setTooltip("Refresh status").onClick(async () => {
      button.setDisabled(true);
      try {
        await refreshStatus();
      } finally {
        button.setDisabled(false);
      }
    });
  });
  const providerId = plugin.settings.embeddingsProvider || "systemsculpt";
  const providerReady = isEmbeddingsProviderReady(plugin.settings, providerId);
  new import_obsidian48.Setting(containerEl).setName("Build embeddings").setDesc(providerReady ? "Process your vault to enable semantic search." : "Finish provider setup before processing.").addButton((button) => {
    button.setButtonText("Start processing").setCta().setDisabled(!providerReady).onClick(async () => {
      var _a;
      try {
        button.setDisabled(true);
        button.setButtonText("Processing...");
        const manager = plugin.getOrCreateEmbeddingsManager();
        (_a = plugin.embeddingsStatusBar) == null ? void 0 : _a.startMonitoring();
        await manager.processVault(async () => {
          await refreshStatus();
        });
        new import_obsidian48.Notice("Embeddings processing complete.");
        await refreshStatus();
      } catch (error) {
        new import_obsidian48.Notice(`Processing failed: ${(error == null ? void 0 : error.message) || error}`);
      } finally {
        button.setDisabled(!providerReady);
        button.setButtonText("Start processing");
      }
    });
  });
  new import_obsidian48.Setting(containerEl).setName("Clear embeddings data").setDesc("Remove stored embeddings to start over.").addButton((button) => {
    button.setWarning().setButtonText("Clear data").onClick(async () => {
      if (!confirm("Clear all embeddings data? This cannot be undone.")) return;
      try {
        const manager = plugin.embeddingsManager;
        if (manager) {
          await manager.clearAll();
          new import_obsidian48.Notice("Embeddings data cleared.");
        } else {
          new import_obsidian48.Notice("No embeddings data to clear.");
        }
        await refreshStatus();
      } catch (error) {
        new import_obsidian48.Notice(`Failed to clear embeddings data: ${(error == null ? void 0 : error.message) || error}`);
      }
    });
  });
  return refreshStatus;
}
async function renderCustomEmbeddingsProviderSettings(containerEl, tabInstance) {
  const { plugin } = tabInstance;
  new import_obsidian48.Setting(containerEl).setName("Scan local providers").setDesc("Detect Ollama or LM Studio servers running on this machine.").addButton((button) => {
    button.setButtonText("Scan local").onClick(async () => {
      await scanLocalEmbeddings(tabInstance, button);
    });
  });
  new import_obsidian48.Setting(containerEl).setName("API endpoint").setDesc("URL of your embeddings API (e.g., https://api.openai.com/v1/embeddings).").addText((text) => {
    text.setValue(plugin.settings.embeddingsCustomEndpoint || "").setPlaceholder("https://api.openai.com/v1/embeddings").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ embeddingsCustomEndpoint: value });
    });
  });
  new import_obsidian48.Setting(containerEl).setName("API key").setDesc("Only required if your endpoint needs authentication.").addText((text) => {
    text.setValue(plugin.settings.embeddingsCustomApiKey || "").setPlaceholder("sk-...").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ embeddingsCustomApiKey: value });
    });
    text.inputEl.type = "password";
  });
  new import_obsidian48.Setting(containerEl).setName("Model name").setDesc("Identifier of the embeddings model (e.g., text-embedding-3-small).").addText((text) => {
    text.setValue(plugin.settings.embeddingsCustomModel || "").setPlaceholder("text-embedding-3-small").onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({ embeddingsCustomModel: value });
    });
  });
}
async function renderExclusionsSection(containerEl, tabInstance) {
  const { plugin } = tabInstance;
  const exclusions = getExclusionsWithDefaults(plugin);
  containerEl.createEl("h3", { text: "Exclusions" });
  containerEl.createEl("p", {
    text: "Decide which folders or files should be ignored during embeddings processing.",
    cls: "setting-item-description"
  });
  new import_obsidian48.Setting(containerEl).setName("Exclude chat history").setDesc("Skip chat transcripts when building embeddings.").addToggle((toggle) => {
    toggle.setValue(exclusions.ignoreChatHistory).onChange(async (value) => {
      await updateExclusionSetting(tabInstance, "ignoreChatHistory", value);
      tabInstance.display();
    });
  });
  new import_obsidian48.Setting(containerEl).setName("Respect Obsidian exclusions").setDesc("Reuse the ignored files configured in Settings \u2192 Files & Links.").addToggle((toggle) => {
    toggle.setValue(exclusions.respectObsidianExclusions).onChange(async (value) => {
      await updateExclusionSetting(tabInstance, "respectObsidianExclusions", value);
      tabInstance.display();
    });
  });
  const folderSetting = new import_obsidian48.Setting(containerEl).setName("Excluded folders").setDesc("Folders that should never be processed.");
  folderSetting.addText((text) => {
    text.setPlaceholder("Select folder...");
    attachFolderSuggester(text.inputEl, (value) => text.setValue(value), tabInstance.plugin.app);
  });
  folderSetting.addButton((button) => {
    button.setButtonText("Add folder").onClick(async () => {
      const input = folderSetting.controlEl.querySelector("input");
      const value = input == null ? void 0 : input.value.trim();
      if (!value) {
        new import_obsidian48.Notice("Select a folder first.");
        return;
      }
      await addExclusionItem(tabInstance, "folders", value);
      tabInstance.display();
    });
  });
  exclusions.folders.forEach((folder) => {
    const row = new import_obsidian48.Setting(containerEl).setName(folder).setDesc("");
    row.addExtraButton((button) => {
      button.setIcon("trash").setTooltip("Remove folder").onClick(async () => {
        await removeExclusion(tabInstance, "folders", folder);
        tabInstance.display();
      });
    });
  });
  const patternSetting = new import_obsidian48.Setting(containerEl).setName("Excluded patterns").setDesc("File name patterns (glob) to skip, e.g., *.png.");
  patternSetting.addText((text) => {
    text.setPlaceholder("pattern e.g. *.png");
  });
  patternSetting.addButton((button) => {
    button.setButtonText("Add pattern").onClick(async () => {
      const input = patternSetting.controlEl.querySelector("input");
      const value = input == null ? void 0 : input.value.trim();
      if (!value) {
        new import_obsidian48.Notice("Enter a pattern to add.");
        return;
      }
      await addExclusionItem(tabInstance, "patterns", value);
      tabInstance.display();
    });
  });
  exclusions.patterns.forEach((pattern) => {
    const row = new import_obsidian48.Setting(containerEl).setName(pattern).setDesc("");
    row.addExtraButton((button) => {
      button.setIcon("trash").setTooltip("Remove pattern").onClick(async () => {
        await removeExclusion(tabInstance, "patterns", pattern);
        tabInstance.display();
      });
    });
  });
}
async function scanLocalEmbeddings(tabInstance, trigger) {
  try {
    if (trigger) {
      trigger.setDisabled(true);
      trigger.setButtonText("Scanning...");
    }
    const options = await scanLocalEmbeddingProviders();
    if (!options || options.length === 0) {
      new import_obsidian48.Notice("No local embeddings providers detected on default ports.");
      return;
    }
    const items = options.map((opt, index) => ({
      id: `local-${index}`,
      title: opt.label,
      description: `${opt.endpoint} \u2022 ${opt.model}`,
      icon: opt.type === "ollama" ? "layers" : "cpu",
      metadata: { index }
    }));
    const modal = new ListSelectionModal(tabInstance.app, items, {
      title: "Local embeddings providers",
      description: "Choose detected endpoints to add or enable.",
      withSearch: false,
      multiSelect: true,
      size: "medium"
    });
    const selection = await modal.openAndGetSelection();
    if (!selection || selection.length === 0) return;
    const chosenIndexes = new Set(selection.map((item) => {
      var _a;
      return (_a = item.metadata) == null ? void 0 : _a.index;
    }));
    const chosen = options.filter((_, idx) => chosenIndexes.has(idx));
    const existing = tabInstance.plugin.settings.customProviders || [];
    const updated = [...existing];
    for (const opt of chosen) {
      const baseName = opt.type === "ollama" ? "Ollama" : "LM Studio";
      const normalizedEndpoint = (opt.endpoint || "").replace(/\/$/, "");
      const already = updated.find((p) => (p.endpoint || "").replace(/\/$/, "") === normalizedEndpoint);
      if (already) {
        already.isEnabled = true;
        continue;
      }
      updated.push({
        id: `local-${baseName.toLowerCase()}-${Date.now()}-${Math.random().toString(16).slice(2)}`,
        name: baseName,
        endpoint: opt.endpoint,
        apiKey: "",
        isEnabled: true
      });
    }
    await tabInstance.plugin.getSettingsManager().updateSettings({ customProviders: updated });
    tabInstance.plugin.customProviderService.clearCache();
    await tabInstance.plugin.modelService.refreshModels();
    new import_obsidian48.Notice(`Added or enabled ${chosen.length} local provider${chosen.length === 1 ? "" : "s"}.`);
    tabInstance.display();
  } catch (error) {
    new import_obsidian48.Notice(`Scan failed: ${(error == null ? void 0 : error.message) || error}`);
  } finally {
    if (trigger) {
      trigger.setDisabled(false);
      trigger.setButtonText("Scan local");
    }
  }
}
function getExclusionsWithDefaults(plugin) {
  return plugin.settings.embeddingsExclusions || {
    folders: [],
    patterns: [],
    ignoreChatHistory: true,
    respectObsidianExclusions: true
  };
}
async function updateExclusionSetting(tabInstance, key, value) {
  const current = getExclusionsWithDefaults(tabInstance.plugin);
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...current,
      [key]: value
    }
  });
}
async function addExclusionItem(tabInstance, type, item) {
  const current = getExclusionsWithDefaults(tabInstance.plugin);
  const updatedList = Array.from(/* @__PURE__ */ new Set([...current[type] || [], item]));
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...current,
      [type]: updatedList
    }
  });
}
async function removeExclusion(tabInstance, type, item) {
  const current = getExclusionsWithDefaults(tabInstance.plugin);
  const updatedList = (current[type] || []).filter((entry) => entry !== item);
  await tabInstance.plugin.getSettingsManager().updateSettings({
    embeddingsExclusions: {
      ...current,
      [type]: updatedList
    }
  });
}
function isEmbeddingsProviderReady(settings, provider) {
  if (provider === "systemsculpt") {
    return !!(settings.licenseKey || "").trim();
  }
  return !!(settings.embeddingsCustomEndpoint || "").trim() && !!(settings.embeddingsCustomModel || "").trim();
}
async function buildStatusSummary(plugin) {
  if (!plugin.settings.embeddingsEnabled) {
    return "Embeddings disabled";
  }
  const manager = plugin.embeddingsManager;
  if (!manager) {
    return "Ready to process files";
  }
  try {
    const stats = manager.getStats();
    const processed = Math.min(stats.processed, stats.total);
    if (manager.isCurrentlyProcessing()) {
      return `Processing\u2026 ${processed}/${stats.total} files complete`;
    }
    if (stats.total > 0 && processed === stats.total) {
      return `Ready for search (${stats.total} file${stats.total === 1 ? "" : "s"} embedded)`;
    }
    if (stats.total > 0) {
      return `${processed}/${stats.total} file${stats.total === 1 ? "" : "s"} embedded`;
    }
    return "Ready to process files";
  } catch (error) {
    return "Status unavailable";
  }
}

// src/settings/AdvancedTabContent.ts
var import_obsidian50 = require("obsidian");
init_ui();
init_types();

// src/modals/UpdateNotificationWarningModal.ts
var import_obsidian49 = require("obsidian");
var UpdateNotificationWarningModal = class extends import_obsidian49.Modal {
  constructor(app) {
    super(app);
    this.result = { confirmed: false };
    this.resolve = () => {
    };
  }
  async open() {
    return new Promise((resolve) => {
      this.resolve = resolve;
      super.open();
    });
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const headerEl = contentEl.createDiv({ cls: "modal-header" });
    const iconEl = headerEl.createDiv({ cls: "modal-header-icon" });
    iconEl.innerHTML = `
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                <path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/>
                <path d="M12 9v4"/>
                <path d="m12 17 .01 0"/>
            </svg>
        `;
    iconEl.addClass("ss-modal-icon--warning");
    const titleEl = headerEl.createDiv({ cls: "modal-title" });
    titleEl.textContent = "Disable Update Notifications";
    const messageEl = contentEl.createDiv({ cls: "modal-content" });
    messageEl.innerHTML = `
            <p><strong>Warning:</strong> Disabling update notifications means you'll be responsible for manually checking for plugin updates.</p>
            
            <p>Without notifications, you may miss important updates that include:</p>
            <ul>
                <li>Security fixes and bug patches</li>
                <li>New features and improvements</li>
                <li>Compatibility updates for new Obsidian versions</li>
                <li>Performance optimizations</li>
            </ul>
            
            <p>If you're not on the latest version, some features may stop working or behave unexpectedly.</p>
            
            <p><strong>Recommendation:</strong> Keep update notifications enabled to stay current with the latest improvements and fixes.</p>
            
            <p>You can re-enable notifications at any time in the Advanced settings tab.</p>
        `;
    const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
    new import_obsidian49.Setting(buttonContainer).addButton((btn) => {
      btn.setButtonText("Cancel").onClick(() => {
        this.result.confirmed = false;
        this.close();
      });
    }).addButton((btn) => {
      btn.setButtonText("Disable Notifications").setWarning().onClick(() => {
        this.result.confirmed = true;
        this.close();
      });
    });
  }
  onClose() {
    this.resolve(this.result);
  }
};

// src/settings/AdvancedTabContent.ts
init_errorHandling();
function displayAdvancedTabContent(containerEl, tabInstance) {
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "advanced";
  }
  const { app, plugin, systemSculptService } = tabInstance;
  containerEl.createEl("h3", { text: "Advanced Settings" });
  const developmentModeSetting = new import_obsidian50.Setting(containerEl).setName("Development mode").setDesc("Enable additional logging and debugging features for troubleshooting").addToggle((toggle) => {
    toggle.setValue(plugin.settings.debugMode).onChange(async (value) => {
      await plugin.getSettingsManager().updateSettings({
        debugMode: value,
        logLevel: value ? 3 /* DEBUG */ : 1 /* WARNING */
      });
      setLogLevel(value ? 3 /* DEBUG */ : 1 /* WARNING */);
      new import_obsidian50.Notice(`Development mode ${value ? "enabled" : "disabled"}.`);
    });
  });
  const updateNotificationsSetting = new import_obsidian50.Setting(containerEl).setName("Update notifications").setDesc("Show notifications when plugin updates are available").addToggle((toggle) => {
    toggle.setValue(plugin.settings.showUpdateNotifications).onChange(async (value) => {
      var _a, _b;
      if (!value) {
        const warningModal = new UpdateNotificationWarningModal(app);
        const result = await warningModal.open();
        if (result.confirmed) {
          await plugin.getSettingsManager().updateSettings({
            showUpdateNotifications: false
          });
          (_a = plugin.versionCheckerService) == null ? void 0 : _a.onUpdateNotificationsDisabled();
          new import_obsidian50.Notice("Update notifications disabled. You can re-enable them anytime in Advanced settings.");
        } else {
          toggle.setValue(true);
        }
      } else {
        await plugin.getSettingsManager().updateSettings({
          showUpdateNotifications: true
        });
        (_b = plugin.versionCheckerService) == null ? void 0 : _b.onUpdateNotificationsEnabled();
        new import_obsidian50.Notice("Update notifications enabled.");
      }
    });
  });
  const resetSetting = new import_obsidian50.Setting(containerEl).setName("Reset to Factory Settings").setDesc(
    "Clear all custom settings and restore defaults for this plugin."
  );
  const resetButton = new import_obsidian50.ButtonComponent(resetSetting.controlEl);
  resetButton.setButtonText("Reset\u2026");
  resetButton.setWarning();
  resetButton.onClick(async () => {
    var _a;
    const confirm2 = await showPopup(
      app,
      "Reset to Factory Defaults",
      {
        description: "This will delete ALL saved settings and customizations for SystemSculpt, returning everything to default. Do you want to continue?",
        primaryButton: "Reset & Reload",
        secondaryButton: "Cancel"
      }
    );
    if (!confirm2 || !confirm2.confirmed) {
      return;
    }
    try {
      (_a = plugin.customProviderService) == null ? void 0 : _a.clearCache();
      await plugin.saveData(null);
      await plugin.getSettingsManager().updateSettings({ ...DEFAULT_SETTINGS });
      new import_obsidian50.Notice("Settings reset. Reloading Obsidian...", 3e3);
      setTimeout(() => window.location.reload(), 1e3);
    } catch (error) {
      showPopup(app, "Failed to reset: " + String(error));
    }
  });
  containerEl.createEl("hr", { cls: "settings-separator" });
  containerEl.createEl("h3", { text: "Diagnostics & Troubleshooting" });
  const logsSetting = new import_obsidian50.Setting(containerEl).setName("Console Logs Collector").setDesc("Copy all SystemSculpt-related console logs to help with troubleshooting");
  const logsButton = new import_obsidian50.ButtonComponent(logsSetting.controlEl);
  logsButton.setButtonText("Copy Logs for Support");
  logsButton.setTooltip("Copy all SystemSculpt logs to clipboard");
  logsButton.onClick(async () => {
    try {
      const success = await plugin.copyAllLogsToClipboard();
      if (success) {
        new import_obsidian50.Notice("SystemSculpt logs copied to clipboard. You can now paste them to share with the developer via Discord.", 5e3);
      } else {
        new import_obsidian50.Notice("Failed to copy logs to clipboard. Please try again.", 5e3);
      }
    } catch (error) {
      new import_obsidian50.Notice("Error copying logs: " + error.message, 5e3);
    }
  });
}

// src/settings/ChangeLogTabContent.ts
var import_obsidian51 = require("obsidian");
init_ChangeLogService();
var RELEASES_PER_BATCH = 10;
async function renderReleaseEntry(entry, parentEl, tabInstance) {
  const entryEl = parentEl.createEl("div", { cls: "systemsculpt-changelog-entry" });
  const headerEl = entryEl.createEl("div", { cls: "systemsculpt-changelog-entry-header" });
  headerEl.createEl("h4", { text: `Version ${entry.version}` });
  headerEl.createEl("span", { cls: "systemsculpt-changelog-entry-date", text: entry.date });
  const notesEl = entryEl.createEl("div", { cls: "systemsculpt-changelog-entry-notes-markdown" });
  await import_obsidian51.MarkdownRenderer.renderMarkdown(entry.notes, notesEl, "", tabInstance.plugin);
  const linkEl = entryEl.createEl("a", {
    cls: "systemsculpt-changelog-entry-link",
    href: entry.url,
    text: "View on GitHub",
    attr: { target: "_blank", rel: "noopener noreferrer" }
  });
  (0, import_obsidian51.setIcon)(linkEl, "external-link");
}
async function displayChangeLogTabContent(containerEl, tabInstance) {
  const app = tabInstance.plugin.app;
  containerEl.empty();
  if (containerEl.classList.contains("systemsculpt-tab-content")) {
    containerEl.dataset.tab = "changelog";
  }
  containerEl.createEl("h3", { text: "Plugin Change Log" });
  const changelogListEl = containerEl.createEl("div", { cls: "systemsculpt-changelog-list" });
  const loadingEl = changelogListEl.createEl("p", { text: "Loading all releases..." });
  let allFetchedReleases = [];
  let displayedReleasesCount = 0;
  let loadMoreButtonEl = null;
  let loadMoreContainerEl = null;
  function updateLoadMoreButtonState() {
    if (!loadMoreButtonEl) return;
    const remaining = allFetchedReleases.length - displayedReleasesCount;
    if (remaining > 0) {
      loadMoreButtonEl.setText(`Load More Releases (${remaining} remaining)`);
      loadMoreButtonEl.style.display = "inline-block";
    } else {
      loadMoreButtonEl.style.display = "none";
    }
  }
  async function displayNextBatchAndManageButton() {
    const startIndex = displayedReleasesCount;
    const endIndex = Math.min(startIndex + RELEASES_PER_BATCH, allFetchedReleases.length);
    if (startIndex >= allFetchedReleases.length) {
      updateLoadMoreButtonState();
      return;
    }
    const batchToDisplay = allFetchedReleases.slice(startIndex, endIndex);
    for (const entry of batchToDisplay) {
      await renderReleaseEntry(entry, changelogListEl, tabInstance);
    }
    displayedReleasesCount = endIndex;
    updateLoadMoreButtonState();
  }
  try {
    allFetchedReleases = await ChangeLogService.getReleases();
    loadingEl.remove();
    if (allFetchedReleases.length === 0) {
      changelogListEl.createEl("p", { text: "No changelog information available at the moment." });
    } else {
      await displayNextBatchAndManageButton();
      if (allFetchedReleases.length > displayedReleasesCount) {
        if (!loadMoreContainerEl) {
          loadMoreContainerEl = containerEl.createEl("div", { cls: "systemsculpt-load-more-container" });
        }
        loadMoreButtonEl = loadMoreContainerEl.createEl("button", {
          text: "Load More Releases",
          cls: "systemsculpt-load-more-button mod-cta"
        });
        loadMoreButtonEl.addEventListener("click", () => displayNextBatchAndManageButton());
        updateLoadMoreButtonState();
      }
    }
  } catch (error) {
    loadingEl.remove();
    const errorMessage = error instanceof Error ? error.message : String(error);
    if (errorMessage.includes("403")) {
      const rateLimitEl = changelogListEl.createEl("p", { cls: "systemsculpt-changelog-rate-limit" });
      rateLimitEl.setText("Changelog temporarily unavailable due to GitHub API rate limiting. Please try again in a few minutes.");
    } else {
      const errorEl = changelogListEl.createEl("p", { cls: "systemsculpt-changelog-error" });
      errorEl.setText("Failed to load changelog. Please check your internet connection or try again later.");
      new import_obsidian51.Notice("Failed to fetch changelog from GitHub.");
    }
  }
  const allReleasesLinkContainer = containerEl.createEl("div", { cls: "systemsculpt-all-releases-link-container" });
  const allReleasesLink = allReleasesLinkContainer.createEl("a", {
    href: ChangeLogService.getReleasesPageUrl(),
    text: "View All Releases on GitHub",
    cls: "systemsculpt-all-releases-link",
    attr: { target: "_blank", rel: "noopener noreferrer" }
  });
  (0, import_obsidian51.setIcon)(allReleasesLink, "github");
}

// src/settings/SettingsTabRegistry.ts
function buildSettingsTabConfigs(tab) {
  const isProActive = tab.plugin.settings.licenseValid === true;
  const isAdvancedMode = tab.plugin.settings.settingsMode === "advanced";
  return [
    {
      id: "overview",
      label: "Overview & Setup",
      sections: [
        (parent) => {
          const section = parent.createDiv();
          displaySetupTabContent(section, tab, isProActive);
        }
      ],
      anchor: {
        title: "Setup, Connect Providers, API Keys, License",
        desc: "Add providers (SystemSculpt, OpenAI, Anthropic, OpenRouter, LM Studio, Ollama), enter API keys, test connection, activate license, enable fallback."
      }
    },
    {
      id: "models-prompts",
      label: "Models & Prompts",
      sections: [
        (parent) => {
          const section = parent.createDiv();
          displayModelSettingsTabContent(section, tab);
        },
        (parent) => {
          const section = parent.createDiv();
          displaySystemPromptSettingsTabContent(section, tab);
        },
        (parent) => {
          const section = parent.createDiv();
          displayTitleGenerationTabContent(section, tab);
        }
      ],
      anchor: {
        title: "Models, System Prompts, Title Generation, Post-processing",
        desc: "Configure chat model, title model, post-processing model; choose presets or custom system prompts; title generation prompts."
      }
    },
    {
      id: "chat-templates",
      label: "Chat & Templates",
      sections: [
        (parent) => {
          const section = parent.createDiv();
          displayChatTabContent(section, tab);
        },
        (parent) => {
          const section = parent.createDiv();
          displayTemplatesTabContent(section, tab);
        }
      ],
      anchor: {
        title: "Chat Settings, Favorites, Templates, Agent Mode",
        desc: "Default chat font size, default agent mode (includes vault structure), manage favorite models, template hotkey and shortcuts."
      }
    },
    {
      id: "audio-transcription",
      label: "Audio & Transcription",
      sections: [
        (parent) => {
          const section = parent.createDiv();
          displayRecorderTabContent(section, tab);
        }
      ],
      anchor: {
        title: "Audio Recording, Microphone, Transcription, Whisper, Groq, OpenAI, Resampling",
        desc: "Preferred microphone, auto-transcribe, clean output, auto-submit, post-processing, custom transcription endpoint and API key, model selection, presets."
      }
    },
    {
      id: "files-backup",
      label: "Files & Backup",
      sections: [
        (parent) => {
          const section = parent.createDiv();
          displayDirectoriesTabContent(section, tab);
        },
        (parent) => {
          const section = parent.createDiv();
          displayBackupTabContent(section, tab);
        }
      ],
      anchor: {
        title: "Directories, Folders, Attachments, Saved Chats, Extractions, Backups, Restore",
        desc: "Configure directories for chats, saved chats, recordings, system prompts, attachments, extractions; verify/repair; automatic backups; manual backup & restore."
      }
    },
    {
      id: "embeddings",
      label: "Embeddings & Search",
      sections: [
        (parent) => {
          displayEmbeddingsTabContent(parent, tab);
        }
      ],
      anchor: {
        title: "Embeddings, Semantic Search, Similar Notes, Exclusions, Provider",
        desc: "Enable embeddings, provider selection, custom API endpoint and key, model selection, file and folder exclusions, respect Obsidian exclusions."
      }
    },
    {
      id: "advanced",
      label: "Advanced",
      sections: [
        (parent) => {
          displayAdvancedTabContent(parent, tab);
        },
        (parent) => {
          const changelogWrapper = parent.createDiv();
          changelogWrapper.createEl("h3", { text: "What's New (Change Log)" });
          displayChangeLogTabContent(changelogWrapper, tab);
        }
      ],
      anchor: {
        title: "Advanced, Debug, Update Notifications, Reset, Diagnostics, Changelog",
        desc: "Development mode, logs, update notifications, reset to factory settings, diagnostics & troubleshooting, plugin change log."
      }
    }
  ];
}

// src/settings/SystemSculptSettingTab.ts
var SystemSculptSettingTab = class extends import_obsidian52.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.debounceTimer = null;
    this.listeners = [];
    this.versionInfoContainer = null;
    this.tabContainerEl = null;
    this.contentContainerEl = null;
    this.searchInputEl = null;
    this.searchResultsContainerEl = null;
    this.allSettingsIndex = [];
    this.tabsDef = [];
    this.contentMutationObserver = null;
    this.indexRebuildTimer = null;
    this.activeTabId = "overview";
    this.plugin = plugin;
    this.systemSculptService = SystemSculptService.getInstance(plugin);
  }
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  generateFeedbackUrl() {
    var _a, _b;
    const environmentInfo = [];
    environmentInfo.push(`- SystemSculpt AI version: ${this.plugin.manifest.version}`);
    const obsidianVersion = this.app.apiVersion || ((_b = (_a = this.app.vault) == null ? void 0 : _a.config) == null ? void 0 : _b.version) || "";
    if (obsidianVersion) {
      environmentInfo.push(`- Obsidian version: ${obsidianVersion}`);
    }
    let os = "";
    if (import_obsidian52.Platform.isWin) {
      os = "Windows";
    } else if (import_obsidian52.Platform.isMacOS) {
      os = "macOS";
    } else if (import_obsidian52.Platform.isLinux) {
      os = "Linux";
    } else if (import_obsidian52.Platform.isIosApp) {
      os = "iOS";
    } else if (import_obsidian52.Platform.isAndroidApp) {
      os = "Android";
    }
    if (os) {
      environmentInfo.push(`- OS: ${os}`);
    }
    let deviceType = "";
    if (import_obsidian52.Platform.isDesktopApp) {
      deviceType = "Desktop";
    } else if (import_obsidian52.Platform.isMobileApp) {
      deviceType = "Mobile";
    } else if (import_obsidian52.Platform.isTablet) {
      deviceType = "Tablet";
    }
    if (deviceType) {
      environmentInfo.push(`- Device type: ${deviceType}`);
    }
    const isDarkTheme = document.body.classList.contains("theme-dark");
    environmentInfo.push(`- Theme: ${isDarkTheme ? "Dark" : "Light"}`);
    if (navigator.language) {
      environmentInfo.push(`- Language: ${navigator.language}`);
    }
    const activeProvider = this.plugin.settings.activeProvider;
    const currentProvider = (activeProvider == null ? void 0 : activeProvider.name) || this.plugin.settings.selectedProvider;
    if (currentProvider) {
      environmentInfo.push(`- AI Provider: ${currentProvider}`);
    }
    const currentModel = this.plugin.settings.selectedModelId;
    if (currentModel) {
      environmentInfo.push(`- AI Model: ${currentModel}`);
    }
    const pluginMode = this.plugin.settings.settingsMode === "advanced" ? "Advanced" : "Standard";
    environmentInfo.push(`- Plugin mode: ${pluginMode}`);
    const files = this.app.vault.getFiles();
    const noteCount = files.filter((f) => f.extension === "md").length;
    let vaultSize = "";
    if (noteCount < 100) vaultSize = "Small (<100 notes)";
    else if (noteCount < 500) vaultSize = "Medium (100-500 notes)";
    else if (noteCount < 2e3) vaultSize = "Large (500-2000 notes)";
    else vaultSize = "Very Large (2000+ notes)";
    environmentInfo.push(`- Vault size: ${vaultSize}`);
    const enabledFeatures = [];
    if (this.plugin.settings.mcpEnabled) enabledFeatures.push("MCP");
    if (this.plugin.settings.embeddingsEnabled) enabledFeatures.push("Embeddings");
    if (this.plugin.settings.enableSystemSculptProvider) enabledFeatures.push("SystemSculpt Provider");
    if (enabledFeatures.length > 0) {
      environmentInfo.push(`- Enabled features: ${enabledFeatures.join(", ")}`);
    }
    const enabledCustomProviders = (this.plugin.settings.customProviders || []).filter((p) => p.isEnabled).map((p) => p.name).filter(Boolean);
    if (enabledCustomProviders.length > 0) {
      environmentInfo.push(`- Custom providers enabled: ${enabledCustomProviders.join(", ")}`);
    }
    const title = encodeURIComponent("SystemSculpt Feedback: ");
    const body = encodeURIComponent(
      `Please describe your feedback:

- What happened or what would you like to see improved?
- Steps to reproduce (if a bug):
- Expected behavior:
- Screenshots or logs:

Environment:
` + environmentInfo.join("\n") + `

Additional context:`
    );
    return `https://github.com/SystemSculpt/obsidian-systemsculpt-ai/issues/new?title=${title}&body=${body}`;
  }
  removeAllListeners() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
  async display() {
    var _a, _b;
    this.removeAllListeners();
    const { containerEl } = this;
    containerEl.empty();
    this.tabContainerEl = null;
    this.contentContainerEl = null;
    containerEl.createEl("h2", { text: "SystemSculpt AI" });
    containerEl.createEl("p", {
      text: "Configure AI models, prompts, embeddings, audio, and more.",
      cls: "setting-item-description"
    });
    const versionSetting = new import_obsidian52.Setting(containerEl).setName("Plugin version").setDesc("");
    versionSetting.controlEl.addClass("ss-inline-actions");
    this.versionInfoContainer = versionSetting.descEl;
    this.initializeVersionDisplay();
    versionSetting.addExtraButton((button) => {
      button.setIcon("refresh-cw").setTooltip("Check for updates").onClick(async () => {
        button.setDisabled(true);
        try {
          await this.checkForUpdates(true);
        } finally {
          button.setDisabled(false);
        }
      });
    });
    const modeSetting = new import_obsidian52.Setting(containerEl).setName("Settings mode").setDesc("Standard hides advanced options. Advanced unlocks everything.");
    modeSetting.addDropdown((dropdown) => {
      var _a2;
      dropdown.addOption("standard", "Standard").addOption("advanced", "Advanced").setValue((_a2 = this.plugin.settings.settingsMode) != null ? _a2 : "standard").onChange(async (value) => {
        const nextMode = value === "advanced" ? "advanced" : "standard";
        if (nextMode === this.plugin.settings.settingsMode) {
          return;
        }
        await this.plugin.getSettingsManager().updateSettings({ settingsMode: nextMode });
        this.display();
      });
    });
    const searchSetting = new import_obsidian52.Setting(containerEl).setName("Search settings").setDesc("Search across every tab.");
    searchSetting.addText((text) => {
      text.setPlaceholder("Search settings...");
      text.setValue("");
      text.inputEl.type = "search";
      text.inputEl.addClass("search-input");
      this.searchInputEl = text.inputEl;
      this.registerListener(text.inputEl, "input", () => this.handleSearchInput());
      this.registerListener(text.inputEl, "keydown", (event) => {
        if (event.key === "Escape" && this.searchInputEl) {
          this.searchInputEl.value = "";
          this.exitSearchMode();
          this.searchInputEl.focus();
        }
      });
    });
    searchSetting.addExtraButton((button) => {
      button.setIcon("x-circle").setTooltip("Clear search").onClick(() => {
        if (!this.searchInputEl) return;
        this.searchInputEl.value = "";
        this.exitSearchMode();
        this.searchInputEl.focus();
      });
    });
    const actionsSetting = new import_obsidian52.Setting(containerEl).setName("Quick actions").setDesc("");
    actionsSetting.addButton((button) => {
      decorateRestoreDefaultsButton(button.buttonEl);
      button.onClick(async () => {
        const confirm2 = await showPopup(
          this.app,
          RESTORE_DEFAULTS_COPY.label,
          {
            description: "This will replace your current configuration with the recommended defaults. Any customizations you've applied will be overwritten. Do you want to continue?",
            primaryButton: "Restore Defaults",
            secondaryButton: "Cancel"
          }
        );
        if (!(confirm2 == null ? void 0 : confirm2.confirmed)) {
          return;
        }
        try {
          button.setDisabled(true);
          await this.plugin.getSettingsManager().updateSettings({
            settingsMode: "standard",
            selectedModelId: this.plugin.settings.selectedModelId || "systemsculpt@@moonshotai/kimi-k2",
            systemPromptType: "general-use",
            systemPromptPath: "",
            chatFontSize: "medium",
            automaticTitleGeneration: false,
            enableSystemSculptProvider: true,
            useSystemSculptAsFallback: true,
            selectedModelProviders: [],
            embeddingsEnabled: false,
            showModelTooltips: false,
            showVisionModelsOnly: false,
            showTopPicksOnly: false,
            chatsDirectory: "SystemSculpt/Chats",
            savedChatsDirectory: "SystemSculpt/Saved Chats",
            attachmentsDirectory: "SystemSculpt/Attachments",
            extractionsDirectory: "SystemSculpt/Extractions",
            systemPromptsDirectory: "SystemSculpt/System Prompts",
            showUpdateNotifications: true,
            debugMode: false
          });
          new import_obsidian52.Notice("Recommended defaults restored.", 2500);
          this.display();
        } catch (_) {
          new import_obsidian52.Notice("Failed to restore recommended defaults.", 4e3);
        } finally {
          button.setDisabled(false);
        }
      });
    });
    const feedbackLink = actionsSetting.controlEl.createEl("a", {
      cls: "ss-settings-link",
      text: "Send feedback",
      attr: {
        href: this.generateFeedbackUrl(),
        target: "_blank",
        rel: "noopener",
        "aria-label": "Share feedback, report bugs, or suggest improvements"
      }
    });
    (0, import_obsidian52.setIcon)(feedbackLink.createSpan({ cls: "ss-settings-link-icon" }), "external-link");
    const layout = containerEl.createDiv({ cls: "ss-settings-layout" });
    const tabBar = layout.createDiv({ cls: "ss-settings-tab-bar" });
    const contentContainer = layout.createDiv({ cls: "ss-settings-panels" });
    this.tabContainerEl = tabBar;
    this.contentContainerEl = contentContainer;
    const tabConfigsAll = buildSettingsTabConfigs(this);
    const isAdvancedMode = this.plugin.settings.settingsMode === "advanced";
    const visibleTabs = isAdvancedMode ? tabConfigsAll : tabConfigsAll.filter(
      (cfg) => ["overview", "models-prompts", "chat-templates", "embeddings", "audio-transcription"].includes(cfg.id)
    );
    this.tabsDef = visibleTabs.map(({ id, label }) => ({ id, label }));
    this.activeTabId = (_b = (_a = this.tabsDef[0]) == null ? void 0 : _a.id) != null ? _b : "overview";
    for (const [index, cfg] of visibleTabs.entries()) {
      const button = tabBar.createEl("button", {
        cls: "ss-tab-button",
        text: cfg.label
      });
      button.dataset.tab = cfg.id;
      if (cfg.id === this.activeTabId || index === 0 && !this.activeTabId) {
        button.addClass("mod-active");
      }
      this.registerListener(button, "click", () => this.activateTab(cfg.id));
      const panel = contentContainer.createDiv({
        cls: ["ss-tab-panel", "systemsculpt-tab-content"]
      });
      panel.dataset.tab = cfg.id;
      if (cfg.id === this.activeTabId) {
        panel.addClass("is-active");
        panel.toggle(true);
      } else {
        panel.removeClass("is-active");
        panel.toggle(false);
      }
    }
    for (const cfg of visibleTabs) {
      const sectionRoot = contentContainer.querySelector(`[data-tab="${cfg.id}"]`);
      if (!sectionRoot) continue;
      sectionRoot.empty();
      for (const render of cfg.sections) {
        render(sectionRoot);
      }
      if (cfg.anchor) {
        const anchor = sectionRoot.createDiv({
          attr: {
            "data-ss-search": "true",
            "data-ss-title": cfg.anchor.title,
            "data-ss-desc": cfg.anchor.desc
          }
        });
        anchor.toggle(false);
      }
    }
    if (!isAdvancedMode) {
      const hiddenConfigs = tabConfigsAll.filter((cfg) => !visibleTabs.find((c) => c.id === cfg.id));
      for (const cfg of hiddenConfigs) {
        const hiddenPanel = contentContainer.createDiv({
          cls: ["ss-tab-panel", "systemsculpt-tab-content"]
        });
        hiddenPanel.dataset.tab = cfg.id;
        hiddenPanel.toggle(false);
        if (cfg.anchor) {
          const anchor = hiddenPanel.createDiv({
            attr: {
              "data-ss-search": "true",
              "data-ss-title": cfg.anchor.title,
              "data-ss-desc": cfg.anchor.desc,
              "data-ss-advanced": "true"
            }
          });
          anchor.toggle(false);
        }
      }
    }
    this.buildSettingsIndex();
    window.setTimeout(() => this.buildSettingsIndex(), 300);
    if (this.contentContainerEl) {
      if (this.contentMutationObserver) {
        this.contentMutationObserver.disconnect();
      }
      this.contentMutationObserver = new MutationObserver(() => {
        if (this.indexRebuildTimer) window.clearTimeout(this.indexRebuildTimer);
        this.indexRebuildTimer = window.setTimeout(() => this.buildSettingsIndex(), 150);
      });
      this.contentMutationObserver.observe(this.contentContainerEl, { childList: true, subtree: true });
    }
    this.searchResultsContainerEl = containerEl.createDiv({ cls: "ss-settings-search-results" });
    this.searchResultsContainerEl.toggle(false);
  }
  /**
   * Initialize version display and check for updates
   */
  async initializeVersionDisplay() {
    if (!this.versionInfoContainer) return;
    this.versionInfoContainer.empty();
    const currentVersion = this.plugin.manifest.version;
    this.versionInfoContainer.createSpan({
      cls: "ss-version-pill ss-version-pill--checking",
      text: `v${currentVersion} (checking...)`
    });
    await this.checkForUpdates();
  }
  /**
   * Check for updates and update the UI
   */
  async checkForUpdates(forceRefresh = false) {
    if (!this.versionInfoContainer) return;
    try {
      const versionInfo = await this.plugin.getVersionCheckerService().checkVersion(forceRefresh);
      this.updateVersionDisplay(versionInfo);
    } catch (error) {
      const versionText = this.versionInfoContainer.querySelector(".ss-version-pill");
      if (versionText) {
        versionText.setText(`v${this.plugin.manifest.version} (check failed)`);
        versionText.removeClass("ss-version-pill--latest", "ss-version-pill--outdated", "ss-version-pill--checking");
        versionText.addClass("ss-version-pill--error");
      }
    }
  }
  /**
   * Update the version display with the version info
   */
  updateVersionDisplay(versionInfo) {
    var _a;
    if (!this.versionInfoContainer) return;
    let versionText = this.versionInfoContainer.querySelector(".ss-version-pill");
    if (!versionText) {
      versionText = this.versionInfoContainer.createSpan({ cls: "ss-version-pill" });
    }
    versionText.removeClass(
      "ss-version-pill--latest",
      "ss-version-pill--outdated",
      "ss-version-pill--error",
      "ss-version-pill--checking"
    );
    if (versionInfo.isLatest) {
      versionText.setText(`v${versionInfo.currentVersion} (latest)`);
      versionText.addClass("ss-version-pill--latest");
      (_a = this.versionInfoContainer.querySelector(".ss-version-update")) == null ? void 0 : _a.remove();
    } else {
      versionText.setText(`v${versionInfo.currentVersion} \u2192 v${versionInfo.latestVersion}`);
      versionText.addClass("ss-version-pill--outdated");
      if (!this.versionInfoContainer.querySelector(".ss-version-update")) {
        const updateLink = this.versionInfoContainer.createEl("a", {
          cls: "ss-version-update",
          text: "Update",
          attr: {
            href: versionInfo.updateUrl,
            target: "_blank",
            rel: "noopener",
            "aria-label": "Open in Community Plugins"
          }
        });
        this.registerListener(updateLink, "click", (event) => {
          event.preventDefault();
          window.open(versionInfo.updateUrl, "_blank");
          new import_obsidian52.Notice(
            "Opening SystemSculpt AI in Community Plugins...\n\nIf nothing happens, please update manually via Settings \u2192 Community plugins",
            1e4
          );
        });
      }
    }
  }
  // Override hide method to clean up event listeners
  hide() {
    const activeContent = this.containerEl.querySelector(".systemsculpt-tab-content.is-active");
    if (activeContent && activeContent.cleanup) {
      activeContent.cleanup();
      activeContent.cleanup = null;
    }
    this.removeAllListeners();
    if (this.contentMutationObserver) {
      this.contentMutationObserver.disconnect();
      this.contentMutationObserver = null;
    }
    super.hide();
  }
  /**
   * Build an index of all `.setting-item` elements across tabs for fast search
   */
  activateTab(tabId) {
    if (!this.tabContainerEl || !this.contentContainerEl) {
      return;
    }
    const targetPanel = this.contentContainerEl.querySelector(`.systemsculpt-tab-content[data-tab="${tabId}"]`);
    const activePanel = this.contentContainerEl.querySelector(".systemsculpt-tab-content.is-active");
    if (activePanel && activePanel !== targetPanel && typeof (activePanel == null ? void 0 : activePanel.cleanup) === "function") {
      try {
        activePanel.cleanup();
      } catch (_) {
      }
    }
    this.activeTabId = tabId;
    Array.from(this.tabContainerEl.querySelectorAll("button[data-tab]")).forEach((button) => {
      const el = button;
      if (el.dataset.tab === tabId) {
        el.addClass("mod-active", "mod-cta");
      } else {
        el.removeClass("mod-active", "mod-cta");
      }
    });
    Array.from(this.contentContainerEl.querySelectorAll(".systemsculpt-tab-content")).forEach((panel) => {
      const el = panel;
      if (el.dataset.tab === tabId) {
        el.addClass("is-active");
        el.toggle(true);
      } else {
        el.removeClass("is-active");
        el.toggle(false);
      }
    });
  }
  /**
   * Build an index of all `.setting-item` elements across tabs for fast search
   */
  buildSettingsIndex() {
    this.allSettingsIndex = [];
    if (!this.contentContainerEl) return;
    this.allSettingsIndex = buildSettingsIndexFromRoot(this.contentContainerEl, this.tabsDef);
  }
  /**
   * Handle search input with debounce
   */
  handleSearchInput() {
    if (!this.searchInputEl) return;
    const query = this.searchInputEl.value.trim();
    if (this.debounceTimer) {
      clearTimeout(this.debounceTimer);
    }
    this.debounceTimer = setTimeout(() => {
      if (query.length === 0) {
        this.exitSearchMode();
      } else {
        this.enterSearchMode(query);
      }
    }, 200);
  }
  /**
   * Enter search mode: hide tabs, show results
   */
  enterSearchMode(query) {
    if (!this.tabContainerEl || !this.contentContainerEl || !this.searchResultsContainerEl) return;
    this.tabContainerEl.toggle(false);
    Array.from(this.contentContainerEl.querySelectorAll(".systemsculpt-tab-content")).forEach((panel) => panel.toggle(false));
    this.renderSearchResults(query);
    this.searchResultsContainerEl.toggle(true);
  }
  /**
   * Exit search mode: show tabs and active content, hide results
   */
  exitSearchMode() {
    if (!this.tabContainerEl || !this.contentContainerEl || !this.searchResultsContainerEl) return;
    this.searchResultsContainerEl.toggle(false);
    this.tabContainerEl.toggle(true);
    this.activateTab(this.activeTabId);
  }
  /**
   * Render search results list
   */
  renderSearchResults(query) {
    if (!this.searchResultsContainerEl) return;
    const q = query.toLowerCase();
    const matches = this.allSettingsIndex.filter(
      (item) => item.title.toLowerCase().includes(q) || item.description.toLowerCase().includes(q)
    );
    this.searchResultsContainerEl.empty();
    const header = this.searchResultsContainerEl.createDiv({ cls: "ss-search-header" });
    header.createSpan({ text: `Search results (${matches.length})`, cls: "ss-search-count" });
    if (matches.length === 0) {
      this.searchResultsContainerEl.createDiv({ cls: "ss-search-empty", text: "No settings match your search." });
      return;
    }
    for (const match of matches) {
      const row = this.searchResultsContainerEl.createDiv({ cls: "ss-search-result" });
      row.createDiv({ cls: "ss-search-title", text: match.title || "(Untitled setting)" });
      if (match.description) {
        row.createDiv({ cls: "ss-search-desc", text: match.description });
      }
      const isAdvancedOnly = !this.tabsDef.find((tab) => tab.id === match.tabId);
      row.createDiv({
        cls: "ss-search-tab",
        text: isAdvancedOnly ? `${match.tabLabel} \u2022 Requires Advanced` : match.tabLabel
      });
      row.addEventListener("click", () => this.navigateToSetting(match.tabId, match.element));
    }
  }
  /**
   * Activate the tab and scroll to the target setting element
   */
  navigateToSetting(tabId, element) {
    if (!this.tabContainerEl || !this.contentContainerEl) return;
    this.exitSearchMode();
    if (this.searchInputEl) this.searchInputEl.value = "";
    const targetButton = this.tabContainerEl.querySelector(`button[data-tab="${tabId}"]`);
    if (!targetButton) {
      if (this.plugin.settings.settingsMode !== "advanced") {
        this.plugin.getSettingsManager().updateSettings({ settingsMode: "advanced" }).then(() => {
          this.display();
          setTimeout(() => {
            var _a;
            const newBtn = (_a = this.tabContainerEl) == null ? void 0 : _a.querySelector(`button[data-tab="${tabId}"]`);
            newBtn == null ? void 0 : newBtn.click();
          }, 120);
        });
      }
      return;
    }
    this.activateTab(tabId);
    setTimeout(() => {
      try {
        element.scrollIntoView({ behavior: "smooth", block: "center" });
        element.addClass("ss-search-highlight");
        setTimeout(() => element.removeClass("ss-search-highlight"), 1200);
      } catch (e) {
      }
    }, 50);
  }
};

// src/services/RecorderService.ts
var import_obsidian93 = require("obsidian");

// src/modals/AudioTranscriptionModal.ts
var import_obsidian54 = require("obsidian");

// src/services/TranscriptionService.ts
var import_obsidian53 = require("obsidian");
init_PlatformContext();
init_SystemSculptService();
init_errorHandling();

// src/services/AudioResampler.ts
var AudioResampler = class {
  constructor() {
    this.audioContext = null;
  }
  /**
   * Resample audio buffer to target sample rate
   * @param arrayBuffer The original audio file as ArrayBuffer
   * @param targetSampleRate The desired sample rate (e.g., 16000, 48000)
   * @param mimeType The original MIME type
   * @returns Resampled audio as ArrayBuffer
   */
  async resampleAudio(arrayBuffer, targetSampleRate, mimeType) {
    if (!this.audioContext || this.audioContext.sampleRate !== targetSampleRate) {
      this.audioContext = new AudioContext({ sampleRate: targetSampleRate });
    }
    try {
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer.slice(0));
      if (audioBuffer.sampleRate === targetSampleRate) {
        return { buffer: arrayBuffer, actualSampleRate: targetSampleRate };
      }
      const offlineContext = new OfflineAudioContext(
        audioBuffer.numberOfChannels,
        Math.floor(audioBuffer.duration * targetSampleRate),
        targetSampleRate
      );
      const source = offlineContext.createBufferSource();
      source.buffer = audioBuffer;
      source.connect(offlineContext.destination);
      source.start(0);
      const resampledBuffer = await offlineContext.startRendering();
      const wavArrayBuffer = this.audioBufferToWav(resampledBuffer);
      return {
        buffer: wavArrayBuffer,
        actualSampleRate: resampledBuffer.sampleRate
      };
    } catch (error) {
      throw new Error(`Failed to resample audio: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Convert AudioBuffer to WAV format
   * Based on https://www.russellgood.com/how-to-convert-audiobuffer-to-audio-file/
   */
  audioBufferToWav(buffer) {
    const length = buffer.length * buffer.numberOfChannels * 2 + 44;
    const arrayBuffer = new ArrayBuffer(length);
    const view = new DataView(arrayBuffer);
    const channels = [];
    let offset = 0;
    let pos = 0;
    const setUint16 = (data) => {
      view.setUint16(pos, data, true);
      pos += 2;
    };
    const setUint32 = (data) => {
      view.setUint32(pos, data, true);
      pos += 4;
    };
    setUint32(1179011410);
    setUint32(length - 8);
    setUint32(1163280727);
    setUint32(544501094);
    setUint32(16);
    setUint16(1);
    setUint16(buffer.numberOfChannels);
    setUint32(buffer.sampleRate);
    setUint32(buffer.sampleRate * 2 * buffer.numberOfChannels);
    setUint16(buffer.numberOfChannels * 2);
    setUint16(16);
    setUint32(1635017060);
    setUint32(length - pos - 4);
    const volume = 0.8;
    for (let i = 0; i < buffer.numberOfChannels; i++) {
      channels.push(buffer.getChannelData(i));
    }
    while (pos < length) {
      for (let i = 0; i < buffer.numberOfChannels; i++) {
        const sample = Math.max(-1, Math.min(1, channels[i][offset]));
        const val = sample < 0 ? sample * 32768 : sample * 32767;
        view.setInt16(pos, val * volume, true);
        pos += 2;
      }
      offset++;
    }
    return arrayBuffer;
  }
  /**
   * Check if audio needs resampling based on format and current sample rate
   */
  async checkNeedsResampling(arrayBuffer, mimeType, targetSampleRate) {
    try {
      if (!this.audioContext) {
        this.audioContext = new AudioContext();
      }
      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer.slice(0));
      const needsResampling = audioBuffer.sampleRate !== targetSampleRate;
      return {
        needsResampling,
        currentSampleRate: audioBuffer.sampleRate
      };
    } catch (error) {
      return { needsResampling: true };
    }
  }
  /**
   * Clean up resources
   */
  dispose() {
    if (this.audioContext && this.audioContext.state !== "closed") {
      this.audioContext.close();
      this.audioContext = null;
    }
  }
};

// src/services/TranscriptionService.ts
var SUPPORTED_AUDIO_EXTENSIONS = ["wav", "m4a", "webm", "ogg", "mp3"];
var MIME_TYPE_MAP = {
  wav: "audio/wav",
  m4a: "audio/mp4",
  webm: "audio/webm",
  ogg: "audio/ogg;codecs=opus",
  mp3: "audio/mpeg"
};
var MAX_FILE_SIZE2 = 2 * 1024 * 1024 * 1024;
var EXPECTED_SAMPLE_RATES = {
  wav: 16e3,
  m4a: 16e3,
  mp3: 16e3,
  webm: 48e3,
  ogg: 16e3
};
var TranscriptionService = class _TranscriptionService {
  // Process uploads one at a time to avoid rate limiting
  constructor(plugin) {
    this.isTranscribing = false;
    this.retryCount = 0;
    this.maxRetries = 2;
    // Maximum of 2 retries (3 attempts total)
    this.retryDelay = 5e3;
    this.uploadQueue = [];
    this.activeUploads = 0;
    this.maxConcurrentUploads = 1;
    this.plugin = plugin;
    this.app = plugin.app;
    this.sculptService = SystemSculptService.getInstance(plugin);
    this.platform = PlatformContext.get();
    this.audioResampler = new AudioResampler();
  }
  /**
   * Build a multipart/form-data request body from form fields.
   * Returns a Uint8Array suitable as a Request body along with the boundary string.
   */
  async buildMultipartBody(formFields, boundary) {
    const encoder = new TextEncoder();
    const parts = [];
    for (const field of formFields) {
      parts.push(encoder.encode(`--${boundary}\r
`));
      if (field.value instanceof Blob) {
        const contentType = field.value.type || "application/octet-stream";
        const filename = field.filename || "file";
        parts.push(
          encoder.encode(
            `Content-Disposition: form-data; name="${field.name}"; filename="${filename}"\r
`
          )
        );
        parts.push(encoder.encode(`Content-Type: ${contentType}\r
`));
        parts.push(encoder.encode("\r\n"));
        parts.push(new Uint8Array(await field.value.arrayBuffer()));
        parts.push(encoder.encode("\r\n"));
      } else {
        parts.push(
          encoder.encode(
            `Content-Disposition: form-data; name="${field.name}"\r
`
          )
        );
        parts.push(encoder.encode("\r\n"));
        parts.push(encoder.encode(String(field.value)));
        parts.push(encoder.encode("\r\n"));
      }
    }
    parts.push(encoder.encode(`--${boundary}--\r
`));
    const totalSize = parts.reduce((sum, p) => sum + p.length, 0);
    const body = new Uint8Array(totalSize);
    let offset = 0;
    for (const p of parts) {
      body.set(p, offset);
      offset += p.length;
    }
    return body;
  }
  /**
   * Parse an NDJSON text payload by scanning line-by-line and returning the last JSON object
   * that contains either { text } or { error } while surfacing progress callbacks.
   */
  parseNdjsonText(rawText, onProgress) {
    const lines = rawText.trim().split("\n");
    let finalResponse = null;
    for (const line of lines) {
      const trimmed = line.trim();
      if (!trimmed) continue;
      try {
        const obj = JSON.parse(trimmed);
        if (obj && obj.progress_update && typeof onProgress === "function") {
          const p = Number(obj.progress_update.progress);
          const s = String(obj.progress_update.status || "");
          if (!Number.isNaN(p)) onProgress(p, s);
        }
        if (obj && (obj.text || obj.error)) {
          finalResponse = obj;
        }
      } catch (e) {
      }
    }
    return finalResponse != null ? finalResponse : {};
  }
  /**
   * Stream and parse an NDJSON response from fetch, emitting progress as it arrives.
   * Returns the last JSON object with a text/error field.
   */
  async parseNdjsonStream(response, onProgress) {
    if (!response.body) {
      const text = await response.text();
      return this.parseNdjsonText(text, onProgress);
    }
    const reader = response.body.getReader();
    const decoder = new TextDecoder();
    let buffer = "";
    let finalResponse = null;
    while (true) {
      const { done, value } = await reader.read();
      if (done) break;
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split("\n");
      buffer = lines.pop() || "";
      for (const line of lines) {
        const trimmed = line.trim();
        if (!trimmed) continue;
        try {
          const obj = JSON.parse(trimmed);
          if (obj && obj.progress_update && typeof onProgress === "function") {
            const p = Number(obj.progress_update.progress);
            const s = String(obj.progress_update.status || "");
            if (!Number.isNaN(p)) onProgress(p, s);
          }
          if (obj && (obj.text || obj.error)) {
            finalResponse = obj;
          }
        } catch (e) {
        }
      }
    }
    const tail = buffer.trim();
    if (tail) {
      try {
        const obj = JSON.parse(tail);
        if (obj && (obj.text || obj.error)) finalResponse = obj;
      } catch (e) {
      }
    }
    return finalResponse != null ? finalResponse : {};
  }
  static getInstance(plugin) {
    if (!_TranscriptionService.instance) {
      _TranscriptionService.instance = new _TranscriptionService(plugin);
    }
    return _TranscriptionService.instance;
  }
  async parseErrorResponse(response) {
    try {
      const data = await response.json();
      if (data.error) {
        if (typeof data.error === "string") {
          return { message: data.error, data };
        }
        if (data.error.message) {
          return { message: data.error.message, data };
        }
        return { message: JSON.stringify(data.error), data };
      }
      return { message: response.statusText, data };
    } catch (e) {
      return { message: response.statusText };
    }
  }
  /**
   * Transcribe an audio file
   * @param file The audio file to transcribe
   * @param blob The audio file blob
   * @param context Transcription context
   * @returns Promise resolving to the transcription text
   */
  async transcribeAudio(file, blob, context) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const requestId = `req_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
    const isCustom = this.plugin.settings.transcriptionProvider === "custom";
    const customEndpoint = isCustom ? (this.plugin.settings.customTranscriptionEndpoint || "").toLowerCase() : "";
    const isGroqCustom = isCustom && customEndpoint.includes("groq.com");
    const GROQ_SIZE_LIMIT_BYTES = 25 * 1024 * 1024;
    const mustProxyLargeGroq = isGroqCustom && blob.size > GROQ_SIZE_LIMIT_BYTES;
    let endpoint;
    let headers = {};
    const formFields = [];
    if (mustProxyLargeGroq || !isCustom) {
      endpoint = `${this.sculptService.baseUrl}/audio/transcriptions`;
      headers["Content-Type"] = `multipart/form-data; boundary=`;
      if (this.plugin.settings.licenseKey) headers["x-license-key"] = this.plugin.settings.licenseKey;
      formFields.push({ name: "file", value: blob, filename: file.name });
      formFields.push({ name: "requestId", value: requestId });
      if (context == null ? void 0 : context.timestamped) formFields.push({ name: "timestamped", value: "true" });
    } else {
      endpoint = this.plugin.settings.customTranscriptionEndpoint;
      if (this.plugin.settings.customTranscriptionApiKey) {
        headers["Authorization"] = `Bearer ${this.plugin.settings.customTranscriptionApiKey}`;
        if (endpoint.toLowerCase().includes("groq.com")) {
          headers["X-Request-ID"] = `obsidian-client-${Date.now()}-${Math.random().toString(36).substring(2, 8)}`;
          headers["Accept"] = "application/json";
        }
      }
      headers["Content-Type"] = `multipart/form-data; boundary=`;
      if (isGroqCustom) {
        const fileName = blob.type.includes("webm") ? "recording.webm" : blob.type.includes("mp4") ? "recording.m4a" : "recording.wav";
        const mimeType = blob.type || (fileName.endsWith(".webm") ? "audio/webm" : fileName.endsWith(".m4a") ? "audio/mp4" : fileName.endsWith(".wav") ? "audio/wav" : "audio/mpeg");
        const fileBlob = new Blob([await blob.arrayBuffer()], { type: mimeType });
        formFields.push({ name: "file", value: fileBlob, filename: fileName });
        formFields.push({ name: "model", value: this.plugin.settings.customTranscriptionModel || "whisper-large-v3" });
        if (context == null ? void 0 : context.timestamped) {
          formFields.push({ name: "response_format", value: "verbose_json" });
          formFields.push({ name: "timestamp_granularities[]", value: "segment" });
        } else {
          formFields.push({ name: "response_format", value: "text" });
        }
        formFields.push({ name: "language", value: "en" });
      } else {
        formFields.push({ name: "file", value: blob, filename: file.name });
        formFields.push({ name: "model", value: this.plugin.settings.customTranscriptionModel || "whisper-1" });
        formFields.push({ name: "requestId", value: requestId });
        if (context == null ? void 0 : context.timestamped) formFields.push({ name: "timestamped", value: "true" });
      }
    }
    const boundary = "WebKitFormBoundary" + Math.random().toString(36).substring(2, 15);
    const formDataArray = await this.buildMultipartBody(formFields, boundary);
    const requestBodyBuffer = formDataArray.buffer;
    headers["Content-Type"] = `multipart/form-data; boundary=${boundary}`;
    let retryCount = 0;
    let lastError = null;
    while (retryCount <= this.maxRetries) {
      const decoder = new TextDecoder("utf-8", { fatal: false });
      const firstBytes = formDataArray.slice(0, 300);
      const lastBytes = formDataArray.slice(-200);
      const formDataPreview = {
        boundary,
        totalSize: formDataArray.length,
        formDataStart: decoder.decode(firstBytes),
        formDataEnd: decoder.decode(lastBytes),
        fieldCount: formFields.length,
        fields: formFields.map((f) => ({ name: f.name, type: f.value instanceof Blob ? "Blob" : "string", filename: f.filename }))
      };
      const currentFormDataVersion = "v4.0-platform-context";
      try {
        const retryText = retryCount > 0 ? `Retry ${retryCount}/${this.maxRetries}: ` : "";
        (_a = context == null ? void 0 : context.onProgress) == null ? void 0 : _a.call(context, 10, `${retryText}Uploading audio...`);
        (_b = context == null ? void 0 : context.onProgress) == null ? void 0 : _b.call(context, 30, `${retryText}Transcribing audio...`);
        const transportOptions = { endpoint };
        const preferredTransport = this.platform.preferredTransport(transportOptions);
        const canStream = this.platform.supportsStreaming(transportOptions);
        let response;
        if (preferredTransport === "requestUrl") {
          const transportResponse = await (0, import_obsidian53.requestUrl)({
            url: endpoint,
            method: "POST",
            headers: { ...headers },
            body: requestBodyBuffer,
            throw: false
          });
          let responseBody;
          const responseHeaders = new Headers();
          if (transportResponse.headers && transportResponse.headers["content-type"]) {
            responseHeaders.set("content-type", transportResponse.headers["content-type"]);
          }
          if (transportResponse.text) {
            responseBody = transportResponse.text;
          } else if (transportResponse.json) {
            responseBody = JSON.stringify(transportResponse.json);
            responseHeaders.set("content-type", "application/json");
          } else if (transportResponse.arrayBuffer) {
            const decoder2 = new TextDecoder();
            responseBody = decoder2.decode(new Uint8Array(transportResponse.arrayBuffer));
          } else {
            responseBody = "";
          }
          const fallbackContentType = ((_c = transportResponse.headers) == null ? void 0 : _c["content-type"]) || "";
          if (fallbackContentType.includes("application/x-ndjson") || responseBody.includes("\n{")) {
            const finalResponse = this.parseNdjsonText(responseBody, context == null ? void 0 : context.onProgress);
            responseBody = JSON.stringify(finalResponse || {});
            responseHeaders.set("content-type", "application/json");
          }
          response = new Response(responseBody, {
            status: transportResponse.status || 500,
            statusText: transportResponse.status >= 200 && transportResponse.status < 300 ? "OK" : "Error",
            headers: responseHeaders
          });
        } else {
          response = await fetch(endpoint, {
            method: "POST",
            headers,
            body: requestBodyBuffer
          });
        }
        const contentType = response.headers.get("content-type") || "";
        if (!response.ok) {
          let rawResponseText = "";
          try {
            rawResponseText = await response.text();
          } catch (e) {
          }
          let errorMessage = `HTTP ${response.status}`;
          let errorToLog;
          const additionalLogInfo = {
            formDataVersion: currentFormDataVersion,
            // Use updated version
            endpoint,
            status: response.status,
            statusText: response.statusText,
            headers: contentType ? { "content-type": contentType } : {},
            retryCount: retryCount + 1,
            provider: this.plugin.settings.transcriptionProvider,
            formDataDebug: formDataPreview,
            // formDataPreview is defined above
            rawResponseText: rawResponseText ? rawResponseText.substring(0, 1e3) + (rawResponseText.length > 1e3 ? "..." : "") : "N/A"
          };
          try {
            const errorData = JSON.parse(rawResponseText || "{}");
            if ((_d = errorData == null ? void 0 : errorData.error) == null ? void 0 : _d.message) {
              errorMessage = errorData.error.message;
            } else if (errorData == null ? void 0 : errorData.error) {
              errorMessage = typeof errorData.error === "string" ? errorData.error : JSON.stringify(errorData.error);
            } else if (errorData == null ? void 0 : errorData.message) {
              errorMessage = errorData.message;
            }
            errorToLog = new Error(errorMessage);
            additionalLogInfo.parsedErrorData = errorData;
          } catch (jsonParseError) {
            const e = jsonParseError instanceof Error ? jsonParseError : new Error(String(jsonParseError));
            errorMessage = `Failed to parse server error response as JSON (HTTP ${response.status}). Parser error: ${e.message}`;
            errorToLog = new Error(errorMessage);
            additionalLogInfo.jsonParsingError = e.message;
          }
          errorToLog.additionalInfo = additionalLogInfo;
          await logMobileError("TranscriptionService", `API Error (HTTP ${response.status}) on attempt ${retryCount + 1}`, errorToLog, additionalLogInfo);
          throw errorToLog;
        }
        let rawResponseTextFor200 = "";
        let responseData;
        try {
          if (contentType.includes("application/x-ndjson") && canStream) {
            responseData = await this.parseNdjsonStream(response, context == null ? void 0 : context.onProgress);
          } else {
            rawResponseTextFor200 = await response.text();
            if (contentType.includes("application/x-ndjson")) {
              responseData = this.parseNdjsonText(rawResponseTextFor200, context == null ? void 0 : context.onProgress);
            } else {
              responseData = JSON.parse(rawResponseTextFor200 || "{}");
            }
          }
        } catch (jsonParseError) {
          const e = jsonParseError instanceof Error ? jsonParseError : new Error(String(jsonParseError));
          let errorMessage = e.message;
          if (contentType.includes("application/x-ndjson") && e.message.includes("Unexpected non-whitespace character after JSON")) {
            errorMessage = `NDJSON parsing failed. The server returned streaming JSON but it couldn't be processed properly. This might be due to response format incompatibility.`;
          } else if (!contentType.includes("application/x-ndjson") && e.name === "SyntaxError") {
            errorMessage = `HTTP 200 but failed to parse response as JSON. Parser error: ${e.message}`;
          }
          const errorToLog = new Error(errorMessage);
          const additionalLogInfo = {
            formDataVersion: currentFormDataVersion,
            endpoint,
            status: response.status,
            headers: response.headers,
            retryCount: retryCount + 1,
            provider: this.plugin.settings.transcriptionProvider,
            formDataDebug: formDataPreview,
            rawResponseText: rawResponseTextFor200 ? rawResponseTextFor200.substring(0, 1e3) + (rawResponseTextFor200.length > 1e3 ? "..." : "") : "N/A",
            jsonParsingError: e.message,
            contentType,
            location: "transcribeAudio - HTTP 200 JSON parse failed"
          };
          errorToLog.additionalInfo = additionalLogInfo;
          await logMobileError(
            "TranscriptionService.transcribeAudio",
            `HTTP 200 with unparseable JSON on attempt ${retryCount + 1}. Error: ${e.message}`,
            errorToLog,
            additionalLogInfo
          );
          throw errorToLog;
        }
        (_e = context == null ? void 0 : context.onProgress) == null ? void 0 : _e.call(context, 70, `${retryText}Processing response...`);
        let transcriptionText = "";
        if (this.plugin.settings.transcriptionProvider === "custom" && this.plugin.settings.customTranscriptionEndpoint.includes("groq.com")) {
          if ((context == null ? void 0 : context.timestamped) && responseData.segments) {
            transcriptionText = responseData.segments.map((segment, index) => {
              const start = this.formatTimestamp(segment.start);
              const end = this.formatTimestamp(segment.end);
              return `${index + 1}
${start} --> ${end}
${segment.text.trim()}
`;
            }).join("\n");
          } else {
            transcriptionText = responseData.text || "";
          }
        } else {
          if (typeof responseData === "string") {
            transcriptionText = responseData;
          } else if (responseData.text) {
            transcriptionText = responseData.text;
          } else if ((_f = responseData.data) == null ? void 0 : _f.text) {
            transcriptionText = responseData.data.text;
          } else {
            throw new Error("Invalid response format: no transcription text found");
          }
        }
        if (!(transcriptionText == null ? void 0 : transcriptionText.trim())) {
          throw new Error("Empty transcription text received");
        }
        (_g = context == null ? void 0 : context.onProgress) == null ? void 0 : _g.call(context, 100, "Transcription complete!");
        return transcriptionText.trim();
      } catch (error) {
        let currentError = error instanceof Error ? error : new Error(String(error));
        if ((error == null ? void 0 : error.additionalInfo) && !currentError.additionalInfo) {
          currentError.additionalInfo = error.additionalInfo;
        }
        lastError = currentError;
        const isFinalAttempt = retryCount >= this.maxRetries;
        if (isFinalAttempt) {
          const finalLogAdditionalInfo = {
            finalAttempt: retryCount + 1,
            maxRetries: this.maxRetries,
            endpoint: this.plugin.settings.transcriptionProvider === "custom" ? this.plugin.settings.customTranscriptionEndpoint : `${this.sculptService.baseUrl}/audio/transcriptions`,
            fileSize: `${Math.round(blob.size / 1024)}KB`,
            provider: this.plugin.settings.transcriptionProvider,
            ...lastError.additionalInfo || {}
          };
          finalLogAdditionalInfo.formDataVersion = ((_h = lastError.additionalInfo) == null ? void 0 : _h.formDataVersion) || currentFormDataVersion;
          await logMobileError("TranscriptionService", `All ${this.maxRetries + 1} attempts failed. Final error: ${lastError.message}`, lastError, finalLogAdditionalInfo);
        } else {
        }
        const messageForRetryCheck = lastError.message.toLowerCase();
        const is500Error = messageForRetryCheck.includes("500") || messageForRetryCheck.includes("internal_error") || messageForRetryCheck.includes("server error") || messageForRetryCheck.includes("failed to parse server error response as json");
        const isNetworkError = messageForRetryCheck.includes("network error") || messageForRetryCheck.includes("connectivity") || messageForRetryCheck.includes("offline") || messageForRetryCheck.includes("request failed") || messageForRetryCheck.includes("connection was lost");
        const shouldRetry = (is500Error || isNetworkError) && retryCount < this.maxRetries;
        if (shouldRetry) {
          retryCount++;
          const backoffMs = 1e3 * Math.pow(2, retryCount - 1);
          await new Promise((resolve) => setTimeout(resolve, backoffMs));
        } else {
          throw lastError;
        }
      }
    }
    throw lastError || new Error("Unknown transcription error");
  }
  /**
   * Format timestamp for SRT format
   */
  formatTimestamp(seconds) {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = Math.floor(seconds % 60);
    const ms = Math.floor(seconds % 1 * 1e3);
    return `${hours.toString().padStart(2, "0")}:${minutes.toString().padStart(2, "0")}:${secs.toString().padStart(2, "0")},${ms.toString().padStart(3, "0")}`;
  }
  /**
   * Find the longest common suffix/prefix between two strings
   * @param str1 First string
   * @param str2 Second string
   * @param maxOverlapLength Maximum overlap length to consider
   * @returns The length of the overlap
   */
  findOverlap(str1, str2, maxOverlapLength = 150) {
    const searchLength = Math.min(str1.length, str2.length, maxOverlapLength);
    const normalizedStr1 = str1.toLowerCase().trim();
    const normalizedStr2 = str2.toLowerCase().trim();
    for (let i = searchLength; i > 10; i--) {
      const suffix = normalizedStr1.slice(-i);
      const prefix = normalizedStr2.slice(0, i);
      if (suffix === prefix) {
        return i;
      }
    }
    for (let i = Math.min(100, searchLength); i > 20; i--) {
      const suffix = normalizedStr1.slice(-i);
      const prefix = normalizedStr2.slice(0, i);
      const suffixWords = suffix.split(/\s+/);
      const prefixWords = prefix.split(/\s+/);
      if (suffixWords.length < 3 || prefixWords.length < 3) continue;
      let matchCount = 0;
      for (const word of suffixWords) {
        if (word.length > 2 && prefixWords.includes(word)) {
          matchCount++;
        }
      }
      const similarity = matchCount / suffixWords.length;
      if (similarity > 0.7) {
        for (let j = 0; j < prefixWords.length; j++) {
          if (prefixWords[j].length > 2 && suffixWords.includes(prefixWords[j])) {
            const approxPos = normalizedStr2.indexOf(prefixWords.slice(j).join(" "));
            if (approxPos >= 0) {
              return approxPos;
            }
          }
        }
        return prefix.length;
      }
    }
    return 0;
  }
  /**
   * Check if text contains timestamps in SRT or VTT format
   * @param text The text to check
   * @returns True if the text contains timestamps
   */
  hasTimestamps(text) {
    const srtPattern = /\d{2}:\d{2}:\d{2},\d{3}\s+-->\s+\d{2}:\d{2}:\d{2},\d{3}/;
    const vttPattern = /\d{2}:\d{2}:\d{2}\.\d{3}\s+-->\s+\d{2}:\d{2}:\d{2}\.\d{3}/;
    return srtPattern.test(text) || vttPattern.test(text);
  }
  /**
   * Parse timestamps from text in SRT or VTT format
   * @param text The text containing timestamps
   * @returns Array of parsed timestamps with their positions
   */
  parseTimestamps(text) {
    const result = [];
    const timestampRegex = /(\d{2}:\d{2}:\d{2}[,\.]\d{3})\s+-->\s+(\d{2}:\d{2}:\d{2}[,\.]\d{3})/g;
    let match;
    while ((match = timestampRegex.exec(text)) !== null) {
      const startTime = match[1];
      const endTime = match[2];
      const startSeconds = this.timestampToSeconds(startTime);
      const endSeconds = this.timestampToSeconds(endTime);
      result.push({
        index: match.index,
        startTime,
        endTime,
        startSeconds,
        endSeconds
      });
    }
    return result;
  }
  /**
   * Convert a timestamp string to seconds
   * @param timestamp Timestamp in format 00:00:00,000 or 00:00:00.000
   * @returns Time in seconds
   */
  timestampToSeconds(timestamp) {
    const normalizedTimestamp = timestamp.replace(",", ".");
    const parts = normalizedTimestamp.split(":");
    const hours = parseInt(parts[0], 10);
    const minutes = parseInt(parts[1], 10);
    const secondsParts = parts[2].split(".");
    const seconds = parseInt(secondsParts[0], 10);
    const milliseconds = secondsParts.length > 1 ? parseInt(secondsParts[1], 10) : 0;
    return hours * 3600 + minutes * 60 + seconds + milliseconds / 1e3;
  }
  /**
   * Convert seconds to a timestamp string
   * @param seconds Time in seconds
   * @param format Format to use ('srt' or 'vtt')
   * @returns Formatted timestamp string
   */
  secondsToTimestamp(seconds, format = "srt") {
    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor(seconds % 3600 / 60);
    const secs = Math.floor(seconds % 60);
    const milliseconds = Math.floor(seconds % 1 * 1e3);
    const hoursStr = hours.toString().padStart(2, "0");
    const minutesStr = minutes.toString().padStart(2, "0");
    const secsStr = secs.toString().padStart(2, "0");
    const millisecondsStr = milliseconds.toString().padStart(3, "0");
    const separator = format === "srt" ? "," : ".";
    return `${hoursStr}:${minutesStr}:${secsStr}${separator}${millisecondsStr}`;
  }
  /**
   * Adjust timestamps in a text by adding an offset
   * @param text Text containing timestamps
   * @param offsetSeconds Offset to add to timestamps in seconds
   * @returns Text with adjusted timestamps
   */
  adjustTimestamps(text, offsetSeconds) {
    if (offsetSeconds === 0) {
      return text;
    }
    const timestamps = this.parseTimestamps(text);
    if (timestamps.length === 0) {
      return text;
    }
    const format = text.includes(",") ? "srt" : "vtt";
    const separator = format === "srt" ? "," : ".";
    timestamps.sort((a, b) => b.index - a.index);
    let result = text;
    for (const timestamp of timestamps) {
      const newStartSeconds = Math.max(0, timestamp.startSeconds + offsetSeconds);
      const newEndSeconds = Math.max(0, timestamp.endSeconds + offsetSeconds);
      const newStartTime = this.secondsToTimestamp(newStartSeconds, format);
      const newEndTime = this.secondsToTimestamp(newEndSeconds, format);
      const originalTimestamp = `${timestamp.startTime} --> ${timestamp.endTime}`;
      const newTimestamp = `${newStartTime} --> ${newEndTime}`;
      result = result.substring(0, timestamp.index) + newTimestamp + result.substring(timestamp.index + originalTimestamp.length);
    }
    return result;
  }
  /**
   * Parse SRT formatted text into entries
   * @param text SRT formatted text
   * @returns Array of SRT entries with index, timestamp, and content
   */
  parseSrtEntries(text) {
    const result = [];
    const entries = text.split(/\n\s*\n/).filter((entry) => entry.trim().length > 0);
    for (const entry of entries) {
      const lines = entry.trim().split("\n");
      if (lines.length < 3) continue;
      const entryNumber = parseInt(lines[0], 10);
      if (isNaN(entryNumber)) continue;
      const timestamp = lines[1];
      if (!timestamp.includes("-->")) continue;
      const content = lines.slice(2).join("\n");
      result.push({
        index: text.indexOf(entry),
        entryNumber,
        timestamp,
        content
      });
    }
    return result;
  }
  /**
   * Check if SRT entries are in reverse order (descending numbers)
   * @param entries Array of SRT entries
   * @returns True if entries are in reverse order
   */
  isReversedSrtNumbering(entries) {
    if (entries.length < 2) return false;
    const firstNumber = entries[0].entryNumber;
    const lastNumber = entries[entries.length - 1].entryNumber;
    let isConsistentlyDecreasing = true;
    for (let i = 1; i < entries.length; i++) {
      if (entries[i].entryNumber >= entries[i - 1].entryNumber) {
        isConsistentlyDecreasing = false;
        break;
      }
    }
    return firstNumber > lastNumber && isConsistentlyDecreasing;
  }
  /**
   * Check if SRT entries have unusual numbering (non-sequential, very high numbers, etc.)
   * @param entries Array of SRT entries
   * @returns True if entries have unusual numbering
   */
  hasUnusualSrtNumbering(entries) {
    if (entries.length < 2) return false;
    if (entries[0].entryNumber !== 1) return true;
    const isReversed = this.isReversedSrtNumbering(entries);
    if (isReversed) return true;
    for (let i = 1; i < entries.length; i++) {
      if (entries[i].entryNumber !== entries[i - 1].entryNumber + 1) {
        return true;
      }
    }
    return false;
  }
  /**
   * Renumber SRT entries in text
   * @param text SRT formatted text
   * @param startNumber The number to start from
   * @returns Text with renumbered entries
   */
  renumberSrtEntries(text, startNumber) {
    const entries = this.parseSrtEntries(text);
    if (entries.length === 0) {
      return text;
    }
    const isReversed = this.isReversedSrtNumbering(entries);
    let sortedEntries = [...entries];
    sortedEntries.sort((a, b) => b.index - a.index);
    let result = text;
    for (let i = 0; i < sortedEntries.length; i++) {
      const entry = sortedEntries[i];
      const newEntryNumber = isReversed ? startNumber + (sortedEntries.length - 1 - i) : startNumber + i;
      const originalEntryNumber = entry.entryNumber.toString();
      const newEntryNumberStr = newEntryNumber.toString();
      const entryStart = result.indexOf(entry.timestamp, entry.index) - originalEntryNumber.length - 1;
      if (entryStart >= 0) {
        result = result.substring(0, entryStart) + newEntryNumberStr + result.substring(entryStart + originalEntryNumber.length);
      }
    }
    return result;
  }
  /**
   * Check if text is in SRT format
   * @param text The text to check
   * @returns True if the text is in SRT format
   */
  isSrtFormat(text) {
    const srtPattern = /^\d+\s*\n\d{2}:\d{2}:\d{2},\d{3}\s+-->\s+\d{2}:\d{2}:\d{2},\d{3}/m;
    return srtPattern.test(text);
  }
  /**
   * Merge multiple chunk transcriptions into a single result with overlap detection
   * and timestamp adjustment for timestamped transcriptions
   * @param transcriptions Array of transcription texts
   * @returns Merged transcription text
   */
  mergeTranscriptions(transcriptions) {
    if (transcriptions.length === 0) {
      return "";
    }
    if (transcriptions.length === 1) {
      const isSrt2 = this.isSrtFormat(transcriptions[0]);
      if (isSrt2) {
        const entries = this.parseSrtEntries(transcriptions[0]);
        const isReversed = this.isReversedSrtNumbering(entries);
        const hasUnusual = this.hasUnusualSrtNumbering(entries);
        const firstNumber = entries.length > 0 ? entries[0].entryNumber : 0;
        if (entries.length > 0 && (isReversed || hasUnusual || firstNumber !== 1)) {
          let result = "";
          const sortedEntries = [...entries].sort((a, b) => a.index - b.index);
          for (let i = 0; i < sortedEntries.length; i++) {
            const entry = sortedEntries[i];
            const entryNumber = i + 1;
            if (i > 0) {
              result += "\n\n";
            }
            result += `${entryNumber}
${entry.timestamp}
${entry.content}`;
          }
          return result;
        }
      }
      return transcriptions[0];
    }
    const hasTimestamps = this.hasTimestamps(transcriptions[0]);
    const isSrt = this.isSrtFormat(transcriptions[0]);
    if (hasTimestamps && isSrt) {
      let result = "";
      let allEntries = [];
      for (let i = 0; i < transcriptions.length; i++) {
        const transcription = transcriptions[i];
        const entries = this.parseSrtEntries(transcription);
        if (this.isReversedSrtNumbering(entries)) {
        }
        if (this.hasUnusualSrtNumbering(entries)) {
        }
        entries.forEach((entry) => {
          allEntries.push({
            ...entry,
            chunkIndex: i
          });
        });
      }
      allEntries.sort((a, b) => {
        if (a.chunkIndex !== b.chunkIndex) {
          return a.chunkIndex - b.chunkIndex;
        }
        return a.index - b.index;
      });
      for (let i = 0; i < allEntries.length; i++) {
        const entry = allEntries[i];
        const entryNumber = i + 1;
        if (i > 0) {
          result += "\n\n";
        }
        result += `${entryNumber}
${entry.timestamp}
${entry.content}`;
      }
      return result;
    } else if (hasTimestamps) {
      let result = "";
      for (let i = 0; i < transcriptions.length; i++) {
        const transcription = transcriptions[i];
        if (i > 0) {
          result += "\n\n";
        }
        result += transcription;
      }
      return result;
    } else {
      let result = transcriptions[0];
      for (let i = 1; i < transcriptions.length; i++) {
        const current = transcriptions[i];
        const overlapLength = this.findOverlap(result, current, 300);
        if (overlapLength > 0) {
          result += current.slice(overlapLength);
        } else {
          const lastChar = result.charAt(result.length - 1);
          const endsWithPunctuation = /[.!?]/.test(lastChar);
          const endsWithSpace = /\s/.test(lastChar);
          const firstChar = current.charAt(0);
          const startsWithUppercase = /[A-Z]/.test(firstChar);
          if (endsWithPunctuation) {
            result += " ";
            result += current;
          } else if (endsWithSpace) {
            result += current;
          } else {
            if (startsWithUppercase) {
              result += ". " + current;
            } else {
              result += " " + current;
            }
          }
        }
      }
      return result;
    }
  }
  // Legacy multipart helpers removed. All flows use buildMultipartBody now.
  /**
   * Transcribe an audio file
   * @param file The audio file to transcribe
   * @param context Optional transcription context
   * @returns Promise resolving to the transcription text
   */
  async transcribeFile(file, context) {
    var _a, _b, _c, _d, _e, _f, _g;
    if (this.isTranscribing) {
      throw new Error("Already transcribing a file");
    }
    const extension = file.extension.toLowerCase();
    if (!SUPPORTED_AUDIO_EXTENSIONS.includes(extension)) {
      throw new Error(`Unsupported file type: ${extension}`);
    }
    if (file.stat.size > MAX_FILE_SIZE2) {
      throw new Error(`File too large. Maximum allowed size is ${Math.floor(MAX_FILE_SIZE2 / (1024 * 1024))}MB.`);
    }
    this.isTranscribing = true;
    try {
      if (this.plugin.settings.transcriptionProvider === "systemsculpt" && (!this.plugin.settings.licenseKey || !this.plugin.settings.licenseValid)) {
        throw new Error("A valid SystemSculpt license is required to use the SystemSculpt API for transcription. Please enter a valid license key or switch to a custom transcription provider in the settings.");
      }
      (_a = context == null ? void 0 : context.onProgress) == null ? void 0 : _a.call(context, 0, "Reading audio file...");
      let arrayBuffer;
      try {
        arrayBuffer = await this.plugin.app.vault.readBinary(file);
      } catch (readError) {
        try {
          const fs = require("fs");
          const path = require("path");
          let vaultPath = "";
          if (this.plugin.app.vault.adapter.basePath) {
            vaultPath = this.plugin.app.vault.adapter.basePath;
          } else {
            const errorMatch = readError instanceof Error && readError.message.match(/open '(.+?)'/);
            if (errorMatch && errorMatch[1]) {
              const fullErrorPath = errorMatch[1];
              vaultPath = fullErrorPath.replace(new RegExp(`${file.path}$`), "");
              vaultPath = vaultPath.replace(/\/$/, "");
            }
          }
          if (!vaultPath) {
            throw new Error("Could not determine vault path");
          }
          const absolutePath = path.join(vaultPath, file.path);
          arrayBuffer = await new Promise((resolve, reject) => {
            fs.readFile(absolutePath, (err, data) => {
              if (err) {
                reject(new Error(`Failed to read file directly: ${err.message}`));
                return;
              }
              const arrayCopy = new Uint8Array(data.byteLength);
              arrayCopy.set(data);
              resolve(arrayCopy.buffer);
            });
          });
        } catch (fsError) {
          throw new Error(`Failed to read audio file. Original error: ${readError instanceof Error ? readError.message : String(readError)}`);
        }
      }
      let processedArrayBuffer = arrayBuffer;
      let mimeType = MIME_TYPE_MAP[extension];
      let wasResampled = false;
      const isMobile = this.platform.isMobile();
      const resamplingEnabled = (_b = this.plugin.settings.enableAutoAudioResampling) != null ? _b : true;
      if (this.plugin.settings.transcriptionProvider === "systemsculpt" && !isMobile && resamplingEnabled) {
        const targetSampleRate = EXPECTED_SAMPLE_RATES[extension] || 16e3;
        try {
          (_c = context == null ? void 0 : context.onProgress) == null ? void 0 : _c.call(context, 10, "Checking audio compatibility...");
          const { needsResampling, currentSampleRate } = await this.audioResampler.checkNeedsResampling(
            arrayBuffer,
            mimeType,
            targetSampleRate
          );
          if (needsResampling) {
            (_d = context == null ? void 0 : context.onProgress) == null ? void 0 : _d.call(context, 15, `Converting audio format for optimal processing...`);
            new import_obsidian53.Notice(`Audio needs conversion from ${currentSampleRate}Hz to ${targetSampleRate}Hz. This may take a moment...`, 5e3);
            const startTime = Date.now();
            const resampleResult = await this.audioResampler.resampleAudio(
              arrayBuffer,
              targetSampleRate,
              mimeType
            );
            const resampleTime = Date.now() - startTime;
            processedArrayBuffer = resampleResult.buffer;
            mimeType = "audio/wav";
            wasResampled = true;
            if (resampleTime > 2e3) {
              (_e = context == null ? void 0 : context.onProgress) == null ? void 0 : _e.call(context, 18, "Audio conversion complete!");
            }
          }
        } catch (resampleError) {
          new import_obsidian53.Notice("Audio format conversion failed. Attempting with original file...", 3e3);
        }
      } else if (this.plugin.settings.transcriptionProvider === "systemsculpt" && isMobile) {
        try {
          const { needsResampling, currentSampleRate } = await this.audioResampler.checkNeedsResampling(
            arrayBuffer,
            mimeType,
            EXPECTED_SAMPLE_RATES[extension] || 16e3
          );
          if (needsResampling) {
            new import_obsidian53.Notice(`\u26A0\uFE0F Audio format (${currentSampleRate}Hz) may not be compatible. Consider converting on desktop for best results.`, 7e3);
          }
        } catch (e) {
        }
      }
      const blob = new Blob([processedArrayBuffer], {
        type: mimeType
      });
      (_f = context == null ? void 0 : context.onProgress) == null ? void 0 : _f.call(context, 20, "Uploading audio file...");
      const transcriptionText = await this.queueTranscription(file, blob, context, wasResampled);
      (_g = context == null ? void 0 : context.onProgress) == null ? void 0 : _g.call(context, 100, "Transcription complete!");
      return transcriptionText;
    } catch (error) {
      const catchedError = error instanceof Error ? error : new Error(String(error));
      const existingAdditionalInfo = catchedError.additionalInfo;
      const currentFormDataVersionForCatch = "v2.9-native-fetch-ndjson";
      let finalAdditionalInfoToLog = {
        location: "transcribeFile catch block",
        originalErrorName: catchedError.name,
        formDataVersion: currentFormDataVersionForCatch,
        // Default version if not on error
        provider: this.plugin.settings.transcriptionProvider,
        // Default provider
        file: { name: file.name, path: file.path, size: file.stat.size },
        // File context
        ...existingAdditionalInfo || {}
        // Spread info from error, potentially overwriting defaults if present
      };
      if (existingAdditionalInfo) {
        finalAdditionalInfoToLog.formDataVersion = existingAdditionalInfo.formDataVersion || currentFormDataVersionForCatch;
        finalAdditionalInfoToLog.provider = existingAdditionalInfo.provider || this.plugin.settings.transcriptionProvider;
      }
      await logMobileError(
        "TranscriptionService.transcribeFile",
        `Unhandled error in transcription process: ${catchedError.message}`,
        catchedError,
        finalAdditionalInfoToLog
      );
      new import_obsidian53.Notice(`Transcription failed: ${catchedError.message.substring(0, 120)}... (See debug log)`);
      throw catchedError;
    } finally {
      this.isTranscribing = false;
    }
  }
  /**
   * Queue a transcription request to avoid rate limiting
   */
  async queueTranscription(file, blob, context, wasResampled = false) {
    var _a, _b, _c, _d;
    if (this.activeUploads >= this.maxConcurrentUploads) {
      const waitNotice = new import_obsidian53.Notice(`Another transcription is in progress. Your file will be processed next...`, 0);
      (_a = context == null ? void 0 : context.onProgress) == null ? void 0 : _a.call(context, 20, "Waiting for previous transcription to complete...");
      let waitTime = 0;
      while (this.activeUploads >= this.maxConcurrentUploads) {
        await new Promise((resolve) => setTimeout(resolve, 500));
        waitTime += 500;
        if (waitTime % 2e3 === 0) {
          (_b = context == null ? void 0 : context.onProgress) == null ? void 0 : _b.call(context, 20, `Waiting in queue (${Math.round(waitTime / 1e3)}s)...`);
        }
      }
      waitNotice.hide();
      (_c = context == null ? void 0 : context.onProgress) == null ? void 0 : _c.call(context, 25, "Starting transcription...");
    }
    this.activeUploads++;
    try {
      if (wasResampled) {
        (_d = context == null ? void 0 : context.onProgress) == null ? void 0 : _d.call(context, 30, "Uploading converted audio...");
      }
      return await this.transcribeAudio(file, blob, context);
    } finally {
      this.activeUploads--;
      if (this.uploadQueue.length > 0) {
      }
    }
  }
  unload() {
    if (this.audioResampler) {
      this.audioResampler.dispose();
    }
  }
};

// src/services/PostProcessingService.ts
init_SystemSculptService();
init_modelUtils();
var PostProcessingService = class _PostProcessingService {
  constructor(plugin) {
    this.plugin = plugin;
    this.sculptService = SystemSculptService.getInstance(plugin);
  }
  static getInstance(plugin) {
    if (!_PostProcessingService.instance) {
      _PostProcessingService.instance = new _PostProcessingService(plugin);
    }
    return _PostProcessingService.instance;
  }
  /**
   * Get the model ID to use for post-processing
   * @returns The canonical model ID
   */
  getPostProcessingModelId() {
    var _a;
    const useLatestEverywhere = (_a = this.plugin.settings.useLatestModelEverywhere) != null ? _a : true;
    const isStandardMode = this.plugin.settings.settingsMode !== "advanced";
    let modelId = useLatestEverywhere || isStandardMode ? "" : this.plugin.settings.postProcessingModelId;
    let providerId = useLatestEverywhere || isStandardMode ? "" : this.plugin.settings.postProcessingProviderId;
    if (!modelId || !providerId) {
      const globalDefault = this.plugin.settings.selectedModelId;
      if (globalDefault) {
        const parsedGlobal = parseCanonicalId(globalDefault);
        if (parsedGlobal) {
          modelId = parsedGlobal.modelId;
          providerId = parsedGlobal.providerId;
        }
      }
    }
    modelId = ensureCanonicalId(modelId);
    if (!modelId) {
      throw new Error("Failed to determine a valid model for post-processing.");
    }
    return modelId;
  }
  async processTranscription(text) {
    if (!this.plugin.settings.postProcessingEnabled) {
      return text;
    }
    try {
      const modelId = this.getPostProcessingModelId();
      const messages = [
        {
          role: "system",
          content: this.plugin.settings.postProcessingPrompt,
          message_id: crypto.randomUUID()
        },
        {
          role: "user",
          content: text,
          message_id: crypto.randomUUID()
        }
      ];
      let processedText = "";
      const stream = this.sculptService.streamMessage({
        messages,
        model: modelId
      });
      for await (const event of stream) {
        if (event.type === "content") {
          processedText += event.text;
        }
      }
      return processedText.trim();
    } catch (error) {
      return text;
    }
  }
};

// src/services/TranscriptionProgressManager.ts
var TranscriptionProgressManager = class _TranscriptionProgressManager {
  // Private constructor for singleton pattern
  constructor() {
    // Map of active transcriptions by file path
    this.activeTranscriptions = /* @__PURE__ */ new Map();
  }
  /**
   * Get the singleton instance of TranscriptionProgressManager
   */
  static getInstance() {
    if (!_TranscriptionProgressManager.instance) {
      _TranscriptionProgressManager.instance = new _TranscriptionProgressManager();
    }
    return _TranscriptionProgressManager.instance;
  }
  /**
   * Create a progress handler for a file
   * @param file The file being transcribed
   * @param onProgress The progress callback function
   * @returns A TranscriptionContext with progress handling
   */
  createProgressHandler(file, onProgress) {
    const filePath = file.path;
    this.activeTranscriptions.set(filePath, {
      startTime: Date.now(),
      lastProgress: 0,
      lastStatus: "Starting transcription...",
      detailedInfo: null,
      cleanupTimeout: null
    });
    return {
      type: "note",
      onProgress: (progress, status) => {
        const transcription = this.activeTranscriptions.get(filePath);
        if (transcription) {
          transcription.lastProgress = progress;
          transcription.lastStatus = status;
          if (transcription.cleanupTimeout) {
            clearTimeout(transcription.cleanupTimeout);
            transcription.cleanupTimeout = null;
          }
          let icon = "loader-2";
          let details = null;
          if (progress === 0 && status.includes("Error")) {
            icon = "x-circle";
          } else if (progress === 100) {
            icon = "check-circle";
          } else if (status.includes("Uploading")) {
            icon = "upload";
          } else if (status.includes("Chunk") || status.includes("chunk")) {
            icon = "scissors";
          } else if (status.includes("Transcribing")) {
            icon = "file-audio";
          } else if (status.includes("Process")) {
            icon = "cpu";
          }
          onProgress == null ? void 0 : onProgress(progress, status, icon, details || transcription.detailedInfo || void 0);
          if (progress === 100 || status.includes("Error") || status.includes("Complete")) {
            transcription.detailedInfo = null;
            if (progress === 100) {
              transcription.cleanupTimeout = setTimeout(() => {
                this.activeTranscriptions.delete(filePath);
              }, 2e3);
            }
          }
        }
      }
    };
  }
  /**
   * Handle completion of a transcription
   * @param filePath The path of the transcribed file
   * @param resultPath The path of the result file
   * @param onComplete Optional callback for completion handling
   */
  handleCompletion(filePath, resultPath, onComplete) {
    const transcription = this.activeTranscriptions.get(filePath);
    if (transcription) {
      if (transcription.cleanupTimeout) {
        clearTimeout(transcription.cleanupTimeout);
      }
      transcription.cleanupTimeout = setTimeout(() => {
        this.activeTranscriptions.delete(filePath);
      }, 2e3);
      onComplete == null ? void 0 : onComplete(resultPath);
    }
  }
  /**
   * Clear progress information for a file
   * @param filePath The path of the file to clear
   */
  clearProgress(filePath) {
    const transcription = this.activeTranscriptions.get(filePath);
    if (transcription && transcription.cleanupTimeout) {
      clearTimeout(transcription.cleanupTimeout);
    }
    this.activeTranscriptions.delete(filePath);
  }
};

// src/modals/AudioTranscriptionModal.ts
var PersistentTranscriptionNotice = class extends import_obsidian54.Notice {
  constructor() {
    super("", 0);
    this.closeButton = null;
    this.countdownTimer = null;
    this.countdownInterval = null;
    this.lastProgress = null;
    this.noticeEl.addClass("systemsculpt-transcription-notice");
    const progressContainer = this.noticeEl.createDiv("transcription-progress");
    const statusContainer = progressContainer.createDiv("transcription-status");
    this.statusIcon = statusContainer.createDiv("transcription-status-icon");
    this.statusText = statusContainer.createDiv("transcription-status-text");
    const progressBarContainer = progressContainer.createDiv(
      "transcription-progress-bar-container"
    );
    this.progressBar = progressBarContainer.createDiv(
      "transcription-progress-bar"
    );
    if (!document.getElementById("systemsculpt-transcription-notice-styles")) {
      const style = document.createElement("style");
      style.id = "systemsculpt-transcription-notice-styles";
      style.textContent = `
        .systemsculpt-transcription-notice {
          padding: 12px 16px !important;
          min-width: 280px;
          max-width: 400px;
          transition: all 0.3s ease;
          position: fixed;
          bottom: 30px;
          right: 30px;
          z-index: 1000;
          border-radius: 8px;
          box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
          background-color: var(--background-secondary);
          border: 1px solid var(--background-modifier-border);
        }

        .transcription-progress {
          display: flex;
          flex-direction: column;
          gap: 10px;
        }

        .transcription-status {
          display: flex;
          align-items: center;
          gap: 10px;
          color: var(--text-normal);
        }

        .transcription-status-icon {
          display: flex;
          align-items: center;
          justify-content: center;
          color: var(--text-accent);
          min-width: 20px;
        }

        .transcription-status-text {
          flex: 1;
          font-size: 14px;
          line-height: 1.4;
        }

        .transcription-progress-bar-container {
          width: 100%;
          height: 6px;
          background: var(--background-modifier-border);
          border-radius: 3px;
          overflow: hidden;
          margin-top: 2px;
        }

        .transcription-progress-bar {
          height: 100%;
          background: var(--text-accent);
          border-radius: 3px;
          transition: width 0.3s ease;
          width: 0%;
        }

        .notice-success .transcription-progress-bar {
          background: var(--text-success) !important;
        }

        .notice-error .transcription-progress-bar {
          background: var(--text-error) !important;
        }

        .notice-chunking .transcription-progress-bar {
          background: linear-gradient(90deg, var(--text-accent), var(--text-accent-hover)) !important;
          background-size: 200% 100% !important;
          animation: progress-pulse 2s infinite linear !important;
        }

        .notice-processing .transcription-progress-bar {
          background: linear-gradient(90deg, var(--text-accent-hover), var(--interactive-accent)) !important;
          background-size: 200% 100% !important;
          animation: progress-pulse 1.5s infinite linear !important;
        }

        @keyframes progress-pulse {
          0% { background-position: 0% 50%; }
          100% { background-position: 200% 50%; }
        }

        /* Add a subtle shimmer effect to the status text during processing */
        .notice-processing .transcription-status-text,
        .notice-chunking .transcription-status-text {
          position: relative;
          overflow: hidden;
        }

        .notice-processing .transcription-status-text::after,
        .notice-chunking .transcription-status-text::after {
          content: "";
          position: absolute;
          top: 0;
          left: -100%;
          width: 50%;
          height: 100%;
          background: linear-gradient(
            90deg,
            rgba(255, 255, 255, 0) 0%,
            rgba(255, 255, 255, 0.2) 50%,
            rgba(255, 255, 255, 0) 100%
          );
          animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
          0% { left: -100%; }
          100% { left: 200%; }
        }
      `;
      document.head.appendChild(style);
    }
  }
  updateProgress(progress) {
    this.lastProgress = progress;
    this.progressBar.style.width = `${progress.progress}%`;
    this.statusText.setText(progress.status);
    this.statusIcon.empty();
    (0, import_obsidian54.setIcon)(this.statusIcon, progress.icon);
    this.noticeEl.removeClass("notice-success", "notice-error", "notice-chunking", "notice-processing");
    if (progress.progress === 100) {
      this.noticeEl.addClass("notice-success");
    } else if (progress.progress === 0 && progress.icon === "x-circle") {
      this.noticeEl.addClass("notice-error");
    } else if (progress.status.includes("Chunk") || progress.status.includes("chunk")) {
      this.noticeEl.addClass("notice-chunking");
    } else if (progress.status.includes("Transcribing") || progress.status.includes("Processing")) {
      this.noticeEl.addClass("notice-processing");
    }
  }
  /**
   * Update the notice to show a success state
   * This is used to visually indicate that the transcription is complete
   */
  showSuccessState() {
    this.noticeEl.addClass("notice-success");
    this.statusIcon.empty();
    (0, import_obsidian54.setIcon)(this.statusIcon, "check-circle");
    this.progressBar.style.width = "100%";
  }
  /**
   * Add a close button to the notice
   * This allows the user to dismiss the notice manually
   */
  addCloseButton() {
    var _a;
    if (this.closeButton) return;
    this.closeButton = this.noticeEl.createDiv("transcription-close-button");
    (0, import_obsidian54.setIcon)(this.closeButton, "x");
    this.closeButton.addEventListener("click", () => {
      this.hide();
    });
    const styleEl = document.getElementById("systemsculpt-transcription-notice-styles");
    if (styleEl && !((_a = styleEl.textContent) == null ? void 0 : _a.includes(".transcription-close-button"))) {
      styleEl.textContent += `
        .transcription-close-button {
          position: absolute;
          top: 10px;
          right: 10px;
          cursor: pointer;
          opacity: 0.7;
          transition: opacity 0.2s ease;
          display: flex;
          align-items: center;
          justify-content: center;
          width: 24px;
          height: 24px;
          border-radius: 4px;
        }

        .transcription-close-button:hover {
          opacity: 1;
          background-color: var(--background-modifier-hover);
        }
      `;
    }
  }
  /**
   * Start a countdown timer that will automatically close the notice
   * @param seconds The number of seconds to countdown from
   */
  startCountdownTimer(seconds = 5) {
    var _a;
    this.clearCountdownTimer();
    if (!this.countdownTimer) {
      const countdownContainer = this.noticeEl.createDiv("transcription-countdown-container");
      this.countdownTimer = countdownContainer.createDiv("transcription-countdown");
      const styleEl = document.getElementById("systemsculpt-transcription-notice-styles");
      if (styleEl && !((_a = styleEl.textContent) == null ? void 0 : _a.includes(".transcription-countdown-container"))) {
        styleEl.textContent += `
          .transcription-countdown-container {
            display: flex;
            justify-content: center;
            margin-top: 8px;
          }

          .transcription-countdown {
            font-size: 12px;
            color: var(--text-muted);
            background-color: var(--background-secondary);
            border-radius: 10px;
            padding: 2px 8px;
            min-width: 24px;
            text-align: center;
            transition: all 0.3s ease;
          }

          .systemsculpt-transcription-notice.closing {
            animation: slide-out-right 0.5s ease forwards;
          }

          @keyframes slide-out-right {
            from {
              transform: translateX(0);
              opacity: 1;
            }
            to {
              transform: translateX(100%);
              opacity: 0;
            }
          }
        `;
      }
    }
    let timeLeft = seconds;
    if (this.countdownTimer) {
      this.countdownTimer.setText(`Closing in ${timeLeft}s`);
    }
    this.countdownInterval = window.setInterval(() => {
      timeLeft--;
      if (timeLeft <= 0) {
        this.clearCountdownTimer();
        this.noticeEl.addClass("closing");
        setTimeout(() => {
          this.hide();
        }, 500);
      } else if (this.countdownTimer) {
        this.countdownTimer.setText(`Closing in ${timeLeft}s`);
      }
    }, 1e3);
  }
  /**
   * Clear the countdown timer if it exists
   */
  clearCountdownTimer() {
    if (this.countdownInterval) {
      clearInterval(this.countdownInterval);
      this.countdownInterval = null;
    }
  }
  /**
   * Override the hide method to ensure the countdown is cleared
   */
  hide() {
    this.clearCountdownTimer();
    super.hide();
  }
  /**
   * Add completion buttons to the notice
   * This adds both a "View Result" button and a close button
   * @param resultPath The path to the transcription result file
   */
  addCompletionButtons(resultPath) {
    var _a;
    this.showSuccessState();
    this.addCloseButton();
    const existingButtons = this.noticeEl.querySelector(".transcription-buttons");
    if (existingButtons) {
      existingButtons.remove();
    }
    const buttonsContainer = this.noticeEl.createDiv("transcription-buttons");
    const viewButton = document.createElement("button");
    viewButton.className = "transcription-button primary";
    viewButton.textContent = "View Result";
    viewButton.addEventListener("click", () => {
      const app = window.app;
      const file = app.vault.getAbstractFileByPath(resultPath);
      if (file) {
        app.workspace.getLeaf().openFile(file);
        this.hide();
      }
    });
    const closeButton = document.createElement("button");
    closeButton.className = "transcription-button";
    closeButton.textContent = "Close";
    closeButton.addEventListener("click", () => {
      this.hide();
    });
    buttonsContainer.appendChild(viewButton);
    buttonsContainer.appendChild(closeButton);
    const styleEl = document.getElementById("systemsculpt-transcription-notice-styles");
    if (styleEl && !((_a = styleEl.textContent) == null ? void 0 : _a.includes(".transcription-buttons"))) {
      styleEl.textContent += `
        .transcription-buttons {
          display: flex;
          justify-content: flex-end;
          gap: 8px;
          margin-top: 12px;
        }

        .transcription-button {
          padding: 6px 12px;
          border-radius: 4px;
          font-size: 14px;
          cursor: pointer;
          background-color: var(--interactive-normal);
          color: var(--text-normal);
          border: none;
          transition: background-color 0.2s ease;
        }

        .transcription-button:hover {
          background-color: var(--interactive-hover);
        }

        .transcription-button.primary {
          background-color: var(--interactive-accent);
          color: var(--text-on-accent);
        }

        .transcription-button.primary:hover {
          background-color: var(--interactive-accent-hover);
        }
      `;
    }
  }
};
var AudioTranscriptionModal = class {
  constructor(app, options) {
    this.app = app;
    this.options = options;
    this.plugin = options.plugin;
    this.transcriptionService = TranscriptionService.getInstance(
      options.plugin
    );
    this.postProcessingService = PostProcessingService.getInstance(
      options.plugin
    );
  }
  open() {
    this.notice = new PersistentTranscriptionNotice();
    this.startTranscription();
  }
  /**
   * Insert transcribed text into the active view
   */
  insertTranscribedText(text) {
    try {
      const view = this.app.workspace.getActiveViewOfType(import_obsidian54.MarkdownView);
      if (view == null ? void 0 : view.editor) {
        view.editor.replaceSelection(text);
        new import_obsidian54.Notice("\u2713 Transcription inserted into document");
      } else {
        new import_obsidian54.Notice("\u2713 Transcription copied to clipboard (no active editor)");
        navigator.clipboard.writeText(text);
      }
    } catch (error) {
      new import_obsidian54.Notice("\u274C Failed to insert transcription");
      try {
        navigator.clipboard.writeText(text);
        new import_obsidian54.Notice("\u2713 Transcription copied to clipboard instead");
      } catch (e) {
      }
    }
  }
  async startTranscription() {
    try {
      this.notice.updateProgress({
        progress: 0,
        status: "Starting transcription...",
        icon: "mic"
      });
      const progressManager = TranscriptionProgressManager.getInstance();
      const progressHandler = progressManager.createProgressHandler(
        this.options.file,
        (progress, status, icon, details) => {
          this.notice.updateProgress({
            progress,
            status,
            icon: icon || "audio-lines",
            details
          });
        }
      );
      const text = await this.transcriptionService.transcribeFile(
        this.options.file,
        {
          ...progressHandler,
          type: this.options.isChat ? "chat" : "note",
          timestamped: this.options.timestamped
        }
      );
      if (!text) {
        throw new Error("Failed to get transcription text");
      }
      let finalText = text;
      let processedText = text;
      if (this.plugin.settings.postProcessingEnabled) {
        this.notice.updateProgress({
          progress: 80,
          status: "Post-processing transcription...",
          icon: "wand"
        });
        processedText = await this.postProcessingService.processTranscription(text);
      }
      if (this.plugin.settings.cleanTranscriptionOutput || this.options.isChat) {
        finalText = processedText;
      } else if (this.plugin.settings.postProcessingEnabled) {
        let audioPlayerSection = "";
        if (this.plugin.settings.keepRecordingsAfterTranscription) {
          const audioLink = `![[${this.options.file.path}]]`;
          audioPlayerSection = `
## Audio Recording
${audioLink}

`;
        }
        finalText = `# Audio Transcription
Source: ${this.options.file.basename}
Transcribed: ${(/* @__PURE__ */ new Date()).toISOString()}

${audioPlayerSection}## Raw Transcription
${text}

## Processed Transcription
${processedText}`;
      } else {
        let audioPlayerSection = "";
        if (this.plugin.settings.keepRecordingsAfterTranscription) {
          const audioLink = `![[${this.options.file.path}]]`;
          audioPlayerSection = `
## Audio Recording
${audioLink}

`;
        }
        finalText = `# Audio Transcription
Source: ${this.options.file.basename}
Transcribed: ${(/* @__PURE__ */ new Date()).toISOString()}

${audioPlayerSection}## Raw Transcription
${text}`;
      }
      if (!this.options.isChat && this.plugin.settings.autoPasteTranscription) {
        this.insertTranscribedText(finalText);
      }
      if (this.options.onTranscriptionComplete) {
        this.options.onTranscriptionComplete(finalText);
      }
      await navigator.clipboard.writeText(finalText);
      const audioPath = this.options.file.path;
      const markdownPath = audioPath.substring(0, audioPath.lastIndexOf(".")) + ".md";
      const existingFile = this.app.vault.getAbstractFileByPath(markdownPath);
      if (existingFile instanceof import_obsidian54.TFile) {
        await this.app.vault.modify(existingFile, finalText);
      } else {
        await this.app.vault.create(markdownPath, finalText);
      }
      this.notice.updateProgress({
        progress: 100,
        status: "Transcription complete!",
        icon: "check-circle"
      });
      this.notice.showSuccessState();
      this.notice.addCompletionButtons(markdownPath);
      this.notice.startCountdownTimer(5);
      progressManager.handleCompletion(this.options.file.path, markdownPath);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      this.notice.updateProgress({
        progress: 0,
        status: `Error: ${errorMessage}`,
        icon: "x-circle",
        details: `Transcription failed
File: ${this.options.file.path}
Error details: ${errorMessage}

Please try again or check the console for more information.`
      });
      this.notice.addCloseButton();
    }
  }
};
async function showAudioTranscriptionModal(app, options) {
  const modal = new AudioTranscriptionModal(app, options);
  modal.open();
}

// src/modals/RecordingModal.ts
var import_obsidian55 = require("obsidian");
init_PlatformContext();
var RecordingModal = class extends import_obsidian55.Modal {
  constructor(app, plugin, callbacks) {
    super(app);
    // UI elements
    this.statusEl = null;
    this.timerEl = null;
    this.visualizerCanvas = null;
    this.visualizerCtx = null;
    this.stopButton = null;
    this.assuranceEl = null;
    // Timer state
    this.recordingStartTime = 0;
    this.timerInterval = null;
    // Audio visualization
    this.audioContext = null;
    this.analyser = null;
    this.animationId = null;
    this.plugin = plugin;
    this.callbacks = callbacks;
    this.platform = PlatformContext.get();
  }
  onOpen() {
    const { contentEl } = this;
    const uiVariant = this.platform.uiVariant();
    const isMobile = uiVariant === "mobile";
    this.titleEl.setText("\u{1F399}\uFE0F Recording Audio");
    if (isMobile) {
      this.modalEl.addClass("systemsculpt-recording-modal-native-mobile");
    } else {
      this.modalEl.addClass("systemsculpt-recording-modal-native-desktop");
    }
    this.modalEl.addClass(`platform-ui-${uiVariant}`);
    this.createRecordingInterface(contentEl, isMobile, uiVariant);
    this.startTimer();
  }
  onClose() {
    this.stopTimer();
    this.stopVisualization();
    this.statusEl = null;
    this.timerEl = null;
    this.visualizerCanvas = null;
    this.visualizerCtx = null;
    this.stopButton = null;
    this.assuranceEl = null;
  }
  createRecordingInterface(container, isMobile, uiVariant) {
    container.empty();
    container.addClass("systemsculpt-recording-content");
    container.addClass(`platform-ui-${uiVariant}`);
    if (isMobile) {
      container.addClass("systemsculpt-recording-content-mobile");
    }
    this.statusEl = container.createDiv("systemsculpt-recording-status");
    this.statusEl.setText("Recording in progress...");
    if (isMobile) {
      this.statusEl.addClass("systemsculpt-recording-status-mobile");
    }
    this.timerEl = container.createDiv("systemsculpt-recording-timer");
    this.timerEl.setText("00:00");
    if (isMobile) {
      this.timerEl.addClass("systemsculpt-recording-timer-mobile");
    }
    this.visualizerCanvas = container.createEl("canvas", {
      cls: isMobile ? "systemsculpt-recording-visualizer systemsculpt-recording-visualizer-mobile" : "systemsculpt-recording-visualizer"
    });
    if (isMobile) {
      this.visualizerCanvas.width = Math.min(400, window.innerWidth - 80);
      this.visualizerCanvas.height = 100;
    } else {
      this.visualizerCanvas.width = 300;
      this.visualizerCanvas.height = 60;
    }
    this.visualizerCtx = this.visualizerCanvas.getContext("2d");
    if (this.visualizerCtx) {
      this.visualizerCtx.fillStyle = "var(--background-secondary)";
      this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    }
    const buttonContainer = container.createDiv("systemsculpt-recording-buttons");
    if (isMobile) {
      buttonContainer.addClass("systemsculpt-recording-buttons-mobile");
    }
    this.stopButton = new import_obsidian55.ButtonComponent(buttonContainer);
    this.stopButton.setButtonText("Stop Recording").setCta().onClick(() => {
      this.callbacks.onStop();
      this.close();
    });
    if (isMobile) {
      this.stopButton.buttonEl.addClass("systemsculpt-recording-stop-mobile");
      this.stopButton.buttonEl.innerHTML = `
        <svg viewBox="0 0 24 24" width="20" height="20" stroke="currentColor" stroke-width="2"
             fill="none" stroke-linecap="round" stroke-linejoin="round" style="margin-right: 8px;">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
        </svg>
        Stop Recording
      `;
    }
    if (isMobile) {
      this.assuranceEl = container.createDiv("systemsculpt-recording-assurance");
      this.assuranceEl.innerHTML = `
        <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"
             stroke-linecap="round" stroke-linejoin="round">
          <path d="M9 11l3 3L22 4"></path>
          <path d="M21 12v7a2 2 0 01-2 2H5a2 2 0 01-2-2V5a2 2 0 012-2h11"></path>
        </svg>
        Your recording will be saved securely, even if transcription fails.
      `;
    }
  }
  /**
   * Update the status message
   */
  updateStatus(status) {
    if (this.statusEl) {
      this.statusEl.setText(status);
    }
    this.callbacks.onStatusUpdate(status);
  }
  /**
   * Start the recording timer
   */
  startTimer() {
    this.recordingStartTime = Date.now();
    this.stopTimer();
    this.timerInterval = window.setInterval(() => {
      if (!this.timerEl) return;
      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1e3);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      this.timerEl.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }, 1e3);
  }
  /**
   * Stop the recording timer
   */
  stopTimer() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }
  /**
   * Start audio visualization
   */
  async startVisualization(mediaStream) {
    try {
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      const source = this.audioContext.createMediaStreamSource(mediaStream);
      source.connect(this.analyser);
      this.drawVisualization();
    } catch (error) {
    }
  }
  /**
   * Draw the audio visualization
   */
  drawVisualization() {
    if (!this.analyser || !this.visualizerCtx || !this.visualizerCanvas) {
      return;
    }
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);
    this.visualizerCtx.fillStyle = getComputedStyle(document.body).getPropertyValue("--background-secondary");
    this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    const barWidth = this.visualizerCanvas.width / bufferLength * 2.5;
    const barSpacing = 1;
    let x = 0;
    const accentColor = getComputedStyle(document.body).getPropertyValue("--text-accent");
    const mutedAccent = getComputedStyle(document.body).getPropertyValue("--text-muted");
    for (let i = 0; i < bufferLength; i++) {
      const barHeight = dataArray[i] / 255 * this.visualizerCanvas.height * 0.8;
      const gradient = this.visualizerCtx.createLinearGradient(0, this.visualizerCanvas.height - barHeight, 0, this.visualizerCanvas.height);
      gradient.addColorStop(0, accentColor);
      gradient.addColorStop(1, mutedAccent);
      this.visualizerCtx.fillStyle = gradient;
      this.visualizerCtx.fillRect(x, this.visualizerCanvas.height - barHeight, barWidth - barSpacing, barHeight);
      x += barWidth;
      if (x > this.visualizerCanvas.width) break;
    }
    this.animationId = requestAnimationFrame(() => this.drawVisualization());
  }
  /**
   * Stop audio visualization
   */
  stopVisualization() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    if (this.audioContext) {
      this.audioContext.close().catch(() => {
      });
      this.audioContext = null;
    }
    this.analyser = null;
  }
};

// src/views/chatview/ChatView.ts
var import_obsidian92 = require("obsidian");
init_SystemSculptService();

// src/views/chatview/ChatStorageService.ts
var import_obsidian56 = require("obsidian");

// src/views/chatview/storage/ChatMarkdownSerializer.ts
var obsidianApi = __toESM(require("obsidian"), 1);

// src/views/chatview/utils/MessagePartList.ts
var MessagePartList = class {
  constructor(parts) {
    this.parts = Array.isArray(parts) ? parts : [];
  }
  /** Return all parts matching the given type */
  _ofType(type) {
    return this.parts.filter((p) => p.type === type);
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Query helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /** Ordered array of *content* strings */
  get contentParts() {
    return this._ofType("content").map((p) => p.data);
  }
  /** Ordered array of *reasoning* strings */
  get reasoningParts() {
    return this._ofType("reasoning").map((p) => p.data);
  }
  /** Ordered array of tool-call payloads */
  get toolCalls() {
    return this._ofType("tool_call").map((p) => p.data);
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Convenience aggregations â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /** Concatenate content parts into a single markdown string */
  contentMarkdown(delimiter = "\n\n") {
    return this.contentParts.join(delimiter);
  }
  /** Concatenate reasoning parts verbatim without extra separators */
  reasoningMarkdown(delimiter = "") {
    return this.reasoningParts.join(delimiter);
  }
  /** Whether the list contains any reasoning segments */
  get hasReasoning() {
    return this.reasoningParts.length > 0;
  }
  /** Whether the list contains any tool-calls */
  get hasToolCalls() {
    return this.toolCalls.length > 0;
  }
};

// src/views/chatview/storage/ChatMarkdownSerializer.ts
var { parseYaml } = obsidianApi;
var ChatMarkdownSerializer = class {
  /**
   * Convert an array of chat messages into the markdown body that lives below
   * the YAML front-matter.  (Front-matter itself is *not* produced here.)
   */
  static serializeMessages(messages) {
    return messages.filter((msg) => msg.role !== "tool").map((msg) => this.messageToMarkdown(msg)).join("\n\n");
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  READ-SIDE â€“ parseMarkdown()
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  /** Parse markdown of a chat file and return metadata + messages. */
  static parseMarkdown(content) {
    const metadata = this.parseMetadata(content);
    if (!metadata) return null;
    const sequential = this.parseSequentialFormat(content);
    if (sequential.success) return { metadata, messages: sequential.messages };
    const aggregated = this.parseAggregatedFormat(content);
    if (aggregated.success) return { metadata, messages: aggregated.messages };
    return null;
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Internal parsing helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static parseSequentialFormat(content) {
    var _a, _b, _c;
    const messages = [];
    const messageRegex = /<!-- SYSTEMSCULPT-MESSAGE-START (.*?) -->([\s\S]*?)<!-- SYSTEMSCULPT-MESSAGE-END -->/g;
    let match;
    while ((match = messageRegex.exec(content)) !== null) {
      const attrs = match[1];
      const body = match[2];
      const roleMatch = attrs.match(/role="(.*?)"/);
      const idMatch = attrs.match(/message-id="(.*?)"/);
      if (!roleMatch || !idMatch) continue;
      const role = roleMatch[1];
      const message_id = idMatch[1];
      const parts = [];
      let ts = Date.now();
      let workingBody = body;
      const extractedBlocks = [];
      const reasoningRegex = /<!-- REASONING\n([\s\S]*?)\n-->/g;
      let reasoningMatch;
      while ((reasoningMatch = reasoningRegex.exec(body)) !== null) {
        const reasoningText = reasoningMatch[1];
        if (reasoningText) {
          extractedBlocks.push({
            type: "reasoning",
            data: reasoningText,
            position: reasoningMatch.index
          });
          workingBody = workingBody.replace(reasoningMatch[0], `
<!-- EXTRACTED-${extractedBlocks.length - 1} -->
`);
        }
      }
      const toolCallRegex = /<!-- TOOL-CALLS\n([\s\S]*?)\n-->/g;
      let toolCallMatch;
      while ((toolCallMatch = toolCallRegex.exec(body)) !== null) {
        const toolCallJson = (_a = toolCallMatch[1]) == null ? void 0 : _a.trim();
        if (toolCallJson) {
          try {
            const toolCallsArray = JSON.parse(toolCallJson);
            if (Array.isArray(toolCallsArray)) {
              for (const toolCall of toolCallsArray) {
                extractedBlocks.push({
                  type: "tool_call",
                  data: toolCall,
                  position: toolCallMatch.index
                });
              }
            }
          } catch (e) {
          }
          workingBody = workingBody.replace(toolCallMatch[0], `
<!-- EXTRACTED-TC -->
`);
        }
      }
      const contentText = workingBody.replace(/<!-- EXTRACTED-[\w-]+ -->/g, "");
      extractedBlocks.sort((a, b) => a.position - b.position);
      let lastPosition = 0;
      for (const block of extractedBlocks) {
        const beforeContent = body.substring(lastPosition, block.position).replace(/<!-- REASONING\n[\s\S]*?\n-->/g, "").replace(/<!-- TOOL-CALLS\n[\s\S]*?\n-->/g, "");
        if (beforeContent && beforeContent.trim().length > 0) {
          parts.push({ id: `content-${ts}`, type: "content", data: beforeContent, timestamp: ts++ });
        }
        if (block.type === "reasoning") {
          parts.push({ id: `reasoning-${ts}`, type: "reasoning", data: block.data, timestamp: ts++ });
        } else if (block.type === "tool_call") {
          const toolId = block.data && typeof block.data.id === "string" ? block.data.id : String(ts);
          const partId = toolId ? `tool_call_part-${toolId}` : `tool_call-${ts}`;
          parts.push({ id: partId, type: "tool_call", data: block.data, timestamp: ts++ });
        }
        lastPosition = block.position + (block.type === "reasoning" ? ((_b = body.substring(block.position).match(/<!-- REASONING\n[\s\S]*?\n-->/)) == null ? void 0 : _b[0].length) || 0 : block.type === "tool_call" ? ((_c = body.substring(block.position).match(/<!-- TOOL-CALLS\n[\s\S]*?\n-->/)) == null ? void 0 : _c[0].length) || 0 : 0);
      }
      const trailingContent = body.substring(lastPosition).replace(/<!-- REASONING\n[\s\S]*?\n-->/g, "").replace(/<!-- TOOL-CALLS\n[\s\S]*?\n-->/g, "");
      if (trailingContent && trailingContent.trim().length > 0) {
        parts.push({ id: `content-${ts}`, type: "content", data: trailingContent, timestamp: ts++ });
      }
      if (parts.length === 0 && contentText && contentText.trim().length > 0) {
        parts.push({ id: `content-${ts}`, type: "content", data: contentText, timestamp: ts++ });
      }
      if (parts.length > 0) {
        messages.push(this.reconstructMessageFromParts(role, message_id, parts));
      }
    }
    return { success: true, messages };
  }
  static parseAggregatedFormat(content) {
    var _a;
    const messages = [];
    const messageRegex = /<!-- SYSTEMSCULPT-MESSAGE-START (.*?) -->([\s\S]*?)<!-- SYSTEMSCULPT-MESSAGE-END -->/g;
    let match;
    while ((match = messageRegex.exec(content)) !== null) {
      const attrs = match[1];
      const body = match[2];
      const roleMatch = attrs.match(/role="(.*?)"/);
      const idMatch = attrs.match(/message-id="(.*?)"/);
      if (!roleMatch || !idMatch) continue;
      const role = roleMatch[1];
      const message_id = idMatch[1];
      const parts = [];
      let ts = Date.now();
      let workingBody = body;
      const reasoningRegex = /<!-- REASONING\n([\s\S]*?)\n-->/g;
      let reasoningMatch;
      const reasoningBlocks = [];
      while ((reasoningMatch = reasoningRegex.exec(body)) !== null) {
        const reasoningText = reasoningMatch[1];
        if (reasoningText) {
          reasoningBlocks.push(reasoningText);
          workingBody = workingBody.replace(reasoningMatch[0], "");
        }
      }
      const toolCallRegex = /<!-- TOOL-CALLS\n([\s\S]*?)\n-->/g;
      let toolCallMatch;
      const toolCallBlocks = [];
      while ((toolCallMatch = toolCallRegex.exec(body)) !== null) {
        const toolCallJson = (_a = toolCallMatch[1]) == null ? void 0 : _a.trim();
        if (toolCallJson) {
          try {
            const toolCallsArray = JSON.parse(toolCallJson);
            if (Array.isArray(toolCallsArray)) {
              toolCallBlocks.push(...toolCallsArray);
            }
          } catch (e) {
          }
          workingBody = workingBody.replace(toolCallMatch[0], "");
        }
      }
      const contentOnly = workingBody;
      if (contentOnly) {
        parts.push({ id: `content-${ts}`, type: "content", data: contentOnly, timestamp: ts++ });
      }
      for (const reasoning of reasoningBlocks) {
        parts.push({ id: `reasoning-${ts}`, type: "reasoning", data: reasoning, timestamp: ts++ });
      }
      for (const toolCall of toolCallBlocks) {
        const toolId = toolCall && typeof toolCall.id === "string" ? toolCall.id : String(ts);
        const partId = toolId ? `tool_call_part-${toolId}` : `tool_call-${ts}`;
        parts.push({ id: partId, type: "tool_call", data: toolCall, timestamp: ts++ });
      }
      if (parts.length > 0) {
        messages.push(this.reconstructMessageFromParts(role, message_id, parts));
      }
    }
    return { success: true, messages };
  }
  static reconstructMessageFromParts(role, message_id, messageParts) {
    const list = new MessagePartList(messageParts);
    return {
      role,
      message_id,
      content: list.contentMarkdown(),
      reasoning: list.reasoningMarkdown(),
      tool_calls: list.toolCalls,
      messageParts
    };
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Front-matter helpers â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static parseMetadata(content) {
    var _a;
    const frontMatterMatch = content.match(/^---\n([\s\S]*?)\n---/);
    if (!frontMatterMatch) return null;
    const yamlContent = frontMatterMatch[1];
    if (!this.isValidYamlFrontmatter(yamlContent)) return null;
    const parsed = parseYaml(yamlContent);
    if (!parsed || typeof parsed !== "object") return null;
    const {
      id = "",
      model = "",
      created = (/* @__PURE__ */ new Date()).toISOString(),
      lastModified = (/* @__PURE__ */ new Date()).toISOString(),
      title = "Untitled Chat",
      context_files = [],
      version: versionRaw = 0
    } = parsed;
    if (!id) return null;
    const processedContextFiles = Array.isArray(context_files) ? context_files.map((file) => {
      if (typeof file === "string") {
        const isExtraction = file.includes("/Extractions/");
        return { path: file, type: isExtraction ? "extraction" : "source" };
      } else if (file && typeof file === "object" && file.path) {
        return {
          path: file.path,
          type: file.type || "source"
        };
      } else {
        return { path: "", type: "source" };
      }
    }) : [];
    let systemMessageType = "general-use";
    let systemMessagePath = void 0;
    if (parsed.systemMessage && typeof parsed.systemMessage === "object") {
      const type = (_a = parsed.systemMessage.type) == null ? void 0 : _a.toLowerCase();
      if (type === "general-use" || type === "concise" || type === "agent" || type === "custom") {
        systemMessageType = type;
        if (type === "custom" && parsed.systemMessage.path) {
          systemMessagePath = parsed.systemMessage.path.replace(/^\[\[(.*?)\]\]$/, "$1");
        }
      }
    } else if (parsed.customPromptFilePath) {
      systemMessageType = "custom";
      systemMessagePath = parsed.customPromptFilePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    }
    return {
      id,
      model,
      created,
      lastModified,
      title,
      version: Number(versionRaw) || 0,
      context_files: processedContextFiles,
      systemMessage: {
        type: systemMessageType,
        path: systemMessagePath
      },
      agentMode: parsed.agentMode !== void 0 ? Boolean(parsed.agentMode) : void 0,
      includeVaultStructure: parsed.includeVaultStructure !== void 0 ? Boolean(parsed.includeVaultStructure) : void 0,
      chatFontSize: parsed.chatFontSize
    };
  }
  static isValidYamlFrontmatter(content) {
    return /\bid\s*:/i.test(content) || /\bmodel\s*:/i.test(content);
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Helpers
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  static messageToMarkdown(msg) {
    let messageBody = "";
    if (msg.messageParts && msg.messageParts.length > 0) {
      msg.messageParts.forEach((part) => {
        switch (part.type) {
          case "content":
            messageBody += part.data;
            break;
          case "reasoning":
            if (typeof part.data === "string") {
              messageBody += `
<!-- REASONING
${part.data}
-->
`;
            }
            break;
          case "tool_call":
            const toolCallArray = [part.data];
            messageBody += `
<!-- TOOL-CALLS
${JSON.stringify(toolCallArray, null, 2)}
-->
`;
            break;
        }
      });
    } else {
      let contentString = "";
      if (typeof msg.content === "string") {
        contentString = msg.content;
      } else if (Array.isArray(msg.content)) {
        contentString = msg.content.map((part) => {
          if (part.type === "text") return part.text;
          if (part.type === "image_url")
            return `![Image Context](${part.image_url.url})`;
          return "";
        }).join("\n");
      }
      messageBody = contentString;
      if (msg.tool_calls && msg.tool_calls.length > 0) {
        messageBody += `
<!-- TOOL-CALLS
${JSON.stringify(msg.tool_calls, null, 2)}
-->`;
      }
      if (msg.reasoning) {
        messageBody += `
<!-- REASONING
${msg.reasoning}
-->`;
      }
    }
    const hasToolCalls = msg.tool_calls && msg.tool_calls.length > 0 || msg.messageParts && msg.messageParts.some((p) => p.type === "tool_call");
    const hasReasoning = !!msg.reasoning || msg.messageParts && msg.messageParts.some((p) => p.type === "reasoning");
    const isStreaming = !!msg.streaming;
    let attributes = `role="${msg.role}" message-id="${msg.message_id}"`;
    if (hasToolCalls) attributes += ' has-tool-calls="true"';
    if (hasReasoning) attributes += ' has-reasoning="true"';
    if (isStreaming) attributes += ' streaming="true"';
    const messageStart = `<!-- SYSTEMSCULPT-MESSAGE-START ${attributes} -->`;
    return `${messageStart}
${messageBody}
<!-- SYSTEMSCULPT-MESSAGE-END -->`;
  }
};

// src/views/chatview/ChatStorageService.ts
function processMessageToolCalls(message, toolCallManager) {
  if (message.role === "tool" && message.content && toolCallManager) {
    try {
      const toolCall = toolCallManager.getToolCall(message.tool_call_id || "");
      if (toolCall) {
        let parsedContent;
        try {
          parsedContent = JSON.parse(message.content);
        } catch (parseError) {
          return message;
        }
        const processedContent = toolCallManager.processToolResult(
          parsedContent,
          toolCall.request.function.name
        );
        try {
          const serialized = JSON.stringify(processedContent, null, 2);
          if (serialized.length > 5e4) {
            return {
              ...message,
              content: JSON.stringify({
                ...processedContent,
                truncation_info: `Content truncated - original size: ${serialized.length} characters`
              }, null, 2)
            };
          }
          return { ...message, content: serialized };
        } catch (stringifyError) {
          return message;
        }
      }
    } catch (error) {
      return message;
    }
  }
  return message;
}
var ChatStorageService = class {
  constructor(app, chatDirectory, toolCallManager) {
    this.app = app;
    this.chatDirectory = chatDirectory;
    this.toolCallManager = toolCallManager;
  }
  // Master save method - always saves in the new, simple format
  async saveChat(chatId, messages, selectedModelId, contextFiles, customPromptFilePath, systemPromptType, systemPromptPath, title, agentMode, includeVaultStructure, chatFontSize) {
    try {
      const { version } = await this.saveChatSimple(
        chatId,
        messages,
        selectedModelId,
        contextFiles,
        customPromptFilePath,
        systemPromptType,
        systemPromptPath,
        title,
        agentMode,
        includeVaultStructure,
        chatFontSize
      );
      return { version };
    } catch (error) {
      throw new Error(`Failed to save chat to ${chatId}.md`);
    }
  }
  async saveChatSimple(chatId, messages, selectedModelId, contextFiles, customPromptFilePath, systemPromptType, systemPromptPath, title, agentMode, includeVaultStructure, chatFontSize) {
    let filePath = `[unknown-path]/${chatId}.md`;
    try {
      filePath = `${this.chatDirectory}/${chatId}.md`;
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const vault = this.app.vault;
      let fileExists = false;
      let existingMetadata = null;
      const file = vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian56.TFile) {
        fileExists = true;
        const content = await vault.read(file);
        existingMetadata = this.parseMetadata(content);
      }
      const creationDate = (existingMetadata == null ? void 0 : existingMetadata.created) || now;
      const currentVersion = Number(existingMetadata == null ? void 0 : existingMetadata.version) || 0;
      let newVersion = currentVersion + 1;
      if (messages.length === 0 && fileExists && existingMetadata && file instanceof import_obsidian56.TFile) {
        const existingContent = await vault.read(file);
        if (existingContent.includes("SYSTEMSCULPT-MESSAGE-START")) {
          throw new Error("Cannot save empty messages over existing chat content");
        }
      }
      const metadata = {
        id: chatId,
        model: selectedModelId,
        created: creationDate,
        lastModified: now,
        title: title || (existingMetadata == null ? void 0 : existingMetadata.title) || "Untitled Chat",
        version: newVersion,
        systemMessage: {
          type: systemPromptType || "general-use",
          path: systemPromptType === "custom" && systemPromptPath ? systemPromptPath : void 0
        },
        agentMode,
        includeVaultStructure,
        chatFontSize: chatFontSize || "medium"
      };
      if (contextFiles && contextFiles.size > 0) {
        metadata.context_files = Array.from(contextFiles).map((path) => ({
          path,
          type: path.includes("/Extractions/") ? "extraction" : "source"
        }));
      }
      const processedMessages = messages.map((msg) => processMessageToolCalls(msg, this.toolCallManager));
      const messagesContent = ChatMarkdownSerializer.serializeMessages(processedMessages);
      const fullContent = `---
${(0, import_obsidian56.stringifyYaml)(metadata)}---

${messagesContent}`;
      const SystemSculptPlugin2 = this.app.plugins.plugins["systemsculpt-ai"];
      if (SystemSculptPlugin2 && SystemSculptPlugin2.directoryManager) {
        await SystemSculptPlugin2.directoryManager.ensureDirectoryByPath(this.chatDirectory);
      } else {
        const exists = await this.app.vault.adapter.exists(this.chatDirectory);
        if (!exists) {
          await this.app.vault.createFolder(this.chatDirectory);
        }
      }
      if (fileExists && file instanceof import_obsidian56.TFile) {
        await vault.modify(file, fullContent);
      } else {
        await vault.create(filePath, fullContent);
      }
      return { filePath, version: newVersion };
    } catch (error) {
      throw error;
    }
  }
  async loadChats() {
    try {
      const files = await this.app.vault.adapter.list(this.chatDirectory);
      const chatFiles = files.files.filter((f) => f.endsWith(".md"));
      const chats = await Promise.allSettled(
        chatFiles.map(async (filePath) => {
          var _a;
          try {
            let fileModifiedTime = null;
            const abstractFile = this.app.vault.getAbstractFileByPath(filePath);
            if (abstractFile instanceof import_obsidian56.TFile) {
              fileModifiedTime = abstractFile.stat.mtime;
            }
            const content = await this.app.vault.adapter.read(filePath);
            if (!this.isValidChatFile(content)) {
              return null;
            }
            const filename = ((_a = filePath.split("/").pop()) == null ? void 0 : _a.replace(".md", "")) || "";
            const parsed = this.parseMarkdownContent(content, filename);
            if (!parsed) return null;
            if (fileModifiedTime && !isNaN(fileModifiedTime)) {
              parsed.lastModified = fileModifiedTime;
            }
            return parsed;
          } catch (error) {
            return null;
          }
        })
      );
      const successfulChats = chats.filter((result) => result.status === "fulfilled").map((result) => result.value).filter((chat) => chat !== null);
      const failedCount = chats.length - successfulChats.length;
      if (failedCount > 0) {
      }
      return successfulChats;
    } catch (error) {
      return [];
    }
  }
  /** @deprecated Streaming writes are now handled by debounced saveChat() */
  async saveStreamingMessage() {
    return;
  }
  async loadChat(chatId) {
    try {
      const filePath = `${this.chatDirectory}/${chatId}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian56.TFile)) {
        return null;
      }
      const content = await this.app.vault.read(file);
      return this.parseMarkdownContent(content, chatId);
    } catch (error) {
      return null;
    }
  }
  generateMarkdownContent(metadata, messages) {
    const yamlMetadata = {
      systemsculpt_chat: true,
      ...metadata
    };
    const metadataSection = [
      "---",
      (0, import_obsidian56.stringifyYaml)(yamlMetadata).trim(),
      "---",
      ""
    ].join("\n");
    const messagesSection = messages.map(
      (msg) => [
        `<!-- SYSTEMSCULPT-MESSAGE-START role="${msg.role}" message-id="${msg.message_id}" -->`,
        msg.content,
        "<!-- SYSTEMSCULPT-MESSAGE-END -->",
        ""
      ].join("\n")
    ).join("\n");
    return metadataSection + messagesSection;
  }
  parseMetadata(content) {
    var _a;
    try {
      const metadataMatch = content.match(/^---\n([\s\S]*?)\n---/);
      if (!metadataMatch) return null;
      const yamlContent = metadataMatch[1];
      if (!this.isValidYamlFrontmatter(yamlContent)) {
        return null;
      }
      const parsed = (0, import_obsidian56.parseYaml)(yamlContent);
      if (!parsed || typeof parsed !== "object") {
        return null;
      }
      const {
        id = "",
        model = "",
        created = (/* @__PURE__ */ new Date()).toISOString(),
        lastModified = (/* @__PURE__ */ new Date()).toISOString(),
        title = "Untitled Chat",
        context_files = [],
        version: versionRaw = 0
      } = parsed;
      if (!id) {
        return null;
      }
      const processedContextFiles = Array.isArray(context_files) ? context_files.map(
        (file) => {
          if (typeof file === "string") {
            const isExtraction = file.includes("/Extractions/");
            return { path: file, type: isExtraction ? "extraction" : "source" };
          } else if (file && typeof file === "object" && file.path) {
            return {
              path: file.path,
              type: file.type || "source"
            };
          } else {
            return { path: "", type: "source" };
          }
        }
      ).filter((file) => file.path !== "") : [];
      let systemMessageType = "general-use";
      let systemMessagePath = void 0;
      if (parsed.systemMessage && typeof parsed.systemMessage === "object") {
        const type = (_a = parsed.systemMessage.type) == null ? void 0 : _a.toLowerCase();
        if (type === "general-use" || type === "concise" || type === "agent" || type === "custom") {
          systemMessageType = type;
          if (type === "custom" && parsed.systemMessage.path) {
            systemMessagePath = parsed.systemMessage.path.replace(/^\[\[(.*?)\]\]$/, "$1");
          }
        }
      } else if (parsed.customPromptFilePath) {
        systemMessageType = "custom";
        systemMessagePath = parsed.customPromptFilePath.replace(/^\[\[(.*?)\]\]$/, "$1");
      }
      return {
        id,
        model,
        created,
        lastModified,
        title: title || id,
        // Use ID if title is missing
        version: Number(versionRaw) || 0,
        context_files: processedContextFiles,
        systemMessage: {
          type: systemMessageType,
          path: systemMessagePath
        },
        agentMode: parsed.agentMode !== void 0 ? Boolean(parsed.agentMode) : void 0,
        includeVaultStructure: parsed.includeVaultStructure !== void 0 ? Boolean(parsed.includeVaultStructure) : void 0,
        chatFontSize: parsed.chatFontSize
      };
    } catch (error) {
      return null;
    }
  }
  parseMarkdownContent(content, filename) {
    if (this.isFiveBacktickLegacyFile(content)) {
      return this.parseFiveBacktickLegacyFile(content, filename);
    }
    const parsed = ChatMarkdownSerializer.parseMarkdown(content);
    if (parsed) {
      const { metadata, messages } = parsed;
      return this.finalizeParsedData(metadata, messages);
    }
    return null;
  }
  // Utility to finalize the parsed data into the expected return format
  finalizeParsedData(metadata, messages) {
    var _a, _b, _c;
    const normalizedMessages = this.normalizeLegacyToolMessages(messages);
    return {
      id: metadata.id,
      messages: normalizedMessages,
      selectedModelId: metadata.model,
      lastModified: new Date(metadata.lastModified).getTime(),
      title: metadata.title,
      version: metadata.version || 0,
      context_files: ((_a = metadata.context_files) == null ? void 0 : _a.map((f) => f.path)) || [],
      systemPromptType: ((_b = metadata.systemMessage) == null ? void 0 : _b.type) || "general-use",
      systemPromptPath: (_c = metadata.systemMessage) == null ? void 0 : _c.path,
      agentMode: metadata.agentMode,
      includeVaultStructure: metadata.includeVaultStructure,
      chatFontSize: metadata.chatFontSize
    };
  }
  /**
   * Normalize legacy persisted tool messages into tool_calls attached to the
   * preceding assistant message. This removes standalone role: "tool" entries
   * from loaded chats while preserving their results.
   */
  normalizeLegacyToolMessages(messages) {
    if (!Array.isArray(messages) || messages.length === 0) {
      return messages;
    }
    const result = [];
    let lastAssistant = null;
    const generateToolCallId = () => {
      const uuid = this.generateMessageId().replace(/-/g, "").substring(0, 24);
      return `call_${uuid}`;
    };
    for (const msg of messages) {
      if (msg.role === "assistant") {
        lastAssistant = msg;
        result.push(msg);
        continue;
      }
      if (msg.role === "tool") {
        let parsed = null;
        const rawContent = typeof msg.content === "string" ? msg.content : Array.isArray(msg.content) ? JSON.stringify(msg.content) : "";
        try {
          parsed = rawContent ? JSON.parse(rawContent) : null;
        } catch (e) {
          parsed = rawContent || null;
        }
        let reconstructedResult;
        let reconstructedState = "completed";
        if (parsed && typeof parsed === "object" && parsed.error) {
          const errorObj = parsed.error;
          const code = String(errorObj.code || "EXECUTION_FAILED");
          if (code === "USER_DENIED") {
            reconstructedState = "denied";
          } else {
            reconstructedState = "failed";
          }
          reconstructedResult = {
            success: false,
            error: {
              code,
              message: String(errorObj.message || "Tool execution failed."),
              details: errorObj.details
            }
          };
        } else {
          reconstructedResult = { success: true, data: parsed != null ? parsed : rawContent };
          reconstructedState = "completed";
        }
        if (lastAssistant) {
          const toolCalls = Array.isArray(lastAssistant.tool_calls) ? [...lastAssistant.tool_calls] : [];
          const callId = msg.tool_call_id && typeof msg.tool_call_id === "string" ? msg.tool_call_id : generateToolCallId();
          let matched = false;
          for (const tc of toolCalls) {
            if (tc.id === callId) {
              if (!tc.request) {
                tc.request = {
                  id: callId,
                  type: "function",
                  function: { name: "legacy.recovered", arguments: "{}" }
                };
              }
              tc.result = reconstructedResult;
              tc.state = reconstructedState;
              matched = true;
              break;
            }
          }
          if (!matched) {
            const newToolCall = {
              id: callId,
              messageId: lastAssistant.message_id,
              request: {
                id: callId,
                type: "function",
                function: { name: "legacy.recovered", arguments: "{}" }
              },
              state: reconstructedState,
              timestamp: Date.now(),
              result: reconstructedResult,
              autoApproved: false
            };
            toolCalls.push(newToolCall);
          }
          lastAssistant.tool_calls = toolCalls;
          continue;
        }
        const summaryPrefix = "Context Note (legacy tool result): ";
        const summaryContent = typeof reconstructedResult.success === "boolean" && reconstructedResult.success ? typeof reconstructedResult.data === "string" ? reconstructedResult.data : JSON.stringify(reconstructedResult.data) : JSON.stringify(reconstructedResult.error);
        result.push({
          role: "system",
          content: `${summaryPrefix}${summaryContent}`,
          message_id: this.generateMessageId()
        });
        continue;
      }
      result.push(msg);
    }
    return result;
  }
  /**
   * Validate and fix tool call IDs to ensure they follow OpenAI format
   * Also creates a mapping for tool result messages that reference the old IDs
   */
  validateAndFixToolCallIds(toolCalls, idMapping) {
    const generateUUID = () => {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
        var r = Math.random() * 16 | 0, v = c == "x" ? r : r & 3 | 8;
        return v.toString(16);
      });
    };
    return toolCalls.map((toolCall) => {
      if (!toolCall.id) {
        const newId = `call_${generateUUID().replace(/-/g, "").substring(0, 24)}`;
        return { ...toolCall, id: newId };
      }
      if (toolCall.id.startsWith("tool_") && toolCall.id.includes("_mcp-")) {
        const newId = `call_${generateUUID().replace(/-/g, "").substring(0, 24)}`;
        if (idMapping) {
          idMapping.set(toolCall.id, newId);
        }
        return { ...toolCall, id: newId };
      }
      return toolCall;
    });
  }
  /**
   * Validates that a file has the expected chat file structure
   */
  isValidChatFile(content) {
    const hasFrontmatter = /^---\n[\s\S]*?\n---/.test(content);
    const hasMessageMarkers = content.includes("SYSTEMSCULPT-MESSAGE-START") && content.includes("SYSTEMSCULPT-MESSAGE-END");
    const hasLegacyFormat = this.isFiveBacktickLegacyFile(content);
    return hasFrontmatter || hasMessageMarkers || hasLegacyFormat;
  }
  /**
   * Detects if this is a legacy chat file format
   */
  isFiveBacktickLegacyFile(content) {
    const hasContextFilesHeader = content.includes("# Context Files");
    const hasChatHistoryHeader = content.includes("# AI Chat History");
    const hasUserBlocks = /`{4,5}user/.test(content);
    const hasAiBlocks = /`{4,5}ai/.test(content);
    return (hasContextFilesHeader || hasChatHistoryHeader) && (hasUserBlocks || hasAiBlocks);
  }
  /**
   * Validates if content is actually YAML frontmatter and not markdown content
   */
  isValidYamlFrontmatter(content) {
    const markdownPatterns = [
      /^\s*#\s+/,
      // Headers
      /\|\s*\w+\s*\|.*\|/,
      // Tables (like "| Database | Storage Model |")
      /^\s*\d+\.\s+\*\*/,
      // Numbered lists with bold (like "1. **Plan Your Will Early**")
      /^\s*[-*+]\s+/,
      // Unordered lists
      /```/,
      // Code blocks
      /\[.*\]\(.*\)/,
      // Markdown links
      /!\[.*\]\(.*\)/
      // Images
    ];
    for (const pattern of markdownPatterns) {
      if (pattern.test(content)) {
        return false;
      }
    }
    const yamlIndicators = [
      /^\s*\w+\s*:/,
      // Key-value pairs
      /^\s*-\s*\w+\s*:/,
      // Array of objects
      /^\s*\w+\s*:\s*\[/,
      // Arrays
      /^\s*\w+\s*:\s*['"]/
      // Quoted strings
    ];
    const hasYamlStructure = yamlIndicators.some((pattern) => pattern.test(content));
    const hasExpectedFields = /\bid\s*:/.test(content) || /\bmodel\s*:/.test(content) || /\btitle\s*:/.test(content);
    return hasYamlStructure || hasExpectedFields;
  }
  /**
   * Format tool arguments for display
   */
  formatToolArguments(args) {
    try {
      const parsed = JSON.parse(args);
      return JSON.stringify(parsed, null, 2);
    } catch (e) {
      return args;
    }
  }
  /**
   * Reconstruct message parts from chronological content blocks for consistency
   */
  reconstructMessagePartsFromContent(content, reasoning, toolCalls) {
    const parts = [];
    let timestamp = Date.now();
    let toolCallIndex = 0;
    const blockPattern = /<!-- REASONING-BLOCK -->\n([\s\S]*?)\n<!-- \/REASONING-BLOCK -->|<!-- TOOL-CALL-DATA\n([\s\S]*?)\n-->|<!-- CONTENT-PART -->\n([\s\S]*?)\n<!-- \/CONTENT-PART -->/g;
    let match;
    while ((match = blockPattern.exec(content)) !== null) {
      if (match[1]) {
        const reasoningTimestamp = timestamp++;
        parts.push({
          id: `reasoning-${reasoningTimestamp}`,
          type: "reasoning",
          timestamp: reasoningTimestamp,
          data: match[1].trimEnd()
          // Only trim trailing whitespace, preserve internal formatting
        });
      } else if (match[2]) {
        try {
          const toolCallData = JSON.parse(match[2]);
          const toolCallTimestamp = timestamp++;
          parts.push({
            id: `tool_call-${toolCallTimestamp}`,
            type: "tool_call",
            timestamp: toolCallTimestamp,
            data: toolCallData
          });
        } catch (error) {
        }
      } else if (match[3]) {
        const contentTimestamp = timestamp++;
        parts.push({
          id: `content-${contentTimestamp}`,
          type: "content",
          timestamp: contentTimestamp,
          data: match[3].trim()
        });
      }
    }
    const foundToolCallIds = new Set(
      parts.filter((p) => p.type === "tool_call").map((p) => p.data.id)
    );
    if (toolCalls && toolCalls.length > 0) {
      toolCalls.forEach((toolCall) => {
        if (!foundToolCallIds.has(toolCall.id)) {
          const toolCallTimestamp = timestamp++;
          parts.push({
            id: `tool_call-${toolCallTimestamp}`,
            type: "tool_call",
            timestamp: toolCallTimestamp,
            data: toolCall
          });
        }
      });
    }
    if (parts.length === 0) {
      if (reasoning) {
        const reasoningTimestamp = timestamp++;
        parts.push({
          id: `reasoning-${reasoningTimestamp}`,
          type: "reasoning",
          timestamp: reasoningTimestamp,
          data: reasoning
        });
      }
      const cleanContent = this.extractNonChronologicalContent(content);
      if (cleanContent.trim()) {
        const contentTimestamp = timestamp++;
        parts.push({
          id: `content-${contentTimestamp}`,
          type: "content",
          timestamp: contentTimestamp,
          data: cleanContent
        });
      }
    }
    if (parts.length > 0) {
      const cleanContent = this.extractNonChronologicalContent(content);
      if (cleanContent.trim()) {
        const hasContentPart = parts.some((p) => p.type === "content");
        if (!hasContentPart) {
          const contentTimestamp = timestamp++;
          parts.push({
            id: `content-${contentTimestamp}`,
            type: "content",
            timestamp: contentTimestamp,
            data: cleanContent
          });
        }
      }
    }
    return parts;
  }
  /**
   * Extract only the non-chronological content (regular text) from storage content
   */
  extractNonChronologicalContent(content) {
    let cleaned = content.replace(/<!-- REASONING-BLOCK -->\n[\s\S]*?\n<!-- \/REASONING-BLOCK -->/g, "").replace(/<!-- TOOL-CALL-DATA\n[\s\S]*?\n-->/g, "").replace(/<!-- CONTENT-PART -->\n[\s\S]*?\n<!-- \/CONTENT-PART -->/g, "");
    cleaned = cleaned.replace(/\n\n\n+/g, "\n\n").trim();
    return cleaned;
  }
  /**
   * Check if content contains chronological blocks from storage
   */
  containsChronologicalBlocks(content) {
    return content.includes("<!-- REASONING-BLOCK -->") || content.includes("<!-- TOOL-CALL-DATA") || content.includes("<!-- CONTENT-PART -->");
  }
  /**
   * Parse legacy chat file format (old ````user/````ai format)
   */
  parseFiveBacktickLegacyFile(content, filename) {
    try {
      const messages = [];
      const timestamp = Date.now();
      const chatId = filename || this.generateMessageId();
      const contextFiles = [];
      const contextSection = content.match(/# Context Files\n([\s\S]*?)(?=# AI Chat History|$)/);
      if (contextSection && contextSection[1]) {
        const links = contextSection[1].match(/\[\[(.*?)\]\]/g);
        if (links) {
          contextFiles.push(...links.map((link) => link.replace(/\[\[(.*?)\]\]/, "$1")));
        }
      }
      const messageRegex = /`{4,5}(user|ai(?:-[\w-]+)?)\n([\s\S]*?)\n`{4,5}/g;
      let match;
      while ((match = messageRegex.exec(content)) !== null) {
        const rolePrefix = match[1];
        const messageContent = match[2].trim();
        let role;
        if (rolePrefix === "user") {
          role = "user";
        } else if (rolePrefix.startsWith("ai")) {
          role = "assistant";
        } else {
          continue;
        }
        const messageId = this.generateMessageId();
        messages.push({
          role,
          content: messageContent,
          message_id: messageId
        });
      }
      let title = "Legacy Chat";
      const firstUserMessage = messages.find((m) => m.role === "user");
      if (firstUserMessage && typeof firstUserMessage.content === "string") {
        title = firstUserMessage.content.substring(0, 50).replace(/\n/g, " ").trim();
        if (title.length >= 50) title += "...";
      }
      const result = {
        id: chatId,
        messages,
        selectedModelId: "gpt-4o",
        // Default model for legacy files
        lastModified: timestamp,
        title,
        version: 0,
        context_files: contextFiles.length > 0 ? contextFiles : void 0,
        systemPromptType: "general-use"
      };
      return result;
    } catch (error) {
      return null;
    }
  }
  /**
   * Fallback parsing for files that might be corrupted or in old format
   */
  tryFallbackParsing(content) {
    try {
      const timestamp = Date.now();
      const fallbackId = this.generateMessageId();
      const messages = [];
      const messageRegex = /(?:^|\n)\s*<!--\s*SYSTEMSCULPT-MESSAGE-START\s*role=[\'\"]?(user|assistant)[\'\"]?\s*message-id=[\'\"]?([^\'\"\\s>]+)[\'\"]?\s*-->\s*([\s\S]*?)\s*<!--\s*SYSTEMSCULPT-MESSAGE-END\s*-->(?=\s*(?:\n|$))/gm;
      let msgMatch;
      while ((msgMatch = messageRegex.exec(content)) !== null) {
        const role = msgMatch[1];
        const messageId = msgMatch[2];
        const messageContent = msgMatch[3];
        messages.push({
          role,
          content: messageContent.trim(),
          message_id: messageId
        });
      }
      if (messages.length > 0) {
        return {
          id: fallbackId,
          messages,
          selectedModelId: "gpt-3.5-turbo",
          // Default fallback model
          lastModified: timestamp,
          title: "Recovered Chat",
          version: 0,
          systemPromptType: "general-use"
        };
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  async getMetadata(chatId) {
    try {
      const filePath = `${this.chatDirectory}/${chatId}.md`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!(file instanceof import_obsidian56.TFile)) {
        return null;
      }
      const content = await this.app.vault.read(file);
      return this.parseMetadata(content);
    } catch (error) {
      return null;
    }
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  standardizeToolCalls(toolCalls, messageId) {
    if (!toolCalls) return [];
    return toolCalls.map((tc) => {
      var _a;
      if ((_a = tc.request) == null ? void 0 : _a.function) {
        if (tc.result && tc.result.success === void 0) {
          tc.result = { success: true, data: tc.result };
        }
        return tc;
      }
      if (tc.function) {
        const result = tc.result;
        let standardizedResult = void 0;
        if (result) {
          if (result.success !== void 0) {
            standardizedResult = result;
          } else {
            standardizedResult = { success: true, data: result };
          }
        }
        return {
          id: tc.id,
          messageId,
          request: {
            id: tc.id,
            type: tc.type,
            function: tc.function
          },
          state: tc.state || "completed",
          timestamp: tc.timestamp || Date.now(),
          autoApproved: tc.autoApproved || false,
          result: standardizedResult
        };
      }
      return tc;
    });
  }
};

// src/views/chatview/ChatView.ts
init_ui();
init_errors();

// src/views/chatview/MessageRenderer.ts
var import_obsidian66 = require("obsidian");
init_workspaceUtils();

// src/views/chatview/utils/MessagePartNormalizer.ts
var MessagePartNormalizer = class {
  /** Returns a chronologically sorted parts array for the given message. */
  static toParts(message) {
    const parts = [];
    let timestamp = 0;
    if (message.messageParts && message.messageParts.length > 0) {
      return [...message.messageParts].sort((a, b) => a.timestamp - b.timestamp);
    }
    if (message.reasoning) {
      parts.push({
        id: `reasoning-${timestamp}`,
        type: "reasoning",
        timestamp: timestamp++,
        data: message.reasoning
      });
    }
    if (message.tool_calls && message.tool_calls.length > 0) {
      message.tool_calls.forEach((tc) => {
        parts.push({
          id: `tool_call_part-${tc.id}`,
          type: "tool_call",
          timestamp: timestamp++,
          data: tc
        });
      });
    }
    if (typeof message.content === "string" && message.content.trim()) {
      parts.push({
        id: `content-${timestamp}`,
        type: "content",
        timestamp: timestamp++,
        data: message.content
      });
    }
    return parts;
  }
};

// src/views/chatview/utils/reasoningFormat.ts
var FUSED_BOLD_HEADING = /([^\s])(\*\*[^*\n]+?\*\*(?=\s*(?:\r?\n)))/g;
function formatReasoningForDisplay(markdown) {
  if (!markdown) return markdown;
  return markdown.replace(FUSED_BOLD_HEADING, (_match, precedingChar, heading) => {
    return `${precedingChar}

${heading}`;
  });
}

// src/views/chatview/utils/treeConnectors.ts
init_errorLogger();
var TREE_HEADER_SYMBOL = "+";
var TREE_LINE_SELECTOR = ".systemsculpt-chat-structured-line";
var TREE_PREFIX_SELECTOR = ".systemsculpt-chat-structured-line-prefix";
var TREE_WRAPPER_SELECTOR = ".systemsculpt-chat-structured-block";
var THEMES = {
  box: {
    branch: "\u251C\u2500\u2500 ",
    end: "\u2514\u2500\u2500 ",
    vertical: "\u2502   ",
    gap: "    ",
    bullet: "\u25CF"
  },
  ascii: {
    branch: "|- ",
    end: "`- ",
    vertical: "|  ",
    gap: "   ",
    bullet: "+"
  }
};
var activeTheme = THEMES.box;
function normalizeDepth(rawDepth) {
  const parsed = Number.parseInt(rawDepth != null ? rawDepth : "", 10);
  return Number.isFinite(parsed) && parsed > 0 ? parsed : 1;
}
function isEffectivelyVisible(descriptor) {
  var _a, _b, _c, _d;
  const { lineEl, hidden } = descriptor;
  if (!lineEl || hidden) return false;
  if (lineEl.hidden) return false;
  if (lineEl.getAttribute("hidden") !== null) return false;
  const display = (_d = (_c = (_b = (_a = lineEl.style) == null ? void 0 : _a.display) == null ? void 0 : _b.toLowerCase) == null ? void 0 : _c.call(_b)) != null ? _d : "";
  if (display === "none") return false;
  const ariaHidden = lineEl.getAttribute("aria-hidden");
  if (ariaHidden === "true") return false;
  if (lineEl.dataset.treeHidden === "true") return false;
  return true;
}
function computeIsLastFlags(nodes) {
  for (let index = 0; index < nodes.length; index += 1) {
    const current = nodes[index];
    let isLast = true;
    for (let scan = index + 1; scan < nodes.length; scan += 1) {
      const next = nodes[scan];
      if (next.depth < current.depth) {
        break;
      }
      if (next.depth === current.depth && isEffectivelyVisible(next)) {
        isLast = false;
        break;
      }
    }
    current.isLast = isLast;
  }
}
function buildDescriptors(rawNodes) {
  var _a, _b;
  const descriptors = [];
  for (const rawNode of rawNodes) {
    const lineEl = rawNode.lineEl;
    if (!lineEl) continue;
    const prefixEl = (_a = rawNode.prefixEl) != null ? _a : lineEl.querySelector(TREE_PREFIX_SELECTOR);
    if (!prefixEl) continue;
    const depth = (_b = rawNode.depth) != null ? _b : normalizeDepth(lineEl.dataset.treeDepth);
    descriptors.push({ lineEl, prefixEl, depth, hidden: rawNode.hidden });
  }
  return descriptors;
}
function applyLayout(nodes, theme, options) {
  if (nodes.length === 0) {
    return;
  }
  computeIsLastFlags(nodes);
  const branchContinuations = [];
  for (const node of nodes) {
    const depthIndex = Math.max(1, node.depth);
    const parentDepthCount = depthIndex - 1;
    if (branchContinuations.length > parentDepthCount) {
      branchContinuations.length = parentDepthCount;
    }
    const segments = [];
    for (let idx = 0; idx < parentDepthCount; idx += 1) {
      segments.push(branchContinuations[idx] ? theme.vertical : theme.gap);
    }
    const isEnd = (options == null ? void 0 : options.forceEnd) ? true : node.isLast;
    const finalSegment = isEnd ? theme.end : theme.branch;
    segments.push(finalSegment);
    if (node.prefixEl) {
      const prefix = segments.join("");
      node.prefixEl.textContent = prefix;
      node.prefixEl.dataset.treePrefix = prefix.trim();
      node.prefixEl.setAttribute("aria-hidden", "true");
      node.prefixEl.title = node.isLast ? "Last item in this tree" : "More items follow";
    }
    node.lineEl.dataset.treeConnector = isEnd ? "end" : "branch";
    node.lineEl.dataset.treeDepth = String(depthIndex);
    branchContinuations[parentDepthCount] = !isEnd && isEffectivelyVisible(node);
  }
  updateWrapperBullets(nodes, theme);
  debugLog("layout-applied", {
    nodeCount: nodes.length,
    depths: Array.from(new Set(nodes.map((node) => node.depth))).sort((a, b) => a - b)
  });
}
function updateWrapperBullets(nodes, theme) {
  const wrappers = /* @__PURE__ */ new Set();
  nodes.forEach((node) => {
    const wrapper = node.lineEl.closest(TREE_WRAPPER_SELECTOR);
    if (wrapper) wrappers.add(wrapper);
  });
  wrappers.forEach((wrapper) => {
    const bullet = wrapper.querySelector(".systemsculpt-chat-structured-bullet");
    if (!bullet) return;
    if (bullet.classList.contains("is-active") || bullet.classList.contains("is-failed") || bullet.classList.contains("is-denied")) {
      return;
    }
    if (!bullet.textContent || bullet.textContent.trim().length === 0) {
      bullet.textContent = theme.bullet;
      bullet.dataset.treePrefix = theme.bullet;
    }
  });
}
function applyTreeLayout(nodes, options) {
  var _a;
  const theme = (options == null ? void 0 : options.theme) ? (_a = THEMES[options.theme]) != null ? _a : activeTheme : activeTheme;
  const descriptors = buildDescriptors(nodes).filter((descriptor) => isEffectivelyVisible(descriptor));
  const layoutNodes = descriptors.map((descriptor) => ({ ...descriptor, isLast: true }));
  applyLayout(layoutNodes, theme, { forceEnd: options == null ? void 0 : options.forceEnd });
}
function rebuildTreeConnectors(containerEl, options) {
  if (!containerEl) {
    return;
  }
  const rawNodes = Array.from(containerEl.querySelectorAll(TREE_LINE_SELECTOR)).map((lineEl) => ({
    lineEl,
    prefixEl: lineEl.querySelector(TREE_PREFIX_SELECTOR),
    depth: normalizeDepth(lineEl.dataset.treeDepth),
    hidden: lineEl.dataset.treeHidden === "true"
  }));
  applyTreeLayout(rawNodes, options);
}
function seedTreeLine(lineEl, depth = 1, isLast = true, options) {
  var _a;
  if (!lineEl) return;
  const theme = (options == null ? void 0 : options.theme) ? (_a = THEMES[options.theme]) != null ? _a : activeTheme : activeTheme;
  const prefixEl = lineEl.querySelector(TREE_PREFIX_SELECTOR);
  const normalizedDepth = Math.max(1, depth);
  const segments = [];
  for (let idx = 1; idx < normalizedDepth; idx += 1) {
    segments.push(theme.gap);
  }
  segments.push(isLast ? theme.end : theme.branch);
  const prefix = segments.join("");
  if (prefixEl) {
    prefixEl.textContent = prefix;
    prefixEl.dataset.treePrefix = prefix.trim();
    prefixEl.setAttribute("aria-hidden", "true");
    prefixEl.title = isLast ? "Last item in this tree" : "More items follow";
  }
  lineEl.dataset.treeDepth = String(normalizedDepth);
  lineEl.dataset.treeConnector = isLast ? "end" : "branch";
}
function setBulletSymbol(bulletEl, symbol) {
  if (!bulletEl) {
    return;
  }
  bulletEl.textContent = symbol;
  bulletEl.dataset.treePrefix = symbol.trim();
}
function debugLog(event, metadata) {
  try {
    errorLogger.debug("Tree connectors", {
      source: "TreeConnectors",
      method: event,
      metadata
    });
  } catch (e) {
  }
}

// src/views/chatview/renderers/MarkdownMessageRenderer.ts
var import_obsidian58 = require("obsidian");
var import_obsidian59 = require("obsidian");

// src/modals/MermaidPreviewModal.ts
var import_obsidian57 = require("obsidian");
var MermaidPreviewModal = class extends import_obsidian57.Modal {
  constructor(app, code) {
    super(app);
    this.code = code;
  }
  onOpen() {
    const { contentEl, modalEl } = this;
    modalEl.addClass("systemsculpt-mermaid-preview-modal");
    const header = contentEl.createDiv({ cls: "ss-mermaid-preview-header" });
    header.createEl("h2", { text: "Mermaid Diagram" });
    const closeBtn = header.createDiv({ cls: "ss-mermaid-preview-close" });
    (0, import_obsidian57.setIcon)(closeBtn, "x");
    closeBtn.addEventListener("click", () => this.close());
    const diagramContainer = contentEl.createDiv({ cls: "ss-mermaid-preview-diagram mermaid" });
    diagramContainer.textContent = this.code;
    const m = globalThis.mermaid;
    if (m && typeof m.init === "function") {
      try {
        m.init(void 0, diagramContainer);
      } catch (err) {
      }
    }
    const footer = contentEl.createDiv({ cls: "ss-mermaid-preview-footer" });
    const copyBtn = footer.createEl("button", { cls: "ss-mermaid-copy-btn", text: "Copy Code" });
    copyBtn.addEventListener("click", () => {
      navigator.clipboard.writeText(this.code).then(() => {
        new import_obsidian57.Notice("Mermaid code copied to clipboard");
      });
    });
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/views/chatview/renderers/MarkdownMessageRenderer.ts
var MarkdownMessageRenderer = class extends import_obsidian58.Component {
  constructor(app) {
    super();
    // Per-container throttling state used to coalesce frequent streaming updates
    this.throttledRenderers = /* @__PURE__ */ new WeakMap();
    this.RENDER_THROTTLE_MS = 100;
    this.app = app;
  }
  /**
   * Render markdown into the given element.  When `isStreaming` is true we
   * debounce the expensive Obsidian markdown renderer so that bursts of very
   * small updates (token streaming) don't flood the DOM.
   */
  async render(content, containerEl, isStreaming = false) {
    var _a;
    content = this.preprocessMermaid(content);
    if (isStreaming) {
      const isHidden = document.hidden;
      const isOffscreen = !containerEl.isConnected || !this.isElementVisible(containerEl);
      this.RENDER_THROTTLE_MS = isHidden || isOffscreen ? 250 : 100;
      try {
        const messagesContainer = containerEl.closest(".systemsculpt-messages-container");
        const ds = (_a = messagesContainer == null ? void 0 : messagesContainer.dataset) == null ? void 0 : _a.autoscroll;
        const isAnchored = ds === void 0 ? true : ds !== "false";
        if (messagesContainer && isAnchored === false) {
          let state2 = this.throttledRenderers.get(containerEl);
          if (!state2) {
            const newState = { timeoutId: null, content: "" };
            this.throttledRenderers.set(containerEl, newState);
            state2 = newState;
          }
          state2.content = content;
          return;
        }
      } catch (e) {
      }
      this.throttledRender(containerEl, content);
      return;
    }
    const state = this.throttledRenderers.get(containerEl);
    if (state == null ? void 0 : state.timeoutId) {
      clearTimeout(state.timeoutId);
      state.timeoutId = null;
    }
    containerEl.empty();
    await import_obsidian58.MarkdownRenderer.render(this.app, content, containerEl, "systemsculpt-chat.md", this);
    this.postProcess(containerEl);
    try {
      containerEl.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
    } catch (e) {
    }
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  Citations
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderCitations(contentEl, citations) {
    if (citations.length === 0) return;
    const citationsContainer = contentEl.createEl("div", {
      cls: "systemsculpt-citations-container"
    });
    citationsContainer.createEl("hr", { cls: "systemsculpt-citations-divider" });
    citationsContainer.createEl("div", {
      cls: "systemsculpt-citations-header",
      text: "Sources"
    });
    const citationsList = citationsContainer.createEl("ol", {
      cls: "systemsculpt-citations-list"
    });
    citations.forEach((citation, index) => {
      const li = citationsList.createEl("li", { cls: "systemsculpt-citation-item" });
      const displayTitle = citation.title || new URL(citation.url).hostname;
      li.createEl("a", {
        cls: "systemsculpt-citation-title",
        text: displayTitle,
        attr: {
          href: citation.url,
          target: "_blank",
          rel: "noopener noreferrer"
        }
      });
      li.createEl("div", {
        cls: "systemsculpt-citation-url",
        text: citation.url
      });
    });
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  //  Internal helpers
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  throttledRender(containerEl, content) {
    let state = this.throttledRenderers.get(containerEl);
    if (!state) {
      state = { timeoutId: null, content: "" };
      this.throttledRenderers.set(containerEl, state);
    }
    state.content = content;
    if (state.timeoutId) return;
    state.timeoutId = setTimeout(async () => {
      const current = this.throttledRenderers.get(containerEl);
      if (!current) return;
      current.timeoutId = null;
      if (!containerEl.isConnected) {
        this.throttledRenderers.delete(containerEl);
        return;
      }
      containerEl.empty();
      await import_obsidian58.MarkdownRenderer.render(this.app, current.content, containerEl, "systemsculpt-chat.md", this);
      this.postProcess(containerEl);
      this.app.workspace.trigger("systemsculpt:content-rendered");
      try {
        containerEl.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
      } catch (e) {
      }
    }, this.RENDER_THROTTLE_MS);
  }
  isElementVisible(el) {
    try {
      const rect = el.getBoundingClientRect();
      const vh = window.innerHeight || document.documentElement.clientHeight;
      const vw = window.innerWidth || document.documentElement.clientWidth;
      return rect.bottom >= 0 && rect.right >= 0 && rect.top <= vh && rect.left <= vw;
    } catch (e) {
      return true;
    }
  }
  /**
   * Post-processing that needs to run after every markdown render (final or
   * throttled) â€“ currently adds code-block styling and click handlers for
   * app:// links on images.
   */
  postProcess(container) {
    container.querySelectorAll("pre").forEach((pre) => {
      pre.classList.add("systemsculpt-code-block");
      if (!pre.querySelector(".copy-code-button")) {
        const btn = document.createElement("button");
        btn.className = "copy-code-button";
        btn.type = "button";
        btn.setAttribute("aria-label", "Copy code");
        btn.textContent = "Copy";
        btn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          try {
            const codeEl = pre.querySelector("code");
            const text = codeEl ? codeEl.innerText : pre.innerText;
            await navigator.clipboard.writeText(text);
            btn.textContent = "Copied";
            setTimeout(() => btn.textContent = "Copy", 1200);
            new import_obsidian58.Notice("Code copied to clipboard", 1500);
          } catch (e2) {
            new import_obsidian58.Notice("Failed to copy code", 2e3);
          }
        });
        pre.appendChild(btn);
      }
    });
    container.querySelectorAll("img").forEach((img) => {
      img.addClass("systemsculpt-message-image");
      img.style.cursor = "pointer";
      img.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const src = img.getAttribute("src");
        if (!src) return;
        if (src.startsWith("app://")) {
          const path = src.replace("app://local/", "");
          this.app.workspace.openLinkText(path, "", true);
        }
      });
      try {
        img.addEventListener("load", () => {
          try {
            img.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
          } catch (e) {
          }
        }, { once: true });
      } catch (e) {
      }
    });
    container.querySelectorAll("a.internal-link").forEach((link) => {
      link.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const href = link.getAttribute("href") || link.getAttribute("data-href");
        if (href) {
          this.app.workspace.openLinkText(href, "", true);
        }
      });
    });
    this.postProcessMermaid(container);
  }
  postProcessMermaid(containerEl) {
    const mermaidDivs = containerEl.querySelectorAll(".mermaid");
    mermaidDivs.forEach((div) => {
      var _a;
      const raw = (_a = div.textContent) != null ? _a : "";
      let fixed = raw;
      fixed = fixed.replace(/\[([\s\S]*?)\]/g, (m2, p1) => `[${p1.replace(/\n+/g, " ")}]`);
      fixed = fixed.replace(/([\w-]+)\(\[([\s\S]*?)\]\)/g, '$1["$2"]');
      fixed = fixed.replace(/([\w-]+)\[([^\]]+?)\]/g, '$1["$2"]');
      if (fixed !== raw) {
        div.textContent = fixed;
      }
      const m = globalThis.mermaid;
      if (m && typeof m.init === "function") {
        try {
          m.init(void 0, div);
        } catch (err) {
        }
      }
      if (!div.dataset.ssExpand) {
        div.dataset.ssExpand = "true";
        const btn = div.createDiv({ cls: "systemsculpt-mermaid-expand-btn" });
        (0, import_obsidian59.setIcon)(btn, "maximize-2");
        btn.setAttribute("aria-label", "Expand diagram");
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          new MermaidPreviewModal(this.app, fixed).open();
        });
      }
    });
  }
  /**
   * Light-weight regex fixes applied directly to the raw markdown string so core Mermaid never
   * sees the bad syntax that causes the NODE_DSTART errors.
   */
  preprocessMermaid(markdown) {
    const fenceRegex = /```mermaid[ \t]*\n([\s\S]*?)\n```/g;
    return markdown.replace(fenceRegex, (_full, code) => {
      let fixed = code;
      fixed = fixed.replace(/\[([\s\S]*?)\]/g, (m, p1) => `[${p1.replace(/\n+/g, " ")}]`);
      fixed = fixed.replace(/([\w-]+)\(\[([\s\S]*?)\]\)/g, '$1["$2"]');
      fixed = fixed.replace(/([\w-]+)\[([^\]]+?)\]/g, '$1["$2"]');
      fixed = fixed.replace(/\]\)([ \t]+)([\w-]+[\[\(])/g, "])\n  $2");
      return `\`\`\`mermaid
${fixed}
\`\`\``;
    });
  }
};

// src/views/chatview/ui/MessageToolbar.ts
var import_obsidian60 = require("obsidian");
init_devlog();
init_PlatformContext();
var TOOLBAR_DEVLOG_PATH = "SystemSculpt/devlogs/chat-toolbar.log";
function logToolbarEvent(app, messageId, event, payload) {
  appendDevlogEntry(
    app,
    TOOLBAR_DEVLOG_PATH,
    {
      messageId,
      event,
      ...payload
    },
    {
      consoleLabel: "Toolbar"
    }
  );
}
function getMessageText(messageEl) {
  const contentParts = Array.from(
    messageEl.querySelectorAll(".systemsculpt-content-part")
  );
  if (contentParts.length > 0) {
    return contentParts.map((el) => (el.textContent || "").trim()).filter(Boolean).join("\n").trim();
  }
  const legacy = messageEl.querySelector(
    ".systemsculpt-message-content"
  );
  return ((legacy == null ? void 0 : legacy.textContent) || "").trim();
}
function createIconButton(name, ariaLabel, onClick) {
  const btn = document.createElement("button");
  btn.className = "systemsculpt-toolbar-btn";
  btn.setAttribute("type", "button");
  btn.setAttribute("aria-label", ariaLabel);
  (0, import_obsidian60.setIcon)(btn, name);
  btn.addEventListener("click", (ev) => {
    ev.preventDefault();
    ev.stopPropagation();
    onClick(ev);
  });
  return btn;
}
function attachMessageToolbar(options) {
  const { app, messageEl, role, messageId } = options;
  if (messageEl.querySelector(".systemsculpt-message-toolbar")) return;
  const contentParts = messageEl.querySelectorAll(
    ".systemsculpt-content-part"
  );
  const anchor = contentParts.length ? contentParts[contentParts.length - 1] : messageEl.querySelector(
    ".systemsculpt-message-content"
  ) || messageEl;
  const toolbar = document.createElement("div");
  toolbar.className = "systemsculpt-message-toolbar";
  const platform = PlatformContext.get();
  const uiVariant = platform.uiVariant();
  const isMobile = import_obsidian60.Platform.isMobile || uiVariant === "mobile";
  toolbar.classList.add(`platform-ui-${isMobile ? "mobile" : "desktop"}`);
  if (messageEl.classList.contains("systemsculpt-user-message")) {
    toolbar.classList.add("is-user");
  } else if (messageEl.classList.contains("systemsculpt-assistant-message")) {
    toolbar.classList.add("is-assistant");
  }
  if (isMobile) toolbar.classList.add("is-mobile");
  const copyBtn = createIconButton("copy", "Copy message", async () => {
    const text = getMessageText(messageEl) || messageEl.dataset.content || "";
    try {
      await navigator.clipboard.writeText(text);
      (0, import_obsidian60.setIcon)(copyBtn, "check");
      copyBtn.classList.add("ss-success");
      copyBtn.setAttribute("aria-label", "Copied");
      setTimeout(() => {
        (0, import_obsidian60.setIcon)(copyBtn, "copy");
        copyBtn.classList.remove("ss-success");
        copyBtn.setAttribute("aria-label", "Copy message");
      }, 1200);
    } catch (e) {
    }
  });
  if (isMobile) {
    const moreBtn = createIconButton("more-horizontal", "More", () => {
      toolbar.classList.toggle("ss-open");
    });
    moreBtn.classList.add("systemsculpt-toolbar-more");
    toolbar.appendChild(moreBtn);
  }
  toolbar.appendChild(copyBtn);
  if (role === "user") {
    const resendBtn = createIconButton("refresh-ccw", "Resend", () => {
    });
    let isConfirmingResend = false;
    let confirmTimer = null;
    const resetConfirm = () => {
      if (!isConfirmingResend) return;
      isConfirmingResend = false;
      if (confirmTimer) {
        window.clearTimeout(confirmTimer);
        confirmTimer = null;
      }
      (0, import_obsidian60.setIcon)(resendBtn, "refresh-ccw");
      resendBtn.classList.remove("ss-confirm");
      resendBtn.setAttribute("aria-label", "Resend");
      resendBtn.removeAttribute("title");
    };
    resendBtn.addEventListener("click", (ev) => {
      ev.preventDefault();
      ev.stopPropagation();
      if (!isConfirmingResend) {
        isConfirmingResend = true;
        (0, import_obsidian60.setIcon)(resendBtn, "help-circle");
        resendBtn.classList.add("ss-confirm");
        resendBtn.setAttribute("aria-label", "Confirm resend");
        resendBtn.setAttribute("title", "Are you sure?");
        confirmTimer = window.setTimeout(() => {
          resetConfirm();
        }, 2500);
        return;
      }
      const content = messageEl.dataset.content || getMessageText(messageEl) || "";
      messageEl.dispatchEvent(
        new CustomEvent("resubmit", {
          bubbles: true,
          detail: { messageId, content }
        })
      );
      resetConfirm();
    });
    toolbar.addEventListener("mouseleave", () => {
      resetConfirm();
    });
    toolbar.appendChild(resendBtn);
  }
  if (role === "assistant") {
    const replyBtn = createIconButton("corner-down-left", "Reply", () => {
      const content = getMessageText(messageEl);
      messageEl.dispatchEvent(
        new CustomEvent("reply", {
          bubbles: true,
          detail: { messageId, content }
        })
      );
    });
    toolbar.appendChild(replyBtn);
  }
  const deleteBtn = createIconButton("trash", "Delete message", () => {
    messageEl.dispatchEvent(
      new CustomEvent("delete", { bubbles: true, detail: { messageId } })
    );
  });
  toolbar.appendChild(deleteBtn);
  anchor.appendChild(toolbar);
  let lastLayoutSignature = null;
  const updateToolbarPosition = () => {
    const container = messageEl.closest(
      ".systemsculpt-messages-container"
    );
    const containerRect = (container == null ? void 0 : container.getBoundingClientRect()) || document.body.getBoundingClientRect();
    toolbar.style.setProperty("--ss-toolbar-shift-x", "0px");
    const anchorRect = anchor.getBoundingClientRect();
    const availableBelow = containerRect.bottom - anchorRect.bottom;
    const requiredClearance = toolbar.offsetHeight + 12;
    const shouldFlip = availableBelow < requiredClearance;
    toolbar.classList.toggle("ss-flip-up", shouldFlip);
    const toolbarRect = toolbar.getBoundingClientRect();
    const horizontalPadding = 8;
    const minLeft = containerRect.left + horizontalPadding;
    const maxRight = containerRect.right - horizontalPadding;
    const leftOverflow = Math.max(0, minLeft - toolbarRect.left);
    const rightOverflow = Math.max(0, toolbarRect.right - maxRight);
    let horizontalShift = 0;
    if (leftOverflow > 0 && rightOverflow > 0) {
      const toolbarCenter = (toolbarRect.left + toolbarRect.right) / 2;
      const containerCenter = (minLeft + maxRight) / 2;
      horizontalShift = containerCenter - toolbarCenter;
    } else if (leftOverflow > 0) {
      horizontalShift = leftOverflow;
    } else if (rightOverflow > 0) {
      horizontalShift = -rightOverflow;
    }
    if (horizontalShift !== 0) {
      toolbar.style.setProperty(
        "--ss-toolbar-shift-x",
        `${Math.round(horizontalShift)}px`
      );
    }
    const layoutSignature = `${shouldFlip ? "up" : "down"}:${Math.round(
      horizontalShift
    )}:${Math.round(toolbarRect.width)}`;
    if (layoutSignature !== lastLayoutSignature) {
      lastLayoutSignature = layoutSignature;
      logToolbarEvent(app, messageId, "toolbar-layout", {
        flipDirection: shouldFlip ? "up" : "down",
        horizontalShift: Math.round(horizontalShift),
        containerWidth: Math.round(containerRect.width),
        toolbarWidth: Math.round(toolbarRect.width),
        anchorWidth: Math.round(anchorRect.width)
      });
    }
  };
  anchor.addEventListener("mouseenter", updateToolbarPosition, { passive: true });
  toolbar.addEventListener("mouseenter", updateToolbarPosition, { passive: true });
  requestAnimationFrame(() => {
    updateToolbarPosition();
  });
  logToolbarEvent(app, messageId, "toolbar-attached", {
    role,
    isMobile
  });
}

// src/views/chatview/renderers/ToolCallTreeRenderer.ts
var import_obsidian65 = require("obsidian");
init_toolDisplay();
init_toolCallPreview();
init_inline_diff();
init_errorLogger();

// src/views/chatview/ui/ToolCallApprovalDeck.ts
var import_obsidian64 = require("obsidian");

// src/views/chatview/ui/ApprovalPanel.ts
var import_obsidian63 = require("obsidian");
init_toolDisplay();
init_toolCallPreview();
var ApprovalPanel = class extends import_obsidian63.Component {
  constructor(opts) {
    var _a;
    super();
    this.app = opts.app;
    this.host = opts.host;
    this.toolCall = opts.toolCall;
    this.variant = (_a = opts.variant) != null ? _a : "inline";
  }
  onload() {
    this.render();
  }
  render() {
    var _a, _b, _c, _d;
    const panel = this.host.createDiv({ cls: "ss-approval-card" });
    panel.dataset.toolCallId = this.toolCall.id;
    panel.dataset.variant = this.variant;
    if (this.variant === "deck") {
      panel.classList.add("ss-approval-card--deck");
    }
    const header = panel.createDiv({ cls: "ss-approval-header" });
    const left = header.createDiv({ cls: "ss-approval-head-left" });
    const right = header.createDiv({ cls: "ss-approval-actions" });
    const title = left.createDiv({ cls: "ss-approval-title" });
    const subtitle = left.createDiv({ cls: "ss-approval-subtitle" });
    const fn = getFunctionDataFromToolCall(this.toolCall);
    const args = this.resolveArguments(fn);
    const base = (_b = (_a = fn == null ? void 0 : fn.name) == null ? void 0 : _a.replace(/^mcp[-_][^_]+_/, "")) != null ? _b : "";
    const pretty = this.prettyOpName(base);
    title.textContent = `${pretty}`;
    subtitle.textContent = this.subtitleFor((_c = fn == null ? void 0 : fn.arguments) != null ? _c : {});
    const approveClasses = ["ss-button", "ss-button--primary"];
    const denyClasses = ["ss-button", "ss-button--secondary"];
    if (this.variant === "deck") {
      approveClasses.push("ss-button--compact");
      denyClasses.push("ss-button--compact");
    }
    this.approveBtn = right.createEl("button", { cls: approveClasses.join(" "), text: "Approve & Run" });
    this.denyBtn = right.createEl("button", { cls: denyClasses.join(" "), text: "Deny" });
    this.approveBtn.addEventListener("click", () => this.dispatchDecision(true));
    this.denyBtn.addEventListener("click", () => this.dispatchDecision(false));
    const body = panel.createDiv({ cls: "ss-approval-body" });
    const details = body.createDiv({ cls: "ss-approval-details" });
    const name = (_d = fn == null ? void 0 : fn.name) != null ? _d : "";
    const rendered = this.renderSpecializedPreview(details, name);
    if (!rendered) {
      this.renderJsonFallback(details, args);
    }
  }
  dispatchDecision(approved) {
    this.approveBtn.disabled = true;
    this.denyBtn.disabled = true;
    this.host.dispatchEvent(new CustomEvent("tool-approval", {
      bubbles: true,
      detail: { toolCallId: this.toolCall.id, approved }
    }));
  }
  prettyOpName(base) {
    if (base === "write") return "Write File";
    if (base === "edit") return "Edit File";
    if (base === "move") return "Move Items";
    if (base === "trash") return "Trash Items";
    if (base === "create_folders") return "Create Folders";
    return base.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
  }
  subtitleFor(args) {
    if (!args) return "";
    const dst = (args == null ? void 0 : args.destination) || (args == null ? void 0 : args.target) || (args == null ? void 0 : args.to);
    if (dst) return `Destination: ${dst}`;
    const path = args == null ? void 0 : args.path;
    if (path) return `Path: ${path}`;
    const paths = Array.isArray(args == null ? void 0 : args.paths) ? args.paths : [];
    if (paths.length > 0) return `${paths.length} item(s)`;
    const items = Array.isArray(args == null ? void 0 : args.items) ? args.items : [];
    if (items.length > 0) return `${items.length} item(s)`;
    return "";
  }
  renderSpecializedPreview(container, toolName) {
    if (isWriteOrEditTool(toolName)) {
      void renderWriteEditInlineDiff(this.app, container, this.toolCall);
      return true;
    }
    if (isMoveTool(toolName) || isTrashTool(toolName) || isCreateFoldersTool(toolName)) {
      void renderOperationsInlinePreview(this.app, container, this.toolCall);
      return true;
    }
    return false;
  }
  renderJsonFallback(container, args) {
    const fallbackWrapper = container.createDiv({ cls: "ss-approval-json-fallback" });
    fallbackWrapper.createDiv({ cls: "ss-approval-json-label", text: "Arguments" });
    const pre = fallbackWrapper.createEl("pre", { cls: "ss-approval-json-pretty" });
    pre.textContent = this.stringifyArgs(args);
  }
  resolveArguments(fn) {
    var _a, _b;
    if ((fn == null ? void 0 : fn.arguments) !== void 0) {
      return fn.arguments;
    }
    const raw = (_b = (_a = this.toolCall.request) == null ? void 0 : _a.function) == null ? void 0 : _b.arguments;
    if (typeof raw === "string") {
      const trimmed = raw.trim();
      if (!trimmed) return void 0;
      try {
        return JSON.parse(trimmed);
      } catch (e) {
        return trimmed;
      }
    }
    return raw != null ? raw : void 0;
  }
  stringifyArgs(args) {
    if (args === null || args === void 0) {
      return "No arguments provided.";
    }
    if (typeof args === "string") {
      const trimmed = args.trim();
      if (!trimmed) {
        return "No arguments provided.";
      }
      try {
        return JSON.stringify(JSON.parse(trimmed), null, 2);
      } catch (e) {
        return trimmed;
      }
    }
    try {
      return JSON.stringify(args, this.circularReplacer(), 2);
    } catch (e) {
      return String(args);
    }
  }
  circularReplacer() {
    const seen = /* @__PURE__ */ new WeakSet();
    return (_key, value) => {
      if (typeof value === "object" && value !== null) {
        const obj = value;
        if (seen.has(obj)) {
          return "[Circular]";
        }
        seen.add(obj);
      }
      return value;
    };
  }
};

// src/views/chatview/ui/ToolCallApprovalDeck.ts
init_errorLogger();
var ToolCallApprovalDeck = class extends import_obsidian64.Component {
  constructor(options) {
    super();
    this.deckEl = null;
    this.entries = [];
    this.cardPanels = /* @__PURE__ */ new Map();
    this.app = options.app;
    this.host = options.host;
  }
  onunload() {
    this.teardownDeck();
  }
  sync(entries) {
    this.entries = entries.slice().sort((a, b) => a.order - b.order);
    if (this.entries.length === 0) {
      this.teardownDeck();
      return;
    }
    if (!this.deckEl) {
      this.deckEl = this.host.createDiv({ cls: "ss-approval-deck" });
    }
    this.deckEl.empty();
    this.disposePanels();
    this.renderHeader();
    this.renderGroups();
    errorLogger.debug("[ApprovalDeck] rendered deck", {
      metadata: {
        pending: this.entries.length,
        chips: this.buildSummaryChips().map((chip) => `${chip.label}:${chip.count}`),
        toolCallIds: this.entries.map((entry) => entry.toolCall.id)
      },
      source: "ToolCallApprovalDeck",
      method: "sync"
    });
  }
  buildSummaryChips() {
    var _a;
    const tallies = /* @__PURE__ */ new Map();
    for (const entry of this.entries) {
      tallies.set(entry.chipLabel, ((_a = tallies.get(entry.chipLabel)) != null ? _a : 0) + 1);
    }
    return Array.from(tallies.entries()).map(([label, count]) => ({ label, count }));
  }
  renderHeader() {
    if (!this.deckEl) return;
    const header = this.deckEl.createDiv({ cls: "ss-approval-deck__header" });
    const title = header.createDiv({ cls: "ss-approval-deck__title" });
    title.textContent = this.entries.length === 1 ? "Review 1 Change" : `Review ${this.entries.length} Changes`;
    const chipsWrap = header.createDiv({ cls: "ss-approval-deck__chips" });
    for (const chip of this.buildSummaryChips()) {
      const chipEl = chipsWrap.createDiv({ cls: "ss-approval-chip" });
      chipEl.textContent = `${chip.label} \xD7 ${chip.count}`;
    }
    const bulk = header.createDiv({ cls: "ss-approval-deck__bulk" });
    const approveAll = bulk.createEl("button", {
      cls: "ss-button ss-button--primary ss-button--compact ss-approval-bulk-approve",
      text: "Approve All"
    });
    const denyAll = bulk.createEl("button", {
      cls: "ss-button ss-button--secondary ss-button--compact ss-approval-bulk-deny",
      text: "Deny All"
    });
    approveAll.addEventListener("click", () => {
      approveAll.disabled = true;
      denyAll.disabled = true;
      for (const entry of this.entries) {
        this.dispatchDecision(entry.toolCall, true);
      }
    });
    denyAll.addEventListener("click", () => {
      approveAll.disabled = true;
      denyAll.disabled = true;
      for (const entry of this.entries) {
        this.dispatchDecision(entry.toolCall, false);
      }
    });
  }
  renderGroups() {
    var _a;
    if (!this.deckEl) return;
    const body = this.deckEl.createDiv({ cls: "ss-approval-deck__groups" });
    const groups = /* @__PURE__ */ new Map();
    for (const entry of this.entries) {
      const existing = (_a = groups.get(entry.sectionLabel)) != null ? _a : [];
      existing.push(entry);
      groups.set(entry.sectionLabel, existing);
    }
    for (const [label, items] of groups.entries()) {
      const section = body.createDiv({ cls: "ss-approval-group" });
      const header = section.createDiv({ cls: "ss-approval-group__header" });
      header.createSpan({ cls: "ss-approval-group__title", text: label });
      header.createSpan({
        cls: "ss-approval-group__meta",
        text: items.length === 1 ? "1 pending action" : `${items.length} pending actions`
      });
      const stack = section.createDiv({ cls: "ss-approval-group__stack" });
      for (const entry of items.sort((a, b) => a.order - b.order)) {
        const host = stack.createDiv({ cls: "ss-approval-card-host" });
        host.dataset.toolCallId = entry.toolCall.id;
        const panel = new ApprovalPanel({
          app: this.app,
          host,
          toolCall: entry.toolCall,
          variant: "deck"
        });
        panel.onload();
        this.cardPanels.set(entry.toolCall.id, panel);
      }
    }
  }
  dispatchDecision(toolCall, approved) {
    if (!this.deckEl) return;
    this.deckEl.dispatchEvent(
      new CustomEvent("tool-approval", {
        bubbles: true,
        detail: {
          toolCallId: toolCall.id,
          approved
        }
      })
    );
  }
  teardownDeck() {
    this.disposePanels();
    if (this.deckEl) {
      this.deckEl.remove();
      this.deckEl = null;
    }
  }
  disposePanels() {
    for (const [id, panel] of this.cardPanels.entries()) {
      try {
        panel.unload();
      } catch (error) {
        errorLogger.debug("[ApprovalDeck] panel disposal failed", {
          metadata: { toolCallId: id, error: error instanceof Error ? error.message : String(error) },
          source: "ToolCallApprovalDeck",
          method: "disposePanels"
        });
      }
    }
    this.cardPanels.clear();
  }
};

// src/views/chatview/renderers/ToolCallTreeRenderer.ts
var ACTIVITY_LABELS = {
  explore: {
    active: "Exploring",
    failed: "Exploration Failed",
    denied: "Exploration Denied",
    completed: "Explored"
  },
  mutate: {
    active: "Changing",
    failed: "Change Failed",
    denied: "Change Denied",
    completed: "Changed"
  },
  run: {
    active: "Running",
    failed: "Command Failed",
    denied: "Command Denied",
    completed: "Ran"
  }
};
var BULLET_SYMBOLS = {
  active: "",
  failed: "x",
  denied: "!",
  completed: TREE_HEADER_SYMBOL
};
var ToolCallTreeRenderer = class extends import_obsidian65.Component {
  constructor(parent) {
    super();
    this.groups = /* @__PURE__ */ new WeakMap();
    this.lineToGroup = /* @__PURE__ */ new WeakMap();
    this.approvalDecks = /* @__PURE__ */ new WeakMap();
    this.parent = parent;
  }
  notifyDomContentChanged(target) {
    try {
      target.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
    } catch (e) {
    }
  }
  /**
   * Render a tool call inside the tree summary. Returns the concrete line element used
   * for part-tracking, while the enclosing group container is reused across calls.
   */
  renderToolCallAsContent(messageEl, toolCall, index, insertAfterElement, partId, _isActivelyStreaming = false) {
    var _a;
    const group = this.ensureGroup(messageEl, insertAfterElement != null ? insertAfterElement : null);
    const resolvedPartId = partId != null ? partId : toolCall.id;
    const line = this.ensureLine(group, resolvedPartId, index);
    group.toolCalls.set(resolvedPartId, toolCall);
    this.lineToGroup.set(line, group);
    this.populateLine(line, toolCall, index);
    this.refreshLineOrder(group);
    this.rebuildAggregations(group);
    this.updateGroupState(group);
    this.syncApprovalDeck(group);
    this.maybeRenderDiffPreview(line, toolCall);
    this.maybeRenderVerboseDetails(line, toolCall);
    this.safeLog("render", toolCall, { messageId: toolCall.messageId });
    this.notifyDomContentChanged(line);
    if (typeof ((_a = this.parent) == null ? void 0 : _a.refreshStructuredBlocks) === "function") {
      this.parent.refreshStructuredBlocks(messageEl);
    }
    return line;
  }
  /**
   * Update an existing rendered line when the tool call state changes.
   */
  updateInlineDisplay(lineEl, toolCall) {
    var _a, _b, _c, _d;
    const group = this.lineToGroup.get(lineEl);
    if (!group) {
      return;
    }
    const partId = (_a = lineEl.dataset.partId) != null ? _a : toolCall.id;
    if (partId) {
      group.toolCalls.set(partId, toolCall);
    }
    const order = Number((_b = lineEl.dataset.order) != null ? _b : 0);
    this.populateLine(lineEl, toolCall, order);
    this.refreshLineOrder(group);
    this.rebuildAggregations(group);
    this.updateGroupState(group);
    this.syncApprovalDeck(group);
    this.maybeRenderDiffPreview(lineEl, toolCall);
    this.maybeRenderVerboseDetails(lineEl, toolCall);
    this.safeLog("update", toolCall, { messageId: toolCall.messageId });
    this.notifyDomContentChanged(lineEl);
    const messageEl = (_c = group == null ? void 0 : group.messageEl) != null ? _c : lineEl.closest(".systemsculpt-message");
    if (messageEl && typeof ((_d = this.parent) == null ? void 0 : _d.refreshStructuredBlocks) === "function") {
      this.parent.refreshStructuredBlocks(messageEl);
    }
  }
  /**
   * Remove a tool call line from the tree, pruning the whole group when empty.
   */
  removeToolCallElement(lineEl) {
    var _a;
    const group = this.lineToGroup.get(lineEl);
    if (!group) {
      lineEl.remove();
      return;
    }
    const partId = lineEl.dataset.partId;
    if (partId) {
      group.toolCalls.delete(partId);
      group.lines.delete(partId);
    }
    this.lineToGroup.delete(lineEl);
    lineEl.remove();
    this.refreshLineOrder(group);
    this.rebuildAggregations(group);
    this.updateGroupState(group);
    this.syncApprovalDeck(group);
    this.notifyDomContentChanged(group.wrapper);
    if (group.lines.size === 0) {
      group.wrapper.remove();
      this.groups.delete(group.messageEl);
      this.safeLog("group-cleared", void 0, {
        messageId: group.messageEl.dataset.messageId
      });
    }
    if (typeof ((_a = this.parent) == null ? void 0 : _a.refreshStructuredBlocks) === "function") {
      this.parent.refreshStructuredBlocks(group.messageEl);
    }
  }
  /**
   * Return the anchor element that should be used for chronological ordering of
   * subsequent message parts (the shared group wrapper).
   */
  getAnchorElement(lineEl) {
    var _a;
    const group = this.lineToGroup.get(lineEl);
    return (_a = group == null ? void 0 : group.wrapper) != null ? _a : null;
  }
  /**
   * Maintain legacy method for diff clean-up compatibility.
   */
  async handleToolCallStateChange(toolCall) {
    const functionData = getFunctionDataFromToolCall(toolCall);
    if (!functionData) return;
    const isFileEdit = /(^|_)(edit|write)$/.test(this.canonicalFunctionName(functionData.name));
    if (!isFileEdit) return;
    const args = functionData.arguments;
    const filePath = extractPrimaryPathArg(functionData.name, args);
    if (!filePath || typeof filePath !== "string") return;
    const app = this.parent.app;
    if (toolCall.state !== "pending") {
      try {
        await clearDiffFromView(app, filePath);
      } catch (error) {
        this.safeLog("clear-diff-error", toolCall, {
          messageId: toolCall.messageId,
          error
        });
      }
    }
  }
  ensureGroup(messageEl, insertAfterElement) {
    let group = this.groups.get(messageEl);
    if (group) {
      return group;
    }
    const wrapper = document.createElement("div");
    wrapper.classList.add("systemsculpt-chat-structured-block", "systemsculpt-tool-call-group", "systemsculpt-chat-tree", "systemsculpt-chat-tree--empty");
    wrapper.dataset.treeConnector = "group";
    const header = wrapper.createDiv({ cls: "systemsculpt-chat-structured-header" });
    header.dataset.treeConnector = "header";
    const bulletEl = header.createSpan({ cls: "systemsculpt-chat-structured-bullet" });
    const titleEl = header.createSpan({ cls: "systemsculpt-chat-structured-title" });
    const approvalHost = wrapper.createDiv({ cls: "ss-approval-host" });
    const linesContainer = wrapper.createDiv({ cls: "systemsculpt-chat-structured-lines" });
    this.parent.insertElementInOrder(messageEl, wrapper, insertAfterElement != null ? insertAfterElement : null);
    group = {
      messageEl,
      wrapper,
      bulletEl,
      titleEl,
      approvalHost,
      linesContainer,
      lines: /* @__PURE__ */ new Map(),
      toolCalls: /* @__PURE__ */ new Map()
    };
    this.groups.set(messageEl, group);
    this.notifyDomContentChanged(wrapper);
    return group;
  }
  ensureLine(group, partId, index) {
    const existing = group.lines.get(partId);
    if (existing) {
      existing.dataset.order = String(index);
      return existing;
    }
    const line = group.linesContainer.createDiv({
      cls: "systemsculpt-chat-structured-line systemsculpt-unified-part"
    });
    line.dataset.partId = partId;
    line.dataset.order = String(index);
    line.dataset.treeConnector = "end";
    line.createSpan({ cls: "systemsculpt-chat-structured-line-prefix" });
    line.createSpan({ cls: "systemsculpt-chat-structured-line-text", text: "" });
    line.createDiv({ cls: "systemsculpt-chat-structured-line-actions" });
    group.lines.set(partId, line);
    seedTreeLine(line, 1, true);
    this.notifyDomContentChanged(line);
    return line;
  }
  populateLine(line, toolCall, index) {
    var _a;
    line.dataset.toolCallId = toolCall.id;
    line.dataset.state = (_a = toolCall.state) != null ? _a : "pending";
    line.dataset.order = String(index);
    const descriptor = this.getToolCallDescriptor(toolCall);
    line.dataset.aggregateLabel = descriptor.label;
    line.dataset.aggregateDetail = descriptor.detail;
    line.dataset.allowAggregation = descriptor.allowAggregation ? "true" : "false";
    line.classList.remove("systemsculpt-chat-structured-line--shadow");
    line.style.removeProperty("display");
    this.renderLineText(line, descriptor.label, descriptor.detail);
    this.populateActions(line, toolCall);
  }
  renderLineText(line, label, detail) {
    const textEl = line.querySelector(".systemsculpt-chat-structured-line-text");
    if (!textEl) {
      return;
    }
    textEl.textContent = "";
    const factory = textEl;
    const appendSpan = (cls, text) => {
      if (!text) return;
      if (factory.createSpan) {
        factory.createSpan({ cls, text });
      } else {
        const span = document.createElement("span");
        span.className = cls;
        span.textContent = text;
        textEl.appendChild(span);
      }
    };
    if (label) {
      appendSpan("systemsculpt-chat-structured-label", label);
    }
    if (detail) {
      if (label) {
        textEl.append(" ");
      }
      appendSpan("systemsculpt-chat-structured-detail", detail);
    }
  }
  /**
   * Render verbose, per-item details directly under a tool call line. Never truncates.
   */
  maybeRenderVerboseDetails(line, toolCall) {
    var _a;
    try {
      Array.from(line.querySelectorAll(".systemsculpt-inline-ops, .systemsculpt-toolcall-details")).forEach((el) => el.remove());
      const app = (_a = this.parent) == null ? void 0 : _a.app;
      const fn = getFunctionDataFromToolCall(toolCall);
      if (!fn) return;
      const canonical = this.canonicalFunctionName(fn.name);
      if (/(^|_)(move|trash|create_folders)$/.test(canonical)) {
        if (app) {
          void renderOperationsInlinePreview(app, line, toolCall);
        }
        return;
      }
      if (/(^|_)(read|list_items)$/.test(canonical)) {
        return;
      }
    } catch (error) {
      this.safeLog("verbose-details-error", toolCall, { error });
    }
  }
  refreshLineOrder(group) {
    const sortedLines = Array.from(group.lines.values()).sort((a, b) => {
      var _a, _b;
      return Number((_a = a.dataset.order) != null ? _a : 0) - Number((_b = b.dataset.order) != null ? _b : 0);
    });
    for (const line of sortedLines) {
      group.linesContainer.appendChild(line);
    }
  }
  rebuildAggregations(group) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    const lines = Array.from(group.linesContainer.children);
    for (const line of lines) {
      line.classList.remove("systemsculpt-chat-structured-line--shadow");
      line.style.removeProperty("display");
      line.dataset.treeHidden = "false";
    }
    const buckets = this.createAggregationBuckets(lines);
    const hiddenToolCallIds = [];
    const visibleToolCallIds = [];
    for (const bucket of buckets) {
      const primaryLine = bucket.lines[0];
      const originalDetails = bucket.details;
      const label = bucket.label;
      if (!label) {
        primaryLine.dataset.aggregateLabel = "";
      }
      if (!bucket.allowAggregation || bucket.lines.length === 1) {
        const detail = (_a = originalDetails[0]) != null ? _a : "";
        this.renderLineText(primaryLine, label, detail);
        visibleToolCallIds.push((_b = primaryLine.dataset.toolCallId) != null ? _b : "");
        continue;
      }
      const aggregatedDetail = this.aggregateDetails(originalDetails);
      this.renderLineText(primaryLine, label, aggregatedDetail);
      visibleToolCallIds.push((_c = primaryLine.dataset.toolCallId) != null ? _c : "");
      for (const hiddenLine of bucket.lines.slice(1)) {
        hiddenLine.dataset.treeHidden = "true";
        hiddenLine.style.display = "none";
        hiddenToolCallIds.push((_d = hiddenLine.dataset.toolCallId) != null ? _d : "");
      }
    }
    const visibleLines = lines.filter((line) => line.style.display !== "none" && line.dataset.treeHidden !== "true" && !line.hidden);
    group.wrapper.classList.toggle("systemsculpt-chat-tree--empty", visibleLines.length === 0);
    rebuildTreeConnectors(group.linesContainer);
    this.safeLog("aggregate-lines", void 0, {
      messageId: (_f = (_e = group.messageEl) == null ? void 0 : _e.dataset) == null ? void 0 : _f.messageId,
      visibleLines: visibleLines.length,
      hiddenLines: hiddenToolCallIds.length,
      visibleToolCallIds: visibleToolCallIds.filter((id) => Boolean(id)),
      hiddenToolCallIds: hiddenToolCallIds.filter((id) => Boolean(id))
    });
    this.safeLog("tree-connectors", void 0, {
      messageId: (_h = (_g = group.messageEl) == null ? void 0 : _g.dataset) == null ? void 0 : _h.messageId,
      visibleLines: visibleLines.length
    });
  }
  syncApprovalDeck(group) {
    var _a, _b, _c;
    const pendingEntries = [];
    for (const [partId, toolCall] of group.toolCalls.entries()) {
      if (toolCall.state !== "pending") continue;
      if (!this.isMutatingToolCall(toolCall)) continue;
      const orderSource = group.lines.get(partId);
      const order = orderSource ? Number((_a = orderSource.dataset.order) != null ? _a : 0) : Number((_b = toolCall.timestamp) != null ? _b : 0);
      const entry = this.buildApprovalDeckEntry(toolCall, order);
      if (entry) {
        pendingEntries.push(entry);
      }
    }
    let deck = this.approvalDecks.get(group.approvalHost);
    if (pendingEntries.length === 0) {
      if (deck) {
        try {
          this.removeChild(deck);
        } catch (error) {
          this.safeLog("approval-deck-remove-error", void 0, { error });
          try {
            deck.unload();
          } catch (e) {
          }
        }
        this.approvalDecks.delete(group.approvalHost);
      }
      group.approvalHost.empty();
      return;
    }
    if (!deck) {
      const app = (_c = this.parent) == null ? void 0 : _c.app;
      deck = new ToolCallApprovalDeck({
        app,
        host: group.approvalHost
      });
      this.addChild(deck);
      this.approvalDecks.set(group.approvalHost, deck);
    }
    try {
      deck.sync(pendingEntries);
    } catch (error) {
      this.safeLog("approval-deck-sync-error", void 0, { error });
    }
  }
  buildApprovalDeckEntry(toolCall, order) {
    var _a;
    const descriptor = this.getToolCallDescriptor(toolCall);
    const fn = getFunctionDataFromToolCall(toolCall);
    const canonical = this.canonicalFunctionName((_a = fn == null ? void 0 : fn.name) != null ? _a : "");
    const sectionLabel = this.computeDeckLabel(canonical, descriptor.label);
    if (!sectionLabel) {
      return null;
    }
    return {
      toolCall,
      chipLabel: sectionLabel,
      sectionLabel,
      order
    };
  }
  computeDeckLabel(canonicalName, descriptorLabel) {
    const normalized = canonicalName.toLowerCase();
    if (normalized.includes("create_folders")) return "Create Folders";
    if (normalized.includes("move")) return "Move Items";
    if (normalized.includes("trash") || normalized.includes("delete")) return "Trash Items";
    if (normalized.includes("rename")) return "Rename Items";
    if (normalized.includes("write") && !normalized.includes("rewrite")) return "Write File";
    if (normalized.includes("edit")) return "Edit File";
    if (normalized.includes("replace")) return "Replace Text";
    const fallback = descriptorLabel || this.singleLine(formatToolDisplayName(canonicalName));
    return fallback ? this.singleLine(fallback) : "Tool";
  }
  createAggregationBuckets(lines) {
    var _a, _b;
    const buckets = [];
    const byKey = /* @__PURE__ */ new Map();
    for (const line of lines) {
      const label = (_a = line.dataset.aggregateLabel) != null ? _a : "";
      const detail = (_b = line.dataset.aggregateDetail) != null ? _b : "";
      const allowAggregation = line.dataset.allowAggregation === "true" && Boolean(label);
      if (!allowAggregation) {
        const uniqueKey = label ? `${label}:${buckets.length}` : `__${buckets.length}`;
        buckets.push({
          key: uniqueKey,
          label,
          allowAggregation: false,
          lines: [line],
          details: [detail]
        });
        continue;
      }
      const key = label.toLowerCase();
      let bucket = byKey.get(key);
      if (!bucket) {
        bucket = {
          key,
          label,
          allowAggregation: true,
          lines: [],
          details: []
        };
        byKey.set(key, bucket);
        buckets.push(bucket);
      }
      bucket.lines.push(line);
      bucket.details.push(detail);
    }
    return buckets;
  }
  aggregateDetails(details) {
    const seen = /* @__PURE__ */ new Set();
    const ordered = [];
    for (const detail of details) {
      const normalized = this.singleLine(detail || "");
      if (!normalized) continue;
      const key = normalized.toLowerCase();
      if (seen.has(key)) continue;
      seen.add(key);
      ordered.push(this.limitText(normalized, 120));
    }
    if (ordered.length === 0) {
      return "";
    }
    return this.singleLine(this.limitText(ordered.join(", "), 160));
  }
  composeLineText(label, detail) {
    const trimmedLabel = this.singleLine(label || "");
    const trimmedDetail = this.singleLine(detail || "");
    if (trimmedLabel && trimmedDetail) {
      return this.singleLine(`${trimmedLabel} ${trimmedDetail}`);
    }
    if (trimmedLabel) return trimmedLabel;
    return trimmedDetail;
  }
  updateGroupState(group) {
    const calls = Array.from(group.toolCalls.values());
    if (calls.length === 0) {
      group.titleEl.textContent = "";
      setBulletSymbol(group.bulletEl, "");
      group.bulletEl.classList.remove("is-active", "is-failed", "is-denied");
      return;
    }
    const activity = this.computeActivity(calls);
    const status = this.computeStatus(calls);
    group.wrapper.dataset.activity = activity;
    group.wrapper.dataset.groupStatus = status;
    group.titleEl.textContent = ACTIVITY_LABELS[activity][status];
    group.bulletEl.className = "systemsculpt-chat-structured-bullet";
    if (status === "active") {
      group.bulletEl.classList.add("is-active");
    } else if (status === "failed") {
      group.bulletEl.classList.add("is-failed");
    } else if (status === "denied") {
      group.bulletEl.classList.add("is-denied");
    }
    setBulletSymbol(group.bulletEl, BULLET_SYMBOLS[status]);
  }
  computeActivity(calls) {
    var _a;
    if (calls.length === 0) return "explore";
    const categories = /* @__PURE__ */ new Set();
    for (const call of calls) {
      categories.add(this.categorizeToolCall(call));
    }
    if (categories.size === 1) {
      return (_a = categories.values().next().value) != null ? _a : "explore";
    }
    if (categories.has("mutate")) {
      return "mutate";
    }
    if (categories.has("explore")) {
      return "explore";
    }
    return "run";
  }
  computeStatus(calls) {
    const hasActive = calls.some((call) => this.isActiveState(call.state));
    if (hasActive) return "active";
    if (calls.some((call) => call.state === "failed")) return "failed";
    if (calls.some((call) => call.state === "denied")) return "denied";
    return "completed";
  }
  isActiveState(state) {
    return state === "pending" || state === "approved" || state === "executing";
  }
  categorizeToolCall(toolCall) {
    var _a, _b, _c;
    const fnName = (_c = (_b = (_a = toolCall.request) == null ? void 0 : _a.function) == null ? void 0 : _b.name) != null ? _c : "";
    const canonical = this.canonicalFunctionName(fnName);
    if (isMutatingTool(fnName) || /(^|_)(write|edit|replace|move|trash|delete|rename|create|append)/.test(canonical)) {
      return "mutate";
    }
    if (/(^|_)(search|find|list|read|context)/.test(canonical)) {
      return "explore";
    }
    return "run";
  }
  getToolCallDescriptor(toolCall) {
    var _a;
    const fn = getFunctionDataFromToolCall(toolCall);
    if (!fn) {
      return {
        label: "Tool",
        detail: "call",
        allowAggregation: false
      };
    }
    const canonical = this.canonicalFunctionName(fn.name);
    const args = (_a = fn.arguments) != null ? _a : {};
    if (canonical === "list_items") {
      return {
        label: "Browsed",
        detail: this.describeBrowseDetail(args),
        allowAggregation: true
      };
    }
    if (/(^|_)(search|find)/.test(canonical)) {
      return {
        label: "Searched",
        detail: this.describeSearchLikeDetail(canonical, args, toolCall.result),
        allowAggregation: true
      };
    }
    if (/^read/.test(canonical)) {
      return {
        label: "Read",
        detail: this.describeReadDetail(args, toolCall.result),
        allowAggregation: true
      };
    }
    if (isWriteOrEditTool(fn.name)) {
      return {
        label: "Edited",
        detail: this.describeWriteEditDetail(canonical, args),
        allowAggregation: false
      };
    }
    if (/(^|_)(write)/.test(canonical)) {
      return {
        label: "Write",
        detail: this.describeWriteDetail(args),
        allowAggregation: false
      };
    }
    if (/(^|_)(move|trash|delete|rename)/.test(canonical)) {
      return this.describeFileOperationDescriptor(canonical, args);
    }
    const primaryPath = extractPrimaryPathArg(fn.name, args);
    const displayName = this.singleLine(formatToolDisplayName(fn.name));
    const fallbackDetail = primaryPath ? this.prettyPath(primaryPath) : this.describeGenericArguments(args);
    const allowAggregation = !this.isMutatingToolCall(toolCall);
    return {
      label: displayName,
      detail: fallbackDetail,
      allowAggregation
    };
  }
  describeToolCall(toolCall) {
    const descriptor = this.getToolCallDescriptor(toolCall);
    return this.composeLineText(descriptor.label, descriptor.detail);
  }
  describeBrowseDetail(args) {
    var _a;
    const path = typeof (args == null ? void 0 : args.path) === "string" ? args.path : null;
    if (path) {
      return this.prettyPath(path);
    }
    const paths = this.normalizeStringArray((_a = args == null ? void 0 : args.paths) != null ? _a : []);
    if (paths.length > 0) {
      return paths.map((p) => this.prettyPath(p)).join(", ");
    }
    return "folder";
  }
  describeSearchLikeDetail(canonical, args, result) {
    const terms = this.extractSearchTerms(args);
    const fallback = this.singleLine(formatToolDisplayName(canonical));
    const joined = terms.length > 0 ? terms.join(", ") : fallback;
    const summary = this.limitText(joined, 160);
    const location = this.extractSearchLocation(args, result);
    if (location) {
      return this.singleLine(`${summary} in ${location}`);
    }
    return this.singleLine(summary);
  }
  describeReadDetail(args, result) {
    var _a;
    const paths = this.normalizeStringArray((_a = args == null ? void 0 : args.paths) != null ? _a : []);
    if (typeof (args == null ? void 0 : args.path) === "string" && !paths.includes(args.path)) {
      paths.push(args.path);
    }
    const fromResult = this.extractFilePathsFromResult(result);
    const combined = paths.length > 0 ? paths : fromResult;
    const primary = combined.length > 0 ? combined.map((p) => this.prettyPath(p)).join(", ") : "file";
    return this.singleLine(primary);
  }
  describeWriteEditDetail(canonical, args) {
    const path = typeof (args == null ? void 0 : args.path) === "string" ? args.path : "file";
    const editCount = Array.isArray(args == null ? void 0 : args.edits) ? args.edits.length : 0;
    const detail = canonical.endsWith("edit") && editCount > 1 ? ` (${editCount} edits)` : "";
    return this.singleLine(`${this.prettyPath(path)}${detail}`);
  }
  describeWriteDetail(args) {
    const path = typeof (args == null ? void 0 : args.path) === "string" ? args.path : "file";
    return this.singleLine(this.prettyPath(path));
  }
  extractSearchTerms(args) {
    const terms = [];
    const seen = /* @__PURE__ */ new Set();
    const addTerm = (value) => {
      const normalized = this.singleLine(value);
      if (!normalized) return;
      const key = normalized.toLowerCase();
      if (seen.has(key)) return;
      seen.add(key);
      terms.push(this.limitText(normalized, 80));
    };
    const addMany = (source) => {
      for (const entry of this.normalizeStringArray(source)) {
        addTerm(entry);
      }
    };
    addMany(args == null ? void 0 : args.patterns);
    addMany(args == null ? void 0 : args.queries);
    addMany(args == null ? void 0 : args.terms);
    addMany(args == null ? void 0 : args.keywords);
    addMany(args == null ? void 0 : args.searchTerms);
    if (typeof (args == null ? void 0 : args.query) === "string") {
      this.parseSearchString(args.query, addTerm);
    }
    if (typeof (args == null ? void 0 : args.text) === "string") {
      this.parseSearchString(args.text, addTerm);
    }
    if (typeof (args == null ? void 0 : args.term) === "string") {
      this.parseSearchString(args.term, addTerm);
    }
    return terms;
  }
  parseSearchString(raw, addTerm) {
    const trimmed = this.singleLine(raw);
    if (!trimmed) return;
    const colonSplit = trimmed.split(/:+/).map((segment) => segment.trim()).filter((segment) => segment.length > 0);
    if (colonSplit.length > 1) {
      for (const segment of colonSplit) {
        addTerm(segment);
      }
      return;
    }
    const commaSplit = trimmed.split(/[\n\r,;]+/).map((segment) => segment.trim()).filter((segment) => segment.length > 0);
    if (commaSplit.length > 1) {
      for (const segment of commaSplit) {
        addTerm(segment);
      }
      return;
    }
    addTerm(trimmed);
  }
  describeFileOperationDescriptor(canonical, args) {
    if (canonical.includes("move")) {
      return {
        label: "Moved",
        detail: this.describeMoveDetail(args),
        allowAggregation: false
      };
    }
    if (canonical.includes("trash") || canonical.includes("delete")) {
      return {
        label: "Deleted",
        detail: this.describeDeleteDetail(args),
        allowAggregation: false
      };
    }
    if (canonical.includes("rename")) {
      return {
        label: "Renamed",
        detail: this.describeRenameDetail(args),
        allowAggregation: false
      };
    }
    return {
      label: this.singleLine(formatToolDisplayName(canonical)),
      detail: this.describeGenericArguments(args),
      allowAggregation: false
    };
  }
  describeMoveDetail(args) {
    const items = Array.isArray(args == null ? void 0 : args.items) ? args.items : [];
    const destination = this.prettyPath((args == null ? void 0 : args.destination) || (args == null ? void 0 : args.target) || (args == null ? void 0 : args.targetPath) || "destination");
    const count = items.length || (Array.isArray(args == null ? void 0 : args.paths) ? args.paths.length : 0) || 1;
    return this.singleLine(`${count} item${count === 1 ? "" : "s"} to ${destination}`);
  }
  describeDeleteDetail(args) {
    var _a;
    const paths = this.normalizeStringArray((_a = args == null ? void 0 : args.paths) != null ? _a : []);
    if (paths.length === 0) {
      return "item";
    }
    return this.singleLine(paths.map((p) => this.prettyPath(p)).join(", "));
  }
  describeRenameDetail(args) {
    const source = this.prettyPath((args == null ? void 0 : args.from) || (args == null ? void 0 : args.source) || "item");
    const target = this.prettyPath((args == null ? void 0 : args.to) || (args == null ? void 0 : args.target) || "target");
    return this.singleLine(`${source} \u2192 ${target}`);
  }
  describeGenericArguments(args) {
    if (!args) {
      return "";
    }
    const entries = [];
    for (const [key, value] of Object.entries(args)) {
      if (value === void 0 || value === null) continue;
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        entries.push(`${key}: ${this.limitText(String(value))}`);
      } else if (Array.isArray(value) && value.length > 0) {
        const printable = value.slice(0, 3).map((item) => typeof item === "string" || typeof item === "number" ? String(item) : "\u2026").join(", ");
        entries.push(`${key}: ${this.limitText(printable)}`);
      }
      if (entries.length >= 2) break;
    }
    return this.singleLine(entries.join(" | "));
  }
  extractSearchLocation(args, result) {
    const directPath = typeof (args == null ? void 0 : args.path) === "string" ? args.path : null;
    if (directPath) {
      return this.prettyPath(directPath);
    }
    if (Array.isArray(args == null ? void 0 : args.paths) && args.paths[0]) {
      return this.prettyPath(args.paths[0]);
    }
    const fromResult = this.extractFilePathsFromResult(result);
    if (fromResult.length > 0) {
      return this.prettyPath(fromResult[0]);
    }
    return null;
  }
  extractFilePathsFromResult(result) {
    var _a, _b;
    if (!(result == null ? void 0 : result.data)) return [];
    const data = result.data;
    const paths = [];
    if (Array.isArray(data == null ? void 0 : data.files)) {
      for (const file of data.files) {
        if (typeof (file == null ? void 0 : file.path) === "string") {
          paths.push(file.path);
        } else if (typeof (file == null ? void 0 : file.file) === "string") {
          paths.push(file.file);
        }
      }
    }
    if (Array.isArray(data == null ? void 0 : data.results)) {
      for (const item of data.results) {
        const candidate = (_b = (_a = item == null ? void 0 : item.path) != null ? _a : item == null ? void 0 : item.file) != null ? _b : item == null ? void 0 : item.name;
        if (typeof candidate === "string") {
          paths.push(candidate);
        }
      }
    }
    return paths;
  }
  normalizeStringArray(value) {
    if (Array.isArray(value)) {
      return value.map((item) => String(item)).filter((item) => item.length > 0);
    }
    if (typeof value === "string" && value.length > 0) {
      return [value];
    }
    return [];
  }
  prettyPath(path) {
    if (!path) return "";
    const normalized = path.replace(/\\/g, "/");
    const segments = normalized.split("/");
    return segments[segments.length - 1] || normalized;
  }
  limitText(text, max = 80) {
    if (!text) return "";
    const singleLine = text.replace(/\s+/g, " ").trim();
    if (singleLine.length <= max) return singleLine;
    return singleLine.slice(0, max - 1) + "\u2026";
  }
  singleLine(text) {
    return text.replace(/\s+/g, " ").trim();
  }
  canonicalFunctionName(name) {
    let canonical = name || "";
    if (canonical.startsWith("mcp-")) {
      const underscoreIndex = canonical.indexOf("_");
      if (underscoreIndex !== -1) {
        canonical = canonical.slice(underscoreIndex + 1);
      } else {
        canonical = canonical.replace(/^mcp-/, "");
      }
    }
    canonical = canonical.replace(/^filesystem_/, "");
    return canonical;
  }
  populateActions(line, representativeToolCall) {
    const actions = line.querySelector(".systemsculpt-chat-structured-line-actions");
    if (!actions) {
      return;
    }
    actions.empty();
    actions.style.removeProperty("display");
    if (representativeToolCall.state === "pending" && this.isMutatingToolCall(representativeToolCall)) {
      actions.style.display = "none";
      return;
    }
  }
  isMutatingToolCall(toolCall) {
    const fn = getFunctionDataFromToolCall(toolCall);
    if (!fn) {
      return false;
    }
    if (isMutatingTool(fn.name)) {
      return true;
    }
    const canonical = this.canonicalFunctionName(fn.name);
    return /(^|_)(write|edit|replace|move|trash|delete|rename|create|append|update|set)/.test(canonical);
  }
  maybeRenderDiffPreview(line, toolCall) {
    try {
      const fn = getFunctionDataFromToolCall(toolCall);
      if (!fn) return;
      if (!isWriteOrEditTool(fn.name)) {
        const existing = line.querySelector(".systemsculpt-inline-diff");
        if (existing) existing.remove();
        return;
      }
      if (toolCall.state !== "pending") {
        const existing = line.querySelector(".systemsculpt-inline-diff");
        if (existing) existing.remove();
        return;
      }
      const app = this.parent.app;
      if (!app) return;
      void renderWriteEditInlineDiff(app, line, toolCall).catch((error) => {
        this.safeLog("diff-preview-error", toolCall, {
          messageId: toolCall.messageId,
          error
        });
      });
    } catch (error) {
      this.safeLog("diff-preview-error", toolCall, {
        messageId: toolCall.messageId,
        error
      });
    }
  }
  safeLog(event, toolCall, extras) {
    try {
      errorLogger.debug(`[ToolCallTreeRenderer] ${event}`, {
        metadata: {
          toolCallId: toolCall == null ? void 0 : toolCall.id,
          state: toolCall == null ? void 0 : toolCall.state,
          ...extras
        },
        source: "ToolCallTreeRenderer",
        method: event
      });
    } catch (_) {
    }
  }
  // Legacy compatibility stubs used by existing MessageRenderer pathways
  renderToolCallContent(_container, _toolCall, _isStreaming) {
    return Promise.resolve();
  }
  createStatusIndicator(_headerEl, _state) {
  }
  updateStatusIndicator(_statusEl, _state) {
  }
  renderHeaderActions(_headerEl, _toolCall) {
  }
};

// src/views/chatview/MessageRenderer.ts
init_toolDisplay();

// src/constants/largeText.ts
var LARGE_TEXT_THRESHOLDS = {
  // Size thresholds in KB
  SOFT_WARNING_KB: 100,
  // Show warning but continue processing
  HARD_WARNING_KB: 512,
  // Show confirmation dialog
  MAX_SIZE_KB: 1024,
  // Hard limit - reject with error
  // Line count thresholds
  MAX_LINES_PREVIEW: 5,
  // Lines to show in preview
  COLLAPSE_THRESHOLD_LINES: 300,
  // Collapse if more than this many lines
  // Processing constants
  CHUNK_SIZE_CHARS: 1e3,
  // Character chunk size for processing
  BYTES_PER_KB: 1024
  // Conversion constant
};
var LARGE_TEXT_MESSAGES = {
  SIZE_ERROR: "\u274C Text too large (>1MB). Please use file upload or split into smaller sections.",
  SIZE_WARNING_PREFIX: "\u26A0\uFE0F Large text detected",
  PROCESSING: "Processing large text...",
  COMPLETED: "Large text paste completed",
  CONFIRMATION_PREFIX: "Large text processed",
  TRUNCATION_INDICATOR: "... (content truncated)"
};
var LARGE_TEXT_UI = {
  PLACEHOLDER_PREFIX: "[PASTED TEXT - ",
  PLACEHOLDER_SUFFIX: " LINES OF TEXT]",
  STATS_PREFIX: "\u{1F4C4} Large text content: ",
  MODAL_TITLE_SUFFIX: " lines)"
};
var LargeTextHelpers = {
  /**
   * Calculate text size in KB
   */
  getTextSizeKB: (text) => {
    return new Blob([text]).size / LARGE_TEXT_THRESHOLDS.BYTES_PER_KB;
  },
  /**
   * Get line count
   */
  getLineCount: (text) => {
    return text.split("\n").length;
  },
  /**
   * Check if text should be collapsed in chat history
   */
  shouldCollapseInHistory: (text) => {
    const sizeKB = LargeTextHelpers.getTextSizeKB(text);
    const lines = LargeTextHelpers.getLineCount(text);
    return sizeKB > LARGE_TEXT_THRESHOLDS.SOFT_WARNING_KB || lines > LARGE_TEXT_THRESHOLDS.COLLAPSE_THRESHOLD_LINES;
  },
  /**
   * Check if text requires warning during paste
   */
  getTextWarningLevel: (text) => {
    const sizeKB = LargeTextHelpers.getTextSizeKB(text);
    if (sizeKB > LARGE_TEXT_THRESHOLDS.MAX_SIZE_KB) return "error";
    if (sizeKB > LARGE_TEXT_THRESHOLDS.HARD_WARNING_KB) return "hard";
    if (sizeKB > LARGE_TEXT_THRESHOLDS.SOFT_WARNING_KB) return "soft";
    return "none";
  },
  /**
   * Create placeholder text for input field
   */
  createPlaceholder: (lineCount) => {
    return `${LARGE_TEXT_UI.PLACEHOLDER_PREFIX}${lineCount}${LARGE_TEXT_UI.PLACEHOLDER_SUFFIX}`;
  },
  /**
   * Check if text contains a large text placeholder
   */
  containsPlaceholder: (text) => {
    return text.includes(LARGE_TEXT_UI.PLACEHOLDER_PREFIX) && text.includes(LARGE_TEXT_UI.PLACEHOLDER_SUFFIX);
  },
  /**
   * Get preview content (first N lines)
   */
  getPreviewContent: (text) => {
    const lines = text.split("\n");
    return lines.slice(0, LARGE_TEXT_THRESHOLDS.MAX_LINES_PREVIEW).join("\n");
  },
  /**
   * Format size display
   */
  formatSize: (sizeKB) => {
    return `${Math.round(sizeKB)}KB`;
  }
};

// src/views/chatview/MessageRenderer.ts
init_errorLogger();
init_PlatformContext();
var REASONING_MEANINGFUL_CHILD_TAGS = /* @__PURE__ */ new Set([
  "IMG",
  "PICTURE",
  "VIDEO",
  "AUDIO",
  "IFRAME",
  "CANVAS",
  "SVG",
  "PRE",
  "CODE",
  "TABLE",
  "UL",
  "OL",
  "BLOCKQUOTE"
]);
var REASONING_COMPACT_LINE_HEIGHT = "1.35";
var REASONING_COMPACT_MARGIN = "0.35em";
var MessageRenderer = class extends import_obsidian66.Component {
  constructor(app, toolCallManager) {
    super();
    this.throttledRenderers = /* @__PURE__ */ new WeakMap();
    this.RENDER_THROTTLE_MS = 100;
    // Throttled verbatim renderer for reasoning streaming
    this.reasoningThrottledRenderers = /* @__PURE__ */ new WeakMap();
    this.app = app;
    this.toolCallManager = toolCallManager;
    this.markdownRenderer = new MarkdownMessageRenderer(app);
    this.toolCallRenderer = new ToolCallTreeRenderer(this);
    this.addChild(this.toolCallRenderer);
  }
  async renderMessage({
    app,
    messageId,
    role,
    content,
    annotations,
    webSearchEnabled
  }) {
    const messageEl = document.createElement("div");
    messageEl.classList.add("systemsculpt-message");
    messageEl.classList.add(`systemsculpt-${role}-message`);
    messageEl.dataset.messageId = messageId;
    const contentEl = messageEl.createEl("div", {
      cls: "systemsculpt-message-content"
    });
    if (typeof content === "string") {
      const isLargeText = LargeTextHelpers.shouldCollapseInHistory(content);
      if (isLargeText) {
        await this.renderCollapsedLargeText(content, contentEl);
      } else {
        await this.renderMarkdownContent(content, contentEl, false);
      }
    } else if (Array.isArray(content)) {
      const parts = content;
      for (const part of parts) {
        if (part.type === "text") {
          const p = contentEl.createEl("p");
          p.setText(part.text);
        } else if (part.type === "image_url") {
          const img = contentEl.createEl("img", {
            attr: { src: part.image_url.url }
          });
          img.classList.add("systemsculpt-message-image");
        }
      }
    } else {
      await this.renderMarkdownContent(String(content), contentEl, false);
    }
    if (role === "assistant" && webSearchEnabled && annotations && annotations.length > 0) {
      const urlCitations = annotations.filter((annotation) => annotation.type === "url_citation" && annotation.url_citation).map((annotation) => annotation.url_citation).filter((citation) => citation !== void 0);
      if (urlCitations.length > 0) {
        this.renderCitations(contentEl, urlCitations);
      }
    }
    try {
      attachMessageToolbar({
        app: this.app,
        messageEl,
        role,
        messageId
      });
    } catch (e) {
    }
    return { messageEl, contentEl };
  }
  async renderMarkdownContent(content, containerEl, isStreaming = false) {
    return this.markdownRenderer.render(content, containerEl, isStreaming);
  }
  throttledRender(containerEl, content) {
    let state = this.throttledRenderers.get(containerEl);
    if (!state) {
      state = { timeoutId: null, content: "" };
      this.throttledRenderers.set(containerEl, state);
    }
    state.content = content;
    if (state.timeoutId) {
      return;
    }
    state.timeoutId = setTimeout(async () => {
      const currentState = this.throttledRenderers.get(containerEl);
      if (currentState) {
        currentState.timeoutId = null;
        if (!containerEl.isConnected) {
          this.throttledRenderers.delete(containerEl);
          return;
        }
        containerEl.empty();
        await import_obsidian66.MarkdownRenderer.render(
          this.app,
          currentState.content,
          containerEl,
          "systemsculpt-chat.md",
          this
        );
        this.processRenderedContent(containerEl);
        this.app.workspace.trigger("systemsculpt:content-rendered");
      }
    }, this.RENDER_THROTTLE_MS);
  }
  // Post-process Mermaid diagrams: auto-quote labels and render
  postProcessMermaid(containerEl) {
    const mermaidDivs = containerEl.querySelectorAll(".mermaid");
    mermaidDivs.forEach((div) => {
      const raw = div.textContent || "";
      let processed = raw.replace(/\[([\s\S]*?)\]/g, (m2, p1) => `[${p1.replace(/\n+/g, " ")}]`);
      processed = processed.replace(/([\w-]+)\(\[([\s\S]*?)\]\)/g, '$1["$2"]');
      processed = processed.replace(/([\w-]+)\[([^\]]+?)\]/g, '$1["$2"]');
      processed = processed.replace(/\]\)([ \t]+)([\w-]+[\[\(])/g, "])\n  $2");
      if (processed !== raw) {
        div.textContent = processed;
      }
      const m = globalThis.mermaid;
      if (m && typeof m.init === "function") {
        try {
          m.init(void 0, div);
        } catch (err) {
        }
      }
      if (!div.dataset.ssExpand) {
        div.dataset.ssExpand = "true";
        const btn = div.createDiv({ cls: "systemsculpt-mermaid-expand-btn" });
        (0, import_obsidian66.setIcon)(btn, "maximize-2");
        btn.setAttribute("aria-label", "Expand diagram");
        btn.addEventListener("click", (e) => {
          e.preventDefault();
          e.stopPropagation();
          new MermaidPreviewModal(this.app, processed).open();
        });
      }
    });
  }
  // Toolbar visibility is now handled by CSS hover states
  // This method is kept for backward compatibility but does nothing
  setToolbarVisibility(toolbar, visible, expanded = false) {
  }
  // Removed toggleToolbarState - using container-based approach instead
  addMessageButtonToolbar(messageEl, content, role, messageId) {
    try {
      attachMessageToolbar({
        app: this.app,
        messageEl,
        role,
        messageId
      });
    } catch (e) {
    }
  }
  // Legacy reasoning methods removed - now using unified rendering approach
  /**
   * Renders web search citations at the bottom of a message
   */
  renderCitations(contentEl, citations) {
    this.markdownRenderer.renderCitations(contentEl, citations);
  }
  /**
   * Unified rendering for message parts using diff-based updates
   * This approach preserves existing DOM elements and drawer state
   */
  renderUnifiedMessageParts(messageEl, parts, isActivelyStreaming = false) {
    if (!parts || parts.length === 0) {
      const legacyContent2 = messageEl.querySelector(".systemsculpt-message-content:not(.systemsculpt-unified-part)");
      if (legacyContent2) {
        legacyContent2.style.display = "";
      }
      return;
    }
    const legacyContent = messageEl.querySelector(".systemsculpt-message-content:not(.systemsculpt-unified-part)");
    if (legacyContent) {
      legacyContent.style.display = "none";
    }
    const renderedParts = /* @__PURE__ */ new Map();
    messageEl.querySelectorAll(".systemsculpt-unified-part[data-part-id]").forEach((el) => {
      const partId = el.dataset.partId;
      if (partId) {
        renderedParts.set(partId, el);
      }
    });
    const sortedParts = [...parts].sort((a, b) => a.timestamp - b.timestamp);
    const processedPartIds = /* @__PURE__ */ new Set();
    let insertAfterElement = null;
    let toolCallIndex = 0;
    sortedParts.forEach((part) => {
      if (!part.id) {
        return;
      }
      processedPartIds.add(part.id);
      const currentToolCallIndex = toolCallIndex;
      const existingElement = renderedParts.get(part.id);
      if (existingElement) {
        const needsUpdate = this.partNeedsUpdate(part, isActivelyStreaming, existingElement);
        if (needsUpdate) {
          this.updateExistingPart(existingElement, part, isActivelyStreaming);
        }
        const anchor = this.toolCallRenderer.getAnchorElement(existingElement);
        insertAfterElement = anchor != null ? anchor : existingElement;
      } else {
        let newElement = null;
        if (part.type === "reasoning") {
          newElement = this.renderUnifiedReasoning(messageEl, part.data, insertAfterElement, isActivelyStreaming, part.id);
        } else if (part.type === "content") {
          newElement = this.renderUnifiedContent(messageEl, part.data, insertAfterElement, part.id, isActivelyStreaming, part);
        } else if (part.type === "tool_call") {
          const toolCall = part.data;
          newElement = this.toolCallRenderer.renderToolCallAsContent(
            messageEl,
            toolCall,
            currentToolCallIndex,
            insertAfterElement,
            part.id,
            isActivelyStreaming
          );
        }
        if (newElement) {
          const anchor = this.toolCallRenderer.getAnchorElement(newElement);
          insertAfterElement = anchor != null ? anchor : newElement;
        }
      }
      if (part.type === "tool_call") {
        toolCallIndex++;
      }
    });
    renderedParts.forEach((element, partId) => {
      if (!processedPartIds.has(partId)) {
        if (element.classList.contains("systemsculpt-chat-structured-line")) {
          this.toolCallRenderer.removeToolCallElement(element);
        } else {
          element.remove();
        }
      }
    });
    this.refreshStructuredBlocks(messageEl);
    this.ensureToolbarAnchored(messageEl);
  }
  /**
   * Move the floating toolbar under the last visible content container so that
   * it overlays correctly even when messages are grouped (where the outer
   * message uses display: contents).
   */
  ensureToolbarAnchored(messageEl) {
    const toolbar = messageEl.querySelector(".systemsculpt-message-toolbar");
    if (!toolbar) return;
    const contentParts = messageEl.querySelectorAll(".systemsculpt-content-part");
    const anchor = contentParts.length ? contentParts[contentParts.length - 1] : messageEl.querySelector(".systemsculpt-message-content");
    if (!anchor) return;
    if (toolbar.parentElement !== anchor) {
      anchor.appendChild(toolbar);
    }
  }
  /**
   * Check if a part needs to be updated
   */
  partNeedsUpdate(part, isActivelyStreaming, existingElement) {
    var _a;
    if (part.type === "reasoning") {
      const currentStreamingState = ((_a = existingElement == null ? void 0 : existingElement.dataset) == null ? void 0 : _a.reasoningStreaming) === "true";
      if (isActivelyStreaming !== currentStreamingState) {
        return true;
      }
      return isActivelyStreaming || (existingElement == null ? void 0 : existingElement.textContent) !== part.data;
    } else if (part.type === "content") {
      return isActivelyStreaming || (existingElement == null ? void 0 : existingElement.textContent) !== part.data;
    } else if (part.type === "tool_call") {
      return true;
    }
    return false;
  }
  /**
   * Update an existing rendered part with new data
   */
  updateExistingPart(element, part, isActivelyStreaming) {
    if (part.type === "reasoning") {
      this.applyReasoningStreamingState(element, isActivelyStreaming);
      const contentEl = element.querySelector(".systemsculpt-reasoning-text");
      if (contentEl && typeof part.data === "string") {
        if (isActivelyStreaming) {
          this.appendReasoningStream(contentEl, part.data);
        } else {
          this.finalizeReasoningStream(contentEl, part.data);
        }
      }
    } else if (part.type === "content") {
      if (element && typeof part.data === "string") {
        this.renderMarkdownContent(part.data, element, isActivelyStreaming);
      }
    } else if (part.type === "tool_call") {
      const toolCall = part.data;
      this.toolCallRenderer.updateInlineDisplay(element, toolCall);
    }
    const messageEl = element.closest(".systemsculpt-message");
    if (messageEl) {
      this.refreshStructuredBlocks(messageEl);
    }
  }
  /**
   * Render reasoning as part of unified display
   */
  renderUnifiedReasoning(messageEl, reasoning, insertAfterElement, isStreaming = false, partId) {
    const { wrapper, contentEl } = this.createReasoningStructure(isStreaming);
    if (partId) {
      wrapper.dataset.partId = partId;
    }
    if (messageEl && messageEl.classList) {
      messageEl.classList.add("has-reasoning");
    }
    this.insertElementInOrder(messageEl, wrapper, insertAfterElement);
    this.applyReasoningStreamingState(wrapper, isStreaming);
    if (isStreaming) {
      this.appendReasoningStream(contentEl, reasoning);
    } else {
      this.finalizeReasoningStream(contentEl, reasoning);
    }
    this.refreshStructuredBlocks(messageEl);
    return wrapper;
  }
  createReasoningStructure(isStreaming) {
    const wrapper = document.createElement("div");
    wrapper.className = "systemsculpt-reasoning-wrapper systemsculpt-unified-part";
    const block = wrapper.createDiv({ cls: "systemsculpt-reasoning-block systemsculpt-chat-structured-block systemsculpt-chat-tree" });
    block.classList.remove("systemsculpt-chat-tree--empty");
    block.dataset.treeConnector = "group";
    const header = block.createDiv({ cls: "systemsculpt-chat-structured-header" });
    header.dataset.treeConnector = "header";
    header.createSpan({ cls: "systemsculpt-chat-structured-bullet" });
    header.createSpan({ cls: "systemsculpt-chat-structured-title", text: "Reasoning" });
    const lines = block.createDiv({ cls: "systemsculpt-chat-structured-lines" });
    const line = lines.createDiv({ cls: "systemsculpt-chat-structured-line" });
    line.dataset.treeConnector = "end";
    line.createSpan({ cls: "systemsculpt-chat-structured-line-prefix" });
    const textContainer = line.createDiv({ cls: "systemsculpt-chat-structured-line-text" });
    const scrollContainer = textContainer.createDiv({ cls: "systemsculpt-reasoning-scroll-container" });
    const contentEl = scrollContainer.createDiv({ cls: "systemsculpt-reasoning-text markdown-rendered" });
    seedTreeLine(line, 1, true);
    wrapper.dataset.reasoningStreaming = isStreaming ? "true" : "false";
    const prefixEl = wrapper.querySelector(".systemsculpt-chat-structured-line-prefix");
    if (prefixEl) {
      prefixEl.dataset.role = "reasoning-connector";
    }
    return { wrapper, contentEl };
  }
  applyReasoningStreamingState(wrapper, isStreaming) {
    if (!wrapper) return;
    wrapper.dataset.reasoningStreaming = isStreaming ? "true" : "false";
    const bullet = wrapper.querySelector(".systemsculpt-chat-structured-bullet");
    if (bullet) {
      if (isStreaming) {
        bullet.classList.add("is-active");
        setBulletSymbol(bullet, "");
      } else {
        bullet.classList.remove("is-active");
        setBulletSymbol(bullet, TREE_HEADER_SYMBOL);
      }
    }
    const title = wrapper.querySelector(".systemsculpt-chat-structured-title");
    if (title) {
      title.textContent = "Reasoning";
    }
  }
  updateReasoningConnectors(messageEl) {
    if (!messageEl) return;
    const wrappers = Array.from(messageEl.querySelectorAll(".systemsculpt-reasoning-wrapper"));
    const nodes = wrappers.reduce(
      (acc, wrapper) => {
        var _a;
        const line = wrapper.querySelector(".systemsculpt-chat-structured-line");
        if (!line) {
          return acc;
        }
        const prefix = line.querySelector(".systemsculpt-chat-structured-line-prefix");
        const depth = Number.parseInt((_a = line.dataset.treeDepth) != null ? _a : "1", 10);
        acc.push({ lineEl: line, prefixEl: prefix != null ? prefix : void 0, depth });
        return acc;
      },
      []
    );
    applyTreeLayout(nodes, { forceEnd: true });
    try {
      errorLogger.debug("Updated reasoning tree connectors", {
        source: "MessageRenderer",
        method: "updateReasoningConnectors",
        metadata: {
          messageId: messageEl.dataset.messageId,
          segments: nodes.length
        }
      });
    } catch (_) {
    }
  }
  refreshStructuredBlocks(messageEl) {
    if (!messageEl) return;
    this.updateReasoningConnectors(messageEl);
    this.updateStructuredBlockFontSizes(messageEl);
  }
  updateStructuredBlockFontSizes(messageEl) {
    const blocks = Array.from(messageEl.querySelectorAll(".systemsculpt-chat-structured-block"));
    if (blocks.length === 0) {
      delete messageEl.dataset.structuredBlockFontSize;
      return;
    }
    delete messageEl.dataset.structuredBlockFontSize;
    blocks.forEach((block) => {
      block.style.removeProperty("font-size");
    });
  }
  /**
   * Append delta reasoning text into a lightweight streaming container to avoid
   * expensive markdown re-renders while tokens arrive.
   */
  appendReasoningStream(contentEl, fullText) {
    var _a;
    let state = this.reasoningThrottledRenderers.get(contentEl);
    if (!state) {
      state = { timeoutId: null, content: "" };
      this.reasoningThrottledRenderers.set(contentEl, state);
    }
    state.content = fullText;
    if (state.timeoutId) return;
    try {
      const messagesContainer = contentEl.closest(".systemsculpt-messages-container");
      const ds = (_a = messagesContainer == null ? void 0 : messagesContainer.dataset) == null ? void 0 : _a.autoscroll;
      const isAnchored = ds === void 0 ? true : ds !== "false";
      if (messagesContainer && isAnchored === false) {
        return;
      }
    } catch (e) {
    }
    state.timeoutId = setTimeout(async () => {
      const current = this.reasoningThrottledRenderers.get(contentEl);
      if (!current) return;
      current.timeoutId = null;
      if (!contentEl.isConnected) {
        this.reasoningThrottledRenderers.delete(contentEl);
        return;
      }
      await this.renderReasoningVerbatim(current.content, contentEl);
    }, this.RENDER_THROTTLE_MS);
  }
  /**
   * Replace the streaming placeholder with a final markdown render.
   */
  async finalizeReasoningStream(contentEl, markdown) {
    const state = this.reasoningThrottledRenderers.get(contentEl);
    if (state == null ? void 0 : state.timeoutId) {
      clearTimeout(state.timeoutId);
      state.timeoutId = null;
    }
    await this.renderReasoningVerbatim(markdown, contentEl);
  }
  /**
   * Render reasoning content verbatim without any preprocessing
   * This preserves the original markdown formatting exactly as authored
   */
  async renderReasoningVerbatim(markdown, containerEl) {
    var _a, _b, _c, _d, _e;
    const plugin = (_b = (_a = this.app.plugins) == null ? void 0 : _a.plugins) == null ? void 0 : _b["systemsculpt-plugin"];
    const debugMode = (_e = (_d = (_c = plugin == null ? void 0 : plugin.settingsManager) == null ? void 0 : _c.settings) == null ? void 0 : _d.debugMode) != null ? _e : false;
    if (debugMode) {
      console.log("[Reasoning Verbatim] Input length:", markdown.length);
      console.log("[Reasoning Verbatim] First 60 chars:", markdown.substring(0, 60));
      console.log("[Reasoning Verbatim] Contains bold markers:", markdown.includes("**"));
    }
    const formattedMarkdown = formatReasoningForDisplay(markdown);
    containerEl.empty();
    await import_obsidian66.MarkdownRenderer.render(
      this.app,
      formattedMarkdown,
      containerEl,
      "systemsculpt-reasoning.md",
      this
    );
    this.postProcessReasoningContent(containerEl, debugMode);
    this.scrollReasoningContainerToBottom(containerEl);
    if (debugMode) {
      console.log("[Reasoning Verbatim] Rendered HTML length:", containerEl.innerHTML.length);
      console.log("[Reasoning Verbatim] Contains <strong> tags:", containerEl.innerHTML.includes("<strong>"));
    }
    try {
      containerEl.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
    } catch (e) {
    }
  }
  scrollReasoningContainerToBottom(contentEl) {
    const scrollContainer = contentEl.closest(".systemsculpt-reasoning-scroll-container");
    if (!scrollContainer) {
      return;
    }
    if (!scrollContainer.isConnected) {
      return;
    }
    try {
      scrollContainer.scrollTop = scrollContainer.scrollHeight;
    } catch (e) {
    }
  }
  removeBlankReasoningParagraphs(container) {
    let removed = 0;
    const sanitize = (value) => {
      if (!value) {
        return "";
      }
      return value.replace(/\u00a0/g, " ").trim();
    };
    const paragraphs = Array.from(container.querySelectorAll("p"));
    paragraphs.forEach((paragraph) => {
      if (sanitize(paragraph.textContent).length > 0) {
        return;
      }
      const hasMeaningfulChild = Array.from(paragraph.children).some((child) => {
        var _a, _b, _c;
        const tagName = (_c = (_b = (_a = child.tagName) == null ? void 0 : _a.toUpperCase) == null ? void 0 : _b.call(_a)) != null ? _c : "";
        if (tagName === "BR") {
          return false;
        }
        if (REASONING_MEANINGFUL_CHILD_TAGS.has(tagName)) {
          return true;
        }
        return sanitize(child.textContent).length > 0;
      });
      if (hasMeaningfulChild) {
        return;
      }
      paragraph.remove();
      removed += 1;
    });
    return removed;
  }
  /**
   * Minimal post-processing for reasoning content - only for safety
   */
  postProcessReasoningContent(container, debugMode) {
    const removedParagraphs = this.removeBlankReasoningParagraphs(container);
    if (debugMode && removedParagraphs > 0) {
      console.debug(
        `[Reasoning Verbatim] Removed ${removedParagraphs} empty paragraph${removedParagraphs === 1 ? "" : "s"}.`
      );
    }
    if (container) {
      container.style.lineHeight = REASONING_COMPACT_LINE_HEIGHT;
      const blockChildren = Array.from(container.children).filter((child) => child instanceof HTMLElement);
      blockChildren.forEach((child, index) => {
        const isFirst = index === 0;
        const isLast = index === blockChildren.length - 1;
        child.style.marginTop = isFirst ? "0" : REASONING_COMPACT_MARGIN;
        child.style.marginBottom = isLast ? "0" : REASONING_COMPACT_MARGIN;
      });
    }
    container.querySelectorAll("pre").forEach((pre) => {
      pre.classList.add("systemsculpt-code-block");
    });
    container.querySelectorAll("img").forEach((img) => {
      img.addClass("systemsculpt-message-image");
      img.style.cursor = "pointer";
      img.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const src = img.getAttribute("src");
        if (!src) return;
        if (src.startsWith("app://")) {
          const path = src.replace("app://local/", "");
          this.app.workspace.openLinkText(path, "", true);
        }
      });
    });
    container.querySelectorAll("a.internal-link").forEach((link) => {
      link.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const href = link.getAttribute("href") || link.getAttribute("data-href");
        if (href) {
          this.app.workspace.openLinkText(href, "", true);
        }
      });
    });
  }
  /**
   * Render content as part of unified display
   */
  renderUnifiedContent(messageEl, content, insertAfterElement, partId, isStreaming = false, messagePart) {
    if (typeof content === "string") {
      if (this.containsChronologicalBlocks(content)) {
        const preview = this.extractNonChronologicalContent(content).trim();
        if (preview.length === 0) {
          return null;
        }
      } else if (content.trim().length === 0) {
        return null;
      }
    } else if (Array.isArray(content)) {
      const partsArray = content;
      const hasRenderable = partsArray.some(
        (p) => p.type === "text" && typeof p.text === "string" && p.text.trim().length > 0 || p.type === "image_url" && p.image_url && p.image_url.url
      );
      if (!hasRenderable) return null;
    } else if (content == null) {
      return null;
    }
    const container = document.createElement("div");
    container.className = "systemsculpt-unified-part systemsculpt-content-part";
    if (partId) {
      container.dataset.partId = partId;
    }
    this.insertElementInOrder(messageEl, container, insertAfterElement);
    if (typeof content === "string" && this.containsChronologicalBlocks(content)) {
      const cleanedContent = this.extractNonChronologicalContent(content);
      if (cleanedContent.trim()) {
        this.renderMarkdownContent(cleanedContent, container, isStreaming);
      }
    } else if (typeof content === "string") {
      this.renderMarkdownContent(content, container, isStreaming);
    } else if (Array.isArray(content)) {
      const parts = content;
      for (const part of parts) {
        if (part.type === "text") {
          const p = container.createEl("p");
          p.setText(part.text);
        } else if (part.type === "image_url") {
          const img = container.createEl("img", {
            attr: { src: part.image_url.url }
          });
          img.classList.add("systemsculpt-message-image");
        }
      }
    } else {
      this.renderMarkdownContent(String(content), container, isStreaming);
    }
    return container;
  }
  /**
   * Process rendered markdown content for code blocks, images, etc.
   */
  processRenderedContent(container) {
    container.querySelectorAll("pre").forEach((preEl) => {
      preEl.classList.add("systemsculpt-code-block");
      if (!preEl.querySelector(".copy-code-button")) {
        const btn = document.createElement("button");
        btn.className = "copy-code-button";
        btn.type = "button";
        btn.setAttribute("aria-label", "Copy code");
        btn.textContent = "Copy";
        btn.addEventListener("click", async (e) => {
          e.preventDefault();
          e.stopPropagation();
          try {
            const codeEl = preEl.querySelector("code");
            const text = codeEl ? codeEl.innerText : preEl.innerText;
            await navigator.clipboard.writeText(text);
            btn.textContent = "Copied";
            setTimeout(() => btn.textContent = "Copy", 1200);
            new import_obsidian66.Notice("Code copied to clipboard", 1500);
          } catch (e2) {
            new import_obsidian66.Notice("Failed to copy code", 2e3);
          }
        });
        preEl.appendChild(btn);
      }
    });
    container.querySelectorAll("img").forEach((img) => {
      img.style.cursor = "pointer";
      img.classList.add("systemsculpt-message-image");
      img.addEventListener("click", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        const src = img.getAttribute("src");
        if (!src) return;
        if (src.startsWith("app://")) {
          const path = src.replace("app://local/", "");
          this.app.workspace.openLinkText(path, "", true);
        }
      });
      try {
        img.addEventListener("load", () => {
          try {
            img.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
          } catch (e) {
          }
        }, { once: true });
      } catch (e) {
      }
    });
  }
  /**
   * Check if content contains chronological blocks from storage
   */
  containsChronologicalBlocks(content) {
    return content.includes("<!-- REASONING-BLOCK -->") || content.includes("<!-- TOOL-CALL-BLOCK -->") || content.includes("<!-- TOOL-RESPONSE-BLOCK -->");
  }
  /**
   * Extract only the non-chronological content (regular text) from storage content
   */
  extractNonChronologicalContent(content) {
    let cleaned = content.replace(/<!-- REASONING-BLOCK -->\n[\s\S]*?\n<!-- \/REASONING-BLOCK -->/g, "").replace(/<!-- TOOL-CALL-BLOCK -->\n[\s\S]*?\n<!-- \/TOOL-CALL-BLOCK -->/g, "").replace(/<!-- TOOL-RESPONSE-BLOCK -->\n[\s\S]*?\n<!-- \/TOOL-RESPONSE-BLOCK -->/g, "");
    cleaned = cleaned.replace(/\n\n\n+/g, "\n\n").trim();
    return cleaned;
  }
  // REMOVED: renderToolCallAsContent - now handled by ToolCallTreeRenderer
  // REMOVED: shouldCollapseByDefault, createStatusIndicator, updateStatusIndicator - now in ToolCallTreeRenderer
  // REMOVED: renderToolCallContent - now in ToolCallTreeRenderer
  // REMOVED: renderToolCallArguments, renderArgument - now in ToolCallTreeRenderer
  // REMOVED: renderApprovalButtons, renderExecutingState, renderToolCallResult,
  // renderLazyResultPlaceholder, renderLazyErrorPlaceholder, createResultPreview
  // - all now in ToolCallTreeRenderer
  // Removed legacy tool-call rendering helpers (migrated to ToolCallTreeRenderer)
  /**
   * Get function data from tool call (handles different formats)
   */
  getFunctionData(toolCall) {
    var _a;
    if (toolCall.request && toolCall.request.function) {
      try {
        const { repairAndParseJson: repairAndParseJson2 } = (init_jsonRepair(), __toCommonJS(jsonRepair_exports));
        const parsed = repairAndParseJson2(toolCall.request.function.arguments);
        return {
          name: toolCall.request.function.name,
          arguments: parsed.ok ? (_a = parsed.value) != null ? _a : {} : {}
        };
      } catch (e) {
        return {
          name: toolCall.request.function.name,
          arguments: {}
          // Return empty object on parse failure
        };
      }
    }
    return null;
  }
  /**
   * Insert element in correct chronological order
   */
  insertElementInOrder(messageEl, newElement, insertAfterElement) {
    if (insertAfterElement) {
      insertAfterElement.insertAdjacentElement("afterend", newElement);
    } else {
      const contentEl = messageEl.querySelector(".systemsculpt-message-content");
      if (contentEl) {
        messageEl.insertBefore(newElement, contentEl);
      } else {
        messageEl.appendChild(newElement);
      }
    }
  }
  renderMessageParts(messageEl, message, isActivelyStreaming = false) {
    const partList = message.messageParts ? new MessagePartList(message.messageParts) : new MessagePartList(MessagePartNormalizer.toParts(message));
    this.renderUnifiedMessageParts(messageEl, partList.parts, isActivelyStreaming);
  }
  // Removed collapseAllDrawers â€“ rolling window + lazy rendering manage expand/collapse
  // REMOVED: shouldShowFileDiff, _getNewFileContent, renderFileDiffPreview, handleToolCallStateChange
  // - all now in ToolCallTreeRenderer
  /**
   * Handle "View in File" button click - opens file and applies diff overlay
   */
  async handleViewInFile(toolCall) {
    var _a, _b, _c, _d, _e, _f;
    try {
      const functionData = this.getFunctionData(toolCall);
      if (!functionData) return;
      const args = functionData.arguments;
      const toolName = functionData.name;
      const filePath = args.path || args.target_file || args.file_path;
      if (!filePath || typeof filePath !== "string") return;
      const currentLeaf = this.app.workspace.activeLeaf;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian66.TFile)) {
        new import_obsidian66.Notice("File not found or is not a valid file.");
        return;
      }
      const allLeaves = this.app.workspace.getLeavesOfType("markdown");
      let existingFileLeaf = null;
      const normalizedPath = (0, import_obsidian66.normalizePath)(filePath);
      for (const leaf of allLeaves) {
        const view = leaf.view;
        if (view.file && (0, import_obsidian66.normalizePath)(view.file.path) === normalizedPath) {
          existingFileLeaf = leaf;
          break;
        }
      }
      if (existingFileLeaf) {
        try {
          (_b = (_a = window.FreezeMonitor) == null ? void 0 : _a.mark) == null ? void 0 : _b.call(_a, "message-renderer:setActiveLeaf:existing");
        } catch (e) {
        }
        this.app.workspace.setActiveLeaf(existingFileLeaf, { focus: false });
      } else {
        let targetLeaf = null;
        const platform = PlatformContext.get();
        const isMobileVariant = platform.uiVariant() === "mobile";
        if (isMobileVariant) {
          targetLeaf = this.app.workspace.getLeaf("tab");
        } else {
          let suitablePane = null;
          this.app.workspace.iterateAllLeaves((leaf) => {
            if (leaf.getRoot() === this.app.workspace.rootSplit && leaf !== currentLeaf) {
              if (!suitablePane) suitablePane = leaf;
            }
          });
          if (suitablePane) {
            try {
              (_d = (_c = window.FreezeMonitor) == null ? void 0 : _c.mark) == null ? void 0 : _d.call(_c, "message-renderer:setActiveLeaf:suitable");
            } catch (e) {
            }
            this.app.workspace.setActiveLeaf(suitablePane, { focus: false });
            targetLeaf = this.app.workspace.getLeaf("tab");
          } else {
            if (currentLeaf && currentLeaf.getRoot() === this.app.workspace.rootSplit) {
              targetLeaf = this.app.workspace.createLeafBySplit(currentLeaf, "vertical", true);
            } else {
              targetLeaf = this.app.workspace.getLeaf(true);
            }
          }
        }
        if (targetLeaf) {
          await targetLeaf.openFile(file);
        }
      }
      if (currentLeaf) {
        try {
          (_f = (_e = window.FreezeMonitor) == null ? void 0 : _e.mark) == null ? void 0 : _f.call(_e, "message-renderer:restoreFocus");
        } catch (e) {
        }
        this.app.workspace.setActiveLeaf(currentLeaf, { focus: true });
      }
    } catch (error) {
    }
  }
  // Add unload method
  unload() {
    this.throttledRenderers = /* @__PURE__ */ new WeakMap();
    super.unload();
  }
  formatToolName(name) {
    return formatToolDisplayName(name);
  }
  /**
   * Generate a simple tool name for the header (no arguments)
   */
  generateToolSummary(toolName, args) {
    const actualToolName = toolName.replace(/^mcp[_-]/i, "");
    if (actualToolName.startsWith("filesystem_")) {
      const parts = actualToolName.split("_");
      const namespace = parts[0];
      const functionName = parts.slice(1).join("_");
      return namespace.charAt(0).toUpperCase() + namespace.slice(1) + ": " + functionName;
    }
    return actualToolName.charAt(0).toUpperCase() + actualToolName.slice(1);
  }
  /**
   * Check if an argument value is meaningful (not empty, null, undefined, or whitespace-only)
   */
  isArgumentValueMeaningful(value) {
    if (value === null || value === void 0) {
      return false;
    }
    if (typeof value === "string") {
      return value.trim().length > 0;
    }
    return true;
  }
  /**
   * Filter arguments to only include meaningful values
   */
  filterMeaningfulArguments(args) {
    const meaningful = {};
    for (const [key, value] of Object.entries(args)) {
      if (this.isArgumentValueMeaningful(value)) {
        meaningful[key] = value;
      }
    }
    return meaningful;
  }
  /**
   * Normalize any message format into sequential MessageParts for unified rendering
   */
  normalizeMessageToParts(message) {
    const parts = MessagePartNormalizer.toParts(message);
    return new MessagePartList(parts);
  }
  /**
   * Helper method to properly animate drawer collapse/expand states
   * Respects animation timing to ensure smooth transitions
   */
  setDrawerCollapsedState(drawerEl, shouldCollapse) {
    const isCurrentlyCollapsed = drawerEl.classList.contains("systemsculpt-collapsed");
    if (isCurrentlyCollapsed === shouldCollapse) {
      return;
    }
    requestAnimationFrame(() => {
      if (shouldCollapse) {
        drawerEl.classList.add("systemsculpt-collapsed");
      } else {
        drawerEl.classList.remove("systemsculpt-collapsed");
      }
    });
  }
  /**
   * Render an "Open File" button for single-file tools when completed
   */
  renderOpenFileButton(headerEl, toolCall) {
    if (toolCall.state !== "completed") {
      return;
    }
    const functionData = this.getFunctionData(toolCall);
    if (!functionData) {
      return;
    }
    const singleFileTools = {
      "write": "path",
      "edit": "path"
    };
    const baseName = functionData.name.replace(/^mcp-filesystem_/, "");
    let filePath = null;
    if (baseName === "move") {
      if (functionData.arguments.items && Array.isArray(functionData.arguments.items) && functionData.arguments.items.length > 0) {
        filePath = functionData.arguments.items[0].destination;
      }
    } else {
      const pathArgument = singleFileTools[baseName];
      if (pathArgument) {
        const pathValue = functionData.arguments[pathArgument];
        if (typeof pathValue === "string") {
          filePath = pathValue;
        }
      }
    }
    if (!filePath) {
      return;
    }
    const openFileBtn = new import_obsidian66.ButtonComponent(headerEl).setButtonText("Open File").setClass("systemsculpt-tool-call-open-file-btn").setClass("mod-small").setTooltip(`Open ${filePath}`).onClick(async (event) => {
      event.stopPropagation();
      if (filePath) {
        await this.openFileInWorkspace(filePath);
      }
    });
  }
  /**
   * Open a file using workspace management logic similar to open
   */
  async openFileInWorkspace(filePath) {
    try {
      const currentLeaf = this.app.workspace.activeLeaf;
      const { action } = await openFileInMainWorkspace(this.app, filePath);
      if (action !== "switched_in_pane" && currentLeaf) {
        this.app.workspace.setActiveLeaf(currentLeaf, { focus: true });
      }
    } catch (error) {
      new import_obsidian66.Notice("Error opening file. See console for details.");
    }
  }
  // Removed collapseReasoningDrawers â€“ not used in compact flow
  getFilePathFromToolCall(toolCall) {
    const functionData = this.getFunctionData(toolCall);
    if (!functionData) return null;
    const toolName = functionData.name;
    const args = functionData.arguments || {};
    if (toolName === "move" && args.items && Array.isArray(args.items) && args.items.length > 0) {
      return args.items[0].destination || null;
    }
    const pathArgMap = {
      "read": "paths",
      "write": "path",
      "edit": "path",
      "trash": "paths"
    };
    const argName = pathArgMap[toolName];
    if (!argName) return null;
    const pathValue = args[argName];
    if (typeof pathValue === "string") {
      return pathValue;
    } else if (Array.isArray(pathValue) && typeof pathValue[0] === "string") {
      return pathValue[0];
    }
    return null;
  }
  /**
   * Render large text content in a collapsed format with external access options
   */
  async renderCollapsedLargeText(content, contentEl) {
    const lineCount = LargeTextHelpers.getLineCount(content);
    const sizeKB = Math.round(LargeTextHelpers.getTextSizeKB(content));
    const collapsedContainer = contentEl.createEl("div", {
      cls: "systemsculpt-large-text-container"
    });
    const previewContent = LargeTextHelpers.getPreviewContent(content);
    const previewEl = collapsedContainer.createEl("div", {
      cls: "systemsculpt-large-text-preview"
    });
    await this.renderMarkdownContent(previewContent, previewEl, false);
    if (lineCount > LARGE_TEXT_THRESHOLDS.MAX_LINES_PREVIEW) {
      const truncationEl = previewEl.createEl("div", {
        cls: "systemsculpt-text-truncation",
        text: LARGE_TEXT_MESSAGES.TRUNCATION_INDICATOR
      });
    }
    const collapseIndicator = collapsedContainer.createEl("div", {
      cls: "systemsculpt-large-text-indicator"
    });
    collapseIndicator.innerHTML = `
      <span class="systemsculpt-large-text-stats">
        ${LARGE_TEXT_UI.STATS_PREFIX}${lineCount} lines (${LargeTextHelpers.formatSize(sizeKB)})
      </span>
      <div class="systemsculpt-large-text-actions">
        <button class="systemsculpt-view-button">
          \u{1F4C4} View in Modal
        </button>
        <button class="systemsculpt-save-button">
          \u{1F4BE} Save to File
        </button>
        <button class="systemsculpt-copy-button">
          \u{1F4CB} Copy to Clipboard
        </button>
      </div>
    `;
    const viewButton = collapseIndicator.querySelector(".systemsculpt-view-button");
    const saveButton = collapseIndicator.querySelector(".systemsculpt-save-button");
    const copyButton = collapseIndicator.querySelector(".systemsculpt-copy-button");
    viewButton.addEventListener("click", () => {
      this.showLargeTextModal(content, `Large Text Content (${lineCount}${LARGE_TEXT_UI.MODAL_TITLE_SUFFIX}`);
    });
    saveButton.addEventListener("click", () => {
      this.saveLargeTextToFile(content, sizeKB);
    });
    copyButton.addEventListener("click", () => {
      navigator.clipboard.writeText(content);
      copyButton.textContent = "\u2713 Copied";
      setTimeout(() => {
        copyButton.innerHTML = "\u{1F4CB} Copy to Clipboard";
      }, 1e3);
    });
  }
  /**
   * Show large text content in a proper Obsidian modal
   */
  showLargeTextModal(content, title) {
    new LargeTextModal(this.app, content, title).open();
  }
  /**
   * Save large text content to a file
   */
  async saveLargeTextToFile(content, sizeKB) {
    try {
      const blob = new Blob([content], { type: "text/plain" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = `large-text-${Date.now()}.txt`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      const notice = document.createElement("div");
      notice.className = "systemsculpt-notice";
      notice.textContent = `\u2713 Large text saved to file (${LargeTextHelpers.formatSize(sizeKB)})`;
      document.body.appendChild(notice);
      setTimeout(() => {
        notice.remove();
      }, 3e3);
    } catch (error) {
    }
  }
};
var LargeTextModal = class extends import_obsidian66.Modal {
  constructor(app, content, title) {
    super(app);
    this.content = content;
    this.title = title;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText(this.title);
    const container = contentEl.createEl("div", {
      cls: "large-text-modal-container"
    });
    const textarea = container.createEl("textarea", {
      cls: "large-text-viewer",
      attr: {
        readonly: "true",
        spellcheck: "false"
      }
    });
    textarea.value = this.content;
    textarea.style.width = "100%";
    textarea.style.height = "60vh";
    textarea.style.minHeight = "400px";
    textarea.style.fontFamily = "var(--font-monospace)";
    textarea.style.fontSize = "13px";
    textarea.style.lineHeight = "1.4";
    textarea.style.resize = "vertical";
    textarea.style.border = "1px solid var(--border-color)";
    textarea.style.borderRadius = "4px";
    textarea.style.padding = "12px";
    textarea.style.backgroundColor = "var(--background-primary)";
    textarea.style.color = "var(--text-normal)";
    const buttonContainer = container.createEl("div", {
      cls: "large-text-modal-buttons"
    });
    buttonContainer.style.marginTop = "12px";
    buttonContainer.style.display = "flex";
    buttonContainer.style.gap = "8px";
    buttonContainer.style.justifyContent = "flex-end";
    const copyButton = buttonContainer.createEl("button", {
      text: "Copy to Clipboard",
      cls: "mod-cta"
    });
    copyButton.addEventListener("click", async () => {
      try {
        await navigator.clipboard.writeText(this.content);
        copyButton.setText("\u2713 Copied!");
        setTimeout(() => {
          copyButton.setText("Copy to Clipboard");
        }, 1500);
      } catch (error) {
        copyButton.setText("Copy failed");
        setTimeout(() => {
          copyButton.setText("Copy to Clipboard");
        }, 1500);
      }
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/chatview/ChatView.ts
init_SystemPromptService();
init_titleUtils();
init_StandardModelSelectionModal();
init_modelUtils();
init_errorLogger();
init_prompts2();
init_ToolCallManager();
init_MCPService2();

// src/views/chatview/export/ChatExportService.ts
var import_obsidian67 = require("obsidian");
init_SystemPromptService();
init_modelUtils();
init_errorLogger();

// src/views/chatview/export/ChatExportBuilder.ts
var OPTION_KEYS = [
  "includeMetadata",
  "includeSystemPrompt",
  "includeContextFiles",
  "includeContextFileContents",
  "includeConversation",
  "includeUserMessages",
  "includeAssistantMessages",
  "includeToolMessages",
  "includeReasoning",
  "includeToolCalls",
  "includeToolCallArguments",
  "includeToolCallResults",
  "includeImages"
];
var ChatExportBuilder = class {
  constructor(context) {
    this.context = context;
  }
  build(options) {
    const sections = [];
    sections.push(this.renderFrontMatter(options));
    if (options.includeMetadata) {
      const summary = this.renderSummary();
      if (summary) sections.push(summary);
    }
    if (options.includeSystemPrompt) {
      const prompt = this.renderSystemPrompt();
      if (prompt) sections.push(prompt);
    }
    if (options.includeContextFiles) {
      const contextFiles = this.renderContextFiles(options);
      if (contextFiles) sections.push(contextFiles);
    }
    if (options.includeConversation) {
      const conversation = this.renderConversation(options);
      if (conversation) sections.push(conversation);
    }
    return sections.filter(Boolean).join("\n\n") + "\n";
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Front matter
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderFrontMatter(options) {
    var _a, _b;
    const lines = ["---"];
    lines.push(`title: "${this.escapeYaml(this.context.title || "Chat Export")}"`);
    if (this.context.chatId) {
      lines.push(`chatId: "${this.escapeYaml(this.context.chatId)}"`);
    }
    if (typeof this.context.chatVersion === "number") {
      lines.push(`chatVersion: ${this.context.chatVersion}`);
    }
    const exportedAt = this.context.exportedAt instanceof Date ? this.context.exportedAt.toISOString() : String(this.context.exportedAt || (/* @__PURE__ */ new Date()).toISOString());
    lines.push(`exportedAt: "${this.escapeYaml(exportedAt)}"`);
    if (((_a = this.context.model) == null ? void 0 : _a.id) || ((_b = this.context.model) == null ? void 0 : _b.label)) {
      lines.push("model:");
      if (this.context.model.id) {
        lines.push(`  id: "${this.escapeYaml(this.context.model.id)}"`);
      }
      if (this.context.model.label) {
        lines.push(`  label: "${this.escapeYaml(this.context.model.label)}"`);
      }
    }
    if (typeof this.context.agentModeEnabled === "boolean") {
      lines.push(`agentMode: ${this.context.agentModeEnabled}`);
    }
    if (typeof this.context.webSearchEnabled === "boolean") {
      lines.push(`webSearch: ${this.context.webSearchEnabled}`);
    }
    lines.push("options:");
    OPTION_KEYS.forEach((key) => {
      lines.push(`  ${key}: ${options[key]}`);
    });
    lines.push("---");
    return lines.join("\n");
  }
  escapeYaml(value) {
    return value.replace(/"/g, '\\"');
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Summary
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderSummary() {
    const summary = this.context.summary;
    const lines = ["## Summary"];
    if (!summary) {
      lines.push("", "_No summary available._");
      return lines.join("\n");
    }
    const bulletLines = [];
    if (summary.totalMessages > 0) {
      bulletLines.push(`- Total messages: ${summary.totalMessages}`);
    }
    if (summary.assistantMessages > 0) {
      bulletLines.push(`- Assistant messages: ${summary.assistantMessages}`);
    }
    if (summary.userMessages > 0) {
      bulletLines.push(`- User messages: ${summary.userMessages}`);
    }
    if (summary.toolMessages > 0) {
      bulletLines.push(`- Tool messages: ${summary.toolMessages}`);
    }
    if (summary.toolCallCount > 0) {
      bulletLines.push(`- Tool calls: ${summary.toolCallCount}`);
    }
    if (summary.reasoningBlockCount > 0) {
      bulletLines.push(`- Reasoning blocks: ${summary.reasoningBlockCount}`);
    }
    if (summary.imageCount > 0) {
      bulletLines.push(`- Images referenced: ${summary.imageCount}`);
    }
    lines.push("");
    if (bulletLines.length === 0) {
      lines.push("_No message statistics available._");
    } else {
      lines.push(...bulletLines);
    }
    return lines.join("\n");
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // System prompt
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderSystemPrompt() {
    var _a;
    const systemPrompt = this.context.systemPrompt;
    if (!((_a = systemPrompt == null ? void 0 : systemPrompt.content) == null ? void 0 : _a.trim())) {
      return null;
    }
    const headingLabel = systemPrompt.label || this.formatSystemPromptLabel(systemPrompt.type);
    const lines = ["## System Prompt", "", `### ${headingLabel}`, "", "```text"];
    systemPrompt.content.split(/\r?\n/).forEach((line) => {
      lines.push(line);
    });
    lines.push("```");
    return lines.join("\n");
  }
  formatSystemPromptLabel(type) {
    if (!type) {
      return "System Prompt";
    }
    return this.capitalize(type.replace(/[-_]/g, " "));
  }
  capitalize(value) {
    if (!value) {
      return "";
    }
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Context files
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderContextFiles(options) {
    const files = this.context.contextFiles || [];
    if (files.length === 0) {
      return null;
    }
    const lines = ["## Context Files", ""];
    files.forEach((file, index) => {
      var _a;
      lines.push(`- [[${file.path}]]`);
      if (options.includeContextFileContents && ((_a = file.content) == null ? void 0 : _a.trim())) {
        lines.push("");
        lines.push("```text");
        file.content.split(/\r?\n/).forEach((line) => {
          lines.push(line);
        });
        lines.push("```");
        if (index !== files.length - 1) {
          lines.push("");
        }
      }
    });
    return lines.join("\n").replace(/\n{3,}/g, "\n\n");
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Conversation
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  renderConversation(options) {
    const messages = this.context.messages || [];
    const lines = ["## Conversation"];
    let visibleIndex = 0;
    messages.forEach((message) => {
      if (!this.shouldIncludeMessage(message.role, options)) {
        return;
      }
      visibleIndex += 1;
      lines.push("");
      lines.push(`### ${visibleIndex}. ${this.capitalize(message.role)}`);
      const body = this.renderMessageBody(message, options);
      if (body.length === 0) {
        lines.push("");
        lines.push("_(No content)_");
        return;
      }
      lines.push("");
      lines.push(...body);
    });
    if (visibleIndex === 0) {
      lines.push("");
      lines.push("_No messages exported._");
    }
    return lines.join("\n");
  }
  shouldIncludeMessage(role, options) {
    switch (role) {
      case "assistant":
        return options.includeAssistantMessages;
      case "user":
        return options.includeUserMessages;
      case "tool":
        return options.includeToolMessages;
      case "system":
        return true;
      default:
        return true;
    }
  }
  renderMessageBody(message, options) {
    const output = [];
    const parts = MessagePartNormalizer.toParts(message);
    if (!parts || parts.length === 0) {
      this.appendContent(output, message.content, options);
      return output;
    }
    let reasoningBuffer = [];
    const flushReasoning = () => {
      if (!options.includeReasoning || reasoningBuffer.length === 0) {
        reasoningBuffer = [];
        return;
      }
      this.pushBlock(output, ["```reasoning", ...reasoningBuffer.join("").split(/\r?\n/), "```"]);
      reasoningBuffer = [];
    };
    parts.forEach((part) => {
      var _a;
      switch (part.type) {
        case "reasoning":
          reasoningBuffer.push(String((_a = part.data) != null ? _a : ""));
          break;
        case "tool_call":
          flushReasoning();
          if (options.includeToolCalls) {
            this.appendToolCall(output, part.data, options);
          }
          break;
        case "content":
          flushReasoning();
          this.appendContent(output, part.data, options);
          break;
        default:
          flushReasoning();
          break;
      }
    });
    flushReasoning();
    return output;
  }
  appendToolCall(lines, toolCall, options) {
    var _a, _b, _c, _d, _e;
    if (!toolCall) return;
    const name = ((_b = (_a = toolCall.request) == null ? void 0 : _a.function) == null ? void 0 : _b.name) || ((_c = toolCall.request) == null ? void 0 : _c.id) || toolCall.id;
    const state = toolCall.state || "unknown";
    const headerLines = [`**Tool Call \u2022 ${name} (${state})**`];
    if (toolCall.serverId) {
      headerLines.push(`Server: ${toolCall.serverId}`);
    }
    this.pushBlock(lines, headerLines);
    if (options.includeToolCallArguments) {
      const args = (_e = (_d = toolCall.request) == null ? void 0 : _d.function) == null ? void 0 : _e.arguments;
      if (args && args.trim()) {
        const jsonLines = this.formatAsPrettyJson(args);
        this.pushBlock(lines, ["Arguments:", "```json", ...jsonLines, "```"]);
      }
    }
    if (options.includeToolCallResults) {
      const result = toolCall.result;
      if (result) {
        if (result.success && result.data !== void 0) {
          this.pushBlock(lines, ["Result:", "```json", ...this.formatAsPrettyJson(result.data), "```"]);
        } else if (result.error) {
          this.pushBlock(lines, ["Error:", "```json", ...this.formatAsPrettyJson(result.error), "```"]);
        } else {
          this.pushBlock(lines, ["Result:", "```json", ...this.formatAsPrettyJson(result), "```"]);
        }
      }
    }
  }
  appendContent(lines, content, options) {
    const segments = this.normalizeContentSegments(content, options);
    segments.forEach((segment) => {
      if (!segment || !segment.trim()) return;
      this.pushBlock(lines, segment.split(/\r?\n/));
    });
  }
  normalizeContentSegments(content, options) {
    if (!content) {
      return [];
    }
    if (typeof content === "string") {
      return [content];
    }
    const segments = [];
    content.forEach((part) => {
      var _a;
      if (part.type === "text") {
        segments.push(part.text);
      }
      if (part.type === "image_url" && options.includeImages) {
        const url = (_a = part.image_url) == null ? void 0 : _a.url;
        if (url) {
          segments.push(`![Image](${url})`);
        }
      }
    });
    return segments;
  }
  formatAsPrettyJson(payload) {
    if (typeof payload === "string") {
      try {
        const parsed = JSON.parse(payload);
        return JSON.stringify(parsed, null, 2).split(/\r?\n/);
      } catch (e) {
        return payload.split(/\r?\n/);
      }
    }
    try {
      return JSON.stringify(payload, null, 2).split(/\r?\n/);
    } catch (e) {
      return [String(payload)];
    }
  }
  pushBlock(target, block) {
    const trimmedBlock = block.slice();
    while (trimmedBlock.length > 0 && trimmedBlock[0] === "") {
      trimmedBlock.shift();
    }
    while (trimmedBlock.length > 0 && trimmedBlock[trimmedBlock.length - 1] === "") {
      trimmedBlock.pop();
    }
    if (trimmedBlock.length === 0) return;
    if (target.length > 0 && target[target.length - 1] !== "") {
      target.push("");
    }
    target.push(...trimmedBlock);
  }
};

// src/views/chatview/export/ChatExportService.ts
init_chatExport();
var ChatExportService = class {
  constructor(chatView) {
    this.chatView = chatView;
  }
  async export(overrides) {
    const options = normalizeChatExportOptions(overrides);
    errorLogger.info("Preparing chat export", {
      source: "ChatExportService",
      method: "export",
      metadata: {
        chatId: this.chatView.chatId,
        messageCount: this.chatView.messages.length,
        options
      }
    });
    const context = await this.buildContext(options);
    const builder = new ChatExportBuilder(context);
    const markdown = builder.build(options);
    errorLogger.info("Chat export complete", {
      source: "ChatExportService",
      method: "export",
      metadata: {
        chatId: context.chatId,
        includedMessages: context.summary.totalMessages,
        toolCalls: context.summary.toolCallCount
      }
    });
    return {
      markdown,
      context,
      options
    };
  }
  async buildContext(options) {
    const exportedAt = /* @__PURE__ */ new Date();
    const modelLabel = this.chatView.selectedModelId ? getModelLabelWithProvider(this.chatView.selectedModelId) : this.chatView.currentModelName || "";
    const systemPrompt = options.includeSystemPrompt ? await this.resolveSystemPrompt() : void 0;
    const contextFiles = options.includeContextFiles ? await this.collectContextFiles(options) : [];
    const summary = this.calculateSummary(this.chatView.messages);
    return {
      title: this.chatView.chatTitle,
      chatId: this.chatView.chatId,
      chatVersion: this.chatView.chatVersion,
      exportedAt,
      model: modelLabel ? { id: this.chatView.selectedModelId, label: modelLabel } : void 0,
      agentModeEnabled: this.chatView.agentMode,
      webSearchEnabled: this.chatView.webSearchEnabled,
      systemPrompt,
      contextFiles,
      messages: [...this.chatView.messages],
      summary
    };
  }
  calculateSummary(messages) {
    const summary = {
      totalMessages: messages.length,
      assistantMessages: 0,
      userMessages: 0,
      toolMessages: 0,
      toolCallCount: 0,
      reasoningBlockCount: 0,
      imageCount: 0
    };
    for (const message of messages) {
      switch (message.role) {
        case "assistant":
          summary.assistantMessages += 1;
          break;
        case "user":
          summary.userMessages += 1;
          break;
        case "tool":
          summary.toolMessages += 1;
          break;
        default:
          break;
      }
      const parts = MessagePartNormalizer.toParts(message);
      parts.forEach((part) => {
        if (part.type === "tool_call") {
          summary.toolCallCount += 1;
        }
        if (part.type === "reasoning") {
          summary.reasoningBlockCount += 1;
        }
        if (part.type === "content") {
          summary.imageCount += this.countImages(part.data);
        }
      });
      if (!parts.length && message.content) {
        summary.imageCount += this.countImages(message.content);
      }
    }
    return summary;
  }
  countImages(content) {
    if (!content || typeof content === "string") {
      return 0;
    }
    let count = 0;
    content.forEach((part) => {
      var _a;
      if (part.type === "image_url" && ((_a = part.image_url) == null ? void 0 : _a.url)) {
        count += 1;
      }
    });
    return count;
  }
  async resolveSystemPrompt() {
    try {
      const type = this.chatView.systemPromptType || "general-use";
      const path = this.chatView.systemPromptPath;
      const service = SystemPromptService.getInstance(this.chatView.app, () => this.chatView.plugin.settings);
      const basePrompt = await service.getSystemPromptContent(type, path, this.chatView.agentMode);
      const combined = await service.combineWithAgentPrefix(basePrompt, type, this.chatView.agentMode);
      return {
        type,
        label: this.deriveSystemPromptLabel(type, path),
        content: combined
      };
    } catch (error) {
      errorLogger.warn("Failed to resolve system prompt for export", {
        source: "ChatExportService",
        method: "resolveSystemPrompt",
        metadata: {
          chatId: this.chatView.chatId,
          error: error instanceof Error ? error.message : String(error)
        }
      });
      return void 0;
    }
  }
  deriveSystemPromptLabel(type, path) {
    const normalized = (type || "").toLowerCase();
    if (normalized === "custom" && path) {
      const segments = path.split("/");
      return segments[segments.length - 1] || "Custom";
    }
    if (normalized === "general-use") {
      return "General Use";
    }
    if (normalized === "concise") {
      return "Concise";
    }
    if (normalized === "agent") {
      return "Agent";
    }
    return this.capitalize(type || "System Prompt");
  }
  async collectContextFiles(options) {
    var _a, _b, _c;
    const results = [];
    const contextManager = this.chatView.contextManager;
    if (!contextManager) {
      return results;
    }
    const seen = /* @__PURE__ */ new Set();
    const rawFiles = Array.from(((_a = contextManager.getContextFiles) == null ? void 0 : _a.call(contextManager)) || []);
    for (const entry of rawFiles) {
      const cleanPath = this.cleanContextFileEntry(entry);
      if (!cleanPath || seen.has(cleanPath)) {
        continue;
      }
      seen.add(cleanPath);
      const record = { path: cleanPath };
      if (options.includeContextFileContents) {
        const content = await this.tryReadFileContents(cleanPath);
        if (content) {
          record.content = content;
        }
      }
      results.push(record);
    }
    if ((_b = contextManager.isVaultStructureIncluded) == null ? void 0 : _b.call(contextManager)) {
      const structure = (_c = contextManager.getVaultStructure) == null ? void 0 : _c.call(contextManager);
      if (structure) {
        const structureRecord = { path: "Vault Structure" };
        if (options.includeContextFileContents) {
          structureRecord.content = structure;
        }
        results.push(structureRecord);
      }
    }
    return results;
  }
  cleanContextFileEntry(entry) {
    if (!entry) {
      return null;
    }
    if (entry.startsWith("doc:")) {
      return null;
    }
    const withoutWiki = entry.replace(/^\[\[(.*?)\]\]$/, "$1");
    const withoutMath = withoutWiki.replace(/\$begin:math:display\$\[(.*?)\$end:math:display\$]/g, "$1");
    const trimmed = withoutMath.trim();
    return trimmed.length > 0 ? trimmed : null;
  }
  async tryReadFileContents(path) {
    try {
      const file = this.chatView.app.metadataCache.getFirstLinkpathDest(path, "");
      if (!(file instanceof import_obsidian67.TFile)) {
        return void 0;
      }
      if (this.isBinaryFile(file)) {
        return void 0;
      }
      return await this.chatView.app.vault.read(file);
    } catch (error) {
      errorLogger.warn("Failed to read context file for export", {
        source: "ChatExportService",
        method: "tryReadFileContents",
        metadata: {
          path,
          error: error instanceof Error ? error.message : String(error)
        }
      });
      return void 0;
    }
  }
  isBinaryFile(file) {
    var _a;
    const extension = (_a = file.extension) == null ? void 0 : _a.toLowerCase();
    return /^(png|jpe?g|gif|webp|bmp|svg|mp3|wav|flac|ogg|mp4|m4a|mov|pdf|zip|tar|gz)$/i.test(extension);
  }
  capitalize(value) {
    if (!value) {
      return "";
    }
    return value.charAt(0).toUpperCase() + value.slice(1);
  }
};

// src/views/chatview/uiSetup.ts
var import_obsidian87 = require("obsidian");
init_StandardModelSelectionModal();
init_ui();

// src/views/chatview/FileContextManager.ts
var import_obsidian73 = require("obsidian");

// src/views/chatview/DrawerComponent.ts
var import_obsidian68 = require("obsidian");
var DrawerComponent = class extends import_obsidian68.Component {
  constructor(options) {
    super();
    this.isMouseInProximity = false;
    this.hideTimeout = null;
    this.options = options;
    this.initializeDrawer();
    this.setupEventListeners();
  }
  initializeDrawer() {
    this.drawer = this.options.container.createEl("div", {
      cls: `systemsculpt-drawer ${this.options.cls || ""}`
    });
    this.header = this.drawer.createEl("div", {
      cls: "systemsculpt-drawer-header systemsculpt-model-indicator systemsculpt-chip"
    });
    const iconSpan = this.header.createSpan({ cls: "systemsculpt-model-indicator-icon" });
    (0, import_obsidian68.setIcon)(iconSpan, "files");
    const titleEl = this.header.createEl("div", {
      cls: "systemsculpt-drawer-title"
    });
    titleEl.createSpan({ text: this.options.title });
    this.toggle = this.header.createSpan({
      cls: "systemsculpt-drawer-toggle systemsculpt-model-indicator-arrow"
    });
    (0, import_obsidian68.setIcon)(this.toggle, "chevron-down");
    this.content = this.drawer.createEl("div", {
      cls: "systemsculpt-drawer-content"
    });
    this.setVisibility(false);
  }
  setupEventListeners() {
    this.registerDomEvent(this.drawer, "mouseenter", () => {
      this.isMouseInProximity = true;
      this.clearHideTimeout();
      this.setVisibility(true);
    });
    this.registerDomEvent(this.content, "mouseenter", () => {
      this.isMouseInProximity = true;
      this.clearHideTimeout();
      this.setVisibility(true);
    });
    this.registerDomEvent(this.drawer, "mouseleave", (e) => {
      const rect = this.drawer.getBoundingClientRect();
      const buffer = 25;
      if (e.clientY >= rect.bottom && e.clientY <= rect.bottom + buffer && e.clientX >= rect.left && e.clientX <= rect.right) {
        return;
      }
      this.isMouseInProximity = false;
      this.scheduleHide();
    });
    this.registerDomEvent(this.content, "mouseleave", (e) => {
      const rect = this.content.getBoundingClientRect();
      const buffer = 25;
      if (e.clientY <= rect.top && e.clientY >= rect.top - buffer && e.clientX >= rect.left && e.clientX <= rect.right) {
        return;
      }
      this.isMouseInProximity = false;
      this.scheduleHide();
    });
    this.registerDomEvent(this.header, "click", () => {
      const isVisible = this.content.style.opacity === "1";
      this.setVisibility(!isVisible);
    });
  }
  clearHideTimeout() {
    if (this.hideTimeout) {
      clearTimeout(this.hideTimeout);
      this.hideTimeout = null;
    }
  }
  scheduleHide() {
    this.clearHideTimeout();
    this.hideTimeout = setTimeout(() => {
      if (!this.isMouseInProximity) {
        this.setVisibility(false);
      }
    }, 100);
  }
  setVisibility(visible) {
    this.content.style.opacity = visible ? "1" : "0";
    this.content.style.pointerEvents = visible ? "all" : "none";
    this.content.style.transform = `translateY(${visible ? "0" : "-8px"})`;
    this.drawer.setAttribute("data-visible", visible.toString());
    if (this.options.onVisibilityChange) {
      this.options.onVisibilityChange(visible);
    }
  }
  getContent() {
    return this.content;
  }
  getDrawer() {
    return this.drawer;
  }
  getHeader() {
    return this.header;
  }
  unload() {
    this.clearHideTimeout();
    super.unload();
  }
};

// src/views/chatview/FileContextManager.ts
init_DocumentProcessingService();

// src/modals/ContextSelectionModal.ts
var import_obsidian69 = require("obsidian");
var FILE_TYPES = {
  text: { extensions: ["md", "txt"], icon: "file-text", label: "Text" },
  documents: { extensions: ["pdf", "doc", "docx", "ppt", "pptx", "xls", "xlsx"], icon: "file", label: "Documents" },
  images: { extensions: ["png", "jpg", "jpeg", "gif", "svg", "webp"], icon: "image", label: "Images" },
  audio: { extensions: ["mp3", "wav", "m4a", "ogg", "webm"], icon: "headphones", label: "Audio" }
};
var ContextSelectionModal = class extends import_obsidian69.Modal {
  constructor(app, onSelect, plugin) {
    super(app);
    this.files = [];
    this.filteredFiles = [];
    this.selectedFiles = /* @__PURE__ */ new Set();
    this.currentFilter = "all";
    this.searchQuery = "";
    this.addButton = null;
    this.onSelect = onSelect;
    this.plugin = plugin;
    this.initializeFiles();
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    this.titleEl.setText("Add Context Files");
    new import_obsidian69.Setting(contentEl).setName("Search files").addText((text) => {
      text.setPlaceholder("Type to search...").onChange((value) => {
        this.searchQuery = value.toLowerCase();
        this.applyFilters();
      });
      setTimeout(() => text.inputEl.focus(), 100);
    });
    const filterContainer = contentEl.createDiv("context-filter-container");
    const allBtn = filterContainer.createEl("button", {
      text: "All",
      cls: "context-filter-btn is-active"
    });
    allBtn.onclick = () => this.setFilter("all", allBtn);
    Object.entries(FILE_TYPES).forEach(([type, info]) => {
      const btn = filterContainer.createEl("button", { cls: "context-filter-btn" });
      const icon = btn.createSpan();
      (0, import_obsidian69.setIcon)(icon, info.icon);
      btn.createSpan({ text: info.label });
      btn.onclick = () => this.setFilter(type, btn);
    });
    const listContainer = contentEl.createDiv("context-file-list");
    this.renderFileList(listContainer);
    new import_obsidian69.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => {
      this.addButton = btn;
      this.updateAddButton(btn);
      btn.onClick(async () => {
        await this.handleSelection();
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.selectedFiles.clear();
  }
  initializeFiles() {
    const allFiles = this.app.vault.getFiles();
    this.files = [];
    for (const file of allFiles) {
      const ext = file.extension.toLowerCase();
      for (const [typeName, typeInfo] of Object.entries(FILE_TYPES)) {
        if (typeInfo.extensions.includes(ext)) {
          this.files.push({
            file,
            type: typeName,
            searchText: `${file.basename} ${file.path} ${ext}`.toLowerCase()
          });
          break;
        }
      }
    }
    this.files.sort((a, b) => a.file.basename.localeCompare(b.file.basename));
    this.filteredFiles = [...this.files];
  }
  setFilter(filter, buttonEl) {
    var _a;
    (_a = buttonEl.parentElement) == null ? void 0 : _a.querySelectorAll(".context-filter-btn").forEach((btn) => {
      btn.removeClass("is-active");
    });
    buttonEl.addClass("is-active");
    this.currentFilter = filter;
    this.applyFilters();
  }
  applyFilters() {
    let filtered = this.files;
    if (this.currentFilter !== "all") {
      filtered = filtered.filter((item) => item.type === this.currentFilter);
    }
    if (this.searchQuery) {
      filtered = filtered.filter((item) => item.searchText.includes(this.searchQuery));
    }
    this.filteredFiles = filtered;
    const listContainer = this.contentEl.querySelector(".context-file-list");
    if (listContainer) {
      this.renderFileList(listContainer);
    }
  }
  renderFileList(container) {
    container.empty();
    if (this.filteredFiles.length === 0) {
      const empty = container.createDiv("context-empty");
      const emptyIcon = empty.createDiv();
      (0, import_obsidian69.setIcon)(emptyIcon, "file-x");
      empty.createEl("p", { text: "No files found" });
      return;
    }
    const visibleFiles = this.filteredFiles.slice(0, 100);
    visibleFiles.forEach((item) => {
      const fileEl = container.createDiv("context-file-item");
      const isSelected = this.selectedFiles.has(item.file);
      if (isSelected) {
        fileEl.addClass("is-selected");
      }
      const iconEl = fileEl.createDiv("context-file-icon");
      (0, import_obsidian69.setIcon)(iconEl, FILE_TYPES[item.type].icon);
      const infoEl = fileEl.createDiv("context-file-info");
      infoEl.createDiv({ text: item.file.basename, cls: "context-file-name" });
      infoEl.createDiv({ text: item.file.path, cls: "context-file-path" });
      const checkbox = fileEl.createEl("input", { type: "checkbox" });
      checkbox.checked = isSelected;
      fileEl.onclick = () => this.toggleFileSelection(item.file);
    });
    if (this.filteredFiles.length > 100) {
      const loadMore = container.createEl("button", {
        text: `Show ${this.filteredFiles.length - 100} more files`,
        cls: "context-load-more"
      });
      loadMore.onclick = () => {
        container.empty();
        this.filteredFiles.forEach((item) => {
        });
      };
    }
  }
  toggleFileSelection(file) {
    if (this.selectedFiles.has(file)) {
      this.selectedFiles.delete(file);
    } else {
      this.selectedFiles.add(file);
    }
    const listContainer = this.contentEl.querySelector(".context-file-list");
    if (listContainer) {
      this.renderFileList(listContainer);
    }
    this.updateAddButtonState();
  }
  updateAddButton(btn) {
    const count = this.selectedFiles.size;
    if (count === 0) {
      btn.setButtonText("Add Files").setDisabled(true);
    } else {
      btn.setButtonText(`Add ${count} File${count === 1 ? "" : "s"}`).setDisabled(false).setCta();
    }
  }
  updateAddButtonState() {
    if (this.addButton) {
      this.updateAddButton(this.addButton);
    }
  }
  setLoadingState(loading) {
    const buttons = this.contentEl.querySelectorAll("button");
    const cancelButton = Array.from(buttons).find((btn) => {
      var _a;
      return (_a = btn.textContent) == null ? void 0 : _a.includes("Cancel");
    });
    if (loading) {
      if (this.addButton) {
        this.addButton.setButtonText("Processing...").setDisabled(true);
        this.addButton.buttonEl.removeClass("mod-cta");
      }
      if (cancelButton) {
        cancelButton.disabled = true;
      }
      const fileItems = this.contentEl.querySelectorAll(".context-file-item");
      fileItems.forEach((item) => {
        item.style.pointerEvents = "none";
        item.addClass("is-disabled");
      });
    } else {
      if (this.addButton) {
        this.updateAddButton(this.addButton);
      }
      if (cancelButton) {
        cancelButton.disabled = false;
      }
      const fileItems = this.contentEl.querySelectorAll(".context-file-item");
      fileItems.forEach((item) => {
        item.style.pointerEvents = "auto";
        item.removeClass("is-disabled");
      });
    }
  }
  async handleSelection() {
    if (this.selectedFiles.size === 0) return;
    const selectedArray = Array.from(this.selectedFiles);
    try {
      this.setLoadingState(true);
      await this.onSelect(selectedArray);
      this.close();
    } catch (error) {
      this.setLoadingState(false);
    }
  }
};

// src/views/chatview/FileContextManager.ts
var import_obsidian74 = require("obsidian");

// src/services/PreviewService.ts
var import_obsidian70 = require("obsidian");
var _PreviewService = class _PreviewService {
  // Maximum file size to attempt to preview (100KB)
  /**
   * Get the appropriate cache for a provider type
   */
  static getCacheForProvider(providerType = "systemsculpt") {
    if (providerType === "custom") {
      return {
        previewCache: this.customProviderPreviewCache,
        fileModCache: this.customProviderFileModCache
      };
    }
    return {
      previewCache: this.systemSculptPreviewCache,
      fileModCache: this.systemSculptFileModCache
    };
  }
  /**
   * Initialize global event listeners for safety checks
   */
  static initializeGlobalListeners() {
    if (this.isGlobalListenerActive) return;
    document.addEventListener("mousemove", this.handleGlobalMouseMove);
    document.addEventListener("mousemove", (e) => {
      document.documentElement.setAttribute("data-mouse-x", e.clientX.toString());
      document.documentElement.setAttribute("data-mouse-y", e.clientY.toString());
    });
    document.addEventListener("visibilitychange", this.handleVisibilityChange);
    document.addEventListener("click", this.handleGlobalClick);
    this.isGlobalListenerActive = true;
  }
  /**
   * Start safety timer to automatically hide preview after a certain time
   */
  static startSafetyTimer() {
    if (this.safetyTimer) {
      clearTimeout(this.safetyTimer);
    }
    this.safetyTimer = setTimeout(() => {
      if (this.isPreviewVisible) {
        this.hideAllPreviews();
      }
    }, this.MAX_PREVIEW_DURATION);
  }
  /**
   * Hide all previews and clean up
   */
  static hideAllPreviews() {
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
    if (this.safetyTimer) {
      clearTimeout(this.safetyTimer);
      this.safetyTimer = null;
    }
    if (this.markdownPreview) {
      this.markdownPreview.classList.remove("systemsculpt-visible");
      this.isPreviewVisible = false;
      this.currentPreviewPath = null;
    }
  }
  /**
   * Attach hover preview to an element for the given file path.
   */
  static attachHoverPreview(app, el, filePath, providerType = "systemsculpt") {
    this.initializeGlobalListeners();
    if (!this.markdownPreview) {
      this.markdownPreview = document.body.createDiv({ cls: "systemsculpt-preview systemsculpt-markdown-preview" });
      this.markdownPreview.style.pointerEvents = "auto";
    }
    this.activeElements.add(el);
    let isElementPreviewVisible = false;
    let lastEvent;
    const showPreview = async (e) => {
      const { previewCache, fileModCache } = this.getCacheForProvider(providerType);
      lastEvent = e;
      if (this.hoverTimer) {
        clearTimeout(this.hoverTimer);
      }
      this.hoverTimer = setTimeout(async () => {
        if (isElementPreviewVisible && this.currentPreviewPath === filePath) {
          positionPreview(lastEvent);
          return;
        }
        const file = app.vault.getAbstractFileByPath(filePath);
        if (!(file instanceof import_obsidian70.TFile)) return;
        if (file.stat.size > this.MAX_FILE_SIZE_BYTES) {
          this.markdownPreview.empty();
          this.markdownPreview.createDiv({ cls: "systemsculpt-preview-header", text: file.name });
          this.markdownPreview.createDiv({
            cls: "systemsculpt-preview-error",
            text: `This file is too large to preview (${Math.round(file.stat.size / 1024)}KB).
Open the file to view its contents.`
          });
          this.currentPreviewPath = filePath;
          positionPreview(lastEvent);
          this.markdownPreview.classList.add("systemsculpt-visible");
          isElementPreviewVisible = true;
          this.isPreviewVisible = true;
          previewCache.set(filePath, this.markdownPreview.innerHTML);
          fileModCache.set(filePath, file.stat.mtime);
          this.startSafetyTimer();
          return;
        }
        const cachedModTime = fileModCache.get(filePath);
        const currentModTime = file.stat.mtime;
        const hasChanged = cachedModTime !== currentModTime;
        if (previewCache.has(filePath) && !hasChanged) {
          this.markdownPreview.innerHTML = previewCache.get(filePath);
        } else {
          this.markdownPreview.empty();
          this.markdownPreview.createDiv({ cls: "systemsculpt-preview-header", text: file.name });
          try {
            const content = await app.vault.read(file);
            let displayContent = content;
            let isTruncated = false;
            if (content.length > this.MAX_PREVIEW_CONTENT_LENGTH) {
              displayContent = content.substring(0, this.MAX_PREVIEW_CONTENT_LENGTH);
              isTruncated = true;
            }
            const renderPromise = import_obsidian70.MarkdownRenderer.renderMarkdown(
              displayContent,
              this.markdownPreview,
              file.path,
              new import_obsidian70.Component()
            );
            await Promise.race([
              renderPromise,
              new Promise((_, reject) => {
                setTimeout(() => reject(new Error("Preview render timeout")), this.MAX_PREVIEW_RENDER_TIME);
              })
            ]);
            if (isTruncated) {
              const truncationNotice = this.markdownPreview.createDiv({
                cls: "systemsculpt-preview-truncation-notice",
                text: `This preview is truncated. The file is too large to preview completely.`
              });
            }
          } catch (err) {
            this.markdownPreview.createDiv({
              cls: "systemsculpt-preview-error",
              text: `Error loading preview: ${err.message || "Unknown error"}`
            });
          }
          previewCache.set(filePath, this.markdownPreview.innerHTML);
          fileModCache.set(filePath, file.stat.mtime);
        }
        this.currentPreviewPath = filePath;
        positionPreview(lastEvent);
        this.markdownPreview.classList.add("systemsculpt-visible");
        isElementPreviewVisible = true;
        this.isPreviewVisible = true;
        this.startSafetyTimer();
      }, 0);
    };
    const hidePreview = () => {
      if (this.hoverTimer) {
        clearTimeout(this.hoverTimer);
        this.hoverTimer = null;
      }
      setTimeout(() => {
        const mousePos = {
          x: document.documentElement.getAttribute("data-mouse-x") ? parseInt(document.documentElement.getAttribute("data-mouse-x")) : 0,
          y: document.documentElement.getAttribute("data-mouse-y") ? parseInt(document.documentElement.getAttribute("data-mouse-y")) : 0
        };
        setTimeout(() => {
          if (this.markdownPreview && isElementPreviewVisible) {
            const rect = this.markdownPreview.getBoundingClientRect();
            const isOverPreview = mousePos.x >= rect.left && mousePos.x <= rect.right && mousePos.y >= rect.top && mousePos.y <= rect.bottom;
            const elRect = el.getBoundingClientRect();
            const isOverElement = mousePos.x >= elRect.left && mousePos.x <= elRect.right && mousePos.y >= elRect.top && mousePos.y <= elRect.bottom;
            if (!isOverPreview && !isOverElement) {
              this.markdownPreview.classList.remove("systemsculpt-visible");
              isElementPreviewVisible = false;
              this.isPreviewVisible = false;
              this.currentPreviewPath = null;
            }
          }
        }, 0);
      }, 0);
    };
    const positionPreview = (e) => {
      if (!this.markdownPreview) return;
      const { clientX: x, clientY: y } = e;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const previewEl = this.markdownPreview;
      const prevDisplay = previewEl.style.display;
      const prevVisibility = previewEl.style.visibility;
      previewEl.style.visibility = "hidden";
      previewEl.style.display = "block";
      previewEl.style.left = "-9999px";
      previewEl.style.top = "-9999px";
      const { width: previewWidth, height: previewHeight } = previewEl.getBoundingClientRect();
      previewEl.style.display = prevDisplay;
      previewEl.style.visibility = prevVisibility;
      const offset = 16;
      let posX = x + offset;
      let posY = y + offset;
      if (posX + previewWidth > viewportWidth) {
        posX = Math.max(0, x - previewWidth - offset);
      }
      if (posY + previewHeight > viewportHeight) {
        posY = Math.max(0, y - previewHeight - offset);
      }
      previewEl.style.left = `${posX}px`;
      previewEl.style.top = `${posY}px`;
    };
    el.addEventListener("mouseenter", showPreview);
    el.addEventListener("mousemove", (e) => {
      lastEvent = e;
      if (isElementPreviewVisible) {
        positionPreview(lastEvent);
      }
    });
    el.addEventListener("mouseleave", hidePreview);
    this.markdownPreview.addEventListener("mouseleave", hidePreview);
    return () => {
      this.activeElements.delete(el);
    };
  }
  /**
   * Clean up all event listeners and resources
   */
  static cleanup() {
    document.removeEventListener("mousemove", this.handleGlobalMouseMove);
    document.removeEventListener("visibilitychange", this.handleVisibilityChange);
    document.removeEventListener("click", this.handleGlobalClick);
    if (this.hoverTimer) {
      clearTimeout(this.hoverTimer);
      this.hoverTimer = null;
    }
    if (this.safetyTimer) {
      clearTimeout(this.safetyTimer);
      this.safetyTimer = null;
    }
    if (this.markdownPreview) {
      this.markdownPreview.remove();
      this.markdownPreview = null;
    }
    this.isPreviewVisible = false;
    this.currentPreviewPath = null;
    this.activeElements.clear();
    this.isGlobalListenerActive = false;
    this.systemSculptPreviewCache.clear();
    this.customProviderPreviewCache.clear();
    this.systemSculptFileModCache.clear();
    this.customProviderFileModCache.clear();
    document.documentElement.removeAttribute("data-mouse-x");
    document.documentElement.removeAttribute("data-mouse-y");
  }
};
_PreviewService.markdownPreview = null;
/** Provider-isolated cache of rendered preview HTML per file path */
_PreviewService.systemSculptPreviewCache = /* @__PURE__ */ new Map();
_PreviewService.customProviderPreviewCache = /* @__PURE__ */ new Map();
/** Provider-isolated cache of file modification times to detect changes */
_PreviewService.systemSculptFileModCache = /* @__PURE__ */ new Map();
_PreviewService.customProviderFileModCache = /* @__PURE__ */ new Map();
_PreviewService.hoverTimer = null;
_PreviewService.safetyTimer = null;
_PreviewService.currentPreviewPath = null;
_PreviewService.isPreviewVisible = false;
_PreviewService.activeElements = /* @__PURE__ */ new Set();
_PreviewService.isGlobalListenerActive = false;
_PreviewService.MAX_PREVIEW_DURATION = 1e4;
// 10 seconds max preview time without interaction
_PreviewService.MAX_PREVIEW_CONTENT_LENGTH = 5e3;
// Maximum characters to render in preview
_PreviewService.MAX_PREVIEW_RENDER_TIME = 500;
// Maximum time (ms) to spend rendering
_PreviewService.MAX_FILE_SIZE_BYTES = 1e5;
/**
 * Handle global mouse movement to detect when mouse is not over any relevant elements
 */
_PreviewService.handleGlobalMouseMove = (0, import_obsidian70.debounce)((e) => {
  if (!_PreviewService.isPreviewVisible) return;
  const previewEl = _PreviewService.markdownPreview;
  if (!previewEl) return;
  const rect = previewEl.getBoundingClientRect();
  const isOverPreview = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
  let isOverActiveElement = false;
  _PreviewService.activeElements.forEach((el) => {
    const elRect = el.getBoundingClientRect();
    if (e.clientX >= elRect.left && e.clientX <= elRect.right && e.clientY >= elRect.top && e.clientY <= elRect.bottom) {
      isOverActiveElement = true;
    }
  });
  if (!isOverPreview && !isOverActiveElement) {
    _PreviewService.hideAllPreviews();
  }
}, 16);
// Reduce debounce to ~1 frame at 60fps for instant response
/**
 * Handle visibility change to hide previews when tab/window loses focus
 */
_PreviewService.handleVisibilityChange = () => {
  if (document.hidden) {
    _PreviewService.hideAllPreviews();
  }
};
/**
 * Handle global click to hide previews when user clicks elsewhere
 */
_PreviewService.handleGlobalClick = (e) => {
  if (!_PreviewService.isPreviewVisible) return;
  const previewEl = _PreviewService.markdownPreview;
  if (!previewEl) return;
  const rect = previewEl.getBoundingClientRect();
  const isOnPreview = e.clientX >= rect.left && e.clientX <= rect.right && e.clientY >= rect.top && e.clientY <= rect.bottom;
  let isOnActiveElement = false;
  _PreviewService.activeElements.forEach((el) => {
    const elRect = el.getBoundingClientRect();
    if (e.clientX >= elRect.left && e.clientX <= elRect.right && e.clientY >= elRect.top && e.clientY <= elRect.bottom) {
      isOnActiveElement = true;
    }
  });
  if (!isOnPreview && !isOnActiveElement) {
    _PreviewService.hideAllPreviews();
  }
};
var PreviewService = _PreviewService;

// src/utils/vaultStructure.ts
var import_obsidian71 = require("obsidian");
var VaultStructureGenerator = class {
  // Warn if vault has more than 5k files
  constructor(app) {
    this.defaultExcludePatterns = [
      ".obsidian",
      ".git",
      "node_modules",
      ".trash",
      ".DS_Store"
    ];
    this.filesProcessed = 0;
    this.foldersProcessed = 0;
    this.PERFORMANCE_WARNING_THRESHOLD = 5e3;
    this.app = app;
  }
  /**
   * Generate a directory-only structure with subdirectory counts
   * Dynamically expands depth until reaching ~2000 tokens
   */
  generateDirectoryStructure() {
    const TARGET_TOKENS = 2e3;
    const root = this.app.vault.getRoot();
    let currentDepth = 1;
    let lastValidOutput = "";
    let currentOutput = "";
    while (currentDepth <= 10) {
      currentOutput = this.generateTreeAtDepth(root, currentDepth);
      const tokens = Math.ceil(currentOutput.length / 4);
      if (tokens > TARGET_TOKENS) {
        break;
      }
      lastValidOutput = currentOutput;
      currentDepth++;
    }
    return lastValidOutput || currentOutput;
  }
  /**
   * Generate tree at specific depth
   */
  generateTreeAtDepth(root, maxDepth) {
    let output = "\u{1F4C1} Vault Structure (Directories Only)\n";
    output += "\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\n\n";
    const rootFolders = root.children.filter(
      (child) => child instanceof import_obsidian71.TFolder && !this.defaultExcludePatterns.includes(child.name)
    ).sort((a, b) => a.name.localeCompare(b.name));
    rootFolders.forEach((folder, index) => {
      const isLast = index === rootFolders.length - 1;
      output += this.renderFolderTree(folder, "", isLast, 1, maxDepth);
    });
    output += "\n";
    output += `Total: ${rootFolders.length} root directories (depth: ${maxDepth})`;
    return output;
  }
  /**
   * Render a folder and its subdirectories as a tree
   */
  renderFolderTree(folder, prefix, isLast, currentDepth, maxDepth) {
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    const extension = isLast ? "    " : "\u2502   ";
    const counts = this.countSubdirectoriesAndFiles(folder);
    let line = `${prefix}${connector}\u{1F4C2} ${folder.name}`;
    if (currentDepth >= maxDepth || counts.subdirs === 0) {
      line += ` (${counts.subdirs} subdirs, ${counts.files} files)`;
    }
    line += "\n";
    if (currentDepth < maxDepth) {
      const subfolders = folder.children.filter(
        (child) => child instanceof import_obsidian71.TFolder && !this.defaultExcludePatterns.includes(child.name)
      ).sort((a, b) => a.name.localeCompare(b.name));
      subfolders.forEach((subfolder, index) => {
        const subIsLast = index === subfolders.length - 1;
        line += this.renderFolderTree(
          subfolder,
          prefix + extension,
          subIsLast,
          currentDepth + 1,
          maxDepth
        );
      });
    }
    return line;
  }
  /**
   * Recursively count subdirectories and files in a folder
   */
  countSubdirectoriesAndFiles(folder) {
    let subdirs = 0;
    let files = 0;
    for (const child of folder.children) {
      if (child instanceof import_obsidian71.TFolder && !this.defaultExcludePatterns.includes(child.name)) {
        subdirs++;
        const childCounts = this.countSubdirectoriesAndFiles(child);
        subdirs += childCounts.subdirs;
        files += childCounts.files;
      } else if (child instanceof import_obsidian71.TFile) {
        files++;
      }
    }
    return { subdirs, files };
  }
  /**
   * Generate a text-based tree representation of the vault
   * Shows only directories with subdirectory counts
   */
  generateTree(options = {}) {
    return this.generateDirectoryStructure();
  }
  /**
   * Generate a compact tree with just folder structure
   */
  generateCompactTree(options = {}) {
    const {
      maxDepth = 2,
      excludePatterns = this.defaultExcludePatterns,
      includeDotFolders = false,
      maxFolders = 50
    } = options;
    this.foldersProcessed = 0;
    const rootFolder = this.app.vault.getRoot();
    const stats = this.calculateQuickStats(rootFolder, excludePatterns, includeDotFolders);
    let tree = `\u{1F4C1} Vault (${stats.fileCount} files)
`;
    const folders = rootFolder.children.filter((child) => child instanceof import_obsidian71.TFolder && this.shouldInclude(child, excludePatterns, includeDotFolders)).sort((a, b) => a.name.localeCompare(b.name)).slice(0, 20);
    folders.forEach((folder, index) => {
      if (this.foldersProcessed >= maxFolders) return;
      const isLast = index === folders.length - 1;
      const folderStats = this.calculateQuickStats(folder, excludePatterns, includeDotFolders, 100);
      tree += this.renderCompactFolder(folder, "", isLast, 1, maxDepth, excludePatterns, folderStats.fileCount, includeDotFolders, maxFolders);
    });
    return tree;
  }
  /**
   * Generate a compact summary for very large vaults
   */
  generateCompactSummary(stats) {
    const topFolders = this.getTopLevelFolders();
    let summary = `\u{1F4C1} Large Vault Summary (${stats.fileCount.toLocaleString()} files, ${stats.folderCount.toLocaleString()} folders)

`;
    summary += `Top-level folders:
`;
    topFolders.slice(0, 10).forEach((folder, index) => {
      const folderStats = this.calculateQuickStats(folder, this.defaultExcludePatterns, false);
      summary += `\u251C\u2500\u2500 \u{1F4C2} ${folder.name} (${folderStats.fileCount} files)
`;
    });
    if (topFolders.length > 10) {
      summary += `\u2514\u2500\u2500 ... and ${topFolders.length - 10} more folders
`;
    }
    summary += `
Note: Full directory tree disabled for performance. Use Agent Mode with filesystem tools for detailed exploration.`;
    return summary;
  }
  /**
   * Quick stats calculation that stops after a threshold
   */
  calculateQuickStats(folder, excludePatterns, includeDotFolders, maxCount = 1e4) {
    let fileCount = 0;
    let folderCount = 0;
    let totalProcessed = 0;
    const processFolder = (f) => {
      if (totalProcessed > maxCount) return;
      for (const child of f.children) {
        if (totalProcessed > maxCount) break;
        if (!this.shouldInclude(child, excludePatterns, includeDotFolders)) continue;
        totalProcessed++;
        if (child instanceof import_obsidian71.TFolder) {
          folderCount++;
          processFolder(child);
        } else {
          fileCount++;
        }
      }
    };
    processFolder(folder);
    return { fileCount, folderCount };
  }
  /**
   * Get top-level folders sorted by name
   */
  getTopLevelFolders() {
    const root = this.app.vault.getRoot();
    return root.children.filter((child) => child instanceof import_obsidian71.TFolder && !child.name.startsWith(".")).sort((a, b) => a.name.localeCompare(b.name));
  }
  renderNode(node, prefix, isLast, depth, maxDepth, excludePatterns, includeFileCounts, includeDotFolders, maxFiles, maxFolders) {
    if (depth > maxDepth || this.foldersProcessed >= maxFolders || this.filesProcessed >= maxFiles) {
      return "";
    }
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    const extension = isLast ? "    " : "\u2502   ";
    let line = prefix + connector;
    if (node instanceof import_obsidian71.TFolder) {
      this.foldersProcessed++;
      const stats = includeFileCounts ? this.calculateQuickStats(node, excludePatterns, includeDotFolders, 100) : null;
      const fileCountStr = stats ? ` (${stats.fileCount} files)` : "";
      line += `\u{1F4C2} ${node.name}${fileCountStr}
`;
      if (depth < maxDepth && this.foldersProcessed < maxFolders) {
        const children = node.children.filter((child) => this.shouldInclude(child, excludePatterns, includeDotFolders)).sort((a, b) => {
          if (a instanceof import_obsidian71.TFolder && !(b instanceof import_obsidian71.TFolder)) return -1;
          if (!(a instanceof import_obsidian71.TFolder) && b instanceof import_obsidian71.TFolder) return 1;
          return a.name.localeCompare(b.name);
        }).slice(0, 20);
        children.forEach((child, index) => {
          if (this.foldersProcessed >= maxFolders || this.filesProcessed >= maxFiles) {
            return;
          }
          const childIsLast = index === children.length - 1;
          line += this.renderNode(
            child,
            prefix + extension,
            childIsLast,
            depth + 1,
            maxDepth,
            excludePatterns,
            includeFileCounts,
            includeDotFolders,
            maxFiles,
            maxFolders
          );
        });
        if (node.children.length > children.length) {
          line += prefix + extension + `\u2514\u2500\u2500 ... (${node.children.length - children.length} more items)
`;
        }
      } else if (node.children.length > 0) {
        line += prefix + extension + "\u2514\u2500\u2500 ...\n";
      }
    } else {
      this.filesProcessed++;
      if (depth <= 2) {
        const icon = node instanceof import_obsidian71.TFile ? this.getFileIcon(node.extension) : "\u{1F4C4}";
        line += `${icon} ${node.name}
`;
      }
    }
    return line;
  }
  renderCompactFolder(folder, prefix, isLast, depth, maxDepth, excludePatterns, fileCount, includeDotFolders, maxFolders) {
    if (this.foldersProcessed >= maxFolders) return "";
    this.foldersProcessed++;
    const connector = isLast ? "\u2514\u2500\u2500 " : "\u251C\u2500\u2500 ";
    const extension = isLast ? "    " : "\u2502   ";
    let line = prefix + connector + `\u{1F4C2} ${folder.name} (${fileCount})
`;
    if (depth < maxDepth && this.foldersProcessed < maxFolders) {
      const subfolders = folder.children.filter((child) => child instanceof import_obsidian71.TFolder && this.shouldInclude(child, excludePatterns, includeDotFolders)).sort((a, b) => a.name.localeCompare(b.name)).slice(0, 10);
      subfolders.forEach((subfolder, index) => {
        if (this.foldersProcessed >= maxFolders) return;
        const childIsLast = index === subfolders.length - 1;
        const subfolderStats = this.calculateQuickStats(subfolder, excludePatterns, includeDotFolders, 50);
        line += this.renderCompactFolder(
          subfolder,
          prefix + extension,
          childIsLast,
          depth + 1,
          maxDepth,
          excludePatterns,
          subfolderStats.fileCount,
          includeDotFolders,
          maxFolders
        );
      });
    }
    return line;
  }
  shouldInclude(file, excludePatterns, includeDotFolders) {
    if (!includeDotFolders && file.name.startsWith(".")) {
      return false;
    }
    for (const pattern of excludePatterns) {
      if (file.path.includes(pattern) || file.name === pattern) {
        return false;
      }
    }
    return true;
  }
  getFileIcon(extension) {
    const iconMap = {
      "md": "\u{1F4DD}",
      "png": "\u{1F5BC}\uFE0F",
      "jpg": "\u{1F5BC}\uFE0F",
      "jpeg": "\u{1F5BC}\uFE0F",
      "gif": "\u{1F5BC}\uFE0F",
      "svg": "\u{1F5BC}\uFE0F",
      "pdf": "\u{1F4C4}",
      "mp3": "\u{1F3B5}",
      "mp4": "\u{1F3AC}",
      "zip": "\u{1F4E6}",
      "json": "\u{1F4CB}",
      "js": "\u{1F4DC}",
      "ts": "\u{1F4DC}",
      "css": "\u{1F3A8}",
      "html": "\u{1F310}"
    };
    return iconMap[extension.toLowerCase()] || "\u{1F4C4}";
  }
};

// src/views/chatview/DocumentProcessingPanel.ts
var import_obsidian72 = require("obsidian");
init_FileValidator();
var REMOVAL_DELAY_SUCCESS = 2500;
var REMOVAL_DELAY_ERROR = 6e3;
var PROCESSING_TIMEOUT_MS = 6e4;
var STAGE_TO_TIMELINE = {
  queued: "queued",
  validating: "queued",
  uploading: "uploading",
  processing: "processing",
  downloading: "processing",
  contextualizing: "contextualizing",
  ready: "ready",
  error: "processing"
};
var STEP_LABEL = {
  queued: "Queued",
  uploading: "Uploading",
  processing: "Processing",
  contextualizing: "Context",
  ready: "Ready"
};
var DocumentProcessingPanel = class {
  constructor(app, host) {
    this.app = app;
    this.entries = /* @__PURE__ */ new Map();
    this.container = host.createDiv({ cls: "systemsculpt-processing-panel" });
    const header = this.container.createDiv({
      cls: "systemsculpt-processing-panel__header"
    });
    const titleWrap = header.createDiv({
      cls: "systemsculpt-processing-panel__title"
    });
    const iconEl = titleWrap.createSpan({ cls: "systemsculpt-processing-panel__title-icon" });
    (0, import_obsidian72.setIcon)(iconEl, "files");
    titleWrap.createSpan({ text: "Processing" });
    this.countEl = header.createSpan({
      cls: "systemsculpt-processing-panel__count",
      text: ""
    });
    this.listEl = this.container.createDiv({
      cls: "systemsculpt-processing-panel__list"
    });
    this.updateVisibility();
  }
  update(file, event) {
    var _a;
    const key = file.path;
    const entry = (_a = this.entries.get(key)) != null ? _a : this.createEntry(file, event);
    this.applyEvent(entry, event, file);
    this.entries.set(key, entry);
    this.updateHeader();
    this.updateVisibility();
  }
  createEntry(file, event) {
    var _a, _b;
    const flow = (_a = event.flow) != null ? _a : "generic";
    const key = file.path;
    const card = this.listEl.createDiv({
      cls: "systemsculpt-processing-card",
      attr: { "data-flow": flow }
    });
    const head = card.createDiv({ cls: "systemsculpt-processing-card__head" });
    const fileInfo = head.createDiv({ cls: "systemsculpt-processing-card__file" });
    fileInfo.createSpan({
      cls: "systemsculpt-processing-card__name",
      text: file.basename
    });
    const metaParts = [];
    if (file.extension) {
      metaParts.push(file.extension.toUpperCase());
    }
    if (typeof ((_b = file.stat) == null ? void 0 : _b.size) === "number") {
      metaParts.push(formatFileSize(file.stat.size));
    }
    if (metaParts.length > 0) {
      fileInfo.createSpan({
        cls: "systemsculpt-processing-card__meta",
        text: metaParts.join(" \xB7 ")
      });
    }
    const badge = head.createSpan({ cls: "systemsculpt-processing-card__badge" });
    const timelineWrapper = card.createDiv({
      cls: "systemsculpt-processing-card__timeline"
    });
    let timeline;
    if (flow === "document") {
      timeline = {
        queued: this.createTimelineStep(timelineWrapper, "queued"),
        uploading: this.createTimelineStep(timelineWrapper, "uploading"),
        processing: this.createTimelineStep(timelineWrapper, "processing"),
        contextualizing: this.createTimelineStep(timelineWrapper, "contextualizing"),
        ready: this.createTimelineStep(timelineWrapper, "ready")
      };
    } else {
      timelineWrapper.addClass("is-hidden");
    }
    const statusRow = card.createDiv({
      cls: "systemsculpt-processing-card__status"
    });
    const statusLabel = statusRow.createSpan({
      cls: "systemsculpt-processing-card__label",
      text: event.label
    });
    const percentLabel = statusRow.createSpan({
      cls: "systemsculpt-processing-card__percent",
      text: ""
    });
    const progressBar = card.createDiv({
      cls: "systemsculpt-processing-card__meter"
    });
    const progressFill = progressBar.createDiv({
      cls: "systemsculpt-processing-card__meter-fill"
    });
    const detailsEl = card.createDiv({
      cls: "systemsculpt-processing-card__details is-hidden"
    });
    return {
      key,
      filePath: file.path,
      flow,
      stage: event.stage,
      progress: event.progress,
      startedAt: Date.now(),
      updatedAt: Date.now(),
      watchdogTimeout: null,
      removalTimeout: null,
      element: card,
      headerBadge: badge,
      statusLabel,
      percentLabel,
      progressFill,
      detailsEl,
      timeline
    };
  }
  createTimelineStep(container, step) {
    const stepEl = container.createDiv({
      cls: "systemsculpt-processing-card__step",
      attr: { "data-step": step }
    });
    const iconEl = stepEl.createSpan({ cls: "systemsculpt-processing-card__step-icon" });
    (0, import_obsidian72.setIcon)(iconEl, this.iconForStep(step));
    stepEl.createSpan({
      cls: "systemsculpt-processing-card__step-label",
      text: STEP_LABEL[step]
    });
    return stepEl;
  }
  iconForStep(step) {
    switch (step) {
      case "queued":
        return "inbox";
      case "uploading":
        return "upload";
      case "processing":
        return "cpu";
      case "contextualizing":
        return "sparkles";
      case "ready":
        return "check-circle";
    }
  }
  applyEvent(entry, event, file) {
    entry.stage = event.stage;
    entry.progress = event.progress;
    entry.updatedAt = Date.now();
    entry.element.setAttr("data-stage", event.stage);
    this.updateBadge(entry, event);
    this.updateProgress(entry, event.progress);
    this.updateStatus(entry, event.label);
    this.updatePercent(entry, event.progress, event.stage);
    this.updateDetails(entry, event, file);
    this.updateTimeline(entry, event.stage);
    this.resetWatchdog(entry, event.stage, file);
    if (event.stage === "ready" || event.stage === "error") {
      this.scheduleRemoval(entry, event.stage === "ready" ? REMOVAL_DELAY_SUCCESS : REMOVAL_DELAY_ERROR);
    } else {
      this.clearRemoval(entry);
    }
  }
  updateBadge(entry, event) {
    const badge = entry.headerBadge;
    badge.empty();
    const iconEl = badge.createSpan({ cls: "systemsculpt-processing-card__badge-icon" });
    (0, import_obsidian72.setIcon)(iconEl, event.icon || this.iconForStep(STAGE_TO_TIMELINE[event.stage]));
    badge.createSpan({ text: this.badgeLabelForStage(event.stage) });
  }
  badgeLabelForStage(stage) {
    switch (stage) {
      case "queued":
      case "validating":
        return "Queued";
      case "uploading":
        return "Uploading";
      case "processing":
      case "downloading":
        return "Processing";
      case "contextualizing":
        return "Context";
      case "ready":
        return "Ready";
      case "error":
        return "Error";
    }
  }
  updateStatus(entry, status) {
    entry.statusLabel.setText(status);
  }
  updatePercent(entry, progress, stage) {
    if (stage === "error") {
      entry.percentLabel.setText("");
      return;
    }
    if (!Number.isFinite(progress)) {
      entry.percentLabel.setText("");
      return;
    }
    entry.percentLabel.setText(`${Math.round(progress)}%`);
  }
  updateProgress(entry, progress) {
    const clamped = Math.max(0, Math.min(100, Number.isFinite(progress) ? progress : 0));
    entry.progressFill.style.width = `${clamped}%`;
  }
  updateDetails(entry, event, file) {
    const chunks = [];
    if (event.details) {
      chunks.push(event.details);
    }
    if (event.error) {
      chunks.push(event.error);
    }
    if (event.metadata && Object.keys(event.metadata).length > 0) {
      chunks.push(JSON.stringify(event.metadata, null, 2));
    }
    if (entry.flow === "document" && event.stage === "ready") {
      const duration = ((entry.updatedAt - entry.startedAt) / 1e3).toFixed(1);
      chunks.push(`Finished in ${duration}s`);
    }
    if (chunks.length === 0) {
      entry.detailsEl.addClass("is-hidden");
      entry.detailsEl.empty();
      return;
    }
    entry.detailsEl.removeClass("is-hidden");
    entry.detailsEl.setText(chunks.join("\n"));
  }
  updateTimeline(entry, stage) {
    if (!entry.timeline) return;
    const activeStep = STAGE_TO_TIMELINE[stage];
    Object.keys(entry.timeline).forEach((step) => {
      const stepEl = entry.timeline[step];
      stepEl.toggleClass("is-complete", step === activeStep || this.stepIndex(step) < this.stepIndex(activeStep));
      stepEl.toggleClass("is-active", step === activeStep);
    });
  }
  stepIndex(step) {
    switch (step) {
      case "queued":
        return 0;
      case "uploading":
        return 1;
      case "processing":
        return 2;
      case "contextualizing":
        return 3;
      case "ready":
        return 4;
    }
  }
  resetWatchdog(entry, stage, file) {
    if (entry.watchdogTimeout) {
      window.clearTimeout(entry.watchdogTimeout);
      entry.watchdogTimeout = null;
    }
    if (stage === "ready" || stage === "error") {
      return;
    }
    entry.watchdogTimeout = window.setTimeout(() => {
      this.handleTimeout(entry, file);
    }, PROCESSING_TIMEOUT_MS);
  }
  handleTimeout(entry, file) {
    entry.detailsEl.removeClass("is-hidden");
    const duration = ((Date.now() - entry.startedAt) / 1e3).toFixed(1);
    entry.detailsEl.setText(
      `Operation is taking longer than expected (${duration}s). Check console for details or retry.`
    );
    entry.element.addClass("is-stalled");
  }
  scheduleRemoval(entry, delay) {
    this.clearRemoval(entry);
    entry.removalTimeout = window.setTimeout(() => {
      this.removeEntry(entry.key);
    }, delay);
  }
  clearRemoval(entry) {
    if (entry.removalTimeout) {
      window.clearTimeout(entry.removalTimeout);
      entry.removalTimeout = null;
    }
  }
  removeEntry(key) {
    const entry = this.entries.get(key);
    if (!entry) return;
    if (entry.watchdogTimeout) {
      window.clearTimeout(entry.watchdogTimeout);
    }
    if (entry.removalTimeout) {
      window.clearTimeout(entry.removalTimeout);
    }
    entry.element.addClass("is-exiting");
    window.setTimeout(() => {
      entry.element.remove();
      this.entries.delete(key);
      this.updateHeader();
      this.updateVisibility();
    }, 200);
  }
  updateHeader() {
    const active = this.entries.size;
    if (active === 0) {
      this.countEl.setText("No active uploads");
    } else if (active === 1) {
      this.countEl.setText("1 active upload");
    } else {
      this.countEl.setText(`${active} active uploads`);
    }
  }
  updateVisibility() {
    this.container.toggleClass("is-visible", this.entries.size > 0);
  }
};

// src/views/chatview/FileContextManager.ts
var FileContextManager = class extends import_obsidian73.Component {
  constructor(options) {
    super();
    this.contextFiles = /* @__PURE__ */ new Set();
    this.syncStatusEl = null;
    this.isSyncing = false;
    this.includeVaultStructure = false;
    this.vaultStructureCache = null;
    /**
     * Handle visibility change event
     */
    this.handleVisibilityChange = () => {
      if (document.visibilityState === "visible") {
      }
    };
    this.app = options.app;
    this.onContextChange = options.onContextChange;
    this.sculptService = options.sculptService;
    this.plugin = options.plugin;
    this.documentProcessingService = DocumentProcessingService.getInstance(this.app, this.plugin);
    this.drawer = new DrawerComponent({
      container: options.container,
      title: options.title || "Files"
    });
    this.contextPanel = this.drawer.getDrawer();
    document.addEventListener("visibilitychange", this.handleVisibilityChange);
    this.setupContextPanel();
    this.processingPanel = new DocumentProcessingPanel(this.app, this.contextPanel);
  }
  /**
   * Update the processing status for a file
   * @param file The file being processed
   * @param status The status message to display
   * @param icon The icon to display
   * @param remove Whether to clear the status after a delay
   * @param details Optional detailed information to display
   */
  updateProcessingStatus(file, event) {
    var _a;
    if (!this.processingPanel) return;
    const enriched = {
      ...event,
      flow: (_a = event.flow) != null ? _a : "generic",
      icon: event.icon || this.resolveIconForStage(event.stage),
      progress: Number.isFinite(event.progress) ? event.progress : 0
    };
    this.processingPanel.update(file, enriched);
  }
  resolveIconForStage(stage) {
    switch (stage) {
      case "queued":
      case "validating":
        return "inbox";
      case "uploading":
        return "upload";
      case "processing":
      case "downloading":
        return "loader-2";
      case "contextualizing":
        return "sparkles";
      case "ready":
        return "check-circle";
      case "error":
        return "x-circle";
      default:
        return "info";
    }
  }
  mapAudioStatusToStage(status, progress) {
    const normalized = status.toLowerCase();
    if (normalized.includes("error")) {
      return "error";
    }
    if (normalized.includes("upload")) {
      return "uploading";
    }
    if (normalized.includes("complete") || progress >= 100) {
      return "ready";
    }
    if (normalized.includes("context")) {
      return "contextualizing";
    }
    return "processing";
  }
  resolveAudioIcon(status, fallback = "file-audio") {
    const normalized = status.toLowerCase();
    if (normalized.includes("error")) return "x-circle";
    if (normalized.includes("upload")) return "upload";
    if (normalized.includes("chunk")) return "scissors";
    if (normalized.includes("transcrib")) return "file-audio";
    if (normalized.includes("process")) return "cpu";
    if (normalized.includes("complete")) return "check-circle";
    return fallback;
  }
  setupContextPanel() {
    const titleEl = this.contextPanel.querySelector(
      ".systemsculpt-drawer-title"
    );
    if (!titleEl) return;
    const contextCount = titleEl.createSpan({
      cls: "systemsculpt-drawer-count",
      text: "0"
    });
    this.syncStatusEl = titleEl.createSpan({
      cls: "systemsculpt-sync-status synced"
    });
    (0, import_obsidian73.setIcon)(this.syncStatusEl, "check");
    this.updateContextPanel();
  }
  updateSyncStatus(syncing = false) {
    if (!this.syncStatusEl) return;
    this.isSyncing = syncing;
    this.syncStatusEl.empty();
    if (syncing) {
      this.syncStatusEl.removeClass("synced");
      this.syncStatusEl.addClass("syncing");
      (0, import_obsidian73.setIcon)(this.syncStatusEl, "loader-2");
    } else {
      this.syncStatusEl.removeClass("syncing");
      this.syncStatusEl.addClass("synced");
      (0, import_obsidian73.setIcon)(this.syncStatusEl, "check");
    }
  }
  async checkSyncStatus() {
    if (this.contextFiles.size === 0) {
      this.updateSyncStatus(false);
      return;
    }
    this.updateSyncStatus(true);
    this.updateSyncStatus(false);
  }
  /**
   * Trigger the temporary flash effect on the drawer header
   */
  triggerFileChangeFlash() {
    const header = this.contextPanel.querySelector(
      ".systemsculpt-drawer-header"
    );
    if (!header) return;
    header.classList.remove("files-changed");
    header.offsetHeight;
    header.classList.add("files-changed");
    setTimeout(() => {
      header.classList.remove("files-changed");
    }, 2e3);
  }
  /**
   * Update the context panel UI
   */
  updateContextPanel() {
    var _a;
    if (!this.contextPanel) return;
    const header = this.contextPanel.querySelector(
      ".systemsculpt-drawer-header"
    );
    const content = this.contextPanel.querySelector(
      ".systemsculpt-drawer-content"
    );
    const count = this.contextPanel.querySelector(".systemsculpt-drawer-count");
    if (!header || !content || !count) return;
    const totalCount = this.contextFiles.size + (this.includeVaultStructure ? 1 : 0);
    count.textContent = totalCount.toString();
    content.empty();
    const buttonContainer = content.createEl("div", {
      cls: "systemsculpt-drawer-buttons-container"
    });
    new import_obsidian74.ButtonComponent(buttonContainer).setButtonText("Add Context Files").setIcon("plus").setClass("systemsculpt-add-context-button").onClick((e) => {
      e.stopPropagation();
      this.addContextFile();
    });
    if (this.contextFiles.size > 0 || this.includeVaultStructure) {
      new import_obsidian74.ButtonComponent(buttonContainer).setButtonText("Clear All").setWarning().setClass("systemsculpt-clear-all-button").onClick(async (e) => {
        e.stopPropagation();
        await this.clearAllContextFiles();
      });
    }
    if (this.includeVaultStructure) {
      const vaultItem = content.createEl("div", {
        cls: "systemsculpt-vault-structure-item"
      });
      const itemHeader = vaultItem.createEl("div", {
        cls: "systemsculpt-vault-item-header"
      });
      (0, import_obsidian73.setIcon)(itemHeader.createSpan({ cls: "systemsculpt-vault-icon" }), "folder-tree");
      itemHeader.createEl("span", {
        cls: "systemsculpt-vault-title",
        text: "\u{1F4C1} Vault Structure"
      });
      vaultItem.setAttribute("title", "Click to preview vault structure");
      vaultItem.addEventListener("click", () => {
        this.showVaultStructurePreview();
      });
    }
    if (this.contextFiles.size === 0 && !this.includeVaultStructure) {
      content.createEl("div", {
        cls: "systemsculpt-drawer-empty",
        text: "No context files added yet."
      });
      return;
    }
    const categories = {
      text: {
        label: "Text Files",
        files: [],
        extensions: ["md", "txt", "markdown"]
      },
      images: {
        label: "Images",
        files: [],
        extensions: ["jpg", "jpeg", "png", "gif", "webp", "svg"]
      },
      audio: {
        label: "Audio Files",
        files: [],
        extensions: ["mp3", "wav", "ogg", "m4a"]
      },
      documents: {
        label: "Documents",
        files: [],
        extensions: ["doc", "docx", "ppt", "pptx", "xls", "xlsx", "pdf"]
      }
    };
    const documentGroups = /* @__PURE__ */ new Map();
    const nonExtractedFiles = /* @__PURE__ */ new Set();
    for (const filePath of this.contextFiles) {
      const cleanPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
      if (cleanPath.includes("/Extractions/")) {
        const parts = cleanPath.split("/");
        const extractionDirIndex = parts.indexOf("Extractions");
        if (extractionDirIndex >= 0 && extractionDirIndex + 1 < parts.length) {
          const sourceDoc = parts[extractionDirIndex + 1];
          if (!documentGroups.has(sourceDoc)) {
            documentGroups.set(sourceDoc, /* @__PURE__ */ new Set());
          }
          (_a = documentGroups.get(sourceDoc)) == null ? void 0 : _a.add(filePath);
        } else {
          nonExtractedFiles.add(filePath);
        }
      } else {
        nonExtractedFiles.add(filePath);
      }
    }
    this.categorizeFiles(Array.from(nonExtractedFiles), categories);
    for (const categoryKey of ["text", "images", "audio"]) {
      const category = categories[categoryKey];
      if (category.files.length > 0) {
        this.renderCategory(content, category);
      }
    }
    if (categories.documents.files.length > 0 || documentGroups.size > 0) {
      content.createEl("div", {
        cls: "systemsculpt-drawer-category",
        text: "Documents"
      });
      this.renderFiles(content, categories.documents.files);
      for (const [sourceDoc, extractedFiles] of documentGroups) {
        content.createEl("div", {
          cls: "systemsculpt-drawer-category",
          text: `\u{1F4C4} ${sourceDoc} Extractions`
        });
        const extractedCategories = this.createCategories();
        this.categorizeFiles(Array.from(extractedFiles), extractedCategories);
        const textFiles = extractedCategories.text.files;
        if (textFiles.length > 0) {
          this.renderFiles(content, textFiles);
        }
        const imageFiles = extractedCategories.images.files;
        if (imageFiles.length > 0) {
          this.renderFiles(content, imageFiles);
        }
        const otherFiles = [
          ...extractedCategories.audio.files,
          ...extractedCategories.documents.files
        ];
        if (otherFiles.length > 0) {
          this.renderFiles(content, otherFiles);
        }
      }
    }
  }
  createCategories() {
    return {
      text: {
        label: "Text Files",
        files: [],
        extensions: ["md", "txt", "markdown"]
      },
      images: {
        label: "Images",
        files: [],
        extensions: ["jpg", "jpeg", "png", "gif", "webp", "svg"]
      },
      audio: {
        label: "Audio Files",
        files: [],
        extensions: ["mp3", "wav", "ogg", "m4a"]
      },
      documents: {
        label: "Documents",
        files: [],
        extensions: ["doc", "docx", "ppt", "pptx", "xls", "xlsx", "pdf"]
      }
    };
  }
  categorizeFiles(files, categories) {
    for (const filePath of files) {
      const linkText = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
      try {
        let resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
        if (!resolvedFile) {
          const directResult = this.app.vault.getAbstractFileByPath(linkText);
          if (directResult instanceof import_obsidian73.TFile) {
            resolvedFile = directResult;
          }
        }
        if (!resolvedFile && !linkText.endsWith(".md")) {
          const withExtension = this.app.vault.getAbstractFileByPath(`${linkText}.md`);
          if (withExtension instanceof import_obsidian73.TFile) {
            resolvedFile = withExtension;
          }
        }
        if (resolvedFile instanceof import_obsidian73.TFile) {
          const extension = resolvedFile.extension.toLowerCase();
          let categoryFound = false;
          for (const [category, info] of Object.entries(categories)) {
            if (info.extensions.includes(extension)) {
              info.files.push({ file: resolvedFile, path: filePath, linkText });
              categoryFound = true;
              break;
            }
          }
          if (!categoryFound) {
            categories.documents.files.push({
              file: resolvedFile,
              path: filePath,
              linkText
            });
          }
        } else {
        }
      } catch (error) {
      }
    }
  }
  renderCategory(container, category) {
    if (category.files.length === 0) return;
    container.createEl("div", {
      cls: "systemsculpt-drawer-category",
      text: category.label
    });
    this.renderFiles(container, category.files);
  }
  renderFiles(container, files) {
    files.sort((a, b) => a.file.basename.localeCompare(b.file.basename));
    const imagePreview = document.body.createEl("img", {
      cls: "systemsculpt-preview systemsculpt-image-preview"
    });
    const calculatePreviewDimensions = (naturalWidth, naturalHeight, viewportWidth, viewportHeight) => {
      const maxWidth = Math.min(viewportWidth * 0.4, naturalWidth);
      const maxHeight = Math.min(viewportHeight * 0.6, naturalHeight);
      let width = naturalWidth;
      let height = naturalHeight;
      if (width > maxWidth) {
        height = naturalHeight * maxWidth / naturalWidth;
        width = maxWidth;
      }
      if (height > maxHeight) {
        width = naturalWidth * maxHeight / naturalHeight;
        height = maxHeight;
      }
      return { width, height };
    };
    const updatePreviewPosition = (e, previewEl) => {
      if (!previewEl) return;
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;
      const rect = previewEl.getBoundingClientRect();
      let x = e.clientX + 16;
      let y = e.clientY + 16;
      if (x + rect.width > viewportWidth) {
        x = e.clientX - rect.width - 16;
      }
      if (y + rect.height > viewportHeight) {
        y = e.clientY - rect.height - 16;
      }
      previewEl.style.left = `${x}px`;
      previewEl.style.top = `${y}px`;
    };
    this.register(() => {
      imagePreview.remove();
    });
    for (const { file, path, linkText } of files) {
      const item = container.createEl("div", {
        cls: "systemsculpt-drawer-item"
      });
      const pathEl = item.createEl("div", {
        cls: "systemsculpt-drawer-item-path"
      });
      const iconContainer = pathEl.createSpan({
        cls: "systemsculpt-file-icon"
      });
      const extension = file.extension.toLowerCase();
      let iconName = "file";
      const link = pathEl.createEl("a", {
        cls: "internal-link",
        text: file.basename,
        attr: {
          href: path,
          "data-href": path
        }
      });
      if (["md", "txt", "markdown"].includes(extension)) {
        iconName = "file-text";
        PreviewService.attachHoverPreview(this.app, item, file.path);
      } else if (["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(extension)) {
        iconName = "image";
        const showImagePreview = async (e) => {
          try {
            const imageFile = this.app.vault.getAbstractFileByPath(file.path);
            if (imageFile instanceof import_obsidian73.TFile) {
              const arrayBuffer = await this.app.vault.readBinary(imageFile);
              const blob = new Blob([arrayBuffer]);
              const url = URL.createObjectURL(blob);
              imagePreview.src = url;
              imagePreview.onload = () => {
                URL.revokeObjectURL(url);
                imagePreview.classList.add("systemsculpt-visible");
                const { width, height } = calculatePreviewDimensions(
                  imagePreview.naturalWidth,
                  imagePreview.naturalHeight,
                  window.innerWidth,
                  window.innerHeight
                );
                imagePreview.style.width = `${width}px`;
                imagePreview.style.height = `${height}px`;
                updatePreviewPosition(e, imagePreview);
              };
            }
          } catch (error) {
          }
        };
        const hideImagePreview = () => {
          imagePreview.classList.remove("systemsculpt-visible");
          imagePreview.src = "";
          imagePreview.style.width = "";
          imagePreview.style.height = "";
        };
        this.registerDomEvent(item, "mouseenter", showImagePreview);
        this.registerDomEvent(item, "mouseleave", hideImagePreview);
        this.registerDomEvent(
          item,
          "mousemove",
          (e) => updatePreviewPosition(e, imagePreview)
        );
        this.registerDomEvent(imagePreview, "mouseleave", hideImagePreview);
        this.registerDomEvent(this.contextPanel, "mouseleave", hideImagePreview);
      } else if (["mp3", "wav", "ogg", "m4a"].includes(extension)) {
        iconName = "audio-lines";
      } else if (["doc", "docx", "ppt", "pptx", "xls", "xlsx", "pdf"].includes(extension)) {
        iconName = "file";
      }
      (0, import_obsidian73.setIcon)(iconContainer, iconName);
      this.registerDomEvent(link, "click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        this.app.workspace.openLinkText(linkText, "", true);
      });
      const meta = item.createDiv({ cls: "systemsculpt-context-meta" });
      new import_obsidian74.ButtonComponent(meta).setIcon("x").setTooltip("Remove file").setClass("mod-small").setClass("systemsculpt-remove-button").onClick((e) => {
        e.stopPropagation();
        this.removeContextFile(path);
      });
      const updateMetaInfo = () => {
        const availableWidth = container.offsetWidth - 40;
        const fileNameWidth = link.offsetWidth;
        const removeBtnWidth = 24;
        const remainingWidth = availableWidth - fileNameWidth - removeBtnWidth;
        const existingMeta = meta.querySelectorAll(".systemsculpt-context-type, .systemsculpt-context-size");
        existingMeta.forEach((el) => el.remove());
        if (remainingWidth > 150) {
          if (remainingWidth > 200) {
            const type = meta.createDiv({ cls: "systemsculpt-context-type" });
            type.setText(file.extension.toUpperCase());
          }
          if (remainingWidth > 100) {
          }
        }
      };
      updateMetaInfo();
      const resizeObserver = new ResizeObserver(() => {
        updateMetaInfo();
      });
      resizeObserver.observe(container);
      this.register(() => {
        resizeObserver.disconnect();
      });
    }
  }
  async addContextFile() {
    const modal = new ContextSelectionModal(
      this.app,
      async (files) => {
        for (const file of files) {
          try {
            await this.addFileToContext(file);
          } catch (error) {
            this.updateProcessingStatus(
              file,
              {
                stage: "error",
                progress: 0,
                label: `Error: ${error instanceof Error ? error.message : String(error)}`,
                icon: "x-circle",
                flow: "generic",
                error: error instanceof Error ? error.message : String(error)
              }
            );
            throw error;
          }
        }
      },
      this.plugin
    );
    modal.open();
  }
  async removeContextFile(filePath) {
    const normalizedPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    this.contextFiles.delete(filePath);
    this.contextFiles.delete(`[[${normalizedPath}]]`);
    this.updateContextPanel();
    await this.onContextChange();
    document.dispatchEvent(new CustomEvent("systemsculpt:context-changed"));
    this.triggerFileChangeFlash();
  }
  /**
   * Legacy method for adding a file to context
   * @deprecated Use DocumentContextManager.addFileToContext instead
   */
  async addFileToContext(file) {
    const { DocumentContextManager: DocumentContextManager2 } = await Promise.resolve().then(() => (init_DocumentContextManager(), DocumentContextManager_exports));
    const documentContextManager = DocumentContextManager2.getInstance(this.app, this.plugin);
    await documentContextManager.addFileToContext(file, this, {
      showNotices: true,
      updateUI: true,
      saveChanges: true
    });
  }
  /**
   * Add a file to the context files set
   * @param wikiLink The wiki link to add to context
   * @returns boolean indicating if the file was added (true) or was already present (false)
   */
  addToContextFiles(wikiLink) {
    if (this.contextFiles.has(wikiLink)) {
      return false;
    }
    this.contextFiles.add(wikiLink);
    this.triggerFileChangeFlash();
    return true;
  }
  /**
   * Check if a file is already in the context files set
   * @param wikiLink The wiki link to check
   * @returns boolean indicating if the file is in context
   */
  hasContextFile(wikiLink) {
    return this.contextFiles.has(wikiLink);
  }
  /**
   * Remove a file from the context files set
   * @param filePath The file path or wiki link to remove from context
   * @returns boolean indicating if the file was removed (true) or was not found (false)
   */
  async removeFromContextFiles(filePath) {
    const normalizedPath = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    const wikiLink = `[[${normalizedPath}]]`;
    const hadFile = this.contextFiles.has(filePath) || this.contextFiles.has(wikiLink);
    if (hadFile) {
      this.contextFiles.delete(filePath);
      this.contextFiles.delete(wikiLink);
      this.updateContextPanel();
      await this.onContextChange();
      document.dispatchEvent(new CustomEvent("systemsculpt:context-changed"));
      this.triggerFileChangeFlash();
      return true;
    }
    return false;
  }
  /**
   * Trigger the onContextChange callback
   * @returns Promise that resolves when the context change is complete
   */
  async triggerContextChange() {
    await this.onContextChange();
    document.dispatchEvent(new CustomEvent("systemsculpt:context-changed"));
    this.triggerFileChangeFlash();
  }
  // This method is now handled by DocumentContextManager
  // No longer needed - DocumentProcessingService handles these methods
  // These methods are no longer needed as we're using DocumentProcessingService
  /**
   * Get all context files
   * @returns Set of context files
   */
  getContextFiles() {
    return this.contextFiles;
  }
  /**
   * Gets context files including the vault structure if enabled
   * This is used when preparing messages for the AI
   */
  getContextFilesWithVaultStructure() {
    const files = new Set(this.contextFiles);
    if (this.includeVaultStructure && this.vaultStructureCache) {
      files.add("@@vault-structure@@");
    }
    return files;
  }
  /**
   * Gets the vault structure content if available
   */
  getVaultStructureContent() {
    return this.includeVaultStructure ? this.vaultStructureCache : null;
  }
  /**
   * Set context files
   * @param files Array of files to set as context
   */
  async setContextFiles(files) {
    const validFiles = files.filter((file) => !!file && typeof file === "string");
    const normalizedFiles = validFiles.map((file) => {
      if (!file.startsWith("[[") && !file.endsWith("]]")) {
        return `[[${file}]]`;
      }
      return file;
    });
    const existingFiles = [];
    for (const file of normalizedFiles) {
      if (await this.validateFileExists(file)) {
        existingFiles.push(file);
      }
    }
    this.contextFiles = new Set(existingFiles);
    this.updateContextPanel();
    await this.checkSyncStatus();
  }
  /**
   * Get the container element
   * @returns HTMLElement container
   */
  getContainer() {
    return this.contextPanel;
  }
  /**
   * Check if vault structure is included
   */
  isVaultStructureIncluded() {
    return this.includeVaultStructure;
  }
  /**
   * Toggle vault structure inclusion
   */
  async toggleVaultStructure() {
    this.includeVaultStructure = !this.includeVaultStructure;
    if (this.includeVaultStructure) {
      const generator = new VaultStructureGenerator(this.app);
      this.vaultStructureCache = generator.generateTree();
    }
    this.updateContextPanel();
    await this.onContextChange();
    this.triggerFileChangeFlash();
  }
  /**
   * Get the vault structure content
   */
  getVaultStructure() {
    if (!this.includeVaultStructure) return null;
    if (!this.vaultStructureCache) {
      const generator = new VaultStructureGenerator(this.app);
      this.vaultStructureCache = generator.generateTree();
    }
    return this.vaultStructureCache;
  }
  /**
   * Clear vault structure cache (call when vault changes significantly)
   */
  clearVaultStructureCache() {
    this.vaultStructureCache = null;
  }
  /**
   * Show vault structure preview in a modal
   */
  showVaultStructurePreview() {
    const structure = this.getVaultStructure();
    if (!structure) return;
    const modal = new import_obsidian73.Modal(this.app);
    modal.contentEl.createEl("h2", { text: "Vault Structure Preview" });
    const pre = modal.contentEl.createEl("pre", {
      cls: "systemsculpt-vault-structure-preview"
    });
    pre.textContent = structure;
    modal.open();
  }
  /**
   * Unload the component
   */
  unload() {
    document.removeEventListener("visibilitychange", this.handleVisibilityChange);
    super.unload();
  }
  /**
   * Clears all context files from the manager.
   */
  async clearAllContextFiles() {
    this.contextFiles.clear();
    this.updateContextPanel();
    await this.onContextChange();
    await this.checkSyncStatus();
    this.triggerFileChangeFlash();
    new import_obsidian73.Notice("All context files cleared");
  }
  /**
   * Clears the current context file set.
   * Used when initializing a new chat or clearing state.
   */
  clearContext() {
    this.contextFiles.clear();
    this.updateContextPanel();
    this.checkSyncStatus();
  }
  /**
   * Process an audio file and convert it to markdown
   * @param file The audio file to process
   * @param timestamped Whether to include timestamps in the transcription
   * @returns Promise with the path to the transcription file
   */
  async processAudioFile(file, timestamped = false) {
    var _a, _b;
    this.updateProcessingStatus(file, {
      stage: "processing",
      progress: 0,
      label: "Preparing audio transcription\u2026",
      icon: "file-audio",
      flow: "audio"
    });
    try {
      const progressManager = TranscriptionProgressManager.getInstance();
      const progressHandler = progressManager.createProgressHandler(
        file,
        (progress, status, icon, details) => {
          const stage = this.mapAudioStatusToStage(status, progress);
          this.updateProcessingStatus(file, {
            stage,
            progress,
            label: status,
            icon: this.resolveAudioIcon(status, icon || "file-audio"),
            flow: "audio",
            details: details || void 0
          });
        }
      );
      const transcriptionService = TranscriptionService.getInstance(
        this.plugin
      );
      const text = await transcriptionService.transcribeFile(file, {
        ...progressHandler,
        timestamped
      });
      const extractionFolder = this.sculptService.extractionsDirectory;
      const baseName = file.basename.replace(/[\\/:*?"<>|]/g, "-").trim();
      const parentPath = extractionFolder ? `${extractionFolder}/${baseName}` : `${(_b = (_a = file.parent) == null ? void 0 : _a.path) != null ? _b : ""}/${baseName}`;
      if (extractionFolder) {
        await this.plugin.directoryManager.ensureDirectoryByKey("extractionsDirectory");
      }
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(parentPath);
      } else {
        await this.plugin.createDirectory(parentPath);
      }
      const outputPath = `${parentPath}/${baseName}.md`;
      let finalContent;
      if (this.plugin.settings.cleanTranscriptionOutput) {
        finalContent = text;
      } else {
        finalContent = `# Audio Transcription
Source: ${file.basename}
Transcribed: ${(/* @__PURE__ */ new Date()).toISOString()}

${text}`;
      }
      try {
        const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
        if (existingFile instanceof import_obsidian73.TFile) {
          await this.app.vault.modify(existingFile, finalContent);
        } else {
          await this.app.vault.create(outputPath, finalContent);
        }
      } catch (error) {
        throw error;
      }
      this.updateProcessingStatus(file, {
        stage: "contextualizing",
        progress: 92,
        label: "Saving transcription\u2026",
        icon: "hard-drive",
        flow: "audio"
      });
      this.updateProcessingStatus(file, {
        stage: "ready",
        progress: 100,
        label: "Transcription complete!",
        icon: "check-circle",
        flow: "audio"
      });
      progressManager.handleCompletion(file.path, outputPath, () => {
        this.updateProcessingStatus(file, {
          stage: "ready",
          progress: 100,
          label: "Transcription added to context",
          icon: "check-circle",
          flow: "audio",
          details: `[[${outputPath}]]`
        });
      });
      return outputPath;
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      this.updateProcessingStatus(file, {
        stage: "error",
        progress: 0,
        label: `Error: ${message}`,
        icon: "x-circle",
        flow: "audio",
        error: message
      });
      throw error;
    }
  }
  /**
   * Validate if a file exists in the vault
   */
  async validateFileExists(filePath) {
    const linkText = filePath.replace(/^\[\[(.*?)\]\]$/, "$1");
    let resolvedFile = this.app.metadataCache.getFirstLinkpathDest(linkText, "");
    if (!resolvedFile) {
      const directResult = this.app.vault.getAbstractFileByPath(linkText);
      if (directResult instanceof import_obsidian73.TFile) {
        resolvedFile = directResult;
      }
    }
    if (!resolvedFile && !linkText.endsWith(".md")) {
      const withExtension = this.app.vault.getAbstractFileByPath(`${linkText}.md`);
      if (withExtension instanceof import_obsidian73.TFile) {
        resolvedFile = withExtension;
      }
    }
    return resolvedFile instanceof import_obsidian73.TFile;
  }
  /**
   * Validate and clean context files, removing non-existent ones
   */
  async validateAndCleanContextFiles() {
    const validFiles = [];
    let removedCount = 0;
    for (const file of this.contextFiles) {
      if (await this.validateFileExists(file)) {
        validFiles.push(file);
      } else {
        removedCount++;
      }
    }
    if (removedCount > 0) {
      this.contextFiles = new Set(validFiles);
      this.updateContextPanel();
      await this.onContextChange();
      new import_obsidian73.Notice(`Removed ${removedCount} non-existent file${removedCount > 1 ? "s" : ""} from context`);
    }
  }
};

// src/views/chatview/ScrollManagerService.ts
init_errorLogger();
var ScrollManagerService = class {
  constructor(config) {
    this.autoScroll = true;
    this.programmaticScroll = false;
    this.isGenerating = false;
    this.scheduledFrame = null;
    this.pendingReason = "init";
    this.pendingImmediate = true;
    this.destroyed = false;
    this.ANCHOR_EPSILON_PX = 24;
    this.onIntersection = (entries) => {
      if (this.destroyed) return;
      const entry = entries[0];
      const nearBottom = this.isNearBottom() || !!(entry == null ? void 0 : entry.isIntersecting);
      this.setAutoScroll(nearBottom, { reason: "dom-mutation" });
    };
    this.onMutations = (records) => {
      if (this.destroyed) return;
      if (!this.containsMeaningfulChanges(records)) return;
      const reason = this.isGenerating ? "assistant-chunk" : "dom-mutation";
      this.scheduleReanchor(reason, this.isGenerating);
    };
    this.onUserScroll = () => {
      if (this.destroyed || this.programmaticScroll) return;
      const nearBottom = this.isNearBottom();
      this.setAutoScroll(nearBottom, { reason: "manual" });
    };
    this.onDomContentChanged = () => {
      if (this.destroyed) return;
      this.scheduleReanchor("dom-mutation", this.isGenerating);
    };
    this.onWindowResize = () => {
      if (this.destroyed) return;
      this.scheduleReanchor("resize", false);
    };
    this.container = config.container;
    this.onAutoScrollChange = config.onAutoScrollChange;
    this.onNewContentWhileDetached = config.onNewContentWhileDetached;
    this.initializeSentinel();
    this.initializeObservers();
    this.bindEvents();
    const shouldAutoScroll = this.isNearBottom();
    this.autoScroll = shouldAutoScroll;
    this.updateAutoScrollDataset();
    this.pendingImmediate = true;
    this.pendingReason = "init";
    this.applyReanchor("init", true);
  }
  requestStickToBottom(reason = "external", options = {}) {
    var _a;
    this.scheduleReanchor(reason, (_a = options.immediate) != null ? _a : false);
  }
  forceScrollToBottom() {
    this.cancelScheduledFrame();
    this.applyReanchor("manual", true);
  }
  scrollToBottom() {
    this.cancelScheduledFrame();
    this.applyReanchor("manual", this.isGenerating);
  }
  isAutoScrollEnabled() {
    return this.autoScroll;
  }
  setGenerating(isGenerating) {
    const prev = this.isGenerating;
    this.isGenerating = isGenerating;
    try {
      this.container.dataset.generating = this.isGenerating ? "true" : "false";
    } catch (e) {
    }
    if (!isGenerating && prev) {
      this.scheduleReanchor("assistant-chunk", true);
    }
  }
  getScrollState() {
    return { scrollTop: this.container.scrollTop, isAtBottom: this.autoScroll };
  }
  restoreScrollState(state) {
    if (state.isAtBottom) {
      this.applyReanchor("restore", true);
    } else {
      this.cancelScheduledFrame();
      this.programmaticScroll = true;
      this.container.scrollTop = state.scrollTop;
      setTimeout(() => {
        this.programmaticScroll = false;
      }, 16);
      this.setAutoScroll(false, { reason: "restore" });
    }
  }
  updateContentHeight() {
    this.scheduleReanchor("dom-mutation", this.isGenerating);
  }
  resetScrollState() {
    this.forceScrollToBottom();
  }
  cleanup() {
    this.destroyed = true;
    this.cancelScheduledFrame();
    try {
      this.io.disconnect();
    } catch (e) {
    }
    try {
      this.ro.disconnect();
    } catch (e) {
    }
    try {
      this.mo.disconnect();
    } catch (e) {
    }
    try {
      this.container.removeEventListener("scroll", this.onUserScroll);
    } catch (e) {
    }
    try {
      this.container.removeEventListener("systemsculpt-dom-content-changed", this.onDomContentChanged);
    } catch (e) {
    }
    try {
      window.removeEventListener("resize", this.onWindowResize);
    } catch (e) {
    }
  }
  destroy() {
    this.cleanup();
  }
  initializeSentinel() {
    this.sentinel = document.createElement("div");
    this.sentinel.className = "systemsculpt-scroll-sentinel";
    this.sentinel.setAttribute("aria-hidden", "true");
    this.sentinel.style.cssText = "height:1px;width:100%;pointer-events:none;overflow-anchor:none;";
    this.container.appendChild(this.sentinel);
  }
  initializeObservers() {
    this.io = new IntersectionObserver(this.onIntersection, {
      root: this.container,
      rootMargin: "0px 0px 64px 0px",
      threshold: 0
    });
    this.io.observe(this.sentinel);
    this.ro = new ResizeObserver(() => {
      this.scheduleReanchor("resize", false);
    });
    this.ro.observe(this.container);
    this.mo = new MutationObserver(this.onMutations);
    this.mo.observe(this.container, {
      childList: true,
      subtree: true,
      characterData: true
    });
  }
  bindEvents() {
    this.container.addEventListener("scroll", this.onUserScroll, { passive: true });
    this.container.addEventListener("systemsculpt-dom-content-changed", this.onDomContentChanged);
    window.addEventListener("resize", this.onWindowResize, { passive: true });
  }
  containsMeaningfulChanges(records) {
    for (const record of records) {
      if (record.type === "childList") {
        if (this.hasMeaningfulNodes(record.addedNodes) || this.hasMeaningfulNodes(record.removedNodes)) {
          return true;
        }
      } else if (record.type === "characterData") {
        if (record.target === this.sentinel) continue;
        return true;
      }
    }
    return false;
  }
  hasMeaningfulNodes(nodes) {
    for (const node of Array.from(nodes)) {
      if (node === this.sentinel) continue;
      if (node instanceof HTMLElement) {
        if (node.classList.contains("systemsculpt-scroll-sentinel")) continue;
        return true;
      }
      if (node instanceof Text) {
        return true;
      }
    }
    return false;
  }
  scheduleReanchor(reason, immediate) {
    if (this.destroyed) return;
    this.pendingReason = reason;
    if (immediate) this.pendingImmediate = true;
    if (this.scheduledFrame != null) {
      return;
    }
    this.log("ScrollManager re-anchor scheduled", { reason, immediate });
    this.scheduledFrame = requestAnimationFrame(() => {
      this.scheduledFrame = null;
      const reasonToApply = this.pendingReason;
      const immediateToApply = this.pendingImmediate;
      this.pendingImmediate = false;
      this.applyReanchor(reasonToApply, immediateToApply || this.isGenerating);
    });
  }
  cancelScheduledFrame() {
    if (this.scheduledFrame == null) return;
    cancelAnimationFrame(this.scheduledFrame);
    this.scheduledFrame = null;
  }
  applyReanchor(reason, immediate) {
    var _a;
    if (this.destroyed) return;
    const previousAuto = this.autoScroll;
    this.setAutoScroll(true, { reason });
    this.ensureSentinel();
    if (immediate) {
      this.scrollToBottomImmediate();
    } else {
      this.scrollToBottomWithBehavior(this.isGenerating ? "auto" : "smooth");
    }
    if (!previousAuto) {
      (_a = this.onNewContentWhileDetached) == null ? void 0 : _a.call(this, 0);
    }
    this.log("ScrollManager applied re-anchor", {
      reason,
      immediate,
      wasAuto: previousAuto
    });
  }
  ensureSentinel() {
    if (this.container.lastElementChild !== this.sentinel) {
      this.container.appendChild(this.sentinel);
    }
  }
  scrollToBottomImmediate() {
    this.programmaticScroll = true;
    this.ensureSentinel();
    this.container.scrollTop = this.container.scrollHeight;
    setTimeout(() => {
      this.programmaticScroll = false;
    }, 16);
  }
  scrollToBottomWithBehavior(behavior) {
    this.programmaticScroll = true;
    this.ensureSentinel();
    this.container.scrollTo({ top: this.container.scrollHeight, behavior });
    const delay = behavior === "smooth" ? 250 : 16;
    setTimeout(() => {
      this.programmaticScroll = false;
    }, delay);
  }
  isNearBottom() {
    try {
      const { scrollTop, scrollHeight, clientHeight } = this.container;
      const distance = scrollHeight - (scrollTop + clientHeight);
      return distance <= this.ANCHOR_EPSILON_PX;
    } catch (e) {
      return true;
    }
  }
  setAutoScroll(enabled, metadata) {
    var _a, _b;
    if (this.autoScroll === enabled) return;
    this.autoScroll = enabled;
    this.updateAutoScrollDataset();
    (_a = this.onAutoScrollChange) == null ? void 0 : _a.call(this, enabled);
    this.log("ScrollManager auto-scroll toggled", {
      enabled,
      reason: metadata == null ? void 0 : metadata.reason
    });
    if (enabled) {
      (_b = this.onNewContentWhileDetached) == null ? void 0 : _b.call(this, 0);
    }
  }
  updateAutoScrollDataset() {
    try {
      this.container.dataset.autoscroll = this.autoScroll ? "true" : "false";
    } catch (e) {
    }
  }
  log(message, metadata) {
    try {
      errorLogger.debug(message, {
        source: "ScrollManagerService",
        method: "scroll",
        metadata: {
          autoScroll: this.autoScroll,
          generating: this.isGenerating,
          scheduledFrame: this.scheduledFrame,
          ...metadata
        }
      });
    } catch (e) {
    }
  }
};

// src/views/chatview/InputHandler.ts
var import_obsidian86 = require("obsidian");

// src/views/chatview/SlashCommandMenu.ts
var import_obsidian76 = require("obsidian");

// src/views/chatview/ChatExportModal.ts
var import_obsidian75 = require("obsidian");
init_FolderSuggester();
init_chatExport();
init_titleUtils();
init_errorLogger();
var ChatExportModal = class extends import_obsidian75.Modal {
  constructor(plugin, chatView) {
    var _a;
    super(plugin.app);
    this.folderInput = null;
    this.fileNameInput = null;
    this.openAfterExportCheckbox = null;
    this.plugin = plugin;
    this.chatView = chatView;
    const preferences = this.resolvePreferences();
    const defaultFolder = preferences.lastFolder || this.plugin.settings.chatsDirectory;
    const defaultFileName = preferences.lastFileName || this.generateDefaultFileName();
    const options = normalizeChatExportOptions(preferences.options);
    this.state = {
      options,
      folder: defaultFolder,
      fileName: defaultFileName,
      openAfterExport: (_a = preferences.openAfterExport) != null ? _a : true
    };
  }
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.createEl("h2", { text: "Export Chat" });
    await this.renderSummary(contentEl);
    this.renderOptions(contentEl);
    this.renderDestinationInputs(contentEl);
    this.renderActions(contentEl);
  }
  resolvePreferences() {
    var _a;
    return (_a = this.plugin.settings.chatExportPreferences) != null ? _a : {
      options: createDefaultChatExportOptions()
    };
  }
  async renderSummary(container) {
    try {
      const result = await this.chatView.exportChat(this.state.options);
      const { summary } = result.context;
      container.createEl("h3", { text: "Conversation Summary" });
      const totalsSetting = new import_obsidian75.Setting(container).setName("Messages").setDesc(`${summary.totalMessages} total \xB7 ${summary.assistantMessages} assistant \xB7 ${summary.userMessages} user`);
      totalsSetting.settingEl.classList.add("setting-item--no-control");
      const detailLines = [];
      if (summary.toolMessages > 0) {
        detailLines.push(`Tool messages: ${summary.toolMessages}`);
      }
      if (summary.toolCallCount > 0) {
        detailLines.push(`Tool calls: ${summary.toolCallCount}`);
      }
      if (summary.reasoningBlockCount > 0) {
        detailLines.push(`Reasoning blocks: ${summary.reasoningBlockCount}`);
      }
      if (summary.imageCount > 0) {
        detailLines.push(`Images referenced: ${summary.imageCount}`);
      }
      if (detailLines.length > 0) {
        const detailsList = container.createEl("ul");
        detailLines.forEach((text) => {
          detailsList.createEl("li", { text });
        });
      }
    } catch (error) {
      errorLogger.warn("Failed to render chat summary for export modal", {
        source: "ChatExportModal",
        method: "renderSummary",
        metadata: {
          chatId: this.chatView.chatId,
          error: error instanceof Error ? error.message : String(error)
        }
      });
    }
  }
  renderOptions(container) {
    container.createEl("h3", { text: "Include Sections" });
    const groups = [
      {
        label: "Overview",
        keys: [
          { key: "includeMetadata", label: "Metadata", description: "Chat title, timestamps, model, and tool statistics." },
          { key: "includeSystemPrompt", label: "System prompt", description: "Export the active system prompt content." },
          { key: "includeContextFiles", label: "Context files", description: "Reference linked files and attachments." }
        ]
      },
      {
        label: "Conversation",
        keys: [
          { key: "includeConversation", label: "Conversation history", description: "Include the message transcript." },
          { key: "includeUserMessages", label: "User messages" },
          { key: "includeAssistantMessages", label: "Assistant messages" },
          { key: "includeToolMessages", label: "Tool responses" }
        ]
      },
      {
        label: "Details",
        keys: [
          { key: "includeReasoning", label: "Reasoning traces", description: "Show hidden reasoning callouts when available." },
          { key: "includeToolCalls", label: "Tool call details", description: "Include callouts for each tool invocation." },
          { key: "includeToolCallArguments", label: "Tool arguments", description: "Attach JSON arguments supplied to each tool call." },
          { key: "includeToolCallResults", label: "Tool results", description: "Attach JSON responses returned by tools." },
          { key: "includeContextFileContents", label: "Context file contents", description: "Embed the contents of referenced files." },
          { key: "includeImages", label: "Image references", description: "Render linked images in the export." }
        ]
      }
    ];
    groups.forEach((group) => {
      container.createEl("h4", { text: group.label });
      group.keys.forEach((option) => {
        const setting = new import_obsidian75.Setting(container).setName(option.label);
        if (option.description) {
          setting.setDesc(option.description);
        }
        setting.addToggle((toggle) => {
          toggle.setValue(!!this.state.options[option.key]).onChange((value) => {
            this.state.options = {
              ...this.state.options,
              [option.key]: value
            };
          });
        });
      });
    });
  }
  renderDestinationInputs(container) {
    container.createEl("h3", { text: "Destination" });
    const folderSetting = new import_obsidian75.Setting(container).setName("Folder").setDesc("Vault folder where the exported note will be created.");
    folderSetting.addText((text) => {
      text.setPlaceholder("Folder path");
      text.setValue(this.state.folder);
      attachFolderSuggester(text.inputEl, (folder) => {
        text.setValue(folder);
      }, this.app);
      text.onChange((value) => {
        this.state.folder = value.trim();
      });
      this.folderInput = text.inputEl;
    });
    const fileSetting = new import_obsidian75.Setting(container).setName("File name").setDesc("Name of the exported markdown note (without extension).");
    fileSetting.addText((text) => {
      text.setPlaceholder("File name");
      text.setValue(this.state.fileName);
      text.onChange((value) => {
        this.state.fileName = value.trim();
      });
      this.fileNameInput = text.inputEl;
    });
    const openSetting = new import_obsidian75.Setting(container).setName("Open after export").setDesc("Open the new note immediately after it is created.");
    openSetting.addToggle((toggle) => {
      toggle.setValue(this.state.openAfterExport).onChange((value) => {
        this.state.openAfterExport = value;
      });
      this.openAfterExportCheckbox = toggle.toggleEl.querySelector('input[type="checkbox"]');
    });
  }
  renderActions(container) {
    const footer = container.createDiv({ cls: "modal-button-container" });
    const cancelButton = footer.createEl("button", { text: "Cancel" });
    const exportButton = footer.createEl("button", { text: "Export" });
    exportButton.addClass("mod-cta");
    cancelButton.addEventListener("click", () => this.close());
    exportButton.addEventListener("click", async () => {
      await this.handleExport(exportButton);
    });
  }
  async handleExport(button) {
    var _a, _b;
    const folder = (((_a = this.folderInput) == null ? void 0 : _a.value) || this.state.folder || "").trim() || this.plugin.settings.chatsDirectory;
    const rawFileName = (((_b = this.fileNameInput) == null ? void 0 : _b.value) || this.state.fileName || "").trim();
    const sanitizedName = this.sanitizeFileName(rawFileName);
    if (!sanitizedName) {
      new import_obsidian75.Notice("Please enter a valid file name.");
      return;
    }
    const fullPath = `${folder}/${sanitizedName}.md`;
    try {
      button.setAttribute("disabled", "true");
      await this.ensureFolder(folder);
      const existing = this.app.vault.getAbstractFileByPath(fullPath);
      if (existing instanceof import_obsidian75.TFile) {
        new import_obsidian75.Notice("File already exists. Choose a different name.");
        return;
      }
      const result = await this.chatView.exportChat(this.state.options);
      await this.app.vault.create(fullPath, result.markdown);
      errorLogger.info("Chat exported to markdown", {
        source: "ChatExportModal",
        method: "handleExport",
        metadata: {
          chatId: this.chatView.chatId,
          path: fullPath,
          options: this.state.options
        }
      });
      new import_obsidian75.Notice(`Chat exported to "${sanitizedName}.md"`, 6e3);
      if (this.state.openAfterExport) {
        const file = this.app.vault.getAbstractFileByPath(fullPath);
        if (file instanceof import_obsidian75.TFile) {
          await this.app.workspace.openLinkText(file.path, "", true);
        }
      }
      await this.persistPreferences(folder, sanitizedName);
      this.close();
    } catch (error) {
      errorLogger.error("Failed to export chat", error instanceof Error ? error : void 0, {
        source: "ChatExportModal",
        method: "handleExport",
        metadata: {
          chatId: this.chatView.chatId,
          path: fullPath
        }
      });
      new import_obsidian75.Notice("Failed to export chat. Check logs for details.", 6e3);
    } finally {
      button.removeAttribute("disabled");
    }
  }
  async ensureFolder(folder) {
    if (this.plugin.directoryManager) {
      await this.plugin.directoryManager.ensureDirectoryByPath(folder);
      return;
    }
    await this.app.vault.createFolder(folder).catch(() => {
    });
  }
  sanitizeFileName(name) {
    const base = name || this.generateDefaultFileName();
    return base.replace(/[/\\?%*:|"<>]/g, "").trim();
  }
  generateDefaultFileName() {
    const title = sanitizeChatTitle(this.chatView.getChatTitle() || "Chat Export");
    const now = /* @__PURE__ */ new Date();
    const date = now.toISOString().slice(0, 10);
    const hour = String(now.getHours()).padStart(2, "0");
    const minute = String(now.getMinutes()).padStart(2, "0");
    return `${date} ${hour}-${minute} - ${title}`;
  }
  async persistPreferences(folder, fileName) {
    const preferences = {
      options: { ...this.state.options },
      lastFolder: folder,
      openAfterExport: this.state.openAfterExport,
      lastFileName: fileName
    };
    await this.plugin.getSettingsManager().updateSettings({
      chatExportPreferences: preferences
    });
  }
};

// src/views/chatview/SlashCommandMenu.ts
var SlashCommandMenu = class extends import_obsidian76.Component {
  constructor(options) {
    super();
    this.commands = [];
    this.filteredCommands = [];
    this.selectedIndex = 0;
    this.isVisible = false;
    this.plugin = options.plugin;
    this.chatView = options.chatView;
    this.inputElement = options.inputElement;
    this.inputHandler = options.inputHandler;
    this.onClose = options.onClose;
    this.onExecute = options.onExecute;
    this.initializeCommands();
    this.createMenuElement();
    this.setupEventListeners();
  }
  initializeCommands() {
    this.commands = [
      {
        id: "new",
        name: "New Chat",
        description: "Start a new chat conversation",
        icon: "plus-circle",
        execute: async (chatView) => {
          const { workspace } = this.plugin.app;
          const leaf = workspace.getLeaf("tab");
          await leaf.setViewState({
            type: CHAT_VIEW_TYPE,
            state: {
              chatId: "",
              // Empty ID for new chat
              selectedModelId: this.plugin.settings.selectedModelId
              // Default model
            }
          });
          workspace.setActiveLeaf(leaf, { focus: true });
        }
      },
      {
        id: "clear",
        name: "Clear Chat",
        description: "Remove all messages from the current chat",
        icon: "eraser",
        execute: async (chatView) => {
          const confirmModal = new import_obsidian76.Modal(this.plugin.app);
          confirmModal.onOpen = () => {
            const { contentEl } = confirmModal;
            contentEl.createEl("h2", { text: "Clear chat?" });
            contentEl.createEl("p", { text: "This will remove all messages from the current chat." });
            const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
            const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
            cancelBtn.addEventListener("click", () => confirmModal.close());
            const clearBtn = buttonContainer.createEl("button", {
              text: "Clear",
              cls: "mod-warning"
            });
            clearBtn.addEventListener("click", async () => {
              var _a;
              try {
                chatView.messages.splice(0, chatView.messages.length);
                chatView.chatId = "";
                chatView.chatVersion = 0;
                chatView.isFullyLoaded = false;
                chatView.chatContainer.empty();
                (_a = chatView.contextManager) == null ? void 0 : _a.clearContext();
                new import_obsidian76.Notice("Chat cleared");
              } catch (err) {
                new import_obsidian76.Notice("Failed to clear chat");
              } finally {
                confirmModal.close();
              }
            });
            contentEl.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                e.stopPropagation();
                clearBtn.click();
              }
            });
            setTimeout(() => clearBtn.focus(), 0);
          };
          confirmModal.onClose = () => {
            var _a;
            (_a = chatView.inputHandler) == null ? void 0 : _a.focus();
          };
          confirmModal.open();
        }
      },
      {
        id: "export",
        name: "Export Chat",
        description: "Export chat as markdown note",
        icon: "download",
        execute: async (chatView) => {
          const modal = new ChatExportModal(this.plugin, chatView);
          modal.open();
        }
      },
      {
        id: "history",
        name: "Open Chat History",
        description: "Open the chat history file",
        icon: "file-text",
        execute: async (chatView) => {
          await this.inputHandler.handleOpenChatHistoryFile();
        }
      },
      {
        id: "save",
        name: "Save as Note",
        description: "Save chat as a markdown note",
        icon: "file-plus",
        execute: async (chatView) => {
          await this.inputHandler.handleSaveChatAsNote();
        }
      },
      {
        id: "delete",
        name: "Delete This Chat",
        description: "Permanently delete this chat and close the view",
        icon: "trash-2",
        execute: async (chatView) => {
          if (!chatView.chatId) {
            new import_obsidian76.Notice("No chat to delete - this is a new conversation");
            return;
          }
          const confirmModal = new import_obsidian76.Modal(this.plugin.app);
          confirmModal.onOpen = () => {
            const { contentEl } = confirmModal;
            contentEl.createEl("h2", { text: "Delete this chat?" });
            contentEl.createEl("p", {
              text: "This will permanently delete the chat file and close this view. This action cannot be undone."
            });
            const buttonContainer = contentEl.createDiv({ cls: "modal-button-container" });
            const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
            cancelBtn.addEventListener("click", () => confirmModal.close());
            const deleteBtn = buttonContainer.createEl("button", {
              text: "Delete Chat",
              cls: "mod-warning"
            });
            deleteBtn.addEventListener("click", async () => {
              try {
                const chatDirectory = this.plugin.settings.chatsDirectory;
                const filePath = `${chatDirectory}/${chatView.chatId}.md`;
                const file = this.plugin.app.vault.getAbstractFileByPath(filePath);
                if (file) {
                  await this.plugin.app.vault.trash(file, true);
                }
                if (chatView.leaf) {
                  chatView.leaf.detach();
                }
                new import_obsidian76.Notice("Chat deleted successfully");
              } catch (err) {
                new import_obsidian76.Notice("Failed to delete chat");
              } finally {
                confirmModal.close();
              }
            });
            contentEl.addEventListener("keydown", (e) => {
              if (e.key === "Enter") {
                e.preventDefault();
                e.stopPropagation();
                deleteBtn.click();
              }
            });
            setTimeout(() => deleteBtn.focus(), 0);
          };
          confirmModal.open();
        }
      }
    ];
    this.filteredCommands = [...this.commands];
  }
  createMenuElement() {
    this.menuElement = document.createElement("div");
    this.menuElement.className = "systemsculpt-slash-command-menu";
    this.resultsContainer = this.menuElement.createEl("div", { cls: "systemsculpt-slash-results-container" });
    const searchContainer = this.menuElement.createEl("div", { cls: "systemsculpt-slash-search-container" });
    const searchIcon = searchContainer.createEl("div", { cls: "systemsculpt-slash-search-icon" });
    (0, import_obsidian76.setIcon)(searchIcon, "search");
    this.searchInput = searchContainer.createEl("input", {
      cls: "systemsculpt-slash-search-input",
      attr: { placeholder: "Search commands..." }
    });
    this.menuElement.style.display = "none";
    document.body.appendChild(this.menuElement);
  }
  setupEventListeners() {
    this.registerDomEvent(this.searchInput, "input", () => {
      this.filterCommands();
    });
    this.registerDomEvent(this.searchInput, "keydown", (e) => {
      this.handleSearchKeydown(e);
    });
    this.registerDomEvent(document, "click", (e) => {
      if (!this.menuElement.contains(e.target)) {
        this.hide();
      }
    });
  }
  filterCommands() {
    const query = this.searchInput.value.toLowerCase();
    this.filteredCommands = this.commands.filter(
      (cmd) => cmd.name.toLowerCase().includes(query) || cmd.description.toLowerCase().includes(query)
    );
    this.selectedIndex = 0;
    this.renderResults();
  }
  renderResults() {
    this.resultsContainer.empty();
    if (this.filteredCommands.length === 0) {
      const emptyState = this.resultsContainer.createEl("div", { cls: "systemsculpt-slash-empty-state" });
      emptyState.textContent = "No commands found";
      return;
    }
    this.filteredCommands.forEach((command, index) => {
      const item = this.resultsContainer.createEl("div", {
        cls: `systemsculpt-slash-result-item ${index === this.selectedIndex ? "is-selected" : ""}`
      });
      const icon = item.createEl("div", { cls: "systemsculpt-slash-result-icon" });
      (0, import_obsidian76.setIcon)(icon, command.icon);
      const content = item.createEl("div", { cls: "systemsculpt-slash-result-content" });
      const title = content.createEl("div", { cls: "systemsculpt-slash-result-title", text: command.name });
      const description = content.createEl("div", { cls: "systemsculpt-slash-result-description", text: command.description });
      this.registerDomEvent(item, "click", () => {
        this.executeCommand(command);
      });
      this.registerDomEvent(item, "mouseover", () => {
        this.selectedIndex = index;
        this.updateSelection();
      });
    });
  }
  handleSearchKeydown(e) {
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        this.selectedIndex = (this.selectedIndex + 1) % this.filteredCommands.length;
        this.updateSelection();
        break;
      case "ArrowUp":
        e.preventDefault();
        this.selectedIndex = this.selectedIndex === 0 ? this.filteredCommands.length - 1 : this.selectedIndex - 1;
        this.updateSelection();
        break;
      case "Enter":
        e.preventDefault();
        if (this.filteredCommands.length > 0) {
          this.executeCommand(this.filteredCommands[this.selectedIndex]);
        }
        break;
      case "Escape":
        e.preventDefault();
        this.hide();
        break;
      case "Backspace":
        if (this.searchInput.value === "") {
          e.preventDefault();
          this.removeSlashAndClose();
        }
        break;
    }
  }
  updateSelection() {
    const items = this.resultsContainer.querySelectorAll(".systemsculpt-slash-result-item");
    items.forEach((item, index) => {
      item.classList.toggle("is-selected", index === this.selectedIndex);
    });
    const selectedItem = items[this.selectedIndex];
    if (selectedItem) {
      selectedItem.scrollIntoView({ block: "nearest" });
    }
  }
  async executeCommand(command) {
    try {
      await this.onExecute(command);
      this.hide();
    } catch (error) {
      new import_obsidian76.Notice(`Error executing command: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  show(query = "") {
    this.isVisible = true;
    this.searchInput.value = query;
    this.filterCommands();
    this.positionMenu();
    this.menuElement.style.display = "block";
    this.searchInput.focus();
  }
  hide() {
    if (!this.isVisible) return;
    this.isVisible = false;
    this.menuElement.style.display = "none";
    this.searchInput.value = "";
    this.onClose();
  }
  isOpen() {
    return this.isVisible;
  }
  updateQuery(query) {
    if (!this.isVisible) return;
    this.searchInput.value = query;
    this.filterCommands();
  }
  handleKeydown(e) {
    if (!this.isVisible) return false;
    if (["ArrowDown", "ArrowUp", "Enter", "Escape"].includes(e.key)) {
      this.handleSearchKeydown(e);
      return true;
    }
    return false;
  }
  positionMenu() {
    const inputRect = this.inputElement.getBoundingClientRect();
    const menuWidth = 400;
    let bottom = window.innerHeight - inputRect.top + 10;
    let left = inputRect.left;
    if (left + menuWidth > window.innerWidth - 10) {
      left = window.innerWidth - menuWidth - 10;
    }
    if (inputRect.top < 320) {
      this.menuElement.style.position = "fixed";
      this.menuElement.style.top = `${inputRect.bottom + 10}px`;
      this.menuElement.style.bottom = "auto";
    } else {
      this.menuElement.style.position = "fixed";
      this.menuElement.style.top = "auto";
      this.menuElement.style.bottom = `${bottom}px`;
    }
    this.menuElement.style.left = `${left}px`;
    this.menuElement.style.zIndex = "1000";
  }
  removeSlashAndClose() {
    const currentValue = this.inputElement.value;
    if (currentValue.startsWith("/")) {
      this.inputElement.value = currentValue.substring(1);
      this.inputElement.selectionStart = this.inputElement.selectionEnd = 0;
    }
    this.hide();
  }
  unload() {
    if (this.menuElement && this.menuElement.parentNode) {
      this.menuElement.parentNode.removeChild(this.menuElement);
    }
    super.unload();
  }
};

// src/views/chatview/controllers/StreamingController.ts
var import_obsidian77 = require("obsidian");
init_errors();
init_errorLogger();

// src/views/chatview/transcript/TranscriptAssembler.ts
var TranscriptAssembler = class {
  constructor() {
    this.parts = [];
    this.lastTimestamp = 0;
    this.pendingContent = "";
    this.finalContent = "";
    this.finalReasoning = "";
    this.activeReasoningIndex = null;
  }
  begin() {
    this.parts = [];
    this.lastTimestamp = 0;
    this.pendingContent = "";
    this.finalContent = "";
    this.finalReasoning = "";
    this.activeReasoningIndex = null;
  }
  apply(event) {
    switch (event.type) {
      case "reasoning":
        this.flushPendingContent(false);
        this.appendReasoning(event.text);
        break;
      case "content":
        this.activeReasoningIndex = null;
        this.pendingContent += event.text;
        this.flushPendingContent(false);
        break;
      case "tool-call":
        this.flushPendingContent(true);
        this.activeReasoningIndex = null;
        break;
      case "meta":
      case "footnote":
      default:
        break;
    }
  }
  attachToolCall(toolCall) {
    var _a;
    this.flushPendingContent(true);
    this.activeReasoningIndex = null;
    const timestamp = this.nextTimestamp(Math.max((_a = toolCall.timestamp) != null ? _a : Date.now(), this.lastTimestamp + 1));
    toolCall.timestamp = timestamp;
    const existingIndex = this.parts.findIndex(
      (part) => part.type === "tool_call" && part.data.id === toolCall.id
    );
    if (existingIndex !== -1) {
      this.parts[existingIndex] = {
        id: this.parts[existingIndex].id,
        type: "tool_call",
        timestamp,
        data: toolCall
      };
      return;
    }
    this.parts.push({
      id: `tool_call_part-${toolCall.id}`,
      type: "tool_call",
      timestamp,
      data: toolCall
    });
  }
  getParts() {
    return this.parts;
  }
  finalize() {
    this.flushPendingContent(true);
    return {
      parts: this.parts,
      content: this.finalContent,
      reasoning: this.finalReasoning
    };
  }
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  // Internal helpers
  // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  appendReasoning(text) {
    if (!text) return;
    this.finalReasoning += text;
    if (this.activeReasoningIndex == null) {
      const timestamp = this.nextTimestamp();
      this.parts.push({
        id: `reasoning-${timestamp}`,
        type: "reasoning",
        timestamp,
        data: text
      });
      this.activeReasoningIndex = this.parts.length - 1;
      return;
    }
    const existing = this.parts[this.activeReasoningIndex];
    if (existing && existing.type === "reasoning") {
      existing.data += text;
      existing.timestamp = this.nextTimestamp(existing.timestamp);
    } else {
      const timestamp = this.nextTimestamp();
      this.parts.push({
        id: `reasoning-${timestamp}`,
        type: "reasoning",
        timestamp,
        data: text
      });
      this.activeReasoningIndex = this.parts.length - 1;
    }
  }
  flushPendingContent(force) {
    if (!this.pendingContent) return;
    if (!force) {
      const newlineIndex = this.pendingContent.lastIndexOf("\n");
      let flushText2;
      if (newlineIndex === -1) {
        flushText2 = this.pendingContent;
        this.pendingContent = "";
      } else {
        flushText2 = this.pendingContent.slice(0, newlineIndex + 1);
        this.pendingContent = this.pendingContent.slice(newlineIndex + 1);
      }
      if (flushText2.length > 0) {
        this.appendContent(flushText2);
      }
      return;
    }
    const flushText = this.pendingContent;
    this.pendingContent = "";
    if (flushText.length > 0) {
      this.appendContent(flushText);
    }
  }
  appendContent(text) {
    if (!text) return;
    this.finalContent += text;
    const lastPart = this.parts.length > 0 ? this.parts[this.parts.length - 1] : null;
    if (lastPart && lastPart.type === "content" && typeof lastPart.data === "string") {
      lastPart.data += text;
      lastPart.timestamp = this.nextTimestamp(lastPart.timestamp);
      return;
    }
    const timestamp = this.nextTimestamp();
    this.parts.push({
      id: `content-${timestamp}`,
      type: "content",
      timestamp,
      data: text
    });
  }
  nextTimestamp(seed) {
    const candidate = seed != null ? seed : Date.now();
    const ts = Math.max(candidate, this.lastTimestamp + 1);
    this.lastTimestamp = ts;
    return ts;
  }
};

// src/views/chatview/controllers/StreamingController.ts
init_jsonRepair();

// src/views/chatview/persistence/ChatPersistenceManager.ts
init_errorLogger();
var ChatPersistenceManager = class {
  constructor(options) {
    this.autosaveTimer = null;
    // Save queue semantics: ensure we never lose a final save when a prior save is in flight
    this.inFlight = null;
    this.flushRequested = false;
    var _a;
    this.saveChat = options.saveChat;
    this.onAssistantResponse = options.onAssistantResponse;
    this.debounceMs = (_a = options.debounceMs) != null ? _a : 500;
  }
  scheduleAutosave() {
    if (this.autosaveTimer) {
      clearTimeout(this.autosaveTimer);
    }
    this.autosaveTimer = setTimeout(() => {
      this.autosaveTimer = null;
      this.requestFlush("autosave");
    }, this.debounceMs);
  }
  cancelAutosave() {
    if (this.autosaveTimer) {
      clearTimeout(this.autosaveTimer);
      this.autosaveTimer = null;
    }
  }
  async commit(finalMessage) {
    this.cancelAutosave();
    try {
      await this.onAssistantResponse(finalMessage);
    } catch (error) {
      errorLogger.error("Failed to persist assistant message", error, {
        source: "ChatPersistenceManager",
        method: "commit",
        metadata: { messageId: finalMessage == null ? void 0 : finalMessage.message_id }
      });
      throw error;
    }
    await this.requestFlush("commit");
  }
  // Queue-aware flush: if a save is in-flight, mark that we need another flush
  // and ensure the current run loops to perform it.
  async requestFlush(reason) {
    this.flushRequested = true;
    if (this.inFlight) {
      return this.inFlight;
    }
    this.inFlight = (async () => {
      try {
        while (this.flushRequested) {
          this.flushRequested = false;
          try {
            await this.saveChat();
            errorLogger.info(`Chat ${reason} completed`, {
              source: "ChatPersistenceManager",
              method: "requestFlush",
              metadata: { reason }
            });
          } catch (error) {
            errorLogger.error("Chat save failed", error, {
              source: "ChatPersistenceManager",
              method: "requestFlush",
              metadata: { reason }
            });
            break;
          }
        }
      } finally {
        this.inFlight = null;
      }
    })();
    return this.inFlight;
  }
};

// src/views/chatview/controllers/StreamingController.ts
var StreamingController = class extends import_obsidian77.Component {
  constructor(options) {
    super();
    this.activeAssemblers = /* @__PURE__ */ new Map();
    this.scrollScheduled = false;
    this.opts = options;
    this.persistence = new ChatPersistenceManager({
      saveChat: options.saveChat,
      onAssistantResponse: options.onAssistantResponse,
      debounceMs: options.autosaveDebounceMs
    });
  }
  async stream(stream, messageEl, messageId, abortSignal, initialWebSearchEnabled) {
    var _a, _b;
    const {
      toolCallManager,
      scrollManager,
      updateStreamingStatus: updateStreamingStatus2,
      showStreamingStatus: showStreamingStatus2,
      hideStreamingStatus: hideStreamingStatus2,
      toggleStopButton,
      onError,
      setStreamingFootnote: setStreamingFootnote2,
      clearStreamingFootnote: clearStreamingFootnote2,
      extractAnnotations
    } = this.opts;
    const assembler = this.ensureAssembler(messageId);
    assembler.begin();
    const assistantMessage = {
      role: "assistant",
      content: "",
      message_id: messageId,
      messageParts: assembler.getParts()
    };
    const toolCallState = {
      rawToSanitized: /* @__PURE__ */ new Map(),
      usedSanitized: /* @__PURE__ */ new Set()
    };
    const pendingToolCalls = /* @__PURE__ */ new Map();
    const emittedToolCalls = /* @__PURE__ */ new Set();
    let webSearchEnabled = initialWebSearchEnabled;
    toggleStopButton(true);
    showStreamingStatus2(messageEl);
    let abortedBySignal = false;
    let completedNaturally = false;
    let recoveredStream = false;
    try {
      for await (const event of stream) {
        if (abortSignal.aborted) {
          try {
            errorLogger.debug("Stream aborted by signal", {
              source: "StreamingController",
              method: "stream",
              metadata: { messageId }
            });
          } catch (e) {
          }
          abortedBySignal = true;
          break;
        }
        switch (event.type) {
          case "reasoning": {
            assembler.apply(event);
            this.updateMessageRendering(assembler, messageEl, assistantMessage, true);
            updateStreamingStatus2(messageEl, "reasoning", "Thinking\u2026");
            break;
          }
          case "content": {
            assembler.apply(event);
            this.updateMessageRendering(assembler, messageEl, assistantMessage, true);
            updateStreamingStatus2(messageEl, "content", "Writing\u2026");
            break;
          }
          case "tool-call": {
            updateStreamingStatus2(messageEl, "tool_calls", "Using tools\u2026");
            this.handleToolCallEvent({
              event,
              assembler,
              messageEl,
              assistantMessage,
              messageId,
              pendingToolCalls,
              emittedToolCalls,
              toolCallState
            });
            break;
          }
          case "meta": {
            if (event.key === "web-search-enabled") {
              webSearchEnabled = !!event.value;
            } else if (event.key === "inline-footnote" && setStreamingFootnote2) {
              setStreamingFootnote2(messageEl, String((_a = event.value) != null ? _a : ""));
            }
            break;
          }
          case "footnote": {
            if (setStreamingFootnote2) {
              setStreamingFootnote2(messageEl, event.text);
            }
            break;
          }
          default:
            break;
        }
        this.scheduleStickToBottom(scrollManager);
      }
      if (!abortedBySignal) completedNaturally = true;
    } catch (err) {
      const recovered = await this.tryRecoverFromToolSchemaError({
        error: err,
        assembler,
        messageEl,
        messageId,
        assistantMessage
      });
      if (!recovered) {
        try {
          errorLogger.error("Stream error in StreamingController", err, {
            source: "StreamingController",
            method: "stream",
            metadata: { messageId }
          });
        } catch (e) {
        }
        if (onError) {
          const errorMessage = (err == null ? void 0 : err.message) || ((_b = err == null ? void 0 : err.toString) == null ? void 0 : _b.call(err)) || "Unknown streaming error";
          onError(new SystemSculptError(errorMessage, ERROR_CODES.STREAM_ERROR, 500, { cause: err }));
        }
        throw err;
      }
      recoveredStream = true;
    } finally {
      toggleStopButton(false);
      hideStreamingStatus2(messageEl);
      if (clearStreamingFootnote2) {
        try {
          clearStreamingFootnote2(messageEl);
        } catch (e) {
        }
      }
      const summary = assembler.finalize();
      assistantMessage.content = summary.content;
      assistantMessage.reasoning = summary.reasoning || void 0;
      assistantMessage.messageParts = summary.parts;
      assistantMessage.tool_calls = this.collectToolCalls(summary.parts);
      assistantMessage.annotations = extractAnnotations(summary.content);
      assistantMessage.webSearchEnabled = webSearchEnabled;
      if (!abortedBySignal && (completedNaturally || recoveredStream)) {
        this.updateMessageRendering(assembler, messageEl, assistantMessage, false);
        await this.persistence.commit(assistantMessage);
      } else {
        try {
          this.persistence.cancelAutosave();
        } catch (e) {
        }
      }
      this.scheduleStickToBottom(scrollManager, true);
    }
  }
  finalizeMessage(messageId) {
    this.activeAssemblers.delete(messageId);
  }
  ensureAssembler(messageId) {
    let assembler = this.activeAssemblers.get(messageId);
    if (!assembler) {
      assembler = new TranscriptAssembler();
      this.activeAssemblers.set(messageId, assembler);
    }
    return assembler;
  }
  updateMessageRendering(assembler, messageEl, assistantMessage, isStreaming) {
    const parts = assembler.getParts();
    assistantMessage.messageParts = parts;
    try {
      this.opts.messageRenderer.renderMessageParts(messageEl, { messageParts: parts }, isStreaming);
    } catch (e) {
    }
    this.persistence.scheduleAutosave();
  }
  handleToolCallEvent(params) {
    const {
      event,
      assembler,
      messageEl,
      assistantMessage,
      messageId,
      pendingToolCalls,
      emittedToolCalls,
      toolCallState
    } = params;
    const { toolCallManager, generateMessageId } = this.opts;
    if (!toolCallManager) return;
    const sanitizedId = this.ensureToolCallId(event.call, toolCallState, generateMessageId);
    if (event.phase === "delta") {
      const existing = pendingToolCalls.get(sanitizedId);
      const merged = {
        ...existing != null ? existing : {},
        ...event.call,
        id: sanitizedId,
        function: {
          name: event.call.function.name || (existing == null ? void 0 : existing.function.name) || "",
          arguments: event.call.function.arguments || (existing == null ? void 0 : existing.function.arguments) || ""
        }
      };
      pendingToolCalls.set(sanitizedId, merged);
      return;
    }
    if (emittedToolCalls.has(sanitizedId)) {
      return;
    }
    const aggregated = pendingToolCalls.get(sanitizedId);
    pendingToolCalls.delete(sanitizedId);
    const effectiveCall = {
      id: sanitizedId,
      type: "function",
      function: {
        name: event.call.function.name || (aggregated == null ? void 0 : aggregated.function.name) || "",
        arguments: event.call.function.arguments || (aggregated == null ? void 0 : aggregated.function.arguments) || ""
      }
    };
    if (!effectiveCall.function.name) {
      try {
        errorLogger.debug("Skipping tool call without function name", {
          source: "StreamingController",
          method: "handleToolCallEvent",
          metadata: { messageId, toolCallId: sanitizedId }
        });
      } catch (e) {
      }
      return;
    }
    let normalizedArgs = effectiveCall.function.arguments || "";
    if (normalizedArgs) {
      try {
        normalizedArgs = normalizeJsonString(normalizedArgs);
      } catch (e) {
      }
    }
    const request = {
      id: sanitizedId,
      type: "function",
      function: {
        name: effectiveCall.function.name,
        arguments: normalizedArgs
      }
    };
    const autoApprove = toolCallManager.shouldAutoApprove(request.function.name);
    const toolCall = toolCallManager.createToolCall(request, messageId, autoApprove);
    if (!toolCall) {
      try {
        errorLogger.debug("Tool call manager returned null", {
          source: "StreamingController",
          method: "handleToolCallEvent",
          metadata: { messageId, toolCallId: sanitizedId }
        });
      } catch (e) {
      }
      return;
    }
    emittedToolCalls.add(toolCall.id);
    assembler.attachToolCall(toolCall);
    this.updateMessageRendering(assembler, messageEl, assistantMessage, true);
  }
  ensureToolCallId(call, state, generateMessageId) {
    var _a;
    const baseKey = (_a = call.id) != null ? _a : `index_${typeof (call == null ? void 0 : call.index) === "number" ? call.index : "0"}`;
    if (state.rawToSanitized.has(baseKey)) {
      return state.rawToSanitized.get(baseKey);
    }
    const createCandidate = () => {
      const seed = (call.id || generateMessageId()).replace(/[^a-zA-Z0-9]/g, "");
      const suffix = seed.slice(-12) || generateMessageId().replace(/[^a-zA-Z0-9]/g, "").slice(-12);
      return `call_${suffix}`;
    };
    let candidate = createCandidate();
    while (state.usedSanitized.has(candidate)) {
      candidate = createCandidate();
    }
    state.usedSanitized.add(candidate);
    state.rawToSanitized.set(baseKey, candidate);
    return candidate;
  }
  collectToolCalls(parts) {
    const calls = parts.filter((part) => part.type === "tool_call").map((part) => part.data);
    return calls.length > 0 ? calls : void 0;
  }
  scheduleStickToBottom(scrollManager, immediate = false) {
    if (immediate) {
      try {
        scrollManager.requestStickToBottom("assistant-chunk", { immediate: true });
      } catch (e) {
      }
      return;
    }
    if (this.scrollScheduled) return;
    this.scrollScheduled = true;
    const run = () => {
      this.scrollScheduled = false;
      try {
        scrollManager.requestStickToBottom("assistant-chunk");
      } catch (e) {
      }
    };
    if (typeof window !== "undefined" && typeof window.requestAnimationFrame === "function") {
      window.requestAnimationFrame(() => run());
    } else {
      setTimeout(run, 0);
    }
  }
  async tryRecoverFromToolSchemaError(params) {
    const { error, assembler, messageEl, messageId, assistantMessage } = params;
    const { generateMessageId, toolCallManager } = this.opts;
    if (!toolCallManager) return false;
    try {
      const { deriveChunkedToolCallsFromSchemaError: deriveChunkedToolCallsFromSchemaError2 } = await Promise.resolve().then(() => (init_ToolCallFallback(), ToolCallFallback_exports));
      const plan = deriveChunkedToolCallsFromSchemaError2(error);
      if (!plan) return false;
      const created = [];
      for (let index = 0; index < plan.chunks.length; index += 1) {
        const argsObj = plan.chunks[index];
        const request = {
          id: `call_recovery_${generateMessageId().replace(/[^a-zA-Z0-9]/g, "").slice(-12)}`,
          type: "function",
          function: {
            name: plan.toolName,
            arguments: JSON.stringify(argsObj)
          }
        };
        const toolCall = toolCallManager.createToolCall(request, messageId, true);
        if (toolCall) {
          assembler.attachToolCall(toolCall);
          created.push(toolCall);
        }
      }
      if (created.length === 0) {
        return false;
      }
      this.updateMessageRendering(assembler, messageEl, assistantMessage, true);
      try {
        errorLogger.warn("Recovered from tool schema validation failure by chunking", {
          source: "StreamingController",
          method: "tryRecoverFromToolSchemaError",
          metadata: { messageId, tool: plan.toolName, chunks: plan.chunks.length }
        });
      } catch (e) {
      }
      return true;
    } catch (e) {
      return false;
    }
  }
};

// src/views/chatview/messageHandling.ts
var messageHandling = {
  addMessage: async function(chatView, role, content, existingMessageId, completeMessage, targetContainer) {
    const messageId = existingMessageId || chatView.generateMessageId();
    const { messageEl, contentEl } = await chatView.messageRenderer.renderMessage({ app: chatView.app, messageId, role, content: content || "" });
    const contentStr = typeof content === "string" ? content : content ? JSON.stringify(content) : "";
    messageEl.dataset.content = contentStr;
    if (completeMessage && completeMessage.role === "assistant") {
      await this.renderAssistantMessage(chatView, messageEl, completeMessage);
    }
    this.registerMessageEventHandlers(chatView, messageEl);
    const container = targetContainer || chatView.chatContainer;
    container.appendChild(messageEl);
    const appendedIntoLiveContainer = container === chatView.chatContainer;
    if (appendedIntoLiveContainer) {
      if (chatView.isGenerating) {
        if (window.requestIdleCallback) {
          window.requestIdleCallback(() => chatView.manageDomSize(), { timeout: 1e3 });
        } else {
          setTimeout(() => chatView.manageDomSize(), 50);
        }
      } else {
        chatView.manageDomSize();
      }
    }
  },
  // Group-related helpers removed; flat list insertion only
  /**
   * Render assistant messages with unified parts and proper tool call registration
   */
  renderAssistantMessage: async function(chatView, messageEl, message) {
    if (message.tool_calls && message.tool_calls.length > 0 && chatView.toolCallManager) {
      for (const toolCall of message.tool_calls) {
        const existingToolCall = chatView.toolCallManager.getToolCall(toolCall.id);
        if (!existingToolCall) {
          const serializedToolCall = {
            id: toolCall.id,
            request: toolCall.request,
            state: toolCall.state,
            timestamp: toolCall.timestamp,
            approvedAt: toolCall.approvedAt,
            executionStartedAt: toolCall.executionStartedAt,
            executionCompletedAt: toolCall.executionCompletedAt,
            result: toolCall.result,
            autoApproved: toolCall.autoApproved
          };
          chatView.toolCallManager.restoreToolCall(serializedToolCall, message.message_id);
        }
      }
    }
    const partList = chatView.messageRenderer.normalizeMessageToParts(message);
    if (partList.parts.length > 0) {
      chatView.messageRenderer.renderUnifiedMessageParts(messageEl, partList.parts);
    }
    if (message.webSearchEnabled && message.annotations) {
      const urlCitations = message.annotations.filter((annotation) => annotation.type === "url_citation" && annotation.url_citation).map((annotation) => annotation.url_citation).filter((citation) => citation !== void 0);
      if (urlCitations.length > 0) {
        const contentEl = messageEl.querySelector(".systemsculpt-message-content");
        if (contentEl) {
          chatView.messageRenderer.renderCitations(contentEl, urlCitations);
        }
      }
    }
  },
  /**
   * Register event handlers for message interactions with proper cleanup
   */
  registerMessageEventHandlers: function(chatView, messageEl) {
    const registerHandler = (element, eventName, handler) => {
      element.addEventListener(eventName, handler);
      chatView.register(() => element.removeEventListener(eventName, handler));
    };
    const resubmitHandler = async (e) => {
      const { messageId, content } = e.detail;
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index === -1) return;
      chatView.messages.splice(index);
      if (chatView.messages.length === 0) {
        chatView.chatId = "";
        chatView.chatVersion = 0;
        chatView.isFullyLoaded = false;
      } else {
        await chatView.saveChat();
      }
      await this.reloadAllMessages(chatView);
      if (chatView.inputHandler) {
        try {
          const { trimOuterBlankLines: trimOuterBlankLines2 } = await Promise.resolve().then(() => (init_textUtils(), textUtils_exports));
          const asString = typeof content === "string" ? content : JSON.stringify(content != null ? content : "");
          const normalized = trimOuterBlankLines2(asString);
          chatView.inputHandler.setValue(normalized);
        } catch (e2) {
          chatView.inputHandler.setValue(typeof content === "string" ? content : JSON.stringify(content != null ? content : ""));
        }
        chatView.inputHandler.focus();
      }
    };
    const replyHandler = async (e) => {
      var _a;
      const { content } = e.detail || {};
      const text = typeof content === "string" ? content : (((_a = messageEl.querySelector(".systemsculpt-message-content, .systemsculpt-content-part")) == null ? void 0 : _a.textContent) || "").trim();
      if (!chatView.inputHandler) return;
      const quoted = text.split("\n").map((line) => `> ${line}`).join("\n");
      const replyTemplate = quoted ? `${quoted}

` : "";
      chatView.inputHandler.setValue(replyTemplate);
      chatView.inputHandler.focus();
    };
    const editHandler = async (e) => {
      const { messageId, newContent } = e.detail;
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index !== -1) {
        const existingMessage = chatView.messages[index];
        const updatedMessage = {
          ...existingMessage,
          content: newContent,
          messageParts: void 0
        };
        chatView.messages[index] = updatedMessage;
        await chatView.saveChat();
        const { contentEl: newContentEl } = await chatView.messageRenderer.renderMessage({
          app: chatView.app,
          messageId,
          role: updatedMessage.role,
          content: updatedMessage.content
        });
        if (updatedMessage.role === "assistant") {
          await this.renderAssistantMessage(chatView, messageEl, updatedMessage);
        }
        const oldContentEl = messageEl.querySelector(".systemsculpt-message-content");
        if (oldContentEl && newContentEl) {
          oldContentEl.replaceWith(newContentEl);
        }
        const updatedStr = typeof updatedMessage.content === "string" ? updatedMessage.content : JSON.stringify(updatedMessage.content);
        messageEl.dataset.content = updatedStr;
      }
    };
    const deleteHandler = async (e) => {
      const { messageId } = e.detail;
      const index = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (index !== -1) {
        chatView.messages.splice(index, 1);
        await chatView.saveChat();
        messageEl.remove();
      }
    };
    registerHandler(messageEl, "resubmit", resubmitHandler);
    registerHandler(messageEl, "reply", replyHandler);
    registerHandler(messageEl, "edit", editHandler);
    registerHandler(messageEl, "delete", deleteHandler);
  },
  /**
   * Reload all messages with consistent rendering and visual grouping
   */
  reloadAllMessages: async function(chatView) {
    await chatView.renderMessagesInChunks();
    return;
  },
  /**
   * DEPRECATED: Remove consolidation logic - we now handle tool messages consistently
   */
  consolidateConsecutiveAssistantMessages: function(messages) {
    return messages;
  },
  loadMessages: async function(chatView) {
    if (!chatView.chatContainer) return;
    await this.reloadAllMessages(chatView);
  }
};

// src/components/AtMentionMenu.ts
var import_obsidian78 = require("obsidian");
var AtMentionMenu = class extends import_obsidian78.Component {
  constructor(chatView, inputElement) {
    super();
    this.selectedIndex = 0;
    this.filteredFiles = [];
    this.isVisible = false;
    this.triggerPosition = -1;
    this.maxResults = 50;
    this.searchQuery = "";
    this.allFiles = [];
    this.chatView = chatView;
    this.inputElement = inputElement;
    this.vault = this.chatView.app.vault;
    this.createMenu();
    this.cacheFiles();
  }
  cacheFiles() {
    const plugin = this.chatView.plugin;
    if (plugin == null ? void 0 : plugin.vaultFileCache) {
      this.allFiles = plugin.vaultFileCache.getMarkdownFiles();
    } else {
      this.allFiles = this.vault.getMarkdownFiles();
    }
  }
  createMenu() {
    this.container = document.createElement("div");
    this.container.addClass("at-mention-menu");
    this.container.style.display = "none";
    const header = this.container.createDiv("at-mention-header");
    header.createEl("span", { text: "Add file to context", cls: "at-mention-title" });
    this.itemsContainer = this.container.createDiv("at-mention-items");
    const searchContainer = this.container.createDiv("at-mention-search");
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search files...",
      cls: "at-mention-search-input"
    });
    this.searchInput.addEventListener("input", () => {
      this.handleSearch();
    });
    this.searchInput.addEventListener("keydown", (e) => {
      e.stopPropagation();
      if (e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "Enter" || e.key === "Escape") {
        e.preventDefault();
        this.handleKeyDown(e);
      } else if (e.key === "Backspace" && this.searchInput.value === "") {
        e.preventDefault();
        this.removeAtSymbolAndClose();
      }
    });
    document.body.appendChild(this.container);
  }
  show(triggerPosition) {
    this.triggerPosition = triggerPosition;
    this.isVisible = true;
    this.selectedIndex = 0;
    this.searchQuery = "";
    this.searchInput.value = "";
    this.updateFilteredFiles();
    this.render();
    this.positionMenu();
    this.container.style.display = "block";
    this.searchInput.focus();
  }
  hide() {
    this.isVisible = false;
    this.container.style.display = "none";
    this.inputElement.focus();
  }
  positionMenu() {
    const inputRect = this.inputElement.getBoundingClientRect();
    const menuHeight = 300;
    this.container.style.position = "fixed";
    this.container.style.bottom = `${window.innerHeight - inputRect.top + 10}px`;
    this.container.style.left = `${inputRect.left}px`;
    this.container.style.width = `${inputRect.width}px`;
    this.container.style.maxHeight = `${menuHeight}px`;
  }
  updateFilteredFiles() {
    if (!this.searchQuery) {
      this.filteredFiles = this.allFiles.slice(0, this.maxResults - 1).map((file) => ({ file, score: 0 }));
      return;
    }
    const query = this.searchQuery.toLowerCase();
    if ("vault structure".includes(query) || "vault".startsWith(query)) {
      const results = [];
      for (const file of this.allFiles) {
        const score = this.fuzzyScore(query, file.path.toLowerCase());
        if (score > 0) {
          results.push({ file, score });
        }
      }
      results.sort((a, b) => b.score - a.score);
      this.filteredFiles = results.slice(0, this.maxResults - 1);
    } else {
      const results = [];
      for (const file of this.allFiles) {
        const score = this.fuzzyScore(query, file.path.toLowerCase());
        if (score > 0) {
          results.push({ file, score });
        }
      }
      results.sort((a, b) => b.score - a.score);
      this.filteredFiles = results.slice(0, this.maxResults);
    }
  }
  fuzzyScore(query, target) {
    if (!query || !target) return 0;
    if (target === query) return 1e3;
    if (target.includes(query)) return 500 + (100 - target.indexOf(query));
    let score = 0;
    let queryIndex = 0;
    let targetIndex = 0;
    while (queryIndex < query.length && targetIndex < target.length) {
      if (query[queryIndex] === target[targetIndex]) {
        score += 10;
        queryIndex++;
      }
      targetIndex++;
    }
    if (queryIndex === query.length) {
      score += Math.max(0, 100 - target.length);
      return score;
    }
    return 0;
  }
  handleSearch() {
    this.searchQuery = this.searchInput.value;
    this.selectedIndex = 0;
    this.updateFilteredFiles();
    this.render();
  }
  render() {
    this.itemsContainer.empty();
    const showVaultOption = !this.searchQuery || "vault structure".includes(this.searchQuery.toLowerCase()) || "vault".startsWith(this.searchQuery.toLowerCase());
    if (showVaultOption) {
      const vaultItemEl = this.itemsContainer.createDiv({
        cls: "at-mention-item at-mention-vault" + (this.selectedIndex === 0 ? " selected" : "")
      });
      const iconEl = vaultItemEl.createDiv("at-mention-item-icon");
      iconEl.innerHTML = "\u{1F5C2}\uFE0F";
      const contentEl = vaultItemEl.createDiv("at-mention-item-content");
      const nameEl = contentEl.createDiv("at-mention-item-name");
      nameEl.setText("Vault Structure");
      const pathEl = contentEl.createDiv("at-mention-item-path");
      pathEl.setText("Add directory structure to context");
      vaultItemEl.addEventListener("click", () => {
        this.selectVaultStructure();
      });
      vaultItemEl.addEventListener("mouseenter", () => {
        this.selectedIndex = 0;
        this.render();
      });
    }
    const startIndex = showVaultOption ? 1 : 0;
    if (this.filteredFiles.length === 0 && !showVaultOption) {
      this.itemsContainer.createDiv("at-mention-empty").setText("No files found");
      return;
    }
    this.filteredFiles.forEach((item, index) => {
      const actualIndex = showVaultOption ? index + 1 : index;
      const itemEl = this.itemsContainer.createDiv({
        cls: "at-mention-item" + (actualIndex === this.selectedIndex ? " selected" : "")
      });
      const iconEl = itemEl.createDiv("at-mention-item-icon");
      iconEl.innerHTML = "\u{1F4C4}";
      const contentEl = itemEl.createDiv("at-mention-item-content");
      const nameEl = contentEl.createDiv("at-mention-item-name");
      nameEl.setText(item.file.basename);
      const pathEl = contentEl.createDiv("at-mention-item-path");
      pathEl.setText(item.file.path);
      itemEl.addEventListener("click", () => {
        this.selectFile(item.file);
      });
      itemEl.addEventListener("mouseenter", () => {
        this.selectedIndex = actualIndex;
        this.render();
      });
    });
  }
  handleKeyDown(e) {
    const showVaultOption = !this.searchQuery || "vault structure".includes(this.searchQuery.toLowerCase()) || "vault".startsWith(this.searchQuery.toLowerCase());
    const maxIndex = this.filteredFiles.length + (showVaultOption ? 0 : -1);
    switch (e.key) {
      case "ArrowUp":
        this.selectedIndex = Math.max(0, this.selectedIndex - 1);
        this.render();
        this.scrollToSelected();
        break;
      case "ArrowDown":
        this.selectedIndex = Math.min(maxIndex, this.selectedIndex + 1);
        this.render();
        this.scrollToSelected();
        break;
      case "Enter":
        if (showVaultOption && this.selectedIndex === 0) {
          this.selectVaultStructure();
        } else {
          const fileIndex = showVaultOption ? this.selectedIndex - 1 : this.selectedIndex;
          if (this.filteredFiles[fileIndex]) {
            this.selectFile(this.filteredFiles[fileIndex].file);
          }
        }
        break;
      case "Escape":
        this.hide();
        break;
    }
  }
  scrollToSelected() {
    const selectedEl = this.itemsContainer.querySelector(".at-mention-item.selected");
    if (selectedEl) {
      selectedEl.scrollIntoView({ block: "nearest" });
    }
  }
  selectFile(file) {
    const currentValue = this.inputElement.value;
    const beforeTrigger = currentValue.substring(0, this.triggerPosition);
    const afterCursor = currentValue.substring(this.inputElement.selectionEnd);
    const link = `[[${file.path}]]`;
    const newValue = beforeTrigger + link + " " + afterCursor;
    this.inputElement.value = newValue;
    this.inputElement.selectionStart = this.inputElement.selectionEnd = beforeTrigger.length + link.length + 1;
    this.chatView.addContextFile(file);
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true }));
    this.hide();
  }
  isOpen() {
    return this.isVisible;
  }
  selectVaultStructure() {
    if (this.chatView.contextManager && this.chatView.contextManager.isVaultStructureIncluded()) {
      new import_obsidian78.Notice("Your vault structure is already added into the context for this chat. Remove it from the context drawer at the top of your chat view if you don't want to include it anymore.", 5e3);
    } else {
      if (this.chatView.contextManager) {
        this.chatView.contextManager.toggleVaultStructure();
      }
    }
    const currentValue = this.inputElement.value;
    const beforeTrigger = currentValue.substring(0, this.triggerPosition);
    const afterCursor = currentValue.substring(this.inputElement.selectionEnd);
    const newValue = beforeTrigger + afterCursor;
    this.inputElement.value = newValue;
    this.inputElement.selectionStart = this.inputElement.selectionEnd = this.triggerPosition;
    this.inputElement.dispatchEvent(new Event("input", { bubbles: true }));
    this.hide();
  }
  removeAtSymbolAndClose() {
    const currentValue = this.inputElement.value;
    const beforeAt = currentValue.substring(0, this.triggerPosition);
    const afterAt = currentValue.substring(this.triggerPosition + 1);
    this.inputElement.value = beforeAt + afterAt;
    this.inputElement.selectionStart = this.inputElement.selectionEnd = this.triggerPosition;
    this.hide();
  }
  onunload() {
    this.container.remove();
  }
};

// src/views/chatview/ui/createInputUI.ts
var import_obsidian79 = require("obsidian");
function createPrimaryButtons(parent, deps) {
  const primaryGroup = parent.createDiv({
    cls: "systemsculpt-button-group systemsculpt-button-group-primary"
  });
  const mcpToolsButtonContainer = primaryGroup.createDiv();
  const mcpToolsButton = new import_obsidian79.ButtonComponent(mcpToolsButtonContainer).setIcon("vault").setTooltip("Toggle Agent Mode").setClass("mod-small").onClick(async () => {
    const agentModeActive = deps.getAgentMode();
    if (agentModeActive) {
      await deps.disableAgentModeForChat();
    } else {
      await deps.enableAgentModeForChat();
    }
    deps.updateMcpToolsButtonState();
  });
  if (!deps.isMcpEnabled()) {
    mcpToolsButton.buttonEl.style.display = "none";
  }
  const settingsButtonContainer = primaryGroup.createDiv();
  const settingsButton = new import_obsidian79.ButtonComponent(settingsButtonContainer).setIcon("settings").setTooltip("This Chat's Settings").setClass("mod-small").onClick(() => deps.onEditSystemPrompt());
  const attachButtonContainer = primaryGroup.createDiv();
  const attachButton = new import_obsidian79.ButtonComponent(attachButtonContainer).setIcon("paperclip").setTooltip("Add context file or upload document").setClass("mod-small").onClick(() => deps.onAddContextFile());
  const webSearchButtonContainer = primaryGroup.createDiv();
  const webSearchButton = new import_obsidian79.ButtonComponent(webSearchButtonContainer).setIcon("globe").setTooltip("Toggle web search (SystemSculpt & OpenRouter only)").setClass("mod-small").onClick(() => {
    deps.toggleWebSearchEnabled();
    deps.updateWebSearchButtonState();
    if (deps.getWebSearchEnabled()) new import_obsidian79.Notice("Web search enabled");
    else new import_obsidian79.Notice("Web search disabled");
  });
  if (!deps.isWebSearchAllowed()) {
    webSearchButton.buttonEl.style.display = "none";
  }
  const micButtonContainer = primaryGroup.createDiv();
  const micButton = new import_obsidian79.ButtonComponent(micButtonContainer).setIcon("mic").setTooltip("Record audio message").setClass("mod-small").setDisabled(!deps.hasProLicense()).onClick(() => deps.handleMicClick());
  return { settingsButton, attachButton, mcpToolsButton, webSearchButton, micButton };
}
function createActionButtons(parent, deps) {
  const actionsGroup = parent.createDiv({
    cls: "systemsculpt-button-group systemsculpt-button-group-actions"
  });
  const sendButtonContainer = actionsGroup.createDiv();
  const sendButton = new import_obsidian79.ButtonComponent(sendButtonContainer).setIcon("send").setTooltip("Send message").setClass("mod-small").setCta().onClick(() => void deps.onSend());
  const stopButtonContainer = actionsGroup.createDiv();
  const stopButton = new import_obsidian79.ButtonComponent(stopButtonContainer).setIcon("square").setTooltip("Stop generation").setClass("mod-small").setWarning().onClick(() => void deps.onStop());
  stopButton.buttonEl.style.display = "none";
  return { sendButton, stopButton };
}
function createChatTextArea(parent, deps) {
  const wrapper = parent.createDiv({ cls: "systemsculpt-chat-input-wrap" });
  const input = wrapper.createEl("textarea", {
    cls: "systemsculpt-input systemsculpt-chat-input",
    attr: {
      rows: "1",
      placeholder: "Search your vault, link notes, write ideas"
    }
  });
  deps.registerDomEvent(input, "keydown", deps.onKeyDown);
  deps.registerDomEvent(input, "input", () => {
    deps.onInput();
    const event = new CustomEvent("systemsculpt:input-token-update-request", { detail: { source: "input" } });
    wrapper.dispatchEvent(event);
  });
  deps.registerDomEvent(input, "paste", deps.onPaste);
  return input;
}

// src/views/chatview/handlers/LargePasteHandlers.ts
var import_obsidian80 = require("obsidian");
init_FileValidator();
async function handleLargeTextPaste(ctx, text) {
  const lineCount = LargeTextHelpers.getLineCount(text);
  const placeholder = LargeTextHelpers.createPlaceholder(lineCount);
  ctx.setPendingLargeTextContent(text);
  ctx.insertTextAtCursor(placeholder);
  new import_obsidian80.Notice(`${LARGE_TEXT_MESSAGES.CONFIRMATION_PREFIX} (${lineCount} lines). Full content will be sent when you submit.`);
}
function showLargeTextWarning(ctx, sizeKB, text) {
  return new Promise((resolve) => {
    const modal = new import_obsidian80.Modal(ctx.app);
    modal.titleEl.setText("Large Text Detected");
    const content = modal.contentEl;
    content.createEl("p", {
      text: `You're trying to paste ${Math.round(sizeKB)}KB of text. This might cause performance issues.`
    });
    const preview = content.createEl("div", { cls: "systemsculpt-large-text-preview" });
    preview.createEl("p", { text: "Preview (first 200 characters):" });
    preview.createEl("pre", {
      text: text.substring(0, 200) + (text.length > 200 ? "..." : ""),
      cls: "systemsculpt-text-preview"
    });
    const buttonContainer = content.createDiv({ cls: "systemsculpt-modal-buttons" });
    const proceedBtn = buttonContainer.createEl("button", { text: "Proceed Anyway" });
    proceedBtn.addEventListener("click", () => {
      modal.close();
      resolve(true);
    });
    const cancelBtn = buttonContainer.createEl("button", { text: "Cancel" });
    cancelBtn.addEventListener("click", () => {
      modal.close();
      resolve(false);
    });
    modal.open();
  });
}
async function handlePaste(ctx, e) {
  var _a;
  const dt = e.clipboardData;
  if (!dt) return;
  const pastedText = (_a = dt.getData("text/plain")) != null ? _a : "";
  const allFiles = Array.from(dt.files);
  if (!allFiles.length && pastedText) {
    const warningLevel = LargeTextHelpers.getTextWarningLevel(pastedText);
    if (warningLevel === "error") {
      e.preventDefault();
      new import_obsidian80.Notice(LARGE_TEXT_MESSAGES.SIZE_ERROR);
      return;
    } else if (warningLevel === "hard") {
      e.preventDefault();
      const textSizeKB = LargeTextHelpers.getTextSizeKB(pastedText);
      const proceed = await showLargeTextWarning(ctx, textSizeKB, pastedText);
      if (!proceed) return;
      await handleLargeTextPaste(ctx, pastedText);
      return;
    } else if (warningLevel === "soft") {
      const textSizeKB = LargeTextHelpers.getTextSizeKB(pastedText);
      new import_obsidian80.Notice(`${LARGE_TEXT_MESSAGES.SIZE_WARNING_PREFIX} (${LargeTextHelpers.formatSize(textSizeKB)}). Processing...`);
    }
    return;
  }
  e.preventDefault();
  if (!allFiles.length) {
    return;
  }
  for (const file of allFiles) {
    try {
      const isValidSize = await validateBrowserFileSize(file, ctx.app);
      if (!isValidSize) {
        continue;
      }
      let extension = "bin";
      if (file.name && file.name.includes(".")) {
        const dotIdx = file.name.lastIndexOf(".");
        if (dotIdx >= 0) {
          extension = file.name.substring(dotIdx + 1).toLowerCase();
        }
      } else if (file.type) {
        const mimeParts = file.type.split("/");
        if (mimeParts.length === 2) {
          extension = mimeParts[1].toLowerCase().replace(/[^a-z0-9]/g, "");
        }
      }
      const now = /* @__PURE__ */ new Date();
      const isoString = now.toISOString().replace(/[:.]/g, "-");
      const newFileName = `pasted-${isoString}.${extension}`;
      const arrayBuffer = await file.arrayBuffer();
      const attachmentsDir = ctx.plugin.settings.attachmentsDirectory || "Attachments";
      const finalPath = `${attachmentsDir}/${newFileName}`;
      if (ctx.plugin.directoryManager) {
        await ctx.plugin.directoryManager.ensureDirectoryByPath(attachmentsDir);
      } else {
        await ctx.plugin.createDirectory(attachmentsDir);
      }
      await ctx.app.vault.createBinary(finalPath, arrayBuffer);
      const createdFile = ctx.app.vault.getAbstractFileByPath(finalPath);
      if (createdFile instanceof import_obsidian80.TFile) {
        await ctx.addFileToContext(createdFile);
        new import_obsidian80.Notice(`Pasted file saved & added to context: ${createdFile.name}`);
      } else {
        throw new Error("Failed to locate pasted file in vault.");
      }
    } catch (err) {
      new import_obsidian80.Notice(`Failed to handle pasted file: ${err.message}`);
    }
  }
  if (pastedText) {
    if (LargeTextHelpers.shouldCollapseInHistory(pastedText)) {
      await handleLargeTextPaste(ctx, pastedText);
    } else {
      ctx.insertTextAtCursor(pastedText);
    }
  }
}

// src/views/chatview/handlers/UIKeyHandlers.ts
var import_obsidian81 = require("obsidian");
async function handleKeyDown(ctx, event) {
  var _a, _b;
  if ((_a = ctx.slashCommandMenu) == null ? void 0 : _a.handleKeydown(event)) {
    return;
  }
  if ((_b = ctx.atMentionMenu) == null ? void 0 : _b.isOpen()) {
    if (event.key === "ArrowUp" || event.key === "ArrowDown" || event.key === "Enter" || event.key === "Escape") {
      return;
    }
  }
  if (event.key === "Enter" && !event.shiftKey) {
    event.preventDefault();
    if (ctx.isGenerating()) {
      new import_obsidian81.Notice("Please wait for the current response to complete before sending another message");
      return;
    }
    await ctx.handleSendMessage();
  }
  if (event.key === "Escape" && ctx.isGenerating()) {
    event.preventDefault();
    await ctx.handleStopGeneration();
    return;
  }
  if ((event.metaKey || event.ctrlKey) && event.key === ".") {
    if (ctx.isGenerating()) {
      event.preventDefault();
      await ctx.handleStopGeneration();
    }
  }
}
function handleInputChange(ctx) {
  ctx.adjustInputHeight();
  handleSlashCommandDetection(ctx);
  handleAtMentionDetection(ctx);
  if (ctx.input && ctx.setPendingLargeTextContent) {
    if (!LargeTextHelpers.containsPlaceholder(ctx.input.value)) {
      ctx.setPendingLargeTextContent(null);
    }
  }
}
function handleSlashCommandDetection(ctx) {
  if (!ctx.slashCommandMenu) return;
  const value = ctx.input.value;
  const cursorPos = ctx.input.selectionStart || 0;
  const isLeadingSlash = value.startsWith("/") && cursorPos >= 1;
  if (isLeadingSlash) {
    const query = value.substring(1, cursorPos);
    if (!ctx.slashCommandMenu.isOpen()) ctx.slashCommandMenu.show(query);
    else ctx.slashCommandMenu.updateQuery(query);
  } else if (ctx.slashCommandMenu.isOpen()) {
    ctx.slashCommandMenu.hide();
  }
}
function handleAtMentionDetection(ctx) {
  if (!ctx.atMentionMenu) return;
  const value = ctx.input.value;
  const cursorPos = ctx.input.selectionStart || 0;
  let atIndex = -1;
  for (let i = cursorPos - 1; i >= 0; i--) {
    if (value[i] === "@") {
      if (i === 0 || /\s/.test(value[i - 1])) {
        atIndex = i;
        break;
      }
    } else if (/\s/.test(value[i])) {
      break;
    }
  }
  if (atIndex !== -1) {
    if (!ctx.atMentionMenu.isOpen()) ctx.atMentionMenu.show(atIndex);
  } else if (ctx.atMentionMenu.isOpen()) {
    ctx.atMentionMenu.hide();
  }
}

// src/views/chatview/handlers/MessageElements.ts
var import_obsidian82 = require("obsidian");
function addMessageToContainer(chatContainer, messageEl, role, breakGroup = false) {
  chatContainer.appendChild(messageEl);
  try {
    messageEl.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
  } catch (e) {
  }
  return { isNewGroup: false };
}
function createAssistantMessageContainer(chatContainer, generateMessageId, chatView, breakGroup = false) {
  const messageEl = createDiv({ cls: "systemsculpt-message systemsculpt-assistant-message" });
  messageEl.setAttribute("data-message-id", generateMessageId());
  const contentEl = createDiv({ cls: "systemsculpt-message-content" });
  messageEl.appendChild(contentEl);
  addMessageToContainer(chatContainer, messageEl, "assistant", breakGroup);
  try {
    messageEl.dispatchEvent(new CustomEvent("systemsculpt-dom-content-changed", { bubbles: true }));
  } catch (e) {
  }
  return { messageEl, contentEl };
}
function getStatusIndicator(messageEl) {
  return messageEl.querySelector(".systemsculpt-streaming-status");
}
function updateStreamingStatus(messageEl, liveRegionEl, status, text) {
  const statusIndicator = getStatusIndicator(messageEl) || messageEl.createEl("span", { cls: "systemsculpt-streaming-status" });
  const label = text || (status === "reasoning" ? "Thinking\u2026" : status === "tool_calls" ? "Using tools\u2026" : "Writing\u2026");
  statusIndicator.setAttr("data-status", status);
  statusIndicator.textContent = label;
  if (liveRegionEl) {
    liveRegionEl.textContent = label;
  }
}
function hideStreamingStatus(messageEl, liveRegionEl) {
  const statusIndicator = getStatusIndicator(messageEl);
  if (statusIndicator) {
    statusIndicator.remove();
  }
  const footnoteEl = messageEl.querySelector(".systemsculpt-streaming-footnote");
  if (footnoteEl) {
    footnoteEl.remove();
  }
  if (liveRegionEl) {
    liveRegionEl.textContent = "";
  }
}
function showStreamingStatus(messageEl, liveRegionEl) {
  let statusIndicator = getStatusIndicator(messageEl);
  if (!statusIndicator) {
    statusIndicator = messageEl.createEl("span", { cls: "systemsculpt-streaming-status" });
  }
  statusIndicator.setAttr("data-status", "working");
  statusIndicator.textContent = "Preparing\u2026";
  if (liveRegionEl) {
    liveRegionEl.textContent = "Preparing\u2026";
  }
}
function setStreamingFootnote(messageEl, text) {
  let footnoteEl = messageEl.querySelector(".systemsculpt-streaming-footnote");
  if (!footnoteEl) {
    footnoteEl = messageEl.createEl("div", { cls: "systemsculpt-streaming-footnote" });
  }
  const lower = (text || "").toLowerCase();
  let shortLabel = "Info";
  if (lower.includes("does not support tool") || lower.includes("without tools")) {
    shortLabel = "Answered without tools";
  } else if (lower.includes("retry") && lower.includes("tool")) {
    shortLabel = "Retried without tools";
  } else if (lower.includes("does not support images") || lower.includes("image was not sent")) {
    shortLabel = "Images not supported";
  }
  footnoteEl.empty();
  const iconEl = footnoteEl.createSpan({ cls: "ss-footnote-icon" });
  (0, import_obsidian82.setIcon)(iconEl, "info");
  iconEl.setAttr("aria-label", text || "More information");
  iconEl.setAttr("title", text || "More information");
  iconEl.setAttr("role", "img");
  iconEl.setAttr("tabindex", "0");
  const tipId = `ss-footnote-tip-${Math.random().toString(36).slice(2, 8)}`;
  iconEl.setAttr("aria-describedby", tipId);
  const tooltipEl = iconEl.createSpan({ cls: "ss-footnote-tooltip", text: text || "" });
  tooltipEl.setAttr("id", tipId);
  tooltipEl.setAttr("role", "tooltip");
  footnoteEl.createSpan({ cls: "ss-footnote-text", text: shortLabel });
  const statusIndicator = messageEl.querySelector(".systemsculpt-streaming-status");
  if (statusIndicator && footnoteEl.previousElementSibling !== statusIndicator) {
    statusIndicator.insertAdjacentElement("afterend", footnoteEl);
  }
}
function clearStreamingFootnote(messageEl) {
  const footnoteEl = messageEl.querySelector(".systemsculpt-streaming-footnote");
  if (footnoteEl) {
    footnoteEl.remove();
  }
}

// src/views/chatview/handlers/Annotations.ts
function extractAnnotationsFromResponse(responseText) {
  const annotations = [];
  try {
    const markdownLinkRegex = /\[([^\]]+)\]\(([^\)]+)\)/g;
    let match;
    while ((match = markdownLinkRegex.exec(responseText)) !== null) {
      const domain = match[1];
      const url = match[2];
      const surroundingTextStart = Math.max(0, match.index - 200);
      const surroundingTextEnd = Math.min(responseText.length, match.index + match[0].length + 200);
      const surroundingText = responseText.substring(surroundingTextStart, surroundingTextEnd);
      const sentences = surroundingText.split(/(?<=\.|\?|\!)\s+/);
      const matchText = match[0];
      const sentenceWithCitation = sentences.find((s) => s.includes(matchText)) || "";
      annotations.push({
        type: "url_citation",
        url_citation: {
          title: `Source: ${domain}`,
          url,
          content: sentenceWithCitation.replace(match[0], "").trim(),
          start_index: match.index,
          end_index: match.index + match[0].length
        }
      });
    }
  } catch (_error) {
  }
  return annotations;
}

// src/views/chatview/InputHandler.ts
init_AgentMode();

// src/views/chatview/handlers/NotesHandlers.ts
var import_obsidian84 = require("obsidian");
async function handleOpenChatHistoryFile(self) {
  try {
    const chatId = self.getChatId();
    if (!chatId) {
      new import_obsidian84.Notice("No active chat to open history for");
      return;
    }
    const chatDirectory = self.plugin.settings.chatsDirectory || "SystemSculpt/Chats";
    const chatFilePath = `${chatDirectory}/${chatId}.md`;
    const file = self.app.vault.getAbstractFileByPath(chatFilePath);
    if (!(file instanceof import_obsidian84.TFile)) {
      new import_obsidian84.Notice("Chat history file not found");
      return;
    }
    await self.app.workspace.getLeaf(true).openFile(file);
    new import_obsidian84.Notice("Opened chat history file");
  } catch (error) {
    new import_obsidian84.Notice("Error opening chat history file");
  }
}
async function handleSaveChatAsNote(self) {
  try {
    if (typeof self.getChatMarkdown !== "function" || typeof self.getChatTitle !== "function") {
      new import_obsidian84.Notice("Error saving chat: Missing required functions.", 4e3);
      return;
    }
    const chatContent = await self.getChatMarkdown();
    const currentChatTitle = self.getChatTitle();
    const now = /* @__PURE__ */ new Date();
    const defaultFileName = `Chat ${now.toLocaleDateString()} ${now.toLocaleTimeString().replace(/:/g, "-")}`;
    const folderPath = self.plugin.settings.savedChatsDirectory || "SystemSculpt/Saved Chats";
    let fileName = currentChatTitle || defaultFileName;
    fileName = fileName.replace(/[\\/:*?"<>|]/g, "-");
    try {
      if (self.plugin.directoryManager) {
        await self.plugin.directoryManager.ensureDirectoryByPath(folderPath);
      } else {
        await self.plugin.app.vault.createFolder(folderPath).catch(() => {
        });
      }
      const filePath = `${folderPath}/${fileName}.md`;
      const fileExists = await self.plugin.app.vault.adapter.exists(filePath);
      if (fileExists) {
        const confirmOverwrite = await new Promise((resolve) => {
          const modal = new class extends import_obsidian84.Modal {
            constructor(app) {
              super(app);
            }
            onOpen() {
              this.titleEl.setText("File Already Exists");
              this.contentEl.createEl("p", { text: `"${fileName}.md" already exists. Do you want to overwrite it with the latest chat content?` });
              new import_obsidian84.Setting(this.contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
                this.close();
                resolve(false);
              })).addButton((btn) => btn.setButtonText("Overwrite").setWarning().onClick(() => {
                this.close();
                resolve(true);
              }));
            }
            onClose() {
              this.contentEl.empty();
            }
          }(self.app);
          modal.open();
        });
        if (!confirmOverwrite) return;
        const existingFile = self.app.vault.getAbstractFileByPath(filePath);
        if (existingFile instanceof import_obsidian84.TFile) {
          await self.plugin.app.vault.modify(existingFile, chatContent);
        } else {
          throw new Error("Could not locate the existing file to modify it");
        }
      } else {
        await self.plugin.app.vault.create(filePath, chatContent);
      }
      new import_obsidian84.Notice(`Chat saved to "${filePath}"`, 4e3);
      const file = self.plugin.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian84.TFile) {
        await self.plugin.app.workspace.openLinkText(file.path, "", true);
      }
    } catch (error) {
      new import_obsidian84.Notice("Failed to save chat as note. Please try again.", 4e3);
    }
  } catch (error) {
    new import_obsidian84.Notice("An error occurred while saving chat as note", 4e3);
  }
}

// src/views/chatview/controllers/ChatTurnOrchestrator.ts
init_webSearch();
init_errorLogger();
var ChatTurnOrchestrator = class {
  constructor(host) {
    this.activeAssistantMessage = null;
    this.continuationState = null;
    this.host = host;
    this.ai = host.aiService;
    this.streamer = host.streamingController;
    this.tools = host.toolCallManager;
  }
  async runTurn(options) {
    const { includeContextFiles, signal } = options;
    this.finalizeActiveAssistantMessage();
    this.resetContinuationState();
    try {
      const first = await this.streamAssistant({ includeContextFiles, signal });
      if (!first) return;
      if (!this.host.agentMode() || !this.tools) return;
      this.initializeContinuationState(first.messageId);
      let currentMessageId = first.messageId;
      let iteration = 0;
      for (; ; ) {
        if (signal.aborted) {
          try {
            console.log("[ChatTurnOrchestrator] Aborting continuation loop due to signal");
          } catch (e) {
          }
          break;
        }
        iteration += 1;
        try {
          console.log("[ChatTurnOrchestrator] Continuation check", { iteration, currentMessageId });
        } catch (e) {
        }
        const result = await this.continueAfterTools(currentMessageId, signal);
        if (!result) {
          try {
            console.log("[ChatTurnOrchestrator] No further continuation needed", { iteration, currentMessageId });
          } catch (e) {
          }
          break;
        }
        currentMessageId = result.newMessageId;
      }
    } finally {
      this.finalizeActiveAssistantMessage();
      this.resetContinuationState();
    }
  }
  async streamAssistant({ includeContextFiles, signal, newContainer }) {
    const { messageEl, messageId } = this.ensureAssistantMessageContainer(!!newContainer);
    const { toApiBaseMessages: toApiBaseMessages2 } = await Promise.resolve().then(() => (init_toApiMessages(), toApiMessages_exports));
    const messagesForApi = toApiBaseMessages2(this.host.getMessages());
    const sys = this.host.getSystemPrompt();
    const contextFiles = includeContextFiles ? this.host.getContextFilesWithVaultStructure() : /* @__PURE__ */ new Set();
    let stream;
    try {
      stream = this.ai.streamMessage({
        messages: messagesForApi,
        model: this.host.getSelectedModelId(),
        contextFiles,
        systemPromptType: sys.type,
        systemPromptPath: sys.path,
        agentMode: this.host.agentMode(),
        signal,
        toolCallManager: this.tools,
        plugins: this.host.webSearchEnabled() ? [{ id: WEB_SEARCH_CONFIG.PLUGIN_ID, max_results: WEB_SEARCH_CONFIG.MAX_RESULTS }] : void 0
      });
      try {
        console.log("[ChatTurnOrchestrator] Started assistant stream", { messageId, includeContextFiles });
      } catch (e) {
      }
    } catch (e) {
      this.host.onError(e);
      return null;
    }
    const unsubscribers = [];
    if (this.tools) {
      const updateWrapper = (toolCallId) => {
        try {
          const wrapper = messageEl.querySelector(`.systemsculpt-chat-structured-line[data-tool-call-id="${toolCallId}"]`);
          if (!wrapper) return;
          const tc = this.tools.getToolCall(toolCallId);
          if (!tc) return;
          const part = {
            id: wrapper.dataset.partId || `tool_call_part-${tc.id}`,
            type: "tool_call",
            timestamp: tc.timestamp,
            data: tc
          };
          this.host.messageRenderer.updateExistingPart(wrapper, part, false);
        } catch (e) {
        }
      };
      const sub = this.tools.on("tool-call:state-changed", ({ toolCallId }) => updateWrapper(toolCallId));
      unsubscribers.push(sub);
      const sub2 = this.tools.on("tool-call:execution-completed", ({ toolCallId }) => updateWrapper(toolCallId));
      unsubscribers.push(sub2);
      const sub3 = this.tools.on("tool-call:execution-failed", ({ toolCallId }) => updateWrapper(toolCallId));
      unsubscribers.push(sub3);
      const sub4 = this.tools.on("tool-call:denied", ({ toolCallId }) => updateWrapper(toolCallId));
      unsubscribers.push(sub4);
    }
    try {
      await this.streamer.stream(stream, messageEl, messageId, signal, this.host.webSearchEnabled());
      try {
        console.log("[ChatTurnOrchestrator] Assistant stream finished", { messageId });
      } catch (e) {
      }
    } finally {
      unsubscribers.forEach((u) => {
        try {
          u();
        } catch (e) {
        }
      });
    }
    return { messageId };
  }
  ensureAssistantMessageContainer(forceNew) {
    if (!forceNew && this.activeAssistantMessage && this.activeAssistantMessage.messageEl.isConnected) {
      return this.activeAssistantMessage;
    }
    const { messageEl } = this.host.createAssistantMessageContainer(forceNew);
    let messageId = messageEl.dataset.messageId;
    if (!messageId || messageId.trim().length === 0) {
      messageId = this.host.generateMessageId();
      messageEl.dataset.messageId = messageId;
    }
    this.activeAssistantMessage = { messageId, messageEl };
    return this.activeAssistantMessage;
  }
  finalizeActiveAssistantMessage() {
    if (!this.activeAssistantMessage) {
      return;
    }
    try {
      this.streamer.finalizeMessage(this.activeAssistantMessage.messageId);
    } catch (e) {
    }
    this.activeAssistantMessage = null;
  }
  initializeContinuationState(messageId) {
    if (!this.continuationState || this.continuationState.messageId !== messageId) {
      this.continuationState = { messageId, seenToolCalls: /* @__PURE__ */ new Set() };
    }
  }
  ensureContinuationState(messageId) {
    if (!this.continuationState || this.continuationState.messageId !== messageId) {
      this.continuationState = { messageId, seenToolCalls: /* @__PURE__ */ new Set() };
    }
    return this.continuationState;
  }
  resetContinuationState() {
    this.continuationState = null;
  }
  async continueAfterTools(messageId, signal) {
    if (!this.tools) return null;
    const toolCalls = this.tools.getToolCallsForMessage(messageId);
    if (!toolCalls || toolCalls.length === 0) {
      try {
        console.log("[ChatTurnOrchestrator] No tool calls for message; stopping", { messageId });
      } catch (e) {
      }
      return null;
    }
    const allHandled = () => this.tools.getToolCallsForMessage(messageId).every((tc) => tc.state === "completed" || tc.state === "failed" || tc.state === "denied");
    if (!allHandled()) {
      try {
        await new Promise((resolve) => {
          const timeout = setTimeout(() => resolve(), 12e4);
          const off = [];
          const check = () => {
            if (allHandled()) {
              cleanup();
              resolve();
            }
          };
          const cleanup = () => {
            clearTimeout(timeout);
            off.forEach((u) => {
              try {
                u();
              } catch (e) {
              }
            });
          };
          off.push(this.tools.on("tool-call:state-changed", ({ toolCall }) => {
            if ((toolCall == null ? void 0 : toolCall.messageId) === messageId) check();
          }));
          off.push(this.tools.on("tool-call:execution-completed", ({ toolCall }) => {
            if ((toolCall == null ? void 0 : toolCall.messageId) === messageId) check();
          }));
          off.push(this.tools.on("tool-call:execution-failed", ({ toolCall }) => {
            if ((toolCall == null ? void 0 : toolCall.messageId) === messageId) check();
          }));
          off.push(this.tools.on("tool-call:denied", ({ toolCall }) => {
            if ((toolCall == null ? void 0 : toolCall.messageId) === messageId) check();
          }));
        });
      } catch (e) {
      }
    }
    const continuationState = this.ensureContinuationState(messageId);
    const newlyHandledToolCalls = toolCalls.filter((tc) => !continuationState.seenToolCalls.has(tc.id));
    if (newlyHandledToolCalls.length === 0) {
      try {
        console.log("[ChatTurnOrchestrator] No new tool calls since last continuation; stopping", { messageId });
      } catch (e) {
      }
      return null;
    }
    newlyHandledToolCalls.forEach((tc) => continuationState.seenToolCalls.add(tc.id));
    const msgs = this.host.getMessages();
    const idx = msgs.findIndex((m) => m.message_id === messageId);
    if (idx !== -1) {
      const hasLaterUser = msgs.slice(idx + 1).some((m) => m.role === "user");
      if (hasLaterUser) return null;
    }
    const cont = await this.streamAssistant({ includeContextFiles: false, signal, newContainer: true });
    if (!cont) return null;
    if (cont.messageId !== continuationState.messageId) {
      this.initializeContinuationState(cont.messageId);
    }
    try {
      errorLogger.debug("Continuation after tools completed", {
        source: "ChatTurnOrchestrator",
        method: "continueAfterTools",
        metadata: { prevMessageId: messageId, newMessageId: cont.messageId }
      });
    } catch (e) {
    }
    return { newMessageId: cont.messageId };
  }
};

// src/services/TokenCounterService.ts
init_tokenCounting();
init_webSearch();
var TokenCounterService = class {
  constructor(options) {
    // Simplified caching - cache token counts per message and context
    this.messageTokenCache = /* @__PURE__ */ new Map();
    this.contextTokenCache = /* @__PURE__ */ new Map();
    this.maxCacheSize = 500;
    // Baseline snapshot from the last full count to stabilize quick estimates
    this.baselineTokens = 0;
    this.baselineInputTokens = 0;
    this.baselineSoftLimit = 0;
    this.baselineMaxContext = 0;
    this.hasBaseline = false;
    /**
     * Count tokens efficiently with optimized caching
     */
    this.countTokens = async () => {
      try {
        const modelId = this.safeGetSelectedModelId();
        const sysPrompt = this.safeGetSystemPrompt();
        const { requestBody } = await this.aiService.buildRequestPreview({
          messages: this.safeGetMessages(),
          model: modelId,
          contextFiles: this.safeGetContextFiles(),
          systemPromptType: sysPrompt.type,
          systemPromptPath: sysPrompt.path,
          agentMode: this.agentMode,
          toolCallManager: this.toolCallManager,
          // Web search via plugins
          plugins: this.webSearchEnabled ? [{ id: WEB_SEARCH_CONFIG.PLUGIN_ID, max_results: WEB_SEARCH_CONFIG.MAX_RESULTS }] : void 0
        });
        let tokens = countRequestTokens(requestBody);
        let inputTokens = 0;
        try {
          const inputText = this.getInputText();
          if (inputText && inputText.length > 0) {
            inputTokens = countTextTokens(inputText);
            tokens += inputTokens;
          }
        } catch (e) {
        }
        let maxContext = 0;
        let softLimit = 0;
        try {
          const model = await this.plugin.modelService.getModelById(modelId);
          maxContext = (model == null ? void 0 : model.context_length) || 0;
          const pct = Math.min(Math.max(this.plugin.settings.contextWindowPercentage || 100, 1), 100);
          softLimit = maxContext ? Math.floor(maxContext * (pct / 100)) : 0;
        } catch (error) {
          console.warn("Failed to get model context length:", error);
        }
        const isOverLimit = softLimit > 0 && tokens > softLimit;
        const displayText = this.generateDisplayText(tokens, softLimit, maxContext);
        this.baselineTokens = tokens;
        this.baselineInputTokens = inputTokens;
        this.baselineSoftLimit = softLimit;
        this.baselineMaxContext = maxContext;
        this.hasBaseline = true;
        return {
          tokens,
          maxContext,
          softLimit,
          isOverLimit,
          displayText
        };
      } catch (error) {
        console.warn("Error counting tokens:", error);
        return {
          tokens: 0,
          isOverLimit: false,
          displayText: "Error calculating tokens"
        };
      }
    };
    /**
     * Produce a detailed token breakdown for modal display
     */
    this.getDetailedBreakdown = async () => {
      const modelId = this.safeGetSelectedModelId();
      const sysPrompt = this.safeGetSystemPrompt();
      const { requestBody } = await this.aiService.buildRequestPreview({
        messages: this.safeGetMessages(),
        model: modelId,
        contextFiles: this.safeGetContextFiles(),
        systemPromptType: sysPrompt.type,
        systemPromptPath: sysPrompt.path,
        agentMode: this.agentMode,
        toolCallManager: this.toolCallManager,
        plugins: this.webSearchEnabled ? [{ id: WEB_SEARCH_CONFIG.PLUGIN_ID, max_results: WEB_SEARCH_CONFIG.MAX_RESULTS }] : void 0
      });
      const items = [];
      let total = 0;
      let baseline = 0;
      try {
        baseline = countRequestTokens(requestBody);
      } catch (e) {
      }
      let systemTokens = 0;
      if (typeof requestBody.system === "string") {
        systemTokens = countTextTokens(requestBody.system);
        if (systemTokens > 0) items.push({ label: "System prompt", tokens: systemTokens });
      }
      let uaContentTokens = 0;
      let toolCallsTokens = 0;
      let toolResultsTokens = 0;
      const messages = Array.isArray(requestBody.messages) ? requestBody.messages : [];
      if (messages.length > 0) {
        for (const m of messages) {
          const role = m == null ? void 0 : m.role;
          const content = m == null ? void 0 : m.content;
          if (role === "user" || role === "assistant") {
            try {
              const text = typeof content === "string" ? content : JSON.stringify(content != null ? content : "");
              uaContentTokens += countTextTokens(text);
            } catch (e) {
            }
          }
          if (Array.isArray(m.tool_calls)) {
            try {
              for (const tc of m.tool_calls) {
                toolCallsTokens += countToolCallPayloadTokens(tc);
              }
            } catch (e) {
            }
          }
          if (role === "tool" && typeof content === "string") {
            try {
              toolResultsTokens += countTextTokens(content);
            } catch (e) {
            }
          }
        }
      }
      let toolSchemasTokens = 0;
      if (Array.isArray(requestBody.tools) && requestBody.tools.length > 0) {
        try {
          const brief = JSON.stringify(requestBody.tools.slice(0, 10));
          toolSchemasTokens = Math.min(countTextTokens(brief), 2e3);
        } catch (e) {
        }
      }
      let webSearchTokens = 0;
      if (requestBody.web_search_options) {
        try {
          webSearchTokens = countTextTokens(JSON.stringify(requestBody.web_search_options));
        } catch (e) {
        }
      }
      let pluginsTokens = 0;
      if (Array.isArray(requestBody.plugins) && requestBody.plugins.length > 0) {
        try {
          pluginsTokens = countTextTokens(JSON.stringify(requestBody.plugins));
        } catch (e) {
        }
      }
      let inputTokens = 0;
      try {
        const inputText = this.getInputText();
        if (inputText && inputText.length > 0) inputTokens = countTextTokens(inputText);
      } catch (e) {
      }
      if (uaContentTokens > 0) items.push({ label: "User + assistant content", tokens: uaContentTokens });
      if (toolCallsTokens > 0) items.push({ label: "Tool call requests", tokens: toolCallsTokens });
      if (toolResultsTokens > 0) items.push({ label: "Tool results", tokens: toolResultsTokens });
      if (toolSchemasTokens > 0) items.push({ label: "Tool schemas", tokens: toolSchemasTokens, detail: `${(requestBody.tools || []).length} tools` });
      if (webSearchTokens > 0) items.push({ label: "Web search options", tokens: webSearchTokens });
      if (pluginsTokens > 0) items.push({ label: "Plugins", tokens: pluginsTokens, detail: `${(requestBody.plugins || []).length} plugins` });
      if (inputTokens > 0) items.push({ label: "Current input", tokens: inputTokens });
      const sumWithoutOverhead = systemTokens + uaContentTokens + toolCallsTokens + toolResultsTokens + toolSchemasTokens + webSearchTokens + pluginsTokens;
      const protocolOverhead = Math.max(0, baseline - sumWithoutOverhead);
      if (protocolOverhead > 0) items.push({ label: "Protocol overhead", tokens: protocolOverhead, detail: "roles, separators, framing" });
      total = sumWithoutOverhead + protocolOverhead + inputTokens;
      let maxContext = 0;
      let softLimit = 0;
      try {
        const model = await this.plugin.modelService.getModelById(modelId);
        maxContext = (model == null ? void 0 : model.context_length) || 0;
        const pct = Math.min(Math.max(this.plugin.settings.contextWindowPercentage || 100, 1), 100);
        softLimit = maxContext ? Math.floor(maxContext * (pct / 100)) : 0;
      } catch (e) {
      }
      return { total, maxContext, softLimit, items };
    };
    /**
     * Force refresh the token count
     */
    this.forceRefresh = async () => {
      this.clearCache();
      return this.countTokens();
    };
    /**
     * Return a fast, synchronous estimate suitable for immediate UI updates.
     * This avoids any file I/O and uses cached values when available.
     */
    this.liveEstimate = () => {
      try {
        if (this.hasBaseline) {
          let currentInputTokens = 0;
          try {
            const inputText2 = this.getInputText();
            if (inputText2 && inputText2.length > 0) currentInputTokens = countTextTokens(inputText2);
          } catch (e) {
          }
          const adjusted = Math.max(0, this.baselineTokens - this.baselineInputTokens + currentInputTokens);
          return {
            tokens: adjusted,
            maxContext: this.baselineMaxContext,
            softLimit: this.baselineSoftLimit,
            isOverLimit: this.baselineSoftLimit > 0 && adjusted > this.baselineSoftLimit,
            displayText: this.generateDisplayText(adjusted, this.baselineSoftLimit, this.baselineMaxContext)
          };
        }
        const messages = this.safeGetMessages();
        let total = 0;
        try {
          total += countMessagesTokens(messages);
        } catch (e) {
        }
        const systemPrompt = this.safeGetSystemPrompt();
        if ((systemPrompt == null ? void 0 : systemPrompt.type) && (systemPrompt == null ? void 0 : systemPrompt.path)) {
          const systemKey = `system:${systemPrompt.type}:${systemPrompt.path}`;
          const cachedSystem = this.contextTokenCache.get(systemKey);
          if (typeof cachedSystem === "number") total += cachedSystem;
        }
        const contextFiles = this.safeGetContextFiles();
        for (const filePath of contextFiles) {
          const contextKey = `context:${filePath}`;
          const cached = this.contextTokenCache.get(contextKey);
          if (typeof cached === "number") total += cached;
        }
        const inputText = this.getInputText();
        if (inputText && inputText.length > 0) {
          total += countTextTokens(inputText);
        }
        return {
          tokens: total,
          isOverLimit: false,
          displayText: this.generateDisplayText(total, 0, 0)
        };
      } catch (e) {
        return {
          tokens: 0,
          isOverLimit: false,
          displayText: ""
        };
      }
    };
    this.plugin = options.plugin;
    this.aiService = options.aiService;
    this.getMessages = options.getMessages;
    this.getSelectedModelId = options.getSelectedModelId;
    this.getContextFiles = options.getContextFiles;
    this.getSystemPrompt = options.getSystemPrompt;
    this.getInputText = options.getInputText || (() => "");
    this.webSearchEnabled = options.webSearchEnabled || false;
    this.agentMode = options.agentMode || false;
    this.toolCallManager = options.toolCallManager;
  }
  /**
   * Safe accessors to guard against transient null state during view teardown
   */
  safeGetContextFiles() {
    var _a;
    try {
      const cf = (_a = this.getContextFiles) == null ? void 0 : _a.call(this);
      if (!cf) return /* @__PURE__ */ new Set();
      if (cf instanceof Set) return cf;
      if (Array.isArray(cf)) return new Set(cf);
      try {
        return new Set(Array.from(cf));
      } catch (e) {
        return /* @__PURE__ */ new Set();
      }
    } catch (e) {
      return /* @__PURE__ */ new Set();
    }
  }
  safeGetSystemPrompt() {
    var _a;
    try {
      return ((_a = this.getSystemPrompt) == null ? void 0 : _a.call(this)) || {};
    } catch (e) {
      return {};
    }
  }
  safeGetMessages() {
    var _a;
    try {
      const msgs = (_a = this.getMessages) == null ? void 0 : _a.call(this);
      return Array.isArray(msgs) ? msgs : [];
    } catch (e) {
      return [];
    }
  }
  safeGetSelectedModelId() {
    var _a, _b, _c;
    try {
      return ((_a = this.getSelectedModelId) == null ? void 0 : _a.call(this)) || ((_b = this.plugin.settings) == null ? void 0 : _b.selectedModelId) || "";
    } catch (e) {
      return ((_c = this.plugin.settings) == null ? void 0 : _c.selectedModelId) || "";
    }
  }
  /**
   * Update the web search enabled state
   */
  setWebSearchEnabled(enabled) {
    this.webSearchEnabled = enabled;
    this.clearCache();
  }
  /**
   * Update the agent mode state
   */
  setAgentMode(enabled) {
    this.agentMode = enabled;
    this.clearCache();
  }
  /**
   * Clear the token count cache
   */
  clearCache() {
    this.messageTokenCache.clear();
    this.contextTokenCache.clear();
    this.hasBaseline = false;
    this.baselineTokens = 0;
    this.baselineInputTokens = 0;
    this.baselineSoftLimit = 0;
    this.baselineMaxContext = 0;
  }
  /**
   * Maintain cache size by removing oldest entries
   */
  maintainCacheSize() {
    if (this.messageTokenCache.size > this.maxCacheSize) {
      const entries = Array.from(this.messageTokenCache.entries());
      const toRemove = entries.slice(0, entries.length - this.maxCacheSize);
      toRemove.forEach(([key]) => this.messageTokenCache.delete(key));
    }
    if (this.contextTokenCache.size > this.maxCacheSize) {
      const entries = Array.from(this.contextTokenCache.entries());
      const toRemove = entries.slice(0, entries.length - this.maxCacheSize);
      toRemove.forEach(([key]) => this.contextTokenCache.delete(key));
    }
  }
  /**
   * Calculate tokens efficiently using optimized caching strategy
   */
  async calculateTokensEfficiently() {
    let totalTokens = 0;
    const messages = this.safeGetMessages();
    for (const message of messages) {
      const messageKey = this.getMessageCacheKey(message);
      let messageTokens = this.messageTokenCache.get(messageKey);
      if (messageTokens === void 0) {
        messageTokens = countMessageTokens(message);
        this.messageTokenCache.set(messageKey, messageTokens);
      }
      totalTokens += messageTokens || 0;
    }
    const systemPrompt = this.safeGetSystemPrompt();
    if ((systemPrompt == null ? void 0 : systemPrompt.type) && (systemPrompt == null ? void 0 : systemPrompt.path)) {
      const systemKey = `system:${systemPrompt.type}:${systemPrompt.path}`;
      let systemTokens = this.contextTokenCache.get(systemKey);
      if (systemTokens === void 0) {
        try {
          const file = this.plugin.app.vault.getFileByPath(systemPrompt.path);
          if (file) {
            const content = await this.plugin.app.vault.cachedRead(file);
            systemTokens = countTextTokens(content);
          } else {
            systemTokens = 0;
          }
          this.contextTokenCache.set(systemKey, systemTokens);
        } catch (error) {
          systemTokens = 0;
        }
      }
      totalTokens += systemTokens || 0;
    }
    const contextFiles = this.safeGetContextFiles();
    for (const filePath of contextFiles) {
      const contextKey = `context:${filePath}`;
      let contextTokens = this.contextTokenCache.get(contextKey);
      if (contextTokens === void 0) {
        try {
          const file = this.plugin.app.vault.getFileByPath(filePath);
          if (file) {
            const fileContent = await this.plugin.app.vault.cachedRead(file);
            contextTokens = countTextTokens(fileContent);
            this.contextTokenCache.set(contextKey, contextTokens);
          } else {
            contextTokens = 0;
          }
        } catch (error) {
          contextTokens = 0;
        }
      }
      totalTokens += contextTokens || 0;
    }
    totalTokens += Math.max(0, messages.length - 1) * 2;
    if (this.agentMode && this.toolCallManager) {
      try {
        const tools = await this.toolCallManager.getOpenAITools();
        if (Array.isArray(tools) && tools.length > 0) {
          const brief = JSON.stringify(tools.map((t) => {
            var _a, _b;
            return {
              type: t.type,
              name: (_a = t.function) == null ? void 0 : _a.name,
              params: ((_b = t.function) == null ? void 0 : _b.parameters) ? Object.keys(t.function.parameters.properties || {}).slice(0, 10) : []
            };
          }).slice(0, 50));
          totalTokens += Math.min(countTextTokens(brief), 2e3);
        }
      } catch (e) {
        totalTokens += 300;
      }
    }
    if (this.webSearchEnabled) {
      totalTokens += 200;
    }
    const inputText = this.getInputText();
    if (inputText && inputText.length > 0) {
      totalTokens += countTextTokens(inputText);
    }
    this.maintainCacheSize();
    return totalTokens;
  }
  /**
   * Generate cache key for a message
   */
  getMessageCacheKey(message) {
    const contentKey = typeof message.content === "string" ? message.content : JSON.stringify(message.content);
    return `${message.role}:${contentKey.slice(0, 100)}:${contentKey.length}`;
  }
  /**
   * Get default token count for immediate display
   */
  async getDefaultTokenCount() {
    let maxContext = 0;
    let softLimit = 0;
    try {
      const modelId = this.safeGetSelectedModelId();
      const model = await this.plugin.modelService.getModelById(modelId);
      maxContext = (model == null ? void 0 : model.context_length) || 0;
      const pct = Math.min(Math.max(this.plugin.settings.contextWindowPercentage || 100, 1), 100);
      softLimit = maxContext ? Math.floor(maxContext * (pct / 100)) : 0;
    } catch (error) {
    }
    return {
      tokens: 0,
      maxContext,
      softLimit,
      isOverLimit: false,
      displayText: this.generateDisplayText(0, softLimit, maxContext)
    };
  }
  /**
   * Generate display text for the token counter
   */
  generateDisplayText(tokens, softLimit, maxContext) {
    const limit = softLimit || maxContext || 0;
    const pct = limit > 0 ? Math.min(999, Math.max(0, Math.round(tokens / limit * 100))) : 0;
    return `${pct}%`;
  }
  // Backward compatibility for any callers still using quickEstimate
  quickEstimate() {
    return this.liveEstimate();
  }
};

// src/views/chatview/TokenCounterUI.ts
var import_obsidian85 = require("obsidian");

// src/modals/TokenDetailsModal.ts
init_StandardModal();
var TokenDetailsModal = class extends StandardModal {
  constructor(app, counter) {
    super(app);
    this.counter = counter;
    this.setSize("medium");
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Context Usage", "How much of your conversation memory is being used");
    const breakdown = await this.counter.getDetailedBreakdown();
    const overview = this.contentEl.createDiv({ cls: "ss-modal__section" });
    overview.createEl("h3", { text: "Memory Usage", cls: "ss-modal__section-title" });
    const explainer = overview.createDiv({ cls: "ss-modal__text--muted" });
    explainer.innerHTML = `
      <p style="margin-bottom: 8px;">Think of this like your phone's storage - the AI has limited memory space for your conversation.</p>
      <p>The percentage shows how much memory you're currently using. We keep some space free so the AI can respond properly.</p>
    `;
    const summaryTable = overview.createEl("table", { cls: "ss-modal__table" });
    const stBody = summaryTable.createEl("tbody");
    const limit = breakdown.softLimit || breakdown.maxContext || 0;
    const pct = limit ? Math.round(breakdown.total / limit * 100) : 0;
    const usageRow = stBody.createEl("tr");
    usageRow.createEl("td", { text: "Memory used", cls: "ss-modal__table-key" });
    const usageCell = usageRow.createEl("td", { cls: "ss-modal__table-value" });
    const percentSpan = usageCell.createSpan({
      text: `${Math.min(999, pct)}%`,
      cls: pct > 80 ? "ss-token-high" : pct > 60 ? "ss-token-medium" : "ss-token-low"
    });
    const memoryBar = usageCell.createDiv({ cls: "ss-memory-bar" });
    const memoryFill = memoryBar.createDiv({
      cls: "ss-memory-fill",
      attr: { style: `width: ${Math.min(100, pct)}%` }
    });
    if (breakdown.softLimit || breakdown.maxContext) {
      const spaceRow = stBody.createEl("tr");
      spaceRow.createEl("td", { text: "Why keep space free?", cls: "ss-modal__table-key" });
      spaceRow.createEl("td", {
        text: "The AI needs room to think and respond. Without free space, conversations can get cut off mid-sentence.",
        cls: "ss-modal__table-value"
      });
    }
    const details = this.contentEl.createDiv({ cls: "ss-modal__section" });
    details.createEl("h3", { text: "What's Using Memory", cls: "ss-modal__section-title" });
    const detailsExplainer = details.createDiv({ cls: "ss-modal__text--muted" });
    detailsExplainer.textContent = "Here's what's taking up space in your conversation memory:";
    const table = details.createEl("table", { cls: "ss-modal__table" });
    const tbody = table.createEl("tbody");
    breakdown.items.forEach((item) => {
      const row = tbody.createEl("tr");
      const key = row.createEl("td", { cls: "ss-modal__table-key" });
      const friendlyLabel = this.getFriendlyLabel(item.label);
      key.createEl("strong", { text: friendlyLabel });
      const val = row.createEl("td", { cls: "ss-modal__table-value" });
      const itemPct = breakdown.total > 0 ? Math.round(item.tokens / breakdown.total * 100) : 0;
      val.createSpan({ text: `${itemPct}%` });
      val.createSpan({ text: ` (${item.tokens.toLocaleString()})`, cls: "ss-modal__text--muted" });
      if (item.detail) {
        val.createDiv({ text: this.getFriendlyDetail(item.detail), cls: "ss-modal__text--muted ss-modal__detail" });
      }
    });
    this.addActionButton("Refresh", async () => {
      const fresh = await this.counter.getDetailedBreakdown();
      this.renderFresh(fresh);
    }, false, "refresh-ccw");
    this.addActionButton("Close", () => this.close(), true);
  }
  /**
   * Convert technical labels to user-friendly ones
   */
  getFriendlyLabel(label) {
    const labelMap = {
      "System prompt": "AI instructions",
      "User + assistant content": "Your messages & AI replies",
      "Tool call requests": "AI tool usage requests",
      "Tool results": "Results from AI tools",
      "Tool schemas": "Available AI tools",
      "Web search options": "Web search settings",
      "Plugins": "Active plugins",
      "Current input": "Your current message",
      "Protocol overhead": "System formatting"
    };
    return labelMap[label] || label;
  }
  /**
   * Convert technical details to user-friendly ones
   */
  getFriendlyDetail(detail) {
    if (detail.includes("tools")) {
      return detail.replace("tools", "available functions");
    }
    if (detail.includes("plugins")) {
      return detail.replace("plugins", "active features");
    }
    if (detail === "roles, separators, framing") {
      return "formatting that helps the AI understand the conversation structure";
    }
    return detail;
  }
  renderFresh(breakdown) {
    this.contentEl.empty();
    const overview = this.contentEl.createDiv({ cls: "ss-modal__section" });
    overview.createEl("h3", { text: "Memory Usage (Updated)", cls: "ss-modal__section-title" });
    const explainer = overview.createDiv({ cls: "ss-modal__text--muted" });
    explainer.innerHTML = `
      <p style="margin-bottom: 8px;">Think of this like your phone's storage - the AI has limited memory space for your conversation.</p>
      <p>The percentage shows how much memory you're currently using. We keep some space free so the AI can respond properly.</p>
    `;
    const summaryTable = overview.createEl("table", { cls: "ss-modal__table" });
    const stBody = summaryTable.createEl("tbody");
    const limit = breakdown.softLimit || breakdown.maxContext || 0;
    const pct = limit ? Math.round(breakdown.total / limit * 100) : 0;
    const usageRow = stBody.createEl("tr");
    usageRow.createEl("td", { text: "Memory used", cls: "ss-modal__table-key" });
    const usageCell = usageRow.createEl("td", { cls: "ss-modal__table-value" });
    const percentSpan = usageCell.createSpan({
      text: `${Math.min(999, pct)}%`,
      cls: pct > 80 ? "ss-token-high" : pct > 60 ? "ss-token-medium" : "ss-token-low"
    });
    const memoryBar = usageCell.createDiv({ cls: "ss-memory-bar" });
    const memoryFill = memoryBar.createDiv({
      cls: "ss-memory-fill",
      attr: { style: `width: ${Math.min(100, pct)}%` }
    });
    const totalRow = stBody.createEl("tr");
    totalRow.createEl("td", { text: "Total memory units", cls: "ss-modal__table-key" });
    totalRow.createEl("td", { text: breakdown.total.toLocaleString(), cls: "ss-modal__table-value" });
    if (breakdown.softLimit || breakdown.maxContext) {
      const limitRow = stBody.createEl("tr");
      limitRow.createEl("td", { text: "Memory limit", cls: "ss-modal__table-key" });
      limitRow.createEl("td", { text: `${limit.toLocaleString()} units`, cls: "ss-modal__table-value" });
    }
    const details = this.contentEl.createDiv({ cls: "ss-modal__section" });
    details.createEl("h3", { text: "What's Using Memory", cls: "ss-modal__section-title" });
    const detailsExplainer = details.createDiv({ cls: "ss-modal__text--muted" });
    detailsExplainer.textContent = "Here's what's taking up space in your conversation memory:";
    const table = details.createEl("table", { cls: "ss-modal__table" });
    const tbody = table.createEl("tbody");
    breakdown.items.forEach((item) => {
      const row = tbody.createEl("tr");
      const key = row.createEl("td", { cls: "ss-modal__table-key" });
      const friendlyLabel = this.getFriendlyLabel(item.label);
      key.createEl("strong", { text: friendlyLabel });
      const val = row.createEl("td", { cls: "ss-modal__table-value" });
      const itemPct = breakdown.total > 0 ? Math.round(item.tokens / breakdown.total * 100) : 0;
      val.createSpan({ text: `${itemPct}%` });
      val.createSpan({ text: ` (${item.tokens.toLocaleString()})`, cls: "ss-modal__text--muted" });
      if (item.detail) {
        val.createDiv({ text: this.getFriendlyDetail(item.detail), cls: "ss-modal__text--muted ss-modal__detail" });
      }
    });
  }
};

// src/views/chatview/TokenCounterUI.ts
var TokenCounterUI = class extends import_obsidian85.Component {
  constructor(config) {
    super();
    this.config = config;
    this.counterEl = null;
    this.hostEl = null;
    this.tokenCounterService = null;
    this.isVisible = true;
    this.lastTokenCount = 0;
    this.updateSeq = 0;
    this.lastCountAt = 0;
    this.trailingTimer = null;
  }
  /**
   * Set the token counter service
   */
  setTokenCounterService(service) {
    this.tokenCounterService = service;
  }
  /**
   * Create and attach the token counter element
   */
  createTokenCounter() {
    if (!this.counterEl) {
      const container = this.config.container;
      const isWrapper = container.classList.contains("systemsculpt-chat-input-wrap");
      const host = (isWrapper ? container : container.querySelector(".systemsculpt-chat-input-wrap")) || container;
      this.hostEl = host;
      if (isWrapper) this.hostEl.classList.add("has-token-counter");
      this.counterEl = this.hostEl.createEl("button", { cls: "ss-button mod-small systemsculpt-token-counter", text: "" });
      this.counterEl.setAttribute("aria-live", "polite");
      this.counterEl.setAttribute("aria-atomic", "true");
      this.counterEl.setAttribute("aria-label", "Context usage. Click for details.");
      this.registerDomEvent(this.counterEl, "click", () => {
        if (!this.tokenCounterService) return;
        new TokenDetailsModal(this.config.app, this.tokenCounterService).open();
      });
      this.registerDomEvent(this.counterEl, "keydown", (evt) => {
        if ((evt.key === "Enter" || evt.key === " ") && this.tokenCounterService) {
          evt.preventDefault();
          new TokenDetailsModal(this.config.app, this.tokenCounterService).open();
        }
      });
      if (this.config.onUpdateRequest) {
        this.config.registerDomEvent(
          host,
          "systemsculpt:input-token-update-request",
          () => this.config.onUpdateRequest()
        );
      }
    }
    return this.counterEl;
  }
  /**
   * Update the token counter display
   */
  async updateTokenCounter() {
    if (!this.counterEl || !this.tokenCounterService) {
      return;
    }
    try {
      this.counterEl.classList.add("updating");
      this.counterEl.setAttribute("aria-busy", "true");
      const seq = ++this.updateSeq;
      const estimate = this.tokenCounterService.quickEstimate();
      if (estimate && estimate.displayText) {
        this.lastTokenCount = estimate.tokens;
        this.renderTokenCount(estimate);
      }
      const now = Date.now();
      const elapsed = now - this.lastCountAt;
      const throttleMs = 200;
      if (elapsed < throttleMs) {
        if (this.trailingTimer) {
          window.clearTimeout(this.trailingTimer);
          this.trailingTimer = null;
        }
        this.trailingTimer = window.setTimeout(async () => {
          const trailingSeq = ++this.updateSeq;
          this.lastCountAt = Date.now();
          try {
            const result2 = await this.tokenCounterService.countTokens();
            if (trailingSeq !== this.updateSeq) return;
            this.lastTokenCount = result2.tokens;
            this.renderTokenCount(result2);
          } catch (e) {
            console.warn("Error in trailing token count:", e);
            this.renderError("Unable to calculate context usage");
          } finally {
            if (this.counterEl) {
              this.counterEl.classList.remove("updating");
              this.counterEl.removeAttribute("aria-busy");
            }
          }
        }, throttleMs - elapsed);
        return;
      }
      this.lastCountAt = now;
      const result = await this.tokenCounterService.countTokens();
      if (seq !== this.updateSeq) return;
      this.lastTokenCount = result.tokens;
      this.renderTokenCount(result);
    } catch (error) {
      console.warn("Error updating token counter:", error);
      this.renderError("Unable to calculate context usage");
    } finally {
      if (this.counterEl) {
        this.counterEl.classList.remove("updating");
        this.counterEl.removeAttribute("aria-busy");
      }
    }
  }
  /**
   * Force refresh the token counter
   */
  async forceRefresh() {
    if (!this.counterEl || !this.tokenCounterService) {
      return;
    }
    try {
      const result = await this.tokenCounterService.forceRefresh();
      this.lastTokenCount = result.tokens;
      this.renderTokenCount(result);
    } catch (error) {
      console.warn("Error force refreshing token counter:", error);
      this.renderError("Unable to calculate context usage");
    }
  }
  /**
   * Render token count result
   */
  renderTokenCount(result) {
    if (!this.counterEl) return;
    this.counterEl.classList.remove("over-limit", "updating", "error");
    this.counterEl.textContent = result.displayText;
    this.counterEl.classList.toggle("over-limit", result.isOverLimit);
    this.counterEl.setAttribute("aria-label", `Context usage: ${result.displayText}`);
    if (result.isOverLimit) {
      this.counterEl.setAttribute("aria-description", "Context usage exceeds your configured limit");
    } else {
      this.counterEl.removeAttribute("aria-description");
    }
  }
  /**
   * Render error state
   */
  renderError(message) {
    if (!this.counterEl) return;
    this.counterEl.classList.remove("over-limit", "updating", "error");
    this.counterEl.textContent = message;
    this.counterEl.classList.add("error");
    this.counterEl.setAttribute("aria-label", message);
  }
  /**
   * Show the token counter
   */
  show() {
    if (this.counterEl) {
      this.counterEl.style.display = "block";
      this.isVisible = true;
    }
  }
  /**
   * Hide the token counter
   */
  hide() {
    if (this.counterEl) {
      this.counterEl.style.display = "none";
      this.isVisible = false;
    }
  }
  /**
   * Toggle visibility of the token counter
   */
  toggle() {
    if (this.isVisible) {
      this.hide();
    } else {
      this.show();
    }
  }
  /**
   * Get the current visibility state
   */
  isCounterVisible() {
    return this.isVisible;
  }
  /**
   * Get the token counter element
   */
  getElement() {
    return this.counterEl;
  }
  /**
   * Get the last known token count
   */
  getLastTokenCount() {
    return this.lastTokenCount;
  }
  /**
   * Clean up resources
   */
  onunload() {
    if (this.trailingTimer) {
      window.clearTimeout(this.trailingTimer);
      this.trailingTimer = null;
    }
    if (this.counterEl) {
      this.counterEl.remove();
      this.counterEl = null;
    }
    if (this.hostEl) {
      this.hostEl.classList.remove("has-token-counter");
      this.hostEl = null;
    }
    super.onunload();
  }
};

// src/views/chatview/InputHandler.ts
init_errorLogger();
var InputHandler = class extends import_obsidian86.Component {
  constructor(options) {
    super();
    this.tokenCounterService = null;
    this.tokenCounterUI = null;
    this.isGenerating = false;
    this.renderTimeout = null;
    this.tokenUpdateTimeout = null;
    this.recorderVisualizer = null;
    this.isRecording = false;
    this.abortController = null;
    this.stopButton = null;
    this.webSearchEnabled = false;
    this.pendingLargeTextContent = null;
    this.toolCallEventUnsubscribers = [];
    this.continuedMessageIds = /* @__PURE__ */ new Set();
    this.continuationCheckInProgress = /* @__PURE__ */ new Set();
    // Track tool call patterns to detect actual loops (not arbitrary limits)
    this.recentToolCallPatterns = /* @__PURE__ */ new Map();
    this.pendingContinuations = /* @__PURE__ */ new Set();
    this.liveRegionEl = null;
    /* ------------------------------------------------------------------
     * Batching of tool-call state-changed events to avoid excessive DOM
     * re-renders when many events fire in rapid succession.
     * ------------------------------------------------------------------ */
    this.pendingToolCallUpdates = /* @__PURE__ */ new Set();
    this.scheduledToolCallUpdateFrame = null;
    this.app = options.app;
    this.container = options.container;
    this.aiService = options.aiService;
    this.getMessages = options.getMessages;
    this.getSelectedModelId = options.getSelectedModelId;
    this.getContextFiles = options.getContextFiles;
    this.getSystemPrompt = options.getSystemPrompt;
    this.chatContainer = options.chatContainer;
    this.scrollManager = options.scrollManager;
    this.messageRenderer = options.messageRenderer;
    this.onMessageSubmit = options.onMessageSubmit;
    this.onAssistantResponse = options.onAssistantResponse;
    this.onContextFileAdd = options.onContextFileAdd;
    this.addMessageToHistory = options.addMessageToHistory;
    this.onError = options.onError;
    this.onAddContextFile = options.onAddContextFile;
    this.onEditSystemPrompt = options.onEditSystemPrompt;
    this.plugin = options.plugin;
    this.getValue = () => {
      var _a, _b;
      return (_b = (_a = this.input) == null ? void 0 : _a.value) != null ? _b : "";
    };
    this.setValue = (text) => {
      if (this.input) {
        this.input.value = text;
        this.adjustInputHeight();
      }
    };
    this.getChatMarkdown = options.getChatMarkdown;
    this.getChatTitle = options.getChatTitle;
    this.addFileToContext = options.addFileToContext;
    this.chatStorage = options.chatStorage;
    this.getChatId = options.getChatId;
    this.toolCallManager = options.toolCallManager;
    this.chatView = options.chatView;
    this.registerDomEvent(this.chatContainer, "tool-approval", (event) => {
      var _a, _b, _c;
      const customEvent = event;
      const { toolCallId, approved } = customEvent.detail;
      const toolCall = (_a = this.toolCallManager) == null ? void 0 : _a.getToolCall(toolCallId);
      if (approved) {
        (_b = this.toolCallManager) == null ? void 0 : _b.approveToolCall(toolCallId);
      } else {
        (_c = this.toolCallManager) == null ? void 0 : _c.denyToolCall(toolCallId);
      }
    });
    this.recorderService = RecorderService.getInstance(this.app, this.plugin, {
      isInChat: true,
      onTranscriptionComplete: (text) => {
        this.insertTextAtCursor(text);
        if (this.plugin.settings.autoSubmitAfterTranscription) {
          setTimeout(() => {
            this.handleSendMessage();
          }, 100);
        }
      }
    });
    const originalMessageSubmit = options.onMessageSubmit;
    this.onMessageSubmit = async (message) => {
      await originalMessageSubmit(message);
      try {
        this.scrollManager.requestStickToBottom("user-message", { immediate: true });
      } catch (e) {
      }
    };
    const originalAssistantResponse = options.onAssistantResponse;
    this.onAssistantResponse = async (message) => {
      var _a;
      await originalAssistantResponse(message);
      const currentMessageEl = this.chatContainer.querySelector(`.systemsculpt-message[data-message-id="${message.message_id}"]`);
      if (currentMessageEl) {
        try {
          let contentEl = currentMessageEl.querySelector(".systemsculpt-message-content");
          if (!contentEl) {
            contentEl = currentMessageEl.createDiv({ cls: "systemsculpt-message-content" });
          }
          const partList = this.messageRenderer.normalizeMessageToParts(message);
          this.messageRenderer.renderUnifiedMessageParts(currentMessageEl, partList.parts, false);
          if (!currentMessageEl.querySelector(".systemsculpt-message-toolbar")) {
            this.messageRenderer.addMessageButtonToolbar(
              currentMessageEl,
              typeof message.content === "string" ? message.content : JSON.stringify((_a = message.content) != null ? _a : ""),
              message.role,
              message.message_id
            );
          }
          this.updateLiveTokenCounter();
          return;
        } catch (e) {
        }
      }
      await messageHandling.addMessage(this.chatView, message.role, message.content, message.message_id, message);
      this.updateLiveTokenCounter();
    };
    const originalEditSystemPrompt = options.onEditSystemPrompt;
    this.onEditSystemPrompt = async () => {
      var _a;
      try {
        await originalEditSystemPrompt();
      } finally {
        await ((_a = this.tokenCounterService) == null ? void 0 : _a.forceRefresh());
        this.updateLiveTokenCounter();
      }
    };
    this.setupInput();
    this.initializeTokenCounter();
    this.initializeSlashCommands();
    this.initializeAtMentionMenu();
    this.streamingController = new StreamingController({
      toolCallManager: this.toolCallManager,
      scrollManager: this.scrollManager,
      messageRenderer: this.messageRenderer,
      saveChat: this.saveChatImmediate.bind(this),
      autosaveDebounceMs: 600,
      generateMessageId: this.generateMessageId.bind(this),
      extractAnnotations: this.extractAnnotationsFromResponse.bind(this),
      showStreamingStatus: this.showStreamingStatus.bind(this),
      hideStreamingStatus: this.hideStreamingStatus.bind(this),
      updateStreamingStatus: this.updateStreamingStatus.bind(this),
      toggleStopButton: this.toggleStopButton.bind(this),
      // Use centralized policy on ToolCallManager
      onAssistantResponse: this.onAssistantResponse,
      onError: this.onError,
      setStreamingFootnote: this.setStreamingFootnote.bind(this),
      clearStreamingFootnote: this.clearStreamingFootnote.bind(this)
    });
    this.addChild(this.streamingController);
    this.orchestrator = new ChatTurnOrchestrator({
      app: this.app,
      aiService: this.aiService,
      streamingController: this.streamingController,
      toolCallManager: this.toolCallManager,
      messageRenderer: this.messageRenderer,
      getMessages: this.getMessages,
      getSelectedModelId: this.getSelectedModelId,
      getSystemPrompt: this.getSystemPrompt,
      getContextFilesWithVaultStructure: () => this.chatView.contextManager.getContextFilesWithVaultStructure(),
      agentMode: () => {
        var _a;
        return ((_a = this.chatView) == null ? void 0 : _a.agentMode) || false;
      },
      webSearchEnabled: () => this.webSearchEnabled,
      createAssistantMessageContainer: (breakGroup) => this.createAssistantMessageContainer(breakGroup),
      generateMessageId: this.generateMessageId.bind(this),
      onAssistantResponse: this.onAssistantResponse,
      onError: this.onError
    });
  }
  /**
   * Helper method to properly set generation state and sync with scroll manager
   */
  setGeneratingState(generating) {
    this.isGenerating = generating;
    this.scrollManager.setGenerating(generating);
    this.updateGeneratingState();
  }
  setupInput() {
    if (!this.liveRegionEl) {
      this.liveRegionEl = this.container.createEl("div", {
        cls: "systemsculpt-visually-hidden",
        attr: { "aria-live": "polite", "aria-atomic": "true" }
      });
    }
    this.inputContainer = this.container.createEl("div", { cls: "systemsculpt-input-container" });
    this.buttonGrid = this.inputContainer.createEl("div", { cls: "systemsculpt-button-grid" });
    const primary = createPrimaryButtons(this.buttonGrid, {
      onEditSystemPrompt: this.onEditSystemPrompt,
      onAddContextFile: this.onAddContextFile,
      getAgentMode: () => {
        var _a;
        return ((_a = this.chatView) == null ? void 0 : _a.agentMode) || false;
      },
      enableAgentModeForChat: () => this.enableAgentModeForChat(),
      disableAgentModeForChat: () => this.disableAgentModeForChat(),
      updateMcpToolsButtonState: () => this.updateMcpToolsButtonState(),
      isMcpEnabled: () => !!this.plugin.settings.mcpEnabled,
      isWebSearchAllowed: () => {
        const isNativeProvider = this.plugin.settings.activeProvider.type === "native";
        const currentProvider = this.plugin.settings.customProviders.find((p) => p.id === this.plugin.settings.activeProvider.id);
        const isOpenRouter = currentProvider == null ? void 0 : currentProvider.endpoint.includes("openrouter.ai");
        return isNativeProvider || !!isOpenRouter;
      },
      getWebSearchEnabled: () => this.webSearchEnabled,
      toggleWebSearchEnabled: () => {
        var _a;
        this.webSearchEnabled = !this.webSearchEnabled;
        (_a = this.tokenCounterService) == null ? void 0 : _a.setWebSearchEnabled(this.webSearchEnabled);
        this.updateLiveTokenCounter();
      },
      updateWebSearchButtonState: () => this.updateWebSearchButtonState(),
      hasProLicense: () => {
        var _a;
        return !!(((_a = this.plugin.settings.licenseKey) == null ? void 0 : _a.trim()) && this.plugin.settings.licenseValid);
      },
      handleMicClick: () => this.handleMicClick()
    });
    this.settingsButton = primary.settingsButton;
    this.attachButton = primary.attachButton;
    this.mcpToolsButton = primary.mcpToolsButton;
    this.webSearchButton = primary.webSearchButton;
    this.micButton = primary.micButton;
    this.updateMcpToolsButtonState();
    this.updateWebSearchButtonState();
    const actions = createActionButtons(this.buttonGrid, {
      onSend: () => this.handleSendMessage(),
      onStop: () => this.handleStopGeneration()
    });
    this.sendButton = actions.sendButton;
    this.stopButton = actions.stopButton;
    this.input = createChatTextArea(this.inputContainer, {
      registerDomEvent: this.registerDomEvent.bind(this),
      onKeyDown: (e) => this.handleKeyDown(e),
      onInput: () => this.handleInputChange(),
      onPaste: (e) => this.handlePaste(e)
    });
    this.updateLiveTokenCounter();
    this.registerDomEvent(this.chatContainer, "systemsculpt-dom-content-changed", () => {
      this.updateLiveTokenCounter();
    });
    this.recorderService.onToggle((isRecording) => {
      this.isRecording = isRecording;
      if (this.micButton && this.micButton.buttonEl) {
        this.micButton.buttonEl.classList.toggle("ss-active", isRecording);
        if (isRecording) {
          this.micButton.setTooltip("Recording in progress (click to stop)");
        } else {
          this.micButton.setTooltip("Record audio message");
        }
      }
    });
    this.updateGeneratingState = () => {
      this.input.disabled = false;
      this.settingsButton.setDisabled(false);
      this.attachButton.setDisabled(false);
      this.webSearchButton.setDisabled(false);
      this.micButton.setDisabled(false);
      this.sendButton.setDisabled(this.isGenerating);
      if (this.stopButton) {
        this.stopButton.setDisabled(!this.isGenerating);
        this.stopButton.buttonEl.style.display = this.isGenerating ? "flex" : "none";
        this.sendButton.buttonEl.style.display = "flex";
      }
      this.input.placeholder = this.isGenerating ? "Type your next message while AI generates..." : "Search your vault, link notes, write ideas";
      this.input.classList.remove("disabled");
      this.scrollManager.setGenerating(this.isGenerating);
    };
  }
  initializeTokenCounter() {
    var _a, _b, _c, _d;
    this.tokenCounterService = new TokenCounterService({
      plugin: this.plugin,
      aiService: this.aiService,
      getMessages: this.getMessages,
      getSelectedModelId: this.getSelectedModelId,
      getContextFiles: this.getContextFiles,
      getSystemPrompt: this.getSystemPrompt,
      getInputText: () => {
        var _a2, _b2;
        return (_b2 = (_a2 = this.input) == null ? void 0 : _a2.value) != null ? _b2 : "";
      },
      webSearchEnabled: this.webSearchEnabled,
      agentMode: ((_a = this.chatView) == null ? void 0 : _a.agentMode) || false,
      toolCallManager: this.toolCallManager
    });
    const actionsGroupEl = this.buttonGrid.querySelector(".systemsculpt-button-group-actions");
    if (actionsGroupEl && ((_c = (_b = this.sendButton) == null ? void 0 : _b.buttonEl) == null ? void 0 : _c.parentElement)) {
      const sendContainer = this.sendButton.buttonEl.parentElement;
      this.tokenCounterUI = new TokenCounterUI({
        app: this.app,
        container: sendContainer,
        registerDomEvent: this.registerDomEvent.bind(this),
        onUpdateRequest: () => this.updateLiveTokenCounter()
      });
    } else {
      this.tokenCounterUI = new TokenCounterUI({
        app: this.app,
        container: ((_d = this.input) == null ? void 0 : _d.parentElement) || this.inputContainer,
        registerDomEvent: this.registerDomEvent.bind(this),
        onUpdateRequest: () => this.updateLiveTokenCounter()
      });
    }
    this.tokenCounterUI.setTokenCounterService(this.tokenCounterService);
    this.tokenCounterUI.createTokenCounter();
    this.addChild(this.tokenCounterUI);
    setTimeout(() => {
      this.updateLiveTokenCounter();
    }, 0);
    this.registerDomEvent(document, "systemsculpt:context-changed", () => {
      this.updateLiveTokenCounter();
    });
    this.registerEvent(this.app.workspace.on("systemsculpt:chat-message-added", (_chatId) => {
      this.updateLiveTokenCounter();
    }));
    this.registerEvent(this.app.workspace.on("systemsculpt:chat-settings-changed", (_chatId) => {
      this.updateLiveTokenCounter();
    }));
  }
  initializeSlashCommands() {
    this.slashCommandMenu = new SlashCommandMenu({
      plugin: this.plugin,
      chatView: this.chatView,
      inputElement: this.input,
      inputHandler: this,
      onClose: () => {
        this.input.focus();
      },
      onExecute: async (command) => {
        const currentValue = this.input.value;
        const slashIndex = currentValue.lastIndexOf("/");
        if (slashIndex !== -1) {
          this.input.value = currentValue.substring(0, slashIndex);
        }
        await command.execute(this.chatView);
      }
    });
    this.addChild(this.slashCommandMenu);
  }
  initializeAtMentionMenu() {
    this.atMentionMenu = new AtMentionMenu(this.chatView, this.input);
    this.addChild(this.atMentionMenu);
  }
  handleStopGeneration() {
    if (this.abortController) {
      this.abortController.abort();
      this.abortController = null;
    }
    this.setGeneratingState(false);
    this.updateGeneratingState();
  }
  /**
   * Centralized stream handling logic.
   * This function processes the stream from the AI, updates the UI,
   * handles message parts, and manages tool calls.
   *
   * NOTE: Generating state is managed by the caller (now the ChatTurnOrchestrator)
   * to avoid double-setting and phantom states.
   */
  async handleStream(stream, messageEl, messageId) {
    var _a, _b;
    const abortSignal = (_b = (_a = this.abortController) == null ? void 0 : _a.signal) != null ? _b : new AbortController().signal;
    await this.streamingController.stream(stream, messageEl, messageId, abortSignal, this.webSearchEnabled);
  }
  async handleSendMessage() {
    if (this.isGenerating) return;
    let messageText = this.input.value.trim();
    if (!messageText) return;
    if (this.pendingLargeTextContent && LargeTextHelpers.containsPlaceholder(messageText)) {
      const placeholderRegex = /\[PASTED TEXT - \d+ LINES OF TEXT\]/g;
      messageText = messageText.replace(placeholderRegex, this.pendingLargeTextContent);
      this.pendingLargeTextContent = null;
    }
    this.setGeneratingState(true);
    this.abortController = new AbortController();
    try {
      this.input.value = "";
      this.adjustInputHeight();
      const userMessage = {
        role: "user",
        content: messageText,
        message_id: this.generateMessageId()
      };
      await this.onMessageSubmit(userMessage);
      if (this.toolCallManager) {
        const pendingToolCalls = this.toolCallManager.getPendingToolCalls();
        for (const toolCall of pendingToolCalls) {
          this.toolCallManager.cancelToolCall(
            toolCall.id,
            "The user sent a follow-up message instead of approving this tool call."
          );
        }
      }
      await this.orchestrator.runTurn({
        includeContextFiles: true,
        signal: this.abortController.signal
      });
    } finally {
      this.setGeneratingState(false);
      this.abortController = null;
      this.updateGeneratingState();
      this.focus();
      await this.chatView.contextManager.validateAndCleanContextFiles();
    }
  }
  // Efficient live token counter using the new architecture
  async updateLiveTokenCounter() {
    if (!this.tokenCounterUI) return;
    if (this.tokenUpdateTimeout) {
      clearTimeout(this.tokenUpdateTimeout);
    }
    this.tokenUpdateTimeout = setTimeout(async () => {
      var _a;
      await ((_a = this.tokenCounterUI) == null ? void 0 : _a.updateTokenCounter());
    }, 30);
  }
  handleMicClick() {
    this.toggleRecording();
  }
  async toggleRecording() {
    await this.recorderService.toggleRecording();
    this.input.focus();
  }
  async handlePaste(e) {
    return handlePaste({
      app: this.app,
      plugin: this.plugin,
      addFileToContext: this.addFileToContext,
      insertTextAtCursor: (t) => this.insertTextAtCursor(t),
      getPendingLargeTextContent: () => this.pendingLargeTextContent,
      setPendingLargeTextContent: (t) => {
        this.pendingLargeTextContent = t;
      }
    }, e);
  }
  /**
   * Show warning dialog for large text pastes
   */
  async showLargeTextWarning(sizeKB, text) {
    return showLargeTextWarning({
      app: this.app,
      plugin: this.plugin,
      addFileToContext: this.addFileToContext,
      insertTextAtCursor: (t) => this.insertTextAtCursor(t),
      getPendingLargeTextContent: () => this.pendingLargeTextContent,
      setPendingLargeTextContent: (t) => {
        this.pendingLargeTextContent = t;
      }
    }, sizeKB, text);
  }
  /**
   * Handle large text paste with chunking to prevent UI freeze
   */
  async handleLargeTextPaste(text) {
    return handleLargeTextPaste({
      app: this.app,
      plugin: this.plugin,
      addFileToContext: this.addFileToContext,
      insertTextAtCursor: (t) => this.insertTextAtCursor(t),
      getPendingLargeTextContent: () => this.pendingLargeTextContent,
      setPendingLargeTextContent: (t) => {
        this.pendingLargeTextContent = t;
      }
    }, text);
  }
  async handleKeyDown(event) {
    return handleKeyDown({
      isGenerating: () => this.isGenerating,
      handleSendMessage: () => this.handleSendMessage(),
      handleStopGeneration: () => this.handleStopGeneration(),
      input: this.input,
      slashCommandMenu: this.slashCommandMenu,
      atMentionMenu: this.atMentionMenu
    }, event);
  }
  handleInputChange() {
    const result = handleInputChange({
      input: this.input,
      adjustInputHeight: () => this.adjustInputHeight(),
      slashCommandMenu: this.slashCommandMenu,
      atMentionMenu: this.atMentionMenu,
      setPendingLargeTextContent: (t) => {
        this.pendingLargeTextContent = t;
      }
    });
    this.updateLiveTokenCounter();
    return result;
  }
  adjustInputHeight() {
    if (!this.input) return;
    this.input.style.height = "auto";
    const newHeight = Math.min(Math.max(this.input.scrollHeight, 48), 200);
    this.input.style.height = newHeight + "px";
  }
  handleSlashCommandDetection() {
    return;
  }
  handleAtMentionDetection() {
    return;
  }
  focus() {
    this.input.focus();
  }
  getValue() {
    return this.input.value;
  }
  setValue(value) {
    if (!this.input) {
      return;
    }
    try {
      this.input.value = value;
      const inputEvent = new Event("input", {
        bubbles: true,
        cancelable: true
      });
      this.input.dispatchEvent(inputEvent);
      this.adjustInputHeight();
      this.input.focus();
      this.input.setSelectionRange(value.length, value.length);
    } catch (error) {
      new import_obsidian86.Notice("\u274C Failed to set input value");
    }
  }
  unload() {
    if (this.renderTimeout) {
      clearTimeout(this.renderTimeout);
    }
    if (this.tokenUpdateTimeout) {
      clearTimeout(this.tokenUpdateTimeout);
    }
    if (this.recorderVisualizer) {
      this.recorderVisualizer.remove();
      this.recorderVisualizer = null;
    }
    if (this.recorderService) {
      this.recorderService.onToggle(() => {
      });
    }
    if (this.slashCommandMenu) {
      this.slashCommandMenu.unload();
    }
    if (this.atMentionMenu) {
      this.atMentionMenu.unload();
    }
    if (this.tokenCounterUI) {
      this.tokenCounterUI.unload();
    }
    super.unload();
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  /**
   * Add message to appropriate container, handling visual grouping for consecutive assistant messages
   */
  addMessageToContainer(messageEl, role, breakGroup = false) {
    return addMessageToContainer(this.chatContainer, messageEl, role, breakGroup);
  }
  createAssistantMessageContainer(breakGroup = false) {
    return createAssistantMessageContainer(this.chatContainer, () => this.generateMessageId(), this.chatView, breakGroup);
  }
  /**
   * Sort message parts to ensure reasoning shows before tool calls
   */
  sortMessageParts(parts) {
    return [...parts].sort((a, b) => a.timestamp - b.timestamp);
  }
  /**
   * Insert text at the current cursor position in the input field.
   * This also handles resizing the input field if necessary.
   */
  insertTextAtCursor(text) {
    const cursorPos = this.input.selectionStart;
    const currentValue = this.input.value;
    if (cursorPos !== null) {
      const newValue = currentValue.slice(0, cursorPos) + text + currentValue.slice(cursorPos);
      this.input.value = newValue;
      this.input.selectionStart = this.input.selectionEnd = cursorPos + text.length;
    } else {
      this.input.value = currentValue + text;
      this.input.selectionStart = this.input.selectionEnd = this.input.value.length;
    }
    this.input.dispatchEvent(new Event("input"));
    this.input.focus();
  }
  updateWebSearchButtonState() {
    var _a, _b, _c, _d, _e, _f, _g;
    if (!this.webSearchButton || !this.webSearchButton.buttonEl) return;
    const isNativeProvider = this.plugin.settings.activeProvider.type === "native";
    const currentProvider = this.plugin.settings.customProviders.find(
      (p) => p.id === this.plugin.settings.activeProvider.id
    );
    const isOpenRouter = currentProvider == null ? void 0 : currentProvider.endpoint.includes("openrouter.ai");
    const webSearchAllowed = isNativeProvider || isOpenRouter;
    if (!webSearchAllowed && this.webSearchEnabled) {
      this.webSearchEnabled = false;
      (_a = this.tokenCounterService) == null ? void 0 : _a.setWebSearchEnabled(false);
      try {
        if (((_c = (_b = this.chatView) == null ? void 0 : _b.messages) == null ? void 0 : _c.length) === 0) {
          this.chatView.displayChatStatus();
        }
      } catch (e) {
      }
    }
    if (!webSearchAllowed) {
      this.webSearchButton.buttonEl.style.display = "none";
      try {
        if (((_e = (_d = this.chatView) == null ? void 0 : _d.messages) == null ? void 0 : _e.length) === 0) {
          this.chatView.displayChatStatus();
        }
      } catch (e) {
      }
      return;
    }
    this.webSearchButton.buttonEl.style.display = "flex";
    if (this.webSearchEnabled) {
      this.webSearchButton.buttonEl.classList.add("ss-active");
      this.webSearchButton.setTooltip("Web search enabled (click to disable)");
    } else {
      this.webSearchButton.buttonEl.classList.remove("ss-active");
      this.webSearchButton.setTooltip("Toggle web search (SystemSculpt & OpenRouter only)");
    }
    try {
      if (((_g = (_f = this.chatView) == null ? void 0 : _f.messages) == null ? void 0 : _g.length) === 0) {
        this.chatView.displayChatStatus();
      }
    } catch (e) {
    }
  }
  // Public toggle used by status pills
  toggleWebSearchEnabled() {
    var _a, _b, _c;
    this.webSearchEnabled = !this.webSearchEnabled;
    (_a = this.tokenCounterService) == null ? void 0 : _a.setWebSearchEnabled(this.webSearchEnabled);
    this.updateWebSearchButtonState();
    this.updateLiveTokenCounter();
    try {
      if (this.webSearchEnabled) new import_obsidian86.Notice("Web search enabled");
      else new import_obsidian86.Notice("Web search disabled");
    } catch (e) {
    }
    try {
      if (((_c = (_b = this.chatView) == null ? void 0 : _b.messages) == null ? void 0 : _c.length) === 0) {
        this.chatView.displayChatStatus();
      }
    } catch (e) {
    }
  }
  updateMcpToolsButtonState() {
    var _a, _b, _c;
    if (!this.mcpToolsButton || !this.mcpToolsButton.buttonEl) return;
    const mcpEnabled = this.plugin.settings.mcpEnabled;
    const agentMode = ((_a = this.chatView) == null ? void 0 : _a.agentMode) || false;
    if (!mcpEnabled) {
      this.mcpToolsButton.buttonEl.style.display = "none";
      return;
    }
    this.mcpToolsButton.buttonEl.style.display = "flex";
    if (agentMode) {
      this.mcpToolsButton.buttonEl.classList.add("ss-active");
      this.mcpToolsButton.setTooltip("Agent Mode ON");
      (_b = this.tokenCounterService) == null ? void 0 : _b.setAgentMode(true);
      this.updateLiveTokenCounter();
    } else {
      this.mcpToolsButton.buttonEl.classList.remove("ss-active");
      this.mcpToolsButton.setTooltip("Toggle Agent Mode");
      (_c = this.tokenCounterService) == null ? void 0 : _c.setAgentMode(false);
      this.updateLiveTokenCounter();
    }
  }
  // Call this when model changes
  onModelChange() {
    var _a;
    this.updateWebSearchButtonState();
    this.updateMcpToolsButtonState();
    (_a = this.tokenCounterService) == null ? void 0 : _a.forceRefresh();
    this.updateLiveTokenCounter();
  }
  // Add method to update button state when agent mode changes
  updateAgentModeButtonState() {
    this.updateMcpToolsButtonState();
  }
  async handleOpenChatHistoryFile() {
    return handleOpenChatHistoryFile(this);
  }
  async handleSaveChatAsNote() {
    return handleSaveChatAsNote(this);
  }
  /**
   * Sets the input text content
   * @param content The content to set in the input field
   */
  setInputText(content) {
    this.setValue(typeof content === "string" ? content : JSON.stringify(content));
    this.focus();
  }
  /**
   * Extract annotations from the response text
   * This method parses markdown links in the format [domain](url) and extracts them as citations
   * Based on the actual OpenRouter response format observed in logs
   */
  extractAnnotationsFromResponse(responseText) {
    return extractAnnotationsFromResponse(responseText);
  }
  // Continuations are managed by ChatTurnOrchestrator per-turn
  /**
   * Set up event listeners for tool call events from ToolCallManager
   */
  // Per-turn tool state updates are wired by the orchestrator
  /**
   * Check if a specific tool should auto-accept based on plugin settings
   */
  // Auto-approval policy centralized in ToolCallManager.shouldAutoApprove()
  /**
   * Check if any MCP tools are configured to auto-accept AND are enabled
   */
  hasAnyAutoAcceptTools() {
    const autoAcceptTools = this.plugin.settings.mcpAutoAcceptTools || [];
    return autoAcceptTools.length > 0;
  }
  /**
   * Clean up event listeners on unload
   */
  onunload() {
    this.toolCallEventUnsubscribers.forEach((unsub) => unsub());
    this.toolCallEventUnsubscribers = [];
    this.cleanupAllStatusIndicators();
    super.unload();
  }
  /**
   * Clean up any remaining status indicators to prevent memory leaks
   */
  cleanupAllStatusIndicators() {
    var _a;
    (_a = this.chatContainer) == null ? void 0 : _a.querySelectorAll(".systemsculpt-streaming-status").forEach((el) => {
      el.remove();
    });
  }
  /**
   * Update the streaming status indicator for a message
   */
  updateStreamingStatus(messageEl, status, text) {
    updateStreamingStatus(messageEl, this.liveRegionEl, status, text);
  }
  /**
   * Hide the streaming status indicator when response is complete
   */
  hideStreamingStatus(messageEl) {
    hideStreamingStatus(messageEl, this.liveRegionEl);
  }
  /**
   * Show the streaming status indicator
   */
  showStreamingStatus(messageEl) {
    showStreamingStatus(messageEl, this.liveRegionEl);
  }
  /**
   * Helper method to get the status indicator for a message
   */
  getStatusIndicator(messageEl) {
    return getStatusIndicator(messageEl);
  }
  setStreamingFootnote(messageEl, text) {
    setStreamingFootnote(messageEl, text);
  }
  clearStreamingFootnote(messageEl) {
    clearStreamingFootnote(messageEl);
  }
  toggleStopButton(show) {
    if (this.stopButton) {
      this.stopButton.setDisabled(!show);
      this.stopButton.buttonEl.style.display = show ? "flex" : "none";
    }
  }
  async saveChatImmediate() {
    var _a;
    if (!((_a = this.chatView) == null ? void 0 : _a.isFullyLoaded)) {
      return;
    }
    try {
      await this.chatView.saveChat();
    } catch (e) {
      errorLogger.error("Chat save failed", e, {
        source: "InputHandler",
        method: "saveChatImmediate"
      });
    }
  }
  /**
   * Enable Agent Mode for the current chat (copied from MCPManagerModal logic)
   */
  async enableAgentModeForChat() {
    return enableAgentModeForChat({ plugin: this.plugin, chatView: this.chatView });
  }
  /**
   * Disable Agent Mode for the current chat
   */
  async disableAgentModeForChat() {
    return disableAgentModeForChat({ plugin: this.plugin, chatView: this.chatView });
  }
};

// src/views/chatview/uiSetup.ts
init_modelUtils();
var uiSetup = {
  onOpen: async function(chatView) {
    var _a;
    try {
      const plugins = chatView.app.plugins;
      if (plugins && !plugins.enabledPlugins.has("mermaid")) {
        await plugins.enablePlugin("mermaid");
      }
    } catch (e) {
    }
    const container = chatView.containerEl.children[1];
    container.empty();
    container.addClass("systemsculpt-chat-container");
    chatView.setupDragAndDrop(container);
    const headerContainer = container.createEl("div", { cls: "systemsculpt-chat-header" });
    chatView.contextManager = new FileContextManager({
      app: chatView.app,
      container: headerContainer,
      onContextChange: async () => {
        if (chatView.isFullyLoaded || !chatView.chatId) {
          await chatView.saveChat();
        }
        await chatView.contextManager.checkSyncStatus();
        if (chatView.messages.length === 0) {
          chatView.displayChatStatus();
        }
      },
      sculptService: chatView.aiService,
      plugin: chatView.plugin
    });
    if (chatView.pendingVaultStructureState !== void 0) {
      const shouldBeEnabled = chatView.pendingVaultStructureState;
      const currentlyEnabled = chatView.contextManager.isVaultStructureIncluded();
      if (shouldBeEnabled !== currentlyEnabled) {
        await chatView.contextManager.toggleVaultStructure();
      }
      chatView.pendingVaultStructureState = void 0;
    }
    chatView.chatContainer = container.createEl("div", { cls: "systemsculpt-messages-container" });
    chatView.chatContainer.classList.add(`systemsculpt-chat-${chatView.chatFontSize}`);
    const handleMessageEdited = async (event) => {
      const customEvent = event;
      const { messageId, newContent } = customEvent.detail;
      const messageIndex = chatView.messages.findIndex((msg) => msg.message_id === messageId);
      if (messageIndex !== -1) {
        if (typeof chatView.messages[messageIndex].content === "string") {
          chatView.messages[messageIndex].content = newContent;
          await chatView.saveChat();
        } else {
          if (Array.isArray(chatView.messages[messageIndex].content)) {
            const textPart = chatView.messages[messageIndex].content.find((p) => p.type === "text");
            if (textPart) {
              textPart.text = newContent;
              await chatView.saveChat();
            } else {
            }
          }
        }
      } else {
      }
    };
    chatView.chatContainer.addEventListener("message-edited", handleMessageEdited);
    chatView.register(() => {
      chatView.chatContainer.removeEventListener("message-edited", handleMessageEdited);
    });
    const scrollToBottomButton = document.createElement("button");
    scrollToBottomButton.className = "systemsculpt-scroll-to-bottom";
    scrollToBottomButton.setAttribute("aria-label", "Scroll to bottom");
    scrollToBottomButton.innerHTML = `
      <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 16 16" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round">
        <path d="M8 3v10m0 0l-4-4m4 4l4-4"/>
      </svg>
    `;
    scrollToBottomButton.style.display = "none";
    container.appendChild(scrollToBottomButton);
    const newMessagesPill = document.createElement("button");
    newMessagesPill.className = "systemsculpt-new-messages-pill";
    newMessagesPill.style.display = "none";
    newMessagesPill.setAttribute("aria-live", "polite");
    newMessagesPill.setAttribute("aria-atomic", "true");
    newMessagesPill.textContent = "New messages";
    container.appendChild(newMessagesPill);
    chatView.scrollManager = new ScrollManagerService({
      container: chatView.chatContainer,
      onAutoScrollChange: (isAutoScroll) => {
        scrollToBottomButton.style.display = isAutoScroll ? "none" : "flex";
        if (isAutoScroll) {
          newMessagesPill.style.display = "none";
          newMessagesPill.textContent = "New messages";
        }
      },
      onNewContentWhileDetached: (count) => {
        newMessagesPill.style.display = "flex";
        const label = count > 0 ? `New messages (${count})` : "New messages";
        newMessagesPill.textContent = label;
      }
    });
    scrollToBottomButton.addEventListener("click", () => {
      chatView.scrollManager.forceScrollToBottom();
    });
    newMessagesPill.addEventListener("click", () => {
      chatView.scrollManager.forceScrollToBottom();
      newMessagesPill.style.display = "none";
    });
    const modelIndicatorSection = container.createEl("div", {
      cls: "systemsculpt-model-indicator-section"
    });
    chatView.inputHandler = new InputHandler({
      app: chatView.app,
      container,
      aiService: chatView.aiService,
      getMessages: () => chatView.getMessages(),
      getSelectedModelId: () => chatView.selectedModelId,
      getContextFiles: () => chatView.contextManager.getContextFiles(),
      getSystemPrompt: () => ({ type: chatView.systemPromptType, path: chatView.systemPromptPath }),
      chatContainer: chatView.chatContainer,
      scrollManager: chatView.scrollManager,
      messageRenderer: chatView.messageRenderer,
      onMessageSubmit: async (message) => {
        chatView.messages.push(message);
        await chatView.saveChat();
        await chatView.addMessage(message.role, message.content, message.message_id);
      },
      onAssistantResponse: async (message) => {
        const existingMessageIndex = chatView.messages.findIndex((m) => m.message_id === message.message_id);
        if (existingMessageIndex !== -1) {
          const existingMessage = chatView.messages[existingMessageIndex];
          let mergedToolCalls = void 0;
          if (existingMessage.tool_calls || message.tool_calls) {
            const existingMap = new Map((existingMessage.tool_calls || []).map((tc) => [tc.id, tc]));
            const newMap = new Map((message.tool_calls || []).map((tc) => [tc.id, tc]));
            const mergedMap = new Map([...existingMap, ...newMap]);
            for (const [id, existingTc] of existingMap) {
              if (existingTc.result && mergedMap.has(id)) {
                const mergedTc = mergedMap.get(id);
                if (!mergedTc.result) {
                  mergedTc.result = existingTc.result;
                }
              }
            }
            mergedToolCalls = Array.from(mergedMap.values());
          }
          const mergedMessage = {
            ...existingMessage,
            ...message,
            content: message.content || existingMessage.content,
            reasoning: message.reasoning || existingMessage.reasoning,
            tool_calls: mergedToolCalls,
            messageParts: message.messageParts || existingMessage.messageParts
          };
          chatView.messages[existingMessageIndex] = mergedMessage;
        } else {
          chatView.messages.push(message);
        }
        await chatView.saveChat();
      },
      onContextFileAdd: async (wikilink) => {
        const files = chatView.contextManager.getContextFiles();
        files.add(wikilink);
        chatView.contextManager.setContextFiles(Array.from(files));
        await chatView.saveChat();
      },
      onError: (error) => chatView.handleError(error),
      onAddContextFile: () => {
        chatView.contextManager.addContextFile();
      },
      onEditSystemPrompt: () => chatView.handleSystemPromptEdit(),
      plugin: chatView.plugin,
      getChatMarkdown: () => chatView.exportChatAsMarkdown(),
      getChatTitle: () => chatView.getChatTitle(),
      addFileToContext: (file) => chatView.addFileToContext(file),
      chatStorage: chatView.chatStorage,
      getChatId: () => chatView.chatId,
      toolCallManager: chatView.toolCallManager,
      addMessageToHistory: chatView.addMessageToHistory.bind(chatView),
      chatView
    });
    chatView.inputHandler.onModelChange();
    const originalOnModelChange = chatView.inputHandler.onModelChange.bind(chatView.inputHandler);
    chatView.inputHandler.onModelChange = () => {
      originalOnModelChange();
      if (chatView.messages.length === 0) {
        chatView.displayChatStatus();
      }
    };
    chatView.registerEvent(
      chatView.app.workspace.on("active-leaf-change", (leaf) => {
        var _a2, _b;
        try {
          (_b = (_a2 = window.FreezeMonitor) == null ? void 0 : _a2.mark) == null ? void 0 : _b.call(_a2, "chatview:active-leaf-change");
        } catch (e) {
        }
        if (leaf === chatView.leaf && chatView.inputHandler) {
          chatView.inputHandler.focus();
        }
      })
    );
    chatView.inputHandler.focus();
    if (chatView.agentMode && !chatView.currentPrompt) {
      try {
        const { SystemPromptService: SystemPromptService2 } = await Promise.resolve().then(() => (init_SystemPromptService(), SystemPromptService_exports));
        const svc = SystemPromptService2.getInstance(chatView.app, () => chatView.plugin.settings);
        chatView.currentPrompt = await svc.getSystemPromptContent("agent", void 0, true);
      } catch (e) {
      }
    }
    await chatView.updateModelIndicator();
    await chatView.updateSystemPromptIndicator();
    try {
      const buttonGrid = container.querySelector(".systemsculpt-input-container .systemsculpt-button-grid");
      if (buttonGrid && modelIndicatorSection) {
        modelIndicatorSection.classList.add("inline");
        const divider = buttonGrid.querySelector(".systemsculpt-button-group-divider");
        if (divider) {
          const configGroup = document.createElement("div");
          configGroup.className = "systemsculpt-button-group systemsculpt-button-group-config";
          divider.insertAdjacentElement("afterend", configGroup);
          configGroup.appendChild(modelIndicatorSection);
          const secondDivider = document.createElement("div");
          secondDivider.className = "systemsculpt-button-group-divider";
          configGroup.insertAdjacentElement("afterend", secondDivider);
        } else {
          const primaryGroup = buttonGrid.querySelector(".systemsculpt-button-group-primary");
          if (primaryGroup) {
            primaryGroup.insertAdjacentElement("afterend", modelIndicatorSection);
          } else {
            buttonGrid.insertBefore(modelIndicatorSection, buttonGrid.firstChild);
          }
        }
      }
    } catch (e) {
    }
    if (!chatView.plugin.settings.selectedModelId && !chatView.plugin.hasPromptedForDefaultModel) {
      chatView.plugin.hasPromptedForDefaultModel = true;
      setTimeout(async () => {
        const result = await showPopup(
          chatView.app,
          "Welcome to SystemSculpt! To get started, please select a default AI model for your chats.",
          { title: "Select Default Model", icon: "bot", primaryButton: "Choose Model", secondaryButton: "Skip for Now" }
        );
        if (result == null ? void 0 : result.confirmed) {
          try {
            const modal = new StandardModelSelectionModal({
              app: chatView.app,
              plugin: chatView.plugin,
              currentModelId: "",
              onSelect: async (result2) => {
                await chatView.plugin.getSettingsManager().updateSettings({ selectedModelId: result2.modelId });
                chatView.selectedModelId = result2.modelId;
                await chatView.updateModelIndicator();
                new import_obsidian87.Notice("Default model set! You can change this anytime in settings.", 3e3);
              }
            });
            modal.open();
          } catch (error) {
            new import_obsidian87.Notice("Failed to open model selector. Please try again from settings.", 5e3);
          }
        }
      }, 500);
    } else if (chatView.plugin.settings.selectedModelId) {
      if (!chatView.selectedModelId) {
        const useLatestEverywhere = (_a = chatView.plugin.settings.useLatestModelEverywhere) != null ? _a : true;
        const isStandardMode = chatView.plugin.settings.settingsMode !== "advanced";
        if (useLatestEverywhere || isStandardMode) {
          chatView.selectedModelId = chatView.plugin.settings.selectedModelId;
        }
      }
      try {
        const models = await chatView.plugin.modelService.getModels();
        const currentModel = models.find((model) => model.id === chatView.selectedModelId);
        if (currentModel) {
          const customProvider = chatView.plugin.settings.customProviders.find(
            (p) => p.name.toLowerCase() === currentModel.provider.toLowerCase()
          );
          if (customProvider) {
            await chatView.plugin.getSettingsManager().updateSettings({
              activeProvider: {
                id: customProvider.id,
                name: customProvider.name,
                type: "custom"
              }
            });
          } else {
            await chatView.plugin.getSettingsManager().updateSettings({
              activeProvider: {
                id: "systemsculpt",
                name: "SystemSculpt",
                type: "native"
              }
            });
          }
        }
      } catch (error) {
      }
    }
    chatView.toolCallManager.on("tool-call:state-changed", async ({ toolCall }) => {
      var _a2, _b;
      const message = chatView.messages.find((m) => m.message_id === toolCall.messageId);
      if (!message) return;
      const toolCallInMessage = (_a2 = message.tool_calls) == null ? void 0 : _a2.find((tc) => tc.id === toolCall.id);
      if (!toolCallInMessage) return;
      toolCallInMessage.state = toolCall.state;
      toolCallInMessage.result = toolCall.result;
      if (Array.isArray(message.messageParts)) {
        for (const part of message.messageParts) {
          if (part.type === "tool_call" && ((_b = part.data) == null ? void 0 : _b.id) === toolCall.id) {
            part.data = toolCallInMessage;
          }
        }
      }
      if (chatView.isFullyLoaded) {
        await chatView.saveChat();
      }
      const messageEl = chatView.chatContainer.querySelector(`.systemsculpt-message[data-message-id="${message.message_id}"]`);
      if (messageEl) {
        const partList = chatView.messageRenderer.normalizeMessageToParts(message);
        chatView.messageRenderer.renderUnifiedMessageParts(messageEl, partList.parts, false);
      }
    });
    try {
      const m = globalThis.mermaid;
      if (m && !m.__ssConfigured) {
        const rootStyle = getComputedStyle(document.body);
        const accent = rootStyle.getPropertyValue("--interactive-accent").trim() || "#666";
        const bgPrimary = rootStyle.getPropertyValue("--background-primary").trim() || "#fff";
        const bgSecondary = rootStyle.getPropertyValue("--background-secondary").trim() || "#f4f4f4";
        const textNorm = rootStyle.getPropertyValue("--text-normal").trim() || "#333";
        m.initialize({
          startOnLoad: false,
          theme: "base",
          themeVariables: {
            primaryColor: bgSecondary,
            primaryBorderColor: accent,
            primaryTextColor: textNorm,
            lineColor: accent,
            textColor: textNorm,
            tertiaryColor: bgPrimary
          }
        });
        m.__ssConfigured = true;
      }
    } catch (e) {
    }
    if (chatView.messages.length === 0) {
      chatView.displayChatStatus();
    } else {
      await chatView.renderMessagesInChunks();
    }
  },
  /**
   * Ensures buttons are always in the correct order:
   * 1. Model button
   * 2. System Prompt button
   */
  ensureButtonOrder: function(chatView) {
    const container = chatView.containerEl.children[1];
    const modelSection = container == null ? void 0 : container.querySelector(".systemsculpt-model-indicator-section");
    if (!modelSection) return;
    const buttons = [];
    if (chatView.modelIndicator) {
      buttons.push(chatView.modelIndicator);
    }
    if (chatView.systemPromptIndicator) {
      buttons.push(chatView.systemPromptIndicator);
    }
    modelSection.empty();
    buttons.forEach((button) => {
      modelSection.appendChild(button);
    });
  },
  updateModelIndicator: async function(chatView) {
    const container = chatView.containerEl.children[1];
    const modelSection = container == null ? void 0 : container.querySelector(".systemsculpt-model-indicator-section");
    if (!modelSection) return;
    if (!chatView.modelIndicator) {
      chatView.modelIndicator = modelSection.createEl("div", {
        cls: "systemsculpt-model-indicator systemsculpt-chip"
      });
      chatView.registerDomEvent(chatView.modelIndicator, "click", async () => {
        const modal = new StandardModelSelectionModal({
          app: chatView.app,
          plugin: chatView.plugin,
          currentModelId: chatView.selectedModelId || "",
          onSelect: async (result) => {
            await chatView.setSelectedModelId(result.modelId);
            new import_obsidian87.Notice("Model updated for this chat.", 3e3);
          }
        });
        modal.open();
      });
      chatView.registerDomEvent(chatView.modelIndicator, "keydown", (event) => {
        var _a;
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          (_a = event.target) == null ? void 0 : _a.click();
        }
      });
    } else {
      chatView.modelIndicator.empty();
    }
    chatView.modelIndicator.setAttrs({
      role: "button",
      tabindex: 0,
      "aria-label": "Change chat model"
    });
    if (!chatView.selectedModelId || chatView.selectedModelId.trim() === "" || chatView.selectedModelId === "unknown" || chatView.selectedModelId.includes("unknown")) {
      if (chatView.modelIndicator) {
        const iconSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
        (0, import_obsidian87.setIcon)(iconSpan, "bot");
        chatView.modelIndicator.createSpan({ text: "No model selected" });
        chatView.modelIndicator.addClass("systemsculpt-no-model");
        chatView.modelIndicator.setAttr("aria-label", "No model selected, click to choose one");
      }
      return;
    }
    try {
      const canonicalId = ensureCanonicalId(chatView.selectedModelId);
      chatView.currentModelName = getDisplayName(canonicalId);
      if (chatView.modelIndicator) {
        chatView.modelIndicator.removeClass("systemsculpt-no-model");
      }
      const iconSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
      (0, import_obsidian87.setIcon)(iconSpan, "bot");
      const labelText = getModelLabelWithProvider(canonicalId);
      chatView.modelIndicator.createSpan({ text: labelText });
      const arrowSpan = chatView.modelIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
      (0, import_obsidian87.setIcon)(arrowSpan, "chevron-down");
      chatView.modelIndicator.setAttr("aria-label", `Current model: ${labelText}. Click to change.`);
      chatView.modelIndicator.setAttr("title", `Current model: ${labelText}`);
      chatView.modelIndicator.removeClass("systemsculpt-model-locked");
    } catch (error) {
      chatView.currentModelName = chatView.selectedModelId || "Error";
      if (chatView.modelIndicator) {
        chatView.modelIndicator.removeClass("systemsculpt-no-model");
        const errorText = `Error loading model (${chatView.currentModelName})`;
        chatView.modelIndicator.createSpan({ text: errorText });
        chatView.modelIndicator.setAttr("aria-label", `${errorText}. Click to try changing.`);
        chatView.modelIndicator.setAttr("title", `${errorText}`);
      }
    }
    if (chatView.modelIndicator) {
      chatView.modelIndicator.style.display = "";
    }
    this.ensureButtonOrder(chatView);
  },
  updateSystemPromptIndicator: async function(chatView) {
    const container = chatView.containerEl.children[1];
    const modelSection = container == null ? void 0 : container.querySelector(".systemsculpt-model-indicator-section");
    if (!modelSection) {
      return;
    }
    if (chatView.systemPromptIndicator) {
      chatView.systemPromptIndicator.style.display = "";
    }
    if (!chatView.systemPromptIndicator) {
      chatView.systemPromptIndicator = modelSection.createEl("div", {
        cls: "systemsculpt-model-indicator systemsculpt-chip"
      });
      chatView.registerDomEvent(chatView.systemPromptIndicator, "click", async () => {
        const { StandardSystemPromptSelectionModal: StandardSystemPromptSelectionModal2 } = await Promise.resolve().then(() => (init_StandardSystemPromptSelectionModal(), StandardSystemPromptSelectionModal_exports));
        const modal = new StandardSystemPromptSelectionModal2({
          app: chatView.app,
          plugin: chatView.plugin,
          currentType: chatView.systemPromptType || "general-use",
          currentPath: chatView.systemPromptPath,
          onSelect: async (result) => {
            var _a, _b, _c;
            chatView.systemPromptType = result.type;
            if (result.type === "custom") {
              chatView.systemPromptPath = result.path;
            } else {
              chatView.systemPromptPath = void 0;
            }
            chatView.currentPrompt = result.prompt;
            try {
              const useLatestPrompt = (_a = chatView.plugin.settings.useLatestSystemPromptForNewChats) != null ? _a : true;
              const isStandardMode = chatView.plugin.settings.settingsMode !== "advanced";
              if (useLatestPrompt || isStandardMode) {
                await chatView.plugin.getSettingsManager().updateSettings({
                  systemPromptType: result.type,
                  systemPromptPath: result.type === "custom" ? result.path || "" : ""
                });
                (_c = (_b = chatView.plugin.emitter) == null ? void 0 : _b.emit) == null ? void 0 : _c.call(_b, "systemPromptSettingsChanged");
              }
            } catch (e) {
            }
            await chatView.saveChat();
            await chatView.updateSystemPromptIndicator();
            new import_obsidian87.Notice("System prompt updated for this chat.", 3e3);
            if (chatView.messages.length === 0) {
              chatView.displayChatStatus();
            }
          }
        });
        modal.open();
      });
      chatView.registerDomEvent(chatView.systemPromptIndicator, "keydown", (event) => {
        var _a;
        if (event.key === "Enter" || event.key === " ") {
          event.preventDefault();
          (_a = event.target) == null ? void 0 : _a.click();
        }
      });
    } else {
      chatView.systemPromptIndicator.empty();
    }
    chatView.systemPromptIndicator.setAttrs({
      role: "button",
      tabindex: 0,
      "aria-label": "Change system prompt"
    });
    let promptLabel = "System Prompt";
    switch (chatView.systemPromptType) {
      case "general-use":
        promptLabel = "General Use";
        break;
      case "concise":
        promptLabel = "Concise";
        break;
      case "agent":
        promptLabel = "Agent Prompt";
        break;
      case "custom":
        if (chatView.systemPromptPath) {
          const filename = chatView.systemPromptPath.split("/").pop() || "Custom";
          const baseName = filename.replace(".md", "");
          promptLabel = baseName;
        } else {
          promptLabel = "Custom";
        }
        break;
    }
    const iconSpan = chatView.systemPromptIndicator.createSpan({ cls: "systemsculpt-model-indicator-icon" });
    (0, import_obsidian87.setIcon)(iconSpan, chatView.systemPromptType === "agent" ? "folder-open" : "sparkles");
    chatView.systemPromptIndicator.createSpan({ text: promptLabel });
    const arrowSpan = chatView.systemPromptIndicator.createSpan({ cls: "systemsculpt-model-indicator-arrow" });
    (0, import_obsidian87.setIcon)(arrowSpan, "chevron-down");
    chatView.systemPromptIndicator.setAttr("aria-label", `Current system prompt: ${promptLabel}. Click to change.`);
    chatView.systemPromptIndicator.setAttr("title", `Current system prompt: ${promptLabel}`);
    if (chatView.systemPromptIndicator) {
      chatView.systemPromptIndicator.removeClass("systemsculpt-system-prompt-locked");
    }
    this.ensureButtonOrder(chatView);
  }
};

// src/views/chatview/eventHandling.ts
var import_obsidian88 = require("obsidian");
init_ui();
init_types();
init_DocumentContextManager();
var eventHandling = {
  setupDragAndDrop: function(chatView, container) {
    const overlay = container.createEl("div", { cls: "systemsculpt-drag-overlay" });
    const message = overlay.createEl("div", { cls: "systemsculpt-drag-message", text: "Drop files, folders, or search results to add to context" });
    const detailMessage = overlay.createEl("div", { cls: "systemsculpt-drag-detail", text: "" });
    const MAX_FILES = 100;
    const parseObsidianUri = (uri) => {
      try {
        if (!uri.startsWith("obsidian://open")) return null;
        const url = new URL(uri);
        const filePath = url.searchParams.get("file");
        if (!filePath) return null;
        const decodedPath = decodeURIComponent(filePath);
        return decodedPath;
      } catch (e) {
        return null;
      }
    };
    const getFilesFromFolder2 = (folder) => {
      const files = [];
      const processFolder = (currentFolder) => {
        for (const child of currentFolder.children) {
          if (child instanceof import_obsidian88.TFile) files.push(child);
          else if (child instanceof import_obsidian88.TFolder) processFolder(child);
        }
      };
      processFolder(folder);
      return files.slice(0, MAX_FILES);
    };
    const parseSearchResults = (text) => {
      try {
        const data = JSON.parse(text);
        if (data.type === "search-results" && Array.isArray(data.results)) {
          return data;
        }
      } catch (e) {
      }
      const lines = text.split("\n").filter((line) => line.trim());
      if (lines.length < 2) {
        const line = lines[0];
        const scoreMatch = line == null ? void 0 : line.match(/^(.+?)\s+\((\d+(?:\.\d+)?)%?\)$/);
        const titlePathMatch = line == null ? void 0 : line.match(/^(.+?)\s*-\s*(.+)$/);
        if (!scoreMatch && !titlePathMatch) {
          return null;
        }
      }
      const searchResults = [];
      for (const line of lines) {
        const scoreMatch = line.match(/^(.+?)\s+\((\d+(?:\.\d+)?)%?\)$/);
        const titlePathMatch = line.match(/^(.+?)\s*-\s*(.+)$/);
        if (scoreMatch) {
          const [, path, scoreStr] = scoreMatch;
          const score = parseFloat(scoreStr) / 100;
          searchResults.push({ path: path.trim(), score });
        } else if (titlePathMatch) {
          const [, title, path] = titlePathMatch;
          searchResults.push({ path: path.trim(), title: title.trim() });
        } else if (line.trim()) {
          if (lines.length > 1) {
            searchResults.push({ path: line.trim() });
          }
        }
      }
      if (searchResults.length > 0) {
        return {
          type: "search-results",
          results: searchResults
        };
      }
      return null;
    };
    const parseFolderData = (text) => {
      try {
        const data = JSON.parse(text);
        if (data.type === "folder" && data.path) {
          return data;
        }
      } catch (e) {
      }
      return null;
    };
    const parseSimilarNoteData = (dt) => {
      try {
        const similarNoteData = dt.getData("application/x-systemsculpt-similar-note");
        if (similarNoteData) {
          const data = JSON.parse(similarNoteData);
          if (data.source === "similar-notes" && data.path) {
            return {
              type: "similar-note",
              path: data.path,
              title: data.title || data.path.split("/").pop() || data.path,
              score: data.score || 0,
              source: data.source
            };
          }
        }
      } catch (e) {
      }
      return null;
    };
    const getFileCount = async (dt) => {
      const currentContextSize = chatView.contextManager.getContextFiles().size;
      if (currentContextSize >= MAX_FILES) return { count: 0, type: "limit-reached" };
      const remainingSlots = MAX_FILES - currentContextSize;
      const similarNote = parseSimilarNoteData(dt);
      if (similarNote) {
        const file = chatView.app.vault.getAbstractFileByPath(similarNote.path);
        if (file instanceof import_obsidian88.TFile) {
          const scorePercent = Math.round(similarNote.score * 100);
          return {
            count: 1,
            type: "similar-note",
            details: `Similar note: "${similarNote.title}" (${scorePercent}% match)`
          };
        }
        return { count: 0, type: "similar-note-not-found" };
      }
      let newFileCount = 0;
      let filesToProcess = [];
      let contentType = "files";
      let details = "";
      if (dt.items && dt.items.length > 0) {
        for (const item of Array.from(dt.items)) {
          if (item.type === "text/plain") {
            const text = await new Promise((resolve) => item.getAsString(resolve));
            const lines = text.split("\n").filter((line) => line.trim());
            if (lines.length === 1) {
              const singlePath = lines[0].trim();
              let abstractFile = null;
              if (singlePath.startsWith("obsidian://")) {
                const filePath = parseObsidianUri(singlePath);
                if (filePath) {
                  abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
                  if (!abstractFile && !filePath.endsWith(".md")) {
                    const mdPath = `${filePath}.md`;
                    abstractFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                  }
                }
              } else {
                abstractFile = chatView.app.vault.getAbstractFileByPath(singlePath);
                if (!abstractFile && !singlePath.includes("/") && !singlePath.includes("\\")) {
                  const allFolders = chatView.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian88.TFolder);
                  abstractFile = allFolders.find((f) => f.name === singlePath);
                }
              }
              if (abstractFile instanceof import_obsidian88.TFolder) {
                contentType = "folder";
                details = `Folder: "${abstractFile.name}"`;
                filesToProcess.push(abstractFile);
                break;
              } else if (abstractFile instanceof import_obsidian88.TFile) {
                contentType = "files";
                filesToProcess.push(abstractFile);
                break;
              }
            }
            const searchData = parseSearchResults(text);
            if (searchData) {
              contentType = "search-results";
              details = searchData.query ? `Query: "${searchData.query}"` : "";
              for (const result of searchData.results) {
                const abstractFile = chatView.app.vault.getAbstractFileByPath(result.path);
                if (abstractFile instanceof import_obsidian88.TFile) {
                  filesToProcess.push(abstractFile);
                } else if (!result.path.includes(".")) {
                  const mdPath = `${result.path}.md`;
                  const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                  if (mdFile instanceof import_obsidian88.TFile) filesToProcess.push(mdFile);
                }
              }
              break;
            }
            const folderData = parseFolderData(text);
            if (folderData) {
              const folder = chatView.app.vault.getAbstractFileByPath(folderData.path);
              if (folder instanceof import_obsidian88.TFolder) {
                contentType = "folder";
                details = `Folder: "${folderData.name || folder.name}"`;
                filesToProcess.push(folder);
                break;
              }
            }
            for (const line of lines) {
              let filePath = line;
              let abstractFile = null;
              if (line.startsWith("obsidian://")) filePath = parseObsidianUri(line) || line;
              abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
              if (abstractFile instanceof import_obsidian88.TFolder) {
                filesToProcess.push(abstractFile);
                contentType = "folder";
                details = `Folder: "${abstractFile.name}"`;
              } else if (abstractFile instanceof import_obsidian88.TFile) {
                filesToProcess.push(abstractFile);
              } else if (!filePath.includes(".")) {
                const mdPath = `${filePath}.md`;
                const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                if (mdFile instanceof import_obsidian88.TFile) filesToProcess.push(mdFile);
              }
            }
          }
        }
      }
      for (const item of filesToProcess) {
        if (item instanceof import_obsidian88.TFolder) newFileCount += getFilesFromFolder2(item).length;
        else if (item instanceof import_obsidian88.TFile) newFileCount++;
      }
      if (newFileCount === 0 && dt.types.includes("text/uri-list")) {
        const uriData = await new Promise((resolve) => dt.items[1].getAsString(resolve));
        const uris = uriData.split("obsidian://open").filter((uri) => uri.trim()).map((uri) => "obsidian://open" + uri.trim());
        for (const uri of uris) {
          const filePath = parseObsidianUri(uri);
          if (!filePath) continue;
          const abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
          if (abstractFile instanceof import_obsidian88.TFolder) newFileCount += getFilesFromFolder2(abstractFile).length;
          else if (abstractFile instanceof import_obsidian88.TFile) newFileCount++;
        }
      }
      return {
        count: Math.min(newFileCount, remainingSlots),
        type: contentType,
        details
      };
    };
    const updateMessage = async (dt) => {
      const currentContextSize = chatView.contextManager.getContextFiles().size;
      if (currentContextSize >= MAX_FILES) {
        message.textContent = `Cannot add more files (max ${MAX_FILES} reached)`;
        detailMessage.textContent = "";
        container.removeAttribute("data-drag-type");
        return;
      }
      const fileInfo = await getFileCount(dt);
      if (fileInfo.count > 0) {
        const typeLabel = fileInfo.type === "search-results" ? "search results" : fileInfo.type === "folders" ? "multiple folders" : fileInfo.type === "folder" ? "folder contents" : fileInfo.type === "similar-note" ? "similar notes" : "files";
        if (fileInfo.type === "similar-note") {
          message.textContent = `Add similar note to context (${currentContextSize + fileInfo.count}/${MAX_FILES} total)`;
        } else {
          message.textContent = `Add ${fileInfo.count} file${fileInfo.count > 1 ? "s" : ""} from ${typeLabel} (${currentContextSize + fileInfo.count}/${MAX_FILES} total)`;
        }
        detailMessage.textContent = fileInfo.details || "";
        container.setAttribute("data-drag-type", fileInfo.type);
      } else {
        message.textContent = `Drop files, folders, or search results to add to context (${currentContextSize}/${MAX_FILES})`;
        detailMessage.textContent = "";
        container.removeAttribute("data-drag-type");
      }
    };
    let dragCounter = 0;
    let dragOverTimeout = null;
    const handlers = {
      dragenter: (e) => {
        e.preventDefault();
        e.stopPropagation();
        dragCounter++;
        if (dragCounter === 1) {
          container.addClass("systemsculpt-drag-active");
          if (e.dataTransfer) updateMessage(e.dataTransfer);
        }
      },
      dragleave: (e) => {
        e.preventDefault();
        e.stopPropagation();
        dragCounter--;
        if (dragCounter === 0) {
          container.removeClass("systemsculpt-drag-active");
          container.removeAttribute("data-drag-type");
        }
      },
      dragover: async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (dragOverTimeout) clearTimeout(dragOverTimeout);
        dragOverTimeout = setTimeout(async () => {
          if (e.dataTransfer) await updateMessage(e.dataTransfer);
        }, 100);
      },
      drop: async (e) => {
        var _a, _b, _c, _d;
        e.preventDefault();
        e.stopPropagation();
        dragCounter = 0;
        container.removeClass("systemsculpt-drag-active");
        container.removeAttribute("data-drag-type");
        const dt = e.dataTransfer;
        if (!dt) return;
        const startingContextSize = chatView.contextManager.getContextFiles().size;
        if (startingContextSize >= MAX_FILES) {
          await showAlert(chatView.app, `Cannot add more files (max ${MAX_FILES} reached)`, { type: "info", icon: "alert-triangle" });
          return;
        }
        try {
          const similarNote = parseSimilarNoteData(dt);
          if (similarNote) {
            const file = chatView.app.vault.getAbstractFileByPath(similarNote.path);
            if (file instanceof import_obsidian88.TFile) {
              const documentContextManager2 = DocumentContextManager.getInstance(chatView.app, chatView.plugin);
              await documentContextManager2.addFileToContext(file, chatView.contextManager, {
                showNotices: false,
                // Disable default notice to avoid duplication
                updateUI: true,
                saveChanges: true
              });
              const scorePercent = Math.round(similarNote.score * 100);
              new import_obsidian88.Notice(`Added "${similarNote.title}" (${scorePercent}% match) to context`, 3e3);
              return;
            } else {
              new import_obsidian88.Notice(`Similar note not found: ${similarNote.path}`, 4e3);
              return;
            }
          }
          let filesToProcess = [];
          let dropType = "files";
          let dropDetails = "";
          if (dt.items && dt.items.length > 0) {
            for (const item of Array.from(dt.items)) {
              if (item.type === "text/plain") {
                const text = await new Promise((resolve) => item.getAsString(resolve));
                const lines = text.split("\n").filter((line) => line.trim());
                if (lines.length === 1) {
                  const singlePath = lines[0].trim();
                  let abstractFile = null;
                  if (singlePath.startsWith("obsidian://")) {
                    const filePath = parseObsidianUri(singlePath);
                    if (filePath) {
                      abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
                      if (!abstractFile && !filePath.endsWith(".md")) {
                        const mdPath = `${filePath}.md`;
                        abstractFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                      }
                    }
                  } else {
                    abstractFile = chatView.app.vault.getAbstractFileByPath(singlePath);
                    if (!abstractFile && !singlePath.includes("/") && !singlePath.includes("\\")) {
                      const allFolders = chatView.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian88.TFolder);
                      abstractFile = allFolders.find((f) => f.name === singlePath);
                    }
                  }
                  if (abstractFile instanceof import_obsidian88.TFolder) {
                    dropType = "folder";
                    dropDetails = `Folder: "${abstractFile.name}"`;
                    filesToProcess.push(abstractFile);
                    break;
                  } else if (abstractFile instanceof import_obsidian88.TFile) {
                    dropType = "files";
                    filesToProcess.push(abstractFile);
                    break;
                  }
                }
                const searchData = parseSearchResults(text);
                if (searchData) {
                  dropType = "search-results";
                  dropDetails = searchData.query ? `Search: "${searchData.query}"` : "Search results";
                  for (const result of searchData.results) {
                    const abstractFile = chatView.app.vault.getAbstractFileByPath(result.path);
                    if (abstractFile instanceof import_obsidian88.TFile) {
                      filesToProcess.push(abstractFile);
                    } else if (!result.path.includes(".")) {
                      const mdPath = `${result.path}.md`;
                      const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                      if (mdFile instanceof import_obsidian88.TFile) filesToProcess.push(mdFile);
                    }
                  }
                  break;
                }
                const folderData = parseFolderData(text);
                if (folderData) {
                  const folder = chatView.app.vault.getAbstractFileByPath(folderData.path);
                  if (folder instanceof import_obsidian88.TFolder) {
                    dropType = "folder";
                    dropDetails = `Folder: "${folderData.name || folder.name}"`;
                    filesToProcess.push(folder);
                    break;
                  }
                }
                let folderCount = 0;
                for (const line of lines) {
                  let filePath = line;
                  let abstractFile = null;
                  if (line.startsWith("obsidian://")) filePath = parseObsidianUri(line) || line;
                  abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
                  if (abstractFile instanceof import_obsidian88.TFolder) {
                    filesToProcess.push(abstractFile);
                    folderCount++;
                    dropType = folderCount > 1 ? "folders" : "folder";
                    dropDetails = folderCount > 1 ? `${folderCount} folders` : `Folder: "${abstractFile.name}"`;
                  } else if (abstractFile instanceof import_obsidian88.TFile) {
                    const extension = abstractFile.extension.toLowerCase();
                    const requiresPro = ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
                    if (requiresPro && (!((_a = chatView.plugin.settings.licenseKey) == null ? void 0 : _a.trim()) || !chatView.plugin.settings.licenseValid)) {
                      await showPopup(chatView.app, "Document processing is a Pro feature...", { title: "Pro Feature", primaryButton: "Get License", secondaryButton: "Maybe Later" }).then((result) => {
                        if (result == null ? void 0 : result.confirmed) window.open(LICENSE_URL, "_blank");
                      });
                      return;
                    }
                    filesToProcess.push(abstractFile);
                  } else if (!filePath.includes(".")) {
                    const mdPath = `${filePath}.md`;
                    const mdFile = chatView.app.vault.getAbstractFileByPath(mdPath);
                    if (mdFile instanceof import_obsidian88.TFile) filesToProcess.push(mdFile);
                  }
                }
              }
            }
          }
          if (filesToProcess.length === 0 && dt.types.includes("text/uri-list")) {
            const uriData = await new Promise((resolve) => dt.items[1].getAsString(resolve));
            const uris = uriData.split("obsidian://open").filter((uri) => uri.trim()).map((uri) => "obsidian://open" + uri.trim());
            for (const uri of uris) {
              const filePath = parseObsidianUri(uri);
              if (!filePath) continue;
              let abstractFile = chatView.app.vault.getAbstractFileByPath(filePath);
              if (abstractFile instanceof import_obsidian88.TFile) {
                const extension = abstractFile.extension.toLowerCase();
                const requiresPro = ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
                if (requiresPro && (!((_b = chatView.plugin.settings.licenseKey) == null ? void 0 : _b.trim()) || !chatView.plugin.settings.licenseValid)) {
                  await showPopup(chatView.app, "Document processing is a Pro feature...", { title: "Pro Feature", primaryButton: "Get License", secondaryButton: "Maybe Later" }).then((result) => {
                    if (result == null ? void 0 : result.confirmed) window.open(LICENSE_URL, "_blank");
                  });
                  return;
                }
              }
              if (abstractFile instanceof import_obsidian88.TFile || abstractFile instanceof import_obsidian88.TFolder) filesToProcess.push(abstractFile);
            }
          }
          let totalFilesAdded = 0;
          const remainingSlots = MAX_FILES - startingContextSize;
          const documentContextManager = DocumentContextManager.getInstance(chatView.app, chatView.plugin);
          const folders = filesToProcess.filter((item) => item instanceof import_obsidian88.TFolder);
          const files = filesToProcess.filter((item) => item instanceof import_obsidian88.TFile);
          for (const folder of folders) {
            const folderFiles = getFilesFromFolder2(folder);
            const proFiles = folderFiles.filter((file) => {
              const extension = file.extension.toLowerCase();
              return ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
            });
            if (proFiles.length > 0 && (!((_c = chatView.plugin.settings.licenseKey) == null ? void 0 : _c.trim()) || !chatView.plugin.settings.licenseValid)) {
              await showPopup(chatView.app, "Document processing is a Pro feature...", {
                title: "Pro Feature",
                primaryButton: "Get License",
                secondaryButton: "Maybe Later"
              }).then((result) => {
                if (result == null ? void 0 : result.confirmed) window.open(LICENSE_URL, "_blank");
              });
              continue;
            }
            const addedCount = await documentContextManager.addFilesToContext(folderFiles, chatView.contextManager, {
              showNotices: true,
              updateUI: true,
              saveChanges: true,
              maxFiles: MAX_FILES
            });
            totalFilesAdded += addedCount;
          }
          if (files.length > 0) {
            const proFiles = files.filter((file) => {
              const extension = file.extension.toLowerCase();
              return ["pdf", "doc", "docx", "mp3", "wav", "m4a", "ogg", "webm"].includes(extension);
            });
            if (proFiles.length > 0 && (!((_d = chatView.plugin.settings.licenseKey) == null ? void 0 : _d.trim()) || !chatView.plugin.settings.licenseValid)) {
              await showPopup(chatView.app, "Document processing is a Pro feature...", {
                title: "Pro Feature",
                primaryButton: "Get License",
                secondaryButton: "Maybe Later"
              }).then((result) => {
                if (result == null ? void 0 : result.confirmed) window.open(LICENSE_URL, "_blank");
              });
              return;
            }
            const addedCount = await documentContextManager.addFilesToContext(files, chatView.contextManager, {
              showNotices: true,
              updateUI: true,
              saveChanges: true,
              maxFiles: MAX_FILES
            });
            totalFilesAdded += addedCount;
          }
          if (totalFilesAdded > 0) {
            const contextMessage = dropType === "search-results" ? "from search results" : dropType === "folders" ? "from multiple folders" : dropType === "folder" ? "from folder" : "";
            new import_obsidian88.Notice(`Added ${totalFilesAdded} file${totalFilesAdded > 1 ? "s" : ""} to context ${contextMessage}`, 3e3);
          } else if ((dropType === "folder" || dropType === "folders") && filesToProcess.length > 0) {
            const folderNames = filesToProcess.filter((item) => item instanceof import_obsidian88.TFolder).map((folder) => folder.name);
            if (folderNames.length === 1) {
              new import_obsidian88.Notice(`The "${folderNames[0]}" folder is empty - no files to add to context`, 4e3);
            } else if (folderNames.length > 1) {
              new import_obsidian88.Notice(`The selected folders are empty - no files to add to context`, 4e3);
            }
          }
        } catch (error) {
          await showAlert(chatView.app, "Failed to process dropped files", { type: "error" });
        }
      }
    };
    container.addEventListener("dragenter", handlers.dragenter);
    container.addEventListener("dragleave", handlers.dragleave);
    container.addEventListener("dragover", handlers.dragover);
    container.addEventListener("drop", handlers.drop);
    return () => {
      container.removeEventListener("dragenter", handlers.dragenter);
      container.removeEventListener("dragleave", handlers.dragleave);
      container.removeEventListener("dragover", handlers.dragover);
      container.removeEventListener("drop", handlers.drop);
      if (dragOverTimeout) {
        clearTimeout(dragOverTimeout);
        dragOverTimeout = null;
      }
    };
  }
};

// src/modals/StandardChatSettingsModal.ts
var import_obsidian91 = require("obsidian");
init_SystemPromptService();
init_StandardModelSelectionModal();
init_StandardModal();
init_TitleGenerationService();
init_modelUtils();
init_prompts2();
var CustomPromptFileSuggestModal2 = class extends import_obsidian91.SuggestModal {
  constructor(app, systemPromptService, onSelect) {
    super(app);
    this.systemPromptService = systemPromptService;
    this.onSelectCallback = onSelect;
    this.setPlaceholder("Select a custom system prompt file...");
  }
  async getSuggestions(query) {
    const files = await this.systemPromptService.getCustomPromptFiles();
    if (!query) {
      return files;
    }
    return files.filter((file) => file.name.toLowerCase().includes(query.toLowerCase()));
  }
  renderSuggestion(file, el) {
    el.createEl("div", { text: file.name });
    el.createEl("small", { text: file.path, cls: "ss-suggestion-path" });
  }
  onChooseSuggestion(file, evt) {
    this.onSelectCallback(file);
  }
};
var StandardChatSettingsModal = class extends StandardModal {
  constructor(app, options) {
    var _a, _b, _c, _d, _e;
    super(app);
    this.result = null;
    this.presetButtons = {};
    this.isGeneratingTitle = false;
    this.settingsChangedListener = null;
    this.selectPreset = async (type) => {
      var _a, _b, _c;
      this.currentType = type;
      if (type === "general-use") {
        this.currentPrompt = GENERAL_USE_PRESET.systemPrompt;
        this.currentPath = void 0;
      } else if (type === "concise") {
        this.currentPrompt = CONCISE_PRESET.systemPrompt;
        this.currentPath = void 0;
      } else if (type === "agent") {
        this.currentPrompt = AGENT_PRESET.systemPrompt;
        this.currentPath = void 0;
      } else if (type === "custom") {
        if (!this.currentPath) {
          this.openCustomPromptSelector();
          this.currentPrompt = "";
        } else {
          await this.loadInitialPrompt();
        }
      }
      if (this.promptTextEditor) {
        this.promptTextEditor.value = this.currentPrompt;
      }
      this.updatePresetButtons();
      this.updateSelectedFileInfo();
      if (this.options.chatView) {
        this.options.chatView.systemPromptType = this.currentType;
        this.options.chatView.systemPromptPath = this.currentType === "custom" ? this.currentPath : void 0;
        this.options.chatView.currentPrompt = this.currentPrompt;
        try {
          await this.options.chatView.saveChat();
          await this.options.chatView.updateSystemPromptIndicator();
          if (this.options.chatView.messages.length === 0) {
            this.options.chatView.displayChatStatus();
          }
        } catch (e) {
        }
      }
      if (this.options.mode === "defaults-only" && this.options.plugin) {
        await this.options.plugin.getSettingsManager().updateSettings({
          systemPromptType: this.currentType,
          systemPromptPath: (_a = this.currentPath) != null ? _a : ""
        });
        (_c = (_b = this.options.plugin.emitter) == null ? void 0 : _b.emit) == null ? void 0 : _c.call(_b, "settingsChanged");
        new import_obsidian91.Notice("Default system prompt updated.", 2e3);
      }
    };
    this.openCustomPromptSelector = () => {
      new CustomPromptFileSuggestModal2(
        this.app,
        this.systemPromptService,
        async (file) => {
          this.currentPath = file.path;
          this.currentType = "custom";
          await this.loadInitialPrompt();
          this.updatePresetButtons();
          this.updateSelectedFileInfo();
          if (this.options.chatView) {
            this.options.chatView.systemPromptType = this.currentType;
            this.options.chatView.systemPromptPath = this.currentPath;
            this.options.chatView.currentPrompt = this.currentPrompt;
            try {
              await this.options.chatView.saveChat();
              await this.options.chatView.updateSystemPromptIndicator();
              if (this.options.chatView.messages.length === 0) {
                this.options.chatView.displayChatStatus();
              }
            } catch (e) {
            }
          }
        }
      ).open();
    };
    this.openChangeDefaultPromptModal = () => {
      const modal = new (init_DefaultChatPresetsModal(), __toCommonJS(DefaultChatPresetsModal_exports)).DefaultChatPresetsModal(this.app, this.options.plugin);
      modal.open();
    };
    this.openModelSelectModal = async () => {
      if (!this.options.plugin) {
        new import_obsidian91.Notice("Cannot change model: plugin instance not available", 1e4);
        return;
      }
      const modelSelectionOptions = {
        app: this.app,
        plugin: this.options.plugin,
        currentModelId: this.currentModelId || "",
        isAgentPromptActive: false,
        // No longer restrict models based on prompt type
        onSelect: async (result) => {
          var _a, _b;
          const canonicalId = ensureCanonicalId(result.modelId);
          if (this.options.onModelSelect) {
            try {
              await this.options.onModelSelect(canonicalId);
              this.currentModelId = canonicalId;
              try {
                const useLatestEverywhere = (_a = this.options.plugin.settings.useLatestModelEverywhere) != null ? _a : true;
                const isStandardMode = this.options.plugin.settings.settingsMode !== "advanced";
                if (useLatestEverywhere || isStandardMode) {
                  await this.options.plugin.getSettingsManager().updateSettings({ selectedModelId: canonicalId });
                }
              } catch (e) {
              }
              this.updateModelDisplay();
            } catch (error) {
              new import_obsidian91.Notice("Failed to select model", 1e4);
            }
          } else {
            this.currentModelId = canonicalId;
            try {
              const useLatestEverywhere = (_b = this.options.plugin.settings.useLatestModelEverywhere) != null ? _b : true;
              const isStandardMode = this.options.plugin.settings.settingsMode !== "advanced";
              if (useLatestEverywhere || isStandardMode) {
                await this.options.plugin.getSettingsManager().updateSettings({ selectedModelId: canonicalId });
              }
            } catch (e) {
            }
            this.updateModelDisplay();
          }
        }
      };
      const modal = new StandardModelSelectionModal(modelSelectionOptions);
      modal.open();
    };
    this.handleTitleGeneration = async () => {
      var _a;
      if (this.isGeneratingTitle || !this.options.plugin) return;
      this.isGeneratingTitle = true;
      this.generateTitleButton.setText("Generating...");
      this.generateTitleButton.disabled = true;
      let newTitle;
      try {
        newTitle = await this.titleGenerationService.generateTitle((_a = this.options.messages) != null ? _a : []);
        if (newTitle) {
          newTitle = newTitle.trim();
          this.titleInput.value = newTitle;
          this.currentTitle = newTitle;
          new import_obsidian91.Notice("Title generated!", 2e3);
        } else {
          new import_obsidian91.Notice("Could not generate title.", 5e3);
        }
      } catch (error) {
        const isBenign2000 = ((error == null ? void 0 : error.error) === 2e3 || (error == null ? void 0 : error.message) === "2000") && newTitle;
        if (isBenign2000) {
        } else {
          if ((error == null ? void 0 : error.error) === 2e3 || (error == null ? void 0 : error.message) === "2000") {
            new import_obsidian91.Notice("Title generation failed (error 2000).", 1e4);
          } else {
            new import_obsidian91.Notice("Failed to generate title.", 1e4);
          }
        }
      } finally {
        this.isGeneratingTitle = false;
        this.generateTitleButton.setText("Generate Title");
        this.generateTitleButton.disabled = false;
      }
    };
    // Promise interface for awaiting result
    this.resolvePromise = null;
    this.options = options;
    this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.options.plugin.settings);
    this.titleGenerationService = TitleGenerationService.getInstance(this.options.plugin);
    this.currentPrompt = (_a = options.currentPrompt) != null ? _a : "";
    this.currentType = (_b = options.currentSystemPromptType) != null ? _b : "general-use";
    this.currentPath = options.systemPromptPath;
    this.currentTitle = (_c = options.chatTitle) != null ? _c : "";
    this.currentModelId = (_d = options.currentModelId) != null ? _d : "";
    this.currentChatFontSize = ((_e = options.chatView) == null ? void 0 : _e.chatFontSize) || options.plugin.settings.chatFontSize || "medium";
    this.modalEl.addClass("ss-chat-settings-modal");
    this.setSize("large");
  }
  onOpen() {
    super.onOpen();
    const title = this.options.mode === "defaults-only" ? "Default Chat Presets" : "Chat Settings";
    this.addTitle(title);
    this.display();
    this.updatePresetButtons();
    this.updateSelectedFileInfo();
    this.updateModelDisplay();
    this.loadInitialPrompt();
    if (this.options.plugin && this.options.plugin.emitter) {
      this.settingsChangedListener = () => {
        this.updateSelectedFileInfo();
        this.updatePresetButtons();
      };
      this.options.plugin.emitter.on("settingsChanged", this.settingsChangedListener);
    }
  }
  display() {
    var _a, _b;
    const { contentEl } = this;
    contentEl.empty();
    if (this.options.mode === "defaults-only") {
      contentEl.createEl("h3", { text: "Default Chat Presets" });
      const intro = contentEl.createDiv();
      intro.createEl("div", {
        text: "Set your default AI model and system prompt type for new chats. These presets will be used every time you start a new, fresh chat."
      });
      contentEl.createEl("hr");
      contentEl.createEl("h3", { text: "AI Model" });
      const modelSetting = new import_obsidian91.Setting(contentEl).addButton((btn) => {
        btn.setButtonText("Change Model").onClick(this.openModelSelectModal);
      });
      const modelInput = modelSetting.controlEl.createEl("input", {
        type: "text",
        value: this.currentModelId ? getDisplayName(this.currentModelId) : ((_b = (_a = this.options.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.selectedModelId) ? getDisplayName(this.options.plugin.settings.selectedModelId) : "No model selected",
        attr: { readonly: "true" }
      });
      modelInput.style.marginRight = "8px";
      this.modelNameDisplay = modelInput;
      contentEl.createEl("hr");
      contentEl.createEl("h3", { text: "System Prompt Type" });
      const promptSetting = new import_obsidian91.Setting(contentEl);
      const buttonContainer = promptSetting.controlEl.createDiv();
      this.createPresetButtons(buttonContainer);
      this.selectedFileInfo = promptSetting.controlEl.createDiv();
      this.updateSelectedFileInfo();
      this.updatePresetButtons();
      contentEl.createEl("hr");
    } else {
      const leftPanel = contentEl.createDiv("ss-chat-settings-modal__left-panel");
      const rightPanel = contentEl.createDiv("ss-chat-settings-modal__right-panel");
      this.createTitleSection(leftPanel);
      this.createModelSection(leftPanel);
      this.createChatFontSizeSection(leftPanel);
      this.createSystemPromptTypeSection(leftPanel, false);
      this.createPromptEditorSection(rightPanel);
      this.createDefaultSettingsSection(rightPanel);
    }
  }
  // --- Section Creation Methods (Using NEW Classes) ---
  createTitleSection(containerEl) {
    var _a, _b, _c, _d;
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", { text: "Chat Title", cls: "ss-chat-settings-modal__section-title" });
    const controls = section.createDiv("ss-chat-settings-modal__model-controls");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    controls.style.width = "100%";
    this.titleInput = controls.createEl("input", {
      type: "text",
      value: this.currentTitle,
      cls: "ss-chat-settings-modal__model-input"
    });
    this.titleInput.style.flexGrow = "1";
    this.titleInput.style.minWidth = "0";
    this.titleInput.addEventListener("change", (e) => {
      this.currentTitle = e.target.value;
    });
    this.generateTitleButton = controls.createEl("button", {
      text: "Generate Title",
      cls: "ss-chat-settings-modal__model-change-btn"
    });
    this.generateTitleButton.addEventListener("click", this.handleTitleGeneration);
    const isEmpty = ((_d = (_c = (_a = this.options.chatView) == null ? void 0 : _a.messages.length) != null ? _c : (_b = this.options.messages) == null ? void 0 : _b.length) != null ? _d : 0) === 0;
    this.generateTitleButton.disabled = isEmpty;
  }
  createModelSection(containerEl) {
    var _a, _b;
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", { text: "AI Model", cls: "ss-chat-settings-modal__section-title" });
    const controls = section.createDiv("ss-chat-settings-modal__model-controls");
    controls.style.display = "flex";
    controls.style.gap = "5px";
    controls.style.width = "100%";
    const modelInput = controls.createEl("input", {
      type: "text",
      value: "",
      cls: "ss-chat-settings-modal__model-input",
      attr: { readonly: "true" }
    });
    modelInput.style.flexGrow = "1";
    modelInput.style.minWidth = "0";
    this.modelNameDisplay = modelInput;
    if (this.currentModelId) {
      this.modelNameDisplay.value = getModelLabelWithProvider(this.currentModelId);
    } else if ((_b = (_a = this.options.plugin) == null ? void 0 : _a.settings) == null ? void 0 : _b.selectedModelId) {
      this.modelNameDisplay.value = getModelLabelWithProvider(this.options.plugin.settings.selectedModelId);
    } else {
      this.modelNameDisplay.value = "No model selected";
    }
    this.changeModelButton = controls.createEl("button", {
      text: "Change Model",
      cls: "ss-chat-settings-modal__model-change-btn"
    });
    this.changeModelButton.addEventListener("click", this.openModelSelectModal);
    this.updateModelDisplay();
  }
  createChatFontSizeSection(containerEl) {
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", { text: "Chat Size", cls: "ss-chat-settings-modal__section-title" });
    const sizeSetting = new import_obsidian91.Setting(section).setName("Message Text Size").setDesc("Change the text size for messages in this chat only.").addDropdown((dropdown) => {
      dropdown.addOption("small", "Small").addOption("medium", "Medium").addOption("large", "Large").setValue(this.currentChatFontSize).onChange(async (value) => {
        this.currentChatFontSize = value;
        if (this.options.chatView) {
          await this.options.chatView.setChatFontSize(this.currentChatFontSize);
        }
      });
    });
  }
  createSystemPromptTypeSection(containerEl, defaultsOnlyMode = false) {
    const section = containerEl.createDiv("ss-chat-settings-modal__section");
    section.createEl("h3", { text: "System Prompt Type", cls: "ss-chat-settings-modal__section-title" });
    const buttonContainer = section.createDiv("ss-chat-settings-modal__prompt-type-buttons");
    this.createPresetButtons(buttonContainer);
    this.selectedFileInfo = section.createDiv("ss-chat-settings-modal__prompt-type-details");
    const controlsContainer = section.createDiv("ss-chat-settings-modal__prompt-type-controls");
    this.changeFileButton = new import_obsidian91.ButtonComponent(controlsContainer).setButtonText("Change Custom File...").setClass("ss-chat-settings-modal__prompt-change-file-btn").onClick(this.openCustomPromptSelector);
    this.updateSelectedFileInfo();
    this.updatePresetButtons();
  }
  createPromptEditorSection(containerEl) {
    const section = containerEl.createDiv("ss-chat-settings-modal__prompt-editor-section ss-chat-settings-modal__section");
    section.createEl("h3", { text: "System Prompt Preview/Edit", cls: "ss-chat-settings-modal__section-title" });
    this.promptTextEditor = section.createEl("textarea", {
      cls: "ss-chat-settings-modal__prompt-textarea",
      attr: {
        placeholder: "System prompt content will appear here..."
      }
    });
    this.promptTextEditor.addEventListener("input", () => {
      this.currentPrompt = this.promptTextEditor.value;
    });
    const noteEl = section.createDiv("ss-chat-settings-modal__prompt-editor-note");
    noteEl.setText("Note: Changes to built-in presets (General Use, Concise) apply only to this chat. To save edits permanently, select or save as a new custom prompt file.");
  }
  // New separate section for default settings that will appear at the end
  createDefaultSettingsSection(containerEl) {
    const section = containerEl.createDiv("ss-chat-settings-modal__default-settings-section ss-chat-settings-modal__section");
    const defaultSettingsContainer = section.createDiv("default-settings-container");
    defaultSettingsContainer.style.backgroundColor = "var(--background-secondary)";
    defaultSettingsContainer.style.padding = "12px";
    defaultSettingsContainer.style.borderRadius = "var(--radius-s)";
    defaultSettingsContainer.style.marginTop = "16px";
    defaultSettingsContainer.createEl("h4", {
      text: "Default Settings",
      cls: "setting-item-heading"
    }).style.marginTop = "0";
    const defaultSettingsDescription = defaultSettingsContainer.createDiv();
    defaultSettingsDescription.innerHTML = "Configure the <strong>default model</strong> and <strong>system prompt type</strong> that will be used for all new chats.";
    defaultSettingsDescription.addClass("setting-item-description");
    defaultSettingsDescription.style.marginBottom = "12px";
    this.changeDefaultButton = new import_obsidian91.ButtonComponent(defaultSettingsContainer).setButtonText("Change Default Presets").setCta().onClick(this.openChangeDefaultPromptModal);
  }
  // --- Helper and Update Methods (Adjust classes if needed) ---
  isAgentModeAvailable() {
    return true;
  }
  createPresetButtons(container) {
    const presets = [
      { id: "general-use", label: "General Use Preset" },
      { id: "concise", label: "Concise Preset" },
      { id: "custom", label: "Custom Prompt" }
    ];
    presets.forEach((preset) => {
      this.presetButtons[preset.id] = new import_obsidian91.ButtonComponent(container).setButtonText(preset.label).setClass("ss-preset-button").onClick(() => this.selectPreset(preset.id));
    });
    if (this.options.mode !== "defaults-only") {
      const isAgentAvailable = this.isAgentModeAvailable();
      const agentButton = new import_obsidian91.ButtonComponent(container).setButtonText("Agent Mode").setClass("ss-preset-button").onClick(() => this.selectPreset("agent"));
      this.presetButtons["agent"] = agentButton;
    }
  }
  updatePresetButtons() {
    for (const id in this.presetButtons) {
      if (this.presetButtons.hasOwnProperty(id)) {
        const isActive = id === this.currentType;
        this.presetButtons[id].buttonEl.toggleClass("is-active", isActive);
        if (id === "agent") {
          const isAgentAvailable = this.isAgentModeAvailable();
          if (!isAgentAvailable) {
            this.presetButtons[id].buttonEl.setAttribute("disabled", "true");
            this.presetButtons[id].buttonEl.addClass("ss-preset-button-disabled");
          } else {
            this.presetButtons[id].buttonEl.removeAttribute("disabled");
            this.presetButtons[id].buttonEl.removeClass("ss-preset-button-disabled");
          }
        }
      }
    }
    if (this.changeFileButton) {
      this.changeFileButton.buttonEl.style.display = this.currentType === "custom" ? "block" : "none";
    }
  }
  updateSelectedFileInfo() {
    if (!this.selectedFileInfo) return;
    this.selectedFileInfo.empty();
    if (this.currentType === "custom") {
      if (this.currentPath) {
        const file = this.app.vault.getAbstractFileByPath(this.currentPath);
        if (!file) {
          this.currentType = "general-use";
          this.currentPath = void 0;
          this.currentPrompt = GENERAL_USE_PRESET.systemPrompt;
          this.selectedFileInfo.createEl("span", { text: "General Use (auto-switched from missing custom file)", cls: "ss-text-warning" });
        } else {
          const basename = this.currentPath.split("/").pop() || this.currentPath;
          this.selectedFileInfo.createEl("span", { text: `Selected: ${basename}` });
        }
      } else {
        this.selectedFileInfo.createEl("span", { text: "No custom file selected. Please choose one.", cls: "ss-text-warning" });
      }
    } else {
      let presetLabel;
      if (this.currentType === "general-use") {
        presetLabel = "General Use";
      } else if (this.currentType === "concise") {
        presetLabel = "Concise";
      } else if (this.currentType === "agent") {
        presetLabel = "Agent Mode";
      } else {
        let validTypes;
        if (this.options.mode === "defaults-only") {
          validTypes = ["general-use", "concise", "custom"];
        } else {
          validTypes = ["general-use", "concise", "custom", "agent"];
        }
        if (!validTypes.includes(this.currentType)) {
          this.currentType = "general-use";
          this.currentPrompt = GENERAL_USE_PRESET.systemPrompt;
          presetLabel = "General Use (auto-switched from invalid type)";
        } else {
          presetLabel = "General Use";
        }
      }
      this.selectedFileInfo.createEl("span", { text: `Using ${presetLabel} Preset` });
    }
    let defaultType;
    let defaultPath;
    if (this.options.mode === "defaults-only") {
      defaultType = this.currentType;
      defaultPath = this.currentPath;
    } else {
      defaultType = this.options.plugin.settings.systemPromptType || "general-use";
      defaultPath = this.options.plugin.settings.systemPromptPath;
    }
    const defaultDesc = this.selectedFileInfo.createEl("div", { cls: "ss-modal-description" });
    let defaultDisplayText = "";
    if (defaultType === "custom" && defaultPath) {
      const fileName = defaultPath.split("/").pop() || "Custom";
      defaultDisplayText = `Custom: ${fileName}`;
    } else {
      defaultDisplayText = defaultType === "general-use" ? "General Use" : defaultType.charAt(0).toUpperCase() + defaultType.slice(1);
    }
    defaultDesc.setText(`Default for new chats: ${defaultDisplayText}`);
  }
  async loadInitialPrompt() {
    try {
      let promptContent = "";
      if (this.currentType === "general-use") {
        promptContent = GENERAL_USE_PRESET.systemPrompt;
      } else if (this.currentType === "concise") {
        promptContent = CONCISE_PRESET.systemPrompt;
      } else if (this.currentType === "agent") {
        promptContent = AGENT_PRESET.systemPrompt;
      } else if (this.currentType === "custom" && this.currentPath) {
        promptContent = await this.systemPromptService.getSystemPromptContent("custom", this.currentPath);
      } else {
        promptContent = this.currentPrompt || "";
      }
      this.currentPrompt = promptContent;
      if (this.promptTextEditor) {
        this.promptTextEditor.value = this.currentPrompt;
      }
    } catch (error) {
      new import_obsidian91.Notice("Could not load system prompt content.", 1e4);
      if (this.promptTextEditor) {
        this.promptTextEditor.value = "Error loading prompt.";
      }
    }
  }
  async updateModelDisplay() {
    if (!this.modelNameDisplay || !this.currentModelId) return;
    try {
      let modelInfo = null;
      if (this.options.plugin) {
        const allModels = await this.options.plugin.modelService.getModels();
        modelInfo = await findModelById(allModels, this.currentModelId);
      }
      const canonicalId = ensureCanonicalId(this.currentModelId);
      const displayLabel = getModelLabelWithProvider(canonicalId);
      this.modelNameDisplay.value = displayLabel;
    } catch (error) {
      this.modelNameDisplay.value = getModelLabelWithProvider(this.currentModelId);
    }
  }
  // --- Footer removed ---
  async onClose() {
    var _a, _b, _c, _d, _e;
    if (this.settingsChangedListener && this.options.plugin && this.options.plugin.emitter) {
      this.options.plugin.emitter.off("settingsChanged");
      this.settingsChangedListener = null;
    }
    const { contentEl } = this;
    contentEl.empty();
    const result = {
      type: this.currentType,
      prompt: this.currentPrompt,
      path: this.currentPath,
      modelId: this.currentModelId,
      title: this.currentTitle
    };
    if (result.type === "custom" && !result.path) {
      new import_obsidian91.Notice("Please select a custom prompt file before saving.", 5e3);
      if (this.resolvePromise) this.resolvePromise(null);
      return;
    }
    try {
      if (this.options.chatView) {
        this.options.chatView.systemPromptType = result.type;
        this.options.chatView.systemPromptPath = result.path;
        if (result.modelId && typeof this.options.chatView.setSelectedModelId === "function") {
          await this.options.chatView.setSelectedModelId(result.modelId);
        } else {
          this.options.chatView.selectedModelId = result.modelId || ((_a = this.options.currentModelId) != null ? _a : "");
        }
        const newTitle = result.title || ((_b = this.options.chatTitle) != null ? _b : "");
        await this.options.chatView.setTitle(newTitle, true);
        await this.options.chatView.saveChat();
        this.options.chatView.leaf.setViewState(this.options.chatView.leaf.getViewState());
        this.options.chatView.updateModelIndicator();
        this.options.chatView.updateSystemPromptIndicator();
        if (this.options.chatView.messages.length === 0) {
          this.options.chatView.displayChatStatus();
        }
      }
      if (this.options.plugin) {
        try {
          const useLatestPrompt = (_c = this.options.plugin.settings.useLatestSystemPromptForNewChats) != null ? _c : true;
          const isStandardMode = this.options.plugin.settings.settingsMode !== "advanced";
          if (useLatestPrompt || isStandardMode) {
            await this.options.plugin.getSettingsManager().updateSettings({
              systemPromptType: result.type,
              systemPromptPath: result.type === "custom" ? result.path || "" : ""
            });
            (_e = (_d = this.options.plugin.emitter) == null ? void 0 : _d.emit) == null ? void 0 : _e.call(_d, "systemPromptSettingsChanged");
          }
        } catch (e) {
        }
      }
      if (this.resolvePromise) this.resolvePromise(result);
    } catch (error) {
      new import_obsidian91.Notice("Failed to save settings.", 1e4);
      if (this.resolvePromise) this.resolvePromise(null);
    }
  }
  async switchToVaultAgentModel() {
    const vaultAgentModelId = "systemsculpt/vault-agent";
    this.currentModelId = vaultAgentModelId;
    await this.updateModelDisplay();
    if (this.options.onModelSelect) {
      await this.options.onModelSelect(vaultAgentModelId);
    }
    new import_obsidian91.Notice("Switched to Vault Agent model for agent prompt", 3e3);
  }
  openModal() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      this.open();
    });
  }
};
function showStandardChatSettingsModal(app, options) {
  const modal = new StandardChatSettingsModal(app, options);
  return modal.openModal();
}

// src/views/chatview/systemPromptHandling.ts
var systemPromptHandling = {
  /**
   * Handle the editing of system prompts
   * @param chatView The current chat view
   * @returns Promise that resolves when editing is complete
   */
  async handleSystemPromptEdit(chatView) {
    try {
      const currentPromptContent = await chatView.getCurrentSystemPrompt();
      const currentType = chatView.systemPromptType || "general-use";
      const currentPath = chatView.systemPromptPath;
      const result = await showStandardChatSettingsModal(
        chatView.app,
        // Argument 1: App instance
        {
          // Argument 2: Options object
          // Core properties for the modal
          currentPrompt: currentPromptContent,
          currentSystemPromptType: currentType,
          systemPromptPath: currentPath,
          chatView,
          // Pass the chatView instance itself
          plugin: chatView.plugin,
          // Pass the plugin instance
          // Properties needed for title editing
          chatTitle: chatView.getChatTitle(),
          onTitleChange: async (newTitle) => {
            await chatView.setTitle(newTitle);
          },
          messages: chatView.getMessages(),
          // Pass messages for title generation
          // Properties needed for model selection
          currentModelId: chatView.getSelectedModelId(),
          // Get current model from ChatView
          onModelSelect: async (modelId) => {
            await chatView.setSelectedModelId(modelId);
          }
        }
      );
      if (result) {
      } else {
      }
    } catch (error) {
      chatView.handleError("Failed to edit system prompt");
    }
  }
};

// src/views/chatview/ChatView.ts
var CHAT_VIEW_TYPE = "systemsculpt-chat-view";
var ChatView = class extends import_obsidian92.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.messages = [];
    this.currentModelName = "";
    this.isGenerating = false;
    this.isFullyLoaded = false;
    this.chatVersion = 0;
    this.webSearchEnabled = false;
    this.agentMode = false;
    // Per-chat agent mode setting
    this.dragDropCleanup = null;
    this.chatExportService = null;
    /**
     * Virtualized chat rendering state
     * --------------------------------
     * To prevent the DOM from bloating when a chat grows very long we only keep
     * a window of the most recent messages in the document.  Older messages can
     * be incrementally loaded via a _Load earlier messages_ placeholder that
     * sits at the top of the list.
     */
    this.virtualStartIndex = 0;
    // Index of the first message currently rendered
    this.VIRTUAL_BATCH_SIZE = 40;
    // How many messages to load at a time
    this.hasAdjustedInitialWindow = false;
    this.updateModelIndicator = () => uiSetup.updateModelIndicator(this);
    this.updateSystemPromptIndicator = () => uiSetup.updateSystemPromptIndicator(this);
    this.addMessage = (role, content, existingMessageId, completeMessage) => messageHandling.addMessage(this, role, content, existingMessageId, completeMessage);
    this.loadMessages = () => messageHandling.loadMessages(this);
    this.setupDragAndDrop = (container) => {
      const cleanup = eventHandling.setupDragAndDrop(this, container);
      if (typeof cleanup === "function") {
        this.dragDropCleanup = cleanup;
      }
    };
    this.handleSystemPromptEdit = () => systemPromptHandling.handleSystemPromptEdit(this);
    this.plugin = plugin;
    this.settings = plugin.settings;
    this.app = plugin.app;
    this.aiService = SystemSculptService.getInstance(plugin);
    const state = this.leaf.getViewState();
    const initialState = (state == null ? void 0 : state.state) || {};
    this.messages = [];
    this.chatId = initialState.chatId || "";
    this.initializeChatTitle(initialState.chatTitle);
    this.selectedModelId = initialState.selectedModelId || plugin.settings.selectedModelId;
    this.currentModelName = "";
    this.isGenerating = false;
    this.isFullyLoaded = false;
    this.systemPromptPath = initialState.systemPromptPath;
    this.chatVersion = initialState.version !== void 0 ? initialState.version : -1;
    this.ensureCoreServicesReady();
    this.chatFontSize = initialState.chatFontSize || plugin.settings.chatFontSize || "medium";
    this.systemPromptType = initialState.systemPromptType || plugin.settings.systemPromptType || "general-use";
    if (this.systemPromptType === "custom" && !this.systemPromptPath) {
      this.systemPromptPath = plugin.settings.systemPromptPath;
    }
    this.initializeAgentMode(initialState).catch((error) => {
    });
    if (initialState.includeVaultStructure !== void 0) {
      this.pendingVaultStructureState = initialState.includeVaultStructure;
    } else if (!this.chatId || this.chatId === "") {
      this.pendingVaultStructureState = !!this.plugin.settings.defaultAgentMode;
    }
    this.layoutChangeHandler = this.onLayoutChange.bind(this);
  }
  /**
   * Centralized agent mode initialization logic
   * Determines agent mode based on initial state and settings
   */
  async initializeAgentMode(initialState) {
    if (initialState.agentMode !== void 0) {
      this.agentMode = initialState.agentMode;
      return;
    }
    if (!this.chatId || this.chatId === "") {
      this.agentMode = this.plugin.settings.defaultAgentMode || false;
      return;
    }
    this.agentMode = false;
  }
  /**
   * Sets agent mode from chat data and validates license
   * Handles all the logic for enabling/disabling agent mode when loading a chat
   */
  async setAgentModeFromChatData(chatDataAgentMode) {
    const requestedAgentMode = chatDataAgentMode !== void 0 ? chatDataAgentMode : false;
    if (requestedAgentMode) {
      this.agentMode = true;
    } else {
      this.agentMode = false;
    }
  }
  ensureCoreServicesReady() {
    if (!this.aiService) {
      this.aiService = SystemSculptService.getInstance(this.plugin);
    }
    if (!this.toolCallManager) {
      this.toolCallManager = new ToolCallManager(new MCPService(this.plugin, this.app), this);
    }
    if (!this.chatStorage) {
      this.chatStorage = new ChatStorageService(this.app, this.plugin.settings.chatsDirectory);
    }
    if (!this.messageRenderer) {
      this.messageRenderer = new MessageRenderer(this.app, this.toolCallManager);
    }
    if (!this.systemPromptService) {
      this.systemPromptService = SystemPromptService.getInstance(this.app, () => this.plugin.settings);
    }
  }
  getViewType() {
    return CHAT_VIEW_TYPE;
  }
  getDisplayText() {
    return this.chatTitle || "Loading...";
  }
  // Delegated methods
  async onOpen() {
    this.ensureCoreServicesReady();
    await uiSetup.onOpen(this);
  }
  async saveChat() {
    var _a, _b, _c;
    this.ensureCoreServicesReady();
    if (!this.isFullyLoaded && this.chatId) {
      return;
    }
    const hasMessages = this.messages.length > 0;
    const hasContextFiles = ((_a = this.contextManager) == null ? void 0 : _a.getContextFiles().size) > 0;
    const hasContent = hasMessages || hasContextFiles;
    if (!this.chatId && !hasContent) {
      this.updateViewState();
      return;
    }
    if (!this.chatId) {
      const now = /* @__PURE__ */ new Date();
      const year = now.getFullYear();
      const month = String(now.getMonth() + 1).padStart(2, "0");
      const day = String(now.getDate()).padStart(2, "0");
      const hour = String(now.getHours()).padStart(2, "0");
      const minute = String(now.getMinutes()).padStart(2, "0");
      const second = String(now.getSeconds()).padStart(2, "0");
      this.chatId = `${year}-${month}-${day} ${hour}-${minute}-${second}`;
      if (!this.chatTitle) {
        this.initializeChatTitle();
      }
      this.updateViewState();
    }
    try {
      const savedChat = await this.chatStorage.saveChat(
        this.chatId,
        this.messages,
        this.selectedModelId,
        ((_b = this.contextManager) == null ? void 0 : _b.getContextFiles()) || /* @__PURE__ */ new Set(),
        void 0,
        this.systemPromptType,
        this.systemPromptPath,
        this.chatTitle,
        this.agentMode,
        ((_c = this.contextManager) == null ? void 0 : _c.isVaultStructureIncluded()) || false,
        this.chatFontSize
      );
      this.chatVersion = savedChat.version || this.chatVersion;
      const wasNewChat = !this.isFullyLoaded;
      if (wasNewChat && !this.isFullyLoaded) {
        this.isFullyLoaded = true;
      }
      this.updateViewState();
    } catch (error) {
      this.handleError("Failed to save chat");
    }
  }
  async addMessageToHistory(message) {
    if (!this.messages.find((m) => m.message_id === message.message_id)) {
      this.messages.push(message);
      this.app.workspace.trigger("systemsculpt:chat-message-added", this.chatId);
    }
    await this.saveChat();
  }
  async handleError(error) {
    var _a, _b, _c;
    let errorMessage = typeof error === "string" ? error : error.message;
    const errorContext = {
      source: "ChatView",
      method: "handleError",
      modelId: this.selectedModelId,
      metadata: {
        chatId: this.chatId,
        messageCount: this.messages.length,
        isGenerating: this.isGenerating
      }
    };
    if (error instanceof SystemSculptError) {
      errorLogger.error(errorMessage, error, { ...errorContext, metadata: { ...errorContext.metadata, ...error.metadata } });
    } else {
      errorLogger.error(errorMessage, void 0, errorContext);
    }
    if (error instanceof SystemSculptError && (error.code === "MODEL_UNAVAILABLE" || error.code === "MODEL_REQUEST_ERROR" || error.code === "QUOTA_EXCEEDED")) {
      if (error.code === "MODEL_UNAVAILABLE") {
        try {
          const unavailableModelId = ((_a = error.metadata) == null ? void 0 : _a.model) || this.selectedModelId;
          const models = await this.plugin.modelService.getModels();
          const alternativeModel = this.plugin.modelService.findBestAlternativeModel(unavailableModelId, models);
          if (alternativeModel) {
            const oldModelId = this.selectedModelId;
            this.selectedModelId = ensureCanonicalId(alternativeModel.id);
            await this.updateModelIndicator();
            new import_obsidian92.Notice(`Model "${oldModelId}" is unavailable. Switched to "${alternativeModel.name}"`, 1e4);
            setTimeout(async () => {
              await showPopup(
                this.app,
                `The model "${oldModelId}" you were using is unavailable. This can happen when models are updated or removed by providers. I've automatically switched you to "${alternativeModel.name}" so you can continue chatting. Click below if you'd like to choose a different model.`,
                {
                  title: "Model Automatically Changed",
                  icon: "alert-triangle",
                  primaryButton: "Choose Different Model",
                  secondaryButton: "Continue With New Model"
                }
              ).then((result) => {
                var _a2;
                if (result == null ? void 0 : result.confirmed) {
                  (_a2 = this.modelIndicator) == null ? void 0 : _a2.click();
                }
              });
            }, 500);
            const lastMessage2 = this.chatContainer.querySelector(".systemsculpt-message:last-child");
            if (lastMessage2) lastMessage2.remove();
            const lastUserMessage2 = [...this.messages].reverse().find((msg) => msg.role === "user");
            if (lastUserMessage2 && this.inputHandler) {
              try {
                const { trimOuterBlankLines: trimOuterBlankLines2 } = await Promise.resolve().then(() => (init_textUtils(), textUtils_exports));
                const asString = typeof lastUserMessage2.content === "string" ? lastUserMessage2.content : JSON.stringify((_b = lastUserMessage2.content) != null ? _b : "");
                const normalized = trimOuterBlankLines2(asString);
                this.inputHandler.setInputText(normalized);
              } catch (e) {
                this.inputHandler.setInputText(lastUserMessage2.content || "");
              }
            }
            return;
          }
        } catch (altError) {
        }
      }
      const modal = new StandardModelSelectionModal({
        app: this.app,
        plugin: this.plugin,
        currentModelId: this.selectedModelId,
        onSelect: async (result) => {
          this.selectedModelId = ensureCanonicalId(result.modelId);
          this.updateModelIndicator();
        }
      });
      modal.open();
      const lastMessage = this.chatContainer.querySelector(".systemsculpt-message:last-child");
      if (lastMessage) lastMessage.remove();
      const lastUserMessage = [...this.messages].reverse().find((msg) => msg.role === "user");
      if (lastUserMessage && this.inputHandler) {
        try {
          const { trimOuterBlankLines: trimOuterBlankLines2 } = await Promise.resolve().then(() => (init_textUtils(), textUtils_exports));
          const asString = typeof lastUserMessage.content === "string" ? lastUserMessage.content : JSON.stringify((_c = lastUserMessage.content) != null ? _c : "");
          const normalized = trimOuterBlankLines2(asString);
          this.inputHandler.setInputText(normalized);
        } catch (e) {
          this.inputHandler.setInputText(lastUserMessage.content || "");
        }
      }
    } else {
    }
  }
  async onLayoutChange() {
    var _a;
    if (((_a = this.app.workspace.getActiveViewOfType(import_obsidian92.ItemView)) == null ? void 0 : _a.leaf) === this.leaf) {
      if (this.inputHandler) this.inputHandler.focus();
    }
  }
  generateMessageId() {
    return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.random() * 16 | 0;
      const v = c === "x" ? r : r & 3 | 8;
      return v.toString(16);
    });
  }
  async getCurrentSystemPrompt() {
    this.ensureCoreServicesReady();
    try {
      return await this.systemPromptService.getSystemPromptContent(
        this.systemPromptType,
        this.systemPromptPath
      );
    } catch (error) {
      return GENERAL_USE_PRESET.systemPrompt;
    }
  }
  /**
   * Display the current chat settings status for new/empty chats
   */
  displayChatStatus() {
    var _a, _b;
    if (!this.chatContainer) return;
    let statusContainer = this.chatContainer.querySelector(".systemsculpt-chat-status");
    const isRefresh = !!statusContainer;
    if (statusContainer) {
      statusContainer.empty();
      statusContainer.addClass("no-animate");
    } else {
      statusContainer = this.chatContainer.createEl("div", {
        cls: "systemsculpt-chat-status"
      });
    }
    statusContainer.createEl("h3", {
      text: "Chat Settings",
      cls: "systemsculpt-status-header"
    });
    const pills = statusContainer.createEl("div", { cls: "systemsculpt-status-pills" });
    const createPill = (options) => {
      const btn = pills.createEl("button", { cls: "systemsculpt-status-pill" });
      const iconSpan = btn.createSpan({ cls: "ss-pill-icon" });
      (0, import_obsidian92.setIcon)(iconSpan, options.icon);
      btn.createSpan({ cls: "ss-pill-label", text: options.label });
      btn.createSpan({ cls: "ss-pill-sep", text: "\xB7" });
      btn.createSpan({ cls: "ss-pill-value", text: options.value });
      if (options.isOn !== void 0) {
        btn.addClass(options.isOn ? "is-on" : "is-off");
      }
      if (options.isDisabled) {
        btn.addClass("is-disabled");
        btn.setAttr("aria-disabled", "true");
      } else {
        btn.setAttr("aria-disabled", "false");
      }
      if (options.title) btn.setAttr("title", options.title);
      if (!options.isDisabled && options.onClick) {
        this.registerDomEvent(btn, "click", async () => {
          var _a2;
          await ((_a2 = options.onClick) == null ? void 0 : _a2.call(options));
          this.displayChatStatus();
        });
      }
      return btn;
    };
    const modelLabel = this.currentModelName || this.selectedModelId || "Select\u2026";
    createPill({
      icon: "bot",
      label: "Model",
      value: modelLabel,
      title: modelLabel ? `Current model: ${modelLabel}` : "Choose a model",
      onClick: () => {
        const modal = new StandardModelSelectionModal({
          app: this.app,
          plugin: this.plugin,
          currentModelId: this.selectedModelId || "",
          onSelect: async (result) => {
            await this.setSelectedModelId(result.modelId);
            new import_obsidian92.Notice("Model updated for this chat.", 3e3);
          }
        });
        modal.open();
      }
    });
    let promptLabel = "";
    switch (this.systemPromptType) {
      case "general-use":
        promptLabel = "General Use";
        break;
      case "concise":
        promptLabel = "Concise";
        break;
      case "agent":
        promptLabel = "Agent Prompt";
        break;
      case "custom":
        if (this.systemPromptPath) {
          const filename = this.systemPromptPath.split("/").pop() || "Custom";
          const baseName = filename.replace(".md", "");
          promptLabel = baseName;
        } else {
          promptLabel = "Custom";
        }
        break;
      default:
        promptLabel = "General Use";
        break;
    }
    createPill({
      icon: this.systemPromptType === "agent" ? "folder-open" : "sparkles",
      label: "Prompt",
      value: promptLabel,
      title: `Current system prompt: ${promptLabel}`,
      onClick: async () => {
        const { StandardSystemPromptSelectionModal: StandardSystemPromptSelectionModal2 } = await Promise.resolve().then(() => (init_StandardSystemPromptSelectionModal(), StandardSystemPromptSelectionModal_exports));
        const modal = new StandardSystemPromptSelectionModal2({
          app: this.app,
          plugin: this.plugin,
          currentType: this.systemPromptType || "general-use",
          currentPath: this.systemPromptPath,
          onSelect: async (result) => {
            var _a2, _b2, _c;
            this.systemPromptType = result.type;
            this.systemPromptPath = result.type === "custom" ? result.path : void 0;
            this.currentPrompt = result.prompt;
            try {
              const useLatestPrompt = (_a2 = this.plugin.settings.useLatestSystemPromptForNewChats) != null ? _a2 : true;
              const isStandardMode = this.plugin.settings.settingsMode !== "advanced";
              if (useLatestPrompt || isStandardMode) {
                await this.plugin.getSettingsManager().updateSettings({
                  systemPromptType: result.type,
                  systemPromptPath: result.type === "custom" ? result.path || "" : ""
                });
                (_c = (_b2 = this.plugin.emitter) == null ? void 0 : _b2.emit) == null ? void 0 : _c.call(_b2, "systemPromptSettingsChanged");
              }
            } catch (e) {
            }
            await this.saveChat();
            await this.updateSystemPromptIndicator();
            new import_obsidian92.Notice("System prompt updated for this chat.", 3e3);
            this.notifySettingsChanged();
          }
        });
        modal.open();
      }
    });
    createPill({
      icon: "vault",
      label: "Agent",
      value: this.agentMode ? "On" : "Off",
      isOn: this.agentMode,
      title: this.agentMode ? "Agent Mode is enabled" : "Agent Mode is disabled",
      onClick: async () => {
        var _a2, _b2;
        const { enableAgentModeForChat: enableAgentModeForChat2, disableAgentModeForChat: disableAgentModeForChat2 } = await Promise.resolve().then(() => (init_AgentMode(), AgentMode_exports));
        if (this.agentMode) await disableAgentModeForChat2({ plugin: this.plugin, chatView: this });
        else await enableAgentModeForChat2({ plugin: this.plugin, chatView: this });
        (_b2 = (_a2 = this.inputHandler) == null ? void 0 : _a2.updateAgentModeButtonState) == null ? void 0 : _b2.call(_a2);
      }
    });
    const isNativeProvider = this.plugin.settings.activeProvider.type === "native";
    const currentProvider = this.plugin.settings.customProviders.find((p) => p.id === this.plugin.settings.activeProvider.id);
    const isOpenRouter = !!((_a = currentProvider == null ? void 0 : currentProvider.endpoint) == null ? void 0 : _a.includes("openrouter.ai"));
    const webSearchAllowed = isNativeProvider || isOpenRouter;
    const webSearchEnabled = !!((_b = this.inputHandler) == null ? void 0 : _b.webSearchEnabled);
    createPill({
      icon: "globe",
      label: "Search",
      value: webSearchEnabled ? "On" : "Off",
      isOn: webSearchEnabled,
      isDisabled: !webSearchAllowed,
      title: webSearchAllowed ? "Toggle web search" : "Web search not supported for this provider",
      onClick: () => {
        if (!this.inputHandler) return;
        this.inputHandler.toggleWebSearchEnabled();
        this.notifySettingsChanged();
      }
    });
    const fontLabel = this.chatFontSize.charAt(0).toUpperCase() + this.chatFontSize.slice(1);
    createPill({
      icon: "type",
      label: "Font",
      value: fontLabel,
      title: "Click to cycle font size",
      onClick: async () => {
        const order = ["small", "medium", "large"];
        const idx = order.indexOf(this.chatFontSize);
        const next = order[(idx + 1) % order.length];
        await this.setChatFontSize(next);
      }
    });
    statusContainer.createEl("p", {
      text: "Click any setting above to change it.",
      cls: "systemsculpt-status-tip"
    });
    try {
      statusContainer.removeClass("no-animate");
    } catch (e) {
    }
  }
  /**
   * Re-render the chat status block when the chat is empty so UI stays in sync
   */
  refreshChatStatusIfEmpty() {
    if (!this.chatContainer) return;
    if (this.messages.length === 0) {
      this.displayChatStatus();
    }
  }
  /**
   * Notify the system that chat-level settings have changed. Centralizes
   * status updates and broadcasts a workspace event for any listeners.
   */
  notifySettingsChanged() {
    try {
      this.app.workspace.trigger("systemsculpt:chat-settings-changed", this.chatId);
    } catch (e) {
    }
    this.refreshChatStatusIfEmpty();
  }
  getInputValue() {
    var _a, _b;
    return (_b = (_a = this.inputHandler) == null ? void 0 : _a.getValue()) != null ? _b : "";
  }
  onunload() {
    this.scrollManager.cleanup();
    this.app.workspace.off("active-leaf-change", this.onLayoutChange);
    if (this.dragDropCleanup) {
      this.dragDropCleanup();
      this.dragDropCleanup = null;
    }
    this.contextManager.unload();
    this.inputHandler.unload();
  }
  getState() {
    return {
      chatId: this.chatId,
      selectedModelId: this.selectedModelId,
      chatTitle: this.chatTitle,
      systemPromptType: this.systemPromptType,
      systemPromptPath: this.systemPromptPath,
      version: this.chatVersion,
      agentMode: this.agentMode,
      includeVaultStructure: !!this.agentMode,
      // stored for backward-compatibility only
      chatFontSize: this.chatFontSize
    };
  }
  async setState(state) {
    var _a, _b, _c, _d;
    try {
      const currentState = this.getState();
      if (JSON.stringify(state) === JSON.stringify(currentState)) {
        return;
      }
    } catch (e) {
    }
    if (!(state == null ? void 0 : state.chatId)) {
      this.chatId = "";
      this.initializeChatTitle();
      this.agentMode = !!this.plugin.settings.defaultAgentMode;
      this.selectedModelId = this.plugin.settings.selectedModelId || "";
      const useLatestPrompt = (_a = this.plugin.settings.useLatestSystemPromptForNewChats) != null ? _a : true;
      const isStandardMode = this.plugin.settings.settingsMode !== "advanced";
      if (useLatestPrompt || isStandardMode) {
        this.systemPromptType = this.plugin.settings.systemPromptType || "general-use";
        this.systemPromptPath = this.systemPromptType === "custom" ? this.plugin.settings.systemPromptPath : void 0;
      } else {
        this.systemPromptType = "general-use";
        this.systemPromptPath = void 0;
      }
      this.pendingVaultStructureState = !!this.plugin.settings.defaultAgentMode;
      if (state == null ? void 0 : state.chatFontSize) {
        this.chatFontSize = state.chatFontSize;
        setTimeout(() => {
          if (this.chatContainer) {
            this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
            this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
          }
        }, 0);
      }
      this.virtualStartIndex = 0;
      this.messages = [];
      (_b = this.contextManager) == null ? void 0 : _b.clearContext();
      this.updateModelIndicator();
      this.updateSystemPromptIndicator();
      this.isFullyLoaded = true;
      this.app.workspace.trigger("systemsculpt:chat-loaded", this.chatId);
      if (this.inputHandler && this.inputHandler.updateAgentModeButtonState) {
        this.inputHandler.updateAgentModeButtonState();
      }
      return;
    }
    if (this.chatId === state.chatId && this.isFullyLoaded) {
      return;
    }
    if (!state.chatId || state.chatId === "") {
      this.chatId = "";
      this.selectedModelId = state.selectedModelId || this.plugin.settings.selectedModelId || "";
      this.initializeChatTitle(state.chatTitle);
      this.chatVersion = state.version !== void 0 ? state.version : -1;
      this.systemPromptType = state.systemPromptType || "general-use";
      this.systemPromptPath = this.systemPromptType === "custom" ? state.systemPromptPath : void 0;
      if (state.agentMode !== void 0) {
        this.agentMode = state.agentMode;
      }
      if (state.chatFontSize) {
        this.chatFontSize = state.chatFontSize;
        setTimeout(() => {
          if (this.chatContainer) {
            this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
            this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
          }
        }, 0);
      }
      this.pendingVaultStructureState = state.includeVaultStructure;
      this.isFullyLoaded = true;
      return;
    }
    this.chatId = state.chatId;
    this.selectedModelId = state.selectedModelId || this.plugin.settings.selectedModelId || "";
    this.initializeChatTitle(state.chatTitle);
    this.chatVersion = state.version !== void 0 ? state.version : -1;
    this.systemPromptType = state.systemPromptType || "general-use";
    this.systemPromptPath = this.systemPromptType === "custom" ? state.systemPromptPath : void 0;
    if (state.agentMode !== void 0) {
      this.agentMode = state.agentMode;
    }
    if (state.chatFontSize) {
      this.chatFontSize = state.chatFontSize;
      setTimeout(() => {
        if (this.chatContainer) {
          this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
          this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
        }
      }, 0);
    }
    this.pendingVaultStructureState = !!this.agentMode;
    try {
      await this.loadChatById(state.chatId);
      if (((_c = this.app.workspace.getActiveViewOfType(import_obsidian92.ItemView)) == null ? void 0 : _c.leaf) === this.leaf && this.inputHandler) {
        this.inputHandler.focus();
      }
    } catch (error) {
      this.handleError(`Failed to load chat ${state.chatId}`);
      this.chatId = "";
      this.initializeChatTitle();
      this.virtualStartIndex = 0;
      this.messages = [];
      (_d = this.contextManager) == null ? void 0 : _d.clearContext();
      this.systemPromptType = "general-use";
      this.systemPromptPath = void 0;
      if (this.chatContainer) {
        this.renderMessagesInChunks();
      }
      this.isFullyLoaded = true;
    }
  }
  async loadChatById(chatId) {
    var _a;
    this.ensureCoreServicesReady();
    this.chatId = chatId;
    this.isFullyLoaded = false;
    try {
      const chatData = await this.chatStorage.loadChat(chatId);
      if (!chatData) {
        this.messages = [];
        this.chatContainer.empty();
        this.setTitle("Chat not found");
        this.systemPromptType = "general-use";
        this.systemPromptPath = void 0;
        this.updateModelIndicator();
        this.updateSystemPromptIndicator();
        (_a = this.contextManager) == null ? void 0 : _a.clearContext();
        this.isFullyLoaded = true;
        return;
      }
      this.selectedModelId = chatData.selectedModelId || this.plugin.settings.selectedModelId;
      this.setTitle(chatData.title || generateDefaultChatTitle(), false);
      this.messages = chatData.messages || [];
      this.chatVersion = chatData.version || 0;
      this.systemPromptType = chatData.systemPromptType || "general-use";
      this.systemPromptPath = this.systemPromptType === "custom" ? chatData.systemPromptPath : void 0;
      await this.setAgentModeFromChatData(chatData.agentMode);
      this.chatFontSize = chatData.chatFontSize || this.plugin.settings.chatFontSize || "medium";
      setTimeout(() => {
        if (this.chatContainer) {
          this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
          this.chatContainer.classList.add(`systemsculpt-chat-${this.chatFontSize}`);
        }
      }, 100);
      if (chatData.context_files && this.contextManager) {
        const contextFiles = chatData.context_files.filter(Boolean);
        if (contextFiles.length > 0) {
          await this.contextManager.setContextFiles(contextFiles);
        } else {
          await this.contextManager.clearContext();
        }
      } else if (this.contextManager) {
        await this.contextManager.clearContext();
      }
      if (this.contextManager) {
        const shouldInclude = !!this.agentMode;
        const currentlyIncluded = this.contextManager.isVaultStructureIncluded();
        if (shouldInclude !== currentlyIncluded) {
          await this.contextManager.toggleVaultStructure();
        }
      }
      this.chatContainer.empty();
      if (this.messages.length > 0) {
        await this.renderMessagesInChunks();
      }
      this.isFullyLoaded = true;
      await this.updateModelIndicator();
      await this.updateSystemPromptIndicator();
      if (this.inputHandler) {
        this.inputHandler.onModelChange();
        if (this.inputHandler.updateAgentModeButtonState) {
          this.inputHandler.updateAgentModeButtonState();
        }
      }
      await this.contextManager.validateAndCleanContextFiles();
      this.updateViewState();
      this.app.workspace.trigger("systemsculpt:chat-loaded", this.chatId);
    } catch (error) {
      this.handleError(`Failed to load chat: ${error.message}`);
      this.isFullyLoaded = true;
    }
  }
  async renderMessagesInChunks() {
    var _a;
    if (!this.chatContainer) return;
    const renderStart = performance.now();
    const total = this.messages.length;
    if (total === 0) {
      this.chatContainer.empty();
      this.displayChatStatus();
      return;
    }
    if (this.virtualStartIndex < 0) this.virtualStartIndex = 0;
    if (this.virtualStartIndex >= total) this.virtualStartIndex = Math.max(0, total - this.VIRTUAL_BATCH_SIZE);
    if (!this.hasAdjustedInitialWindow) {
      if (this.virtualStartIndex === 0 && total > this.VIRTUAL_BATCH_SIZE) {
        this.virtualStartIndex = total - this.VIRTUAL_BATCH_SIZE;
      }
      this.hasAdjustedInitialWindow = true;
    }
    this.chatContainer.empty();
    if (this.virtualStartIndex > 0) {
      const placeholder = this.createLoadMoreButton();
      this.chatContainer.appendChild(placeholder);
    }
    const frag = document.createDocumentFragment();
    for (let i = this.virtualStartIndex; i < total; i++) {
      const msg = this.messages[i];
      await messageHandling.addMessage(this, msg.role, msg.content, msg.message_id, msg, frag);
    }
    this.chatContainer.appendChild(frag);
    this.manageDomSize();
    if ((_a = this.scrollManager) == null ? void 0 : _a.isAutoScrollEnabled()) {
      setTimeout(() => {
        var _a2;
        (_a2 = this.scrollManager) == null ? void 0 : _a2.forceScrollToBottom();
      }, 0);
    }
    const duration = performance.now() - renderStart;
    const renderedCount = total - this.virtualStartIndex;
  }
  /**
   * Creates a clickable element which, when activated, loads the next batch
   * of historical messages above the fold.
   */
  createLoadMoreButton() {
    const btn = document.createElement("button");
    btn.type = "button";
    btn.className = "systemsculpt-load-more";
    const remaining = this.virtualStartIndex;
    btn.textContent = `Load earlier messages (${remaining})`;
    btn.tabIndex = 0;
    const load = async () => {
      await this.loadMoreMessages();
    };
    btn.addEventListener("click", load);
    btn.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        load();
      }
    });
    this.register(() => {
      btn.removeEventListener("click", load);
    });
    return btn;
  }
  /**
   * Loads an additional batch of older messages and prepends them to the chat
   * container.  We simply re-invoke renderMessagesInChunks() with an updated
   * virtualStartIndex so that we reuse the existing message rendering logic.
   */
  async loadMoreMessages() {
    if (!this.chatContainer || this.virtualStartIndex === 0) return;
    const placeholder = this.chatContainer.querySelector(".systemsculpt-load-more");
    const setLoadingState = (isLoading) => {
      if (!placeholder) return;
      if (isLoading) {
        placeholder.dataset.loading = "true";
        placeholder.textContent = "Loading...";
        placeholder.setAttribute("aria-busy", "true");
        placeholder.setAttribute("aria-disabled", "true");
      } else {
        placeholder.dataset.loading = "false";
        placeholder.removeAttribute("aria-busy");
        placeholder.removeAttribute("aria-disabled");
        if (this.virtualStartIndex > 0) {
          placeholder.textContent = `Load earlier messages (${this.virtualStartIndex})`;
        } else {
          placeholder.remove();
        }
      }
    };
    try {
      setLoadingState(true);
      const { scrollTop, scrollHeight } = this.chatContainer;
      const wasAtTop = scrollTop <= 50;
      this.virtualStartIndex = Math.max(0, this.virtualStartIndex - this.VIRTUAL_BATCH_SIZE);
      await this.renderMessagesInChunks();
      const newScrollHeight = this.chatContainer.scrollHeight;
      if (wasAtTop) {
        this.chatContainer.scrollTop = 0;
      } else {
        this.chatContainer.scrollTop = newScrollHeight - scrollHeight + scrollTop;
      }
    } catch (err) {
      new import_obsidian92.Notice("Failed to load older messages", 4e3);
    } finally {
      setLoadingState(false);
    }
  }
  /**
   * Ensures we don't let the DOM grow without bound while the conversation is
   * ongoing.  Once we exceed a generous threshold (two batches worth) we
   * remove the oldest elements that are still in the document, keeping the
   * load-more placeholder at the top intact.
   *
   * This method should be called after a new message has been appended.
   */
  manageDomSize() {
    if (!this.chatContainer) return;
    const maxElements = this.VIRTUAL_BATCH_SIZE * 2 + 1;
    const messageGroups = Array.from(this.chatContainer.children).filter((el) => !el.classList.contains("systemsculpt-load-more"));
    if (messageGroups.length > maxElements) {
      const removeCount = messageGroups.length - maxElements;
      for (let i = 0; i < removeCount; i++) {
        const el = messageGroups[i];
        el.remove();
      }
      this.virtualStartIndex = Math.min(this.virtualStartIndex + removeCount, this.messages.length);
      const placeholder = this.chatContainer.querySelector(".systemsculpt-load-more");
      if (placeholder) {
        const remaining = this.virtualStartIndex;
        placeholder.textContent = `Load earlier messages (${remaining})`;
      }
    }
  }
  async addFileToContext(file) {
    await this.contextManager.addFileToContext(file);
  }
  async copyToClipboard() {
    try {
      const content = await this.exportChatAsMarkdown();
      await navigator.clipboard.writeText(content);
      new import_obsidian92.Notice("Chat copied to clipboard", 4e3);
    } catch (error) {
      new import_obsidian92.Notice("Failed to copy chat to clipboard", 4e3);
    }
  }
  focusInput() {
    if (this.inputHandler) this.inputHandler.focus();
  }
  getSelectedModelId() {
    return this.selectedModelId;
  }
  async setSelectedModelId(modelId) {
    var _a;
    const canonicalId = ensureCanonicalId(modelId);
    this.selectedModelId = canonicalId;
    try {
      const useLatestEverywhere = (_a = this.plugin.settings.useLatestModelEverywhere) != null ? _a : true;
      const isStandardMode = this.plugin.settings.settingsMode !== "advanced";
      if (useLatestEverywhere || isStandardMode) {
        await this.plugin.getSettingsManager().updateSettings({ selectedModelId: canonicalId });
      }
    } catch (e) {
    }
    try {
      const model = await this.plugin.modelService.getModelById(canonicalId);
      if (model) {
        const customProvider = this.plugin.settings.customProviders.find(
          (p) => p.name.toLowerCase() === model.provider.toLowerCase()
        );
        if (customProvider) {
          await this.plugin.getSettingsManager().updateSettings({
            activeProvider: {
              id: customProvider.id,
              name: customProvider.name,
              type: "custom"
            }
          });
        } else {
          await this.plugin.getSettingsManager().updateSettings({
            activeProvider: {
              id: "systemsculpt",
              name: "SystemSculpt",
              type: "native"
            }
          });
        }
      } else {
      }
    } catch (error) {
    }
    await this.saveChat();
    await this.updateModelIndicator();
    if (this.inputHandler) {
      this.inputHandler.onModelChange();
    }
    this.focusInput();
    this.notifySettingsChanged();
  }
  getChatExportService() {
    if (!this.chatExportService) {
      this.chatExportService = new ChatExportService(this);
    }
    return this.chatExportService;
  }
  async exportChat(options) {
    return this.getChatExportService().export(options);
  }
  async exportChatAsMarkdown(options) {
    const result = await this.exportChat(options);
    return result.markdown;
  }
  getMessages() {
    return [...this.messages];
  }
  getChatTitle() {
    return this.chatTitle;
  }
  initializeChatTitle(initialTitle) {
    this.chatTitle = initialTitle || generateDefaultChatTitle();
  }
  async setTitle(newTitle, shouldSave = true) {
    if (newTitle === this.chatTitle) return;
    this.chatTitle = newTitle;
    this.updateViewState();
    if (shouldSave) {
      await this.saveChat();
      this.app.workspace.requestSaveLayout();
    }
  }
  updateViewState() {
    if (this.leaf) {
      const currentState = this.getState();
      this.leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state: currentState
      }, { focus: true });
    }
  }
  async setChatFontSize(size) {
    this.chatFontSize = size;
    if (this.chatContainer) {
      this.chatContainer.classList.remove("systemsculpt-chat-small", "systemsculpt-chat-medium", "systemsculpt-chat-large");
      this.chatContainer.classList.add(`systemsculpt-chat-${size}`);
    }
    this.updateViewState();
    if (this.chatId && this.isFullyLoaded) {
      await this.saveChat();
    }
    this.notifySettingsChanged();
  }
  async addContextFile(file) {
    if (this.contextManager) {
      await this.contextManager.addFileToContext(file);
    }
  }
  async onClose() {
    var _a;
    if (this.inputHandler && typeof this.inputHandler.abortCurrentGeneration === "function") {
      this.inputHandler.abortCurrentGeneration();
    }
    if (this.dragDropCleanup) {
      this.dragDropCleanup();
      this.dragDropCleanup = null;
    }
    if (this.scrollManager) {
      if (typeof this.scrollManager.destroy === "function") {
        this.scrollManager.destroy();
      }
      this.scrollManager = null;
    }
    if (this.contextManager) {
      if (typeof this.contextManager.destroy === "function") {
        this.contextManager.destroy();
      }
      this.contextManager = null;
    }
    if (this.messageRenderer) {
      if (typeof this.messageRenderer.destroy === "function") {
        this.messageRenderer.destroy();
      }
      this.messageRenderer = null;
    }
    if (this.toolCallManager) {
      if (typeof this.toolCallManager.destroy === "function") {
        this.toolCallManager.destroy();
      }
      this.toolCallManager = null;
    }
    if (this.inputHandler) {
      if (typeof this.inputHandler.destroy === "function") {
        this.inputHandler.destroy();
      }
      this.inputHandler = null;
    }
    this.messages = [];
    if (this.chatContainer) {
      this.chatContainer = null;
    }
    this.modelIndicator = null;
    this.systemPromptIndicator = null;
    this.aiService = null;
    this.chatStorage = null;
    this.systemPromptService = null;
    await ((_a = super.onClose) == null ? void 0 : _a.call(this));
  }
};

// src/services/RecorderService.ts
init_PlatformContext();
var MicrophoneRecorder = class {
  constructor(mimeType, extension, onError, onStatus, onComplete, preferredMicrophoneId, onStreamChanged) {
    this.mediaStream = null;
    this.mediaRecorder = null;
    this.chunks = [];
    this.isRecording = false;
    this.preferredMicrophoneId = null;
    this.recovering = false;
    this.pendingStream = null;
    this.deviceChangeListener = null;
    this.trackEndListener = null;
    this.onStreamChanged = null;
    this.mimeType = mimeType;
    this.extension = extension;
    this.onError = onError;
    this.onStatus = onStatus;
    this.onComplete = onComplete;
    this.preferredMicrophoneId = preferredMicrophoneId || null;
    this.onStreamChanged = onStreamChanged || null;
  }
  /**
   * Start recording with the given output path
   */
  async start(app, outputPath) {
    var _a;
    if (this.isRecording) {
      this.onStatus("Already recording");
      return;
    }
    this.chunks = [];
    try {
      this.onStatus("Requesting microphone access...");
      const audioConstraints = {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      };
      if (this.preferredMicrophoneId) {
        this.onStatus("Using preferred microphone...");
        audioConstraints.deviceId = {
          exact: this.preferredMicrophoneId
        };
      }
      let streamPromise = navigator.mediaDevices.getUserMedia({
        audio: audioConstraints
      });
      const timeoutPromise = new Promise((_, reject) => {
        setTimeout(() => reject(new Error("Browser took too long to grant microphone access. Please check your browser permissions.")), 1e4);
      });
      try {
        this.mediaStream = await Promise.race([streamPromise, timeoutPromise]);
      } catch (error) {
        if (this.preferredMicrophoneId && (error instanceof Error && (error.message.includes("NotFoundError") || error.message.includes("not found") || error.message.includes("OverconstrainedError")))) {
          this.onStatus("Preferred microphone not available, using default...");
          const fallbackPromise = navigator.mediaDevices.getUserMedia({
            audio: {
              echoCancellation: true,
              noiseSuppression: true,
              autoGainControl: true
            }
          });
          this.mediaStream = await Promise.race([fallbackPromise, timeoutPromise]);
        } else {
          this.onStatus("Retrying with basic settings...");
          const fallbackPromise = navigator.mediaDevices.getUserMedia({
            audio: true
          });
          this.mediaStream = await Promise.race([fallbackPromise, timeoutPromise]);
        }
      }
      this.attachDeviceAndTrackListeners(this.mediaStream);
      const micLabel = ((_a = this.mediaStream.getAudioTracks()[0]) == null ? void 0 : _a.label) || "Default Microphone";
      this.onStatus(`Recording with: ${micLabel}`);
      const mimeType = this.mimeType;
      try {
        this.mediaRecorder = new MediaRecorder(this.mediaStream, {
          mimeType
        });
      } catch (error) {
        this.mediaRecorder = new MediaRecorder(this.mediaStream);
      }
      this.mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) {
          this.chunks.push(e.data);
        }
      };
      this.mediaRecorder.onstop = async () => {
        try {
          if (this.recovering) {
            const next = this.pendingStream;
            this.pendingStream = null;
            this.recovering = false;
            if (next) {
              this.replaceStream(next);
              try {
                this.mediaRecorder = new MediaRecorder(this.mediaStream, { mimeType: this.mimeType });
              } catch (e) {
                this.mediaRecorder = new MediaRecorder(this.mediaStream);
              }
              this.mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                  this.chunks.push(e.data);
                }
              };
              this.mediaRecorder.onstop = async () => {
                try {
                  if (this.chunks.length === 0) {
                    throw new Error("No audio data recorded");
                  }
                  const blob2 = new Blob(this.chunks, { type: this.mimeType });
                  const arrayBuffer2 = await blob2.arrayBuffer();
                  await app.vault.adapter.writeBinary(outputPath, arrayBuffer2);
                  this.onStatus("Recording saved");
                  this.onComplete(outputPath, blob2);
                } catch (error) {
                  this.onError(new Error(`Save failed: ${error instanceof Error ? error.message : String(error)}`));
                } finally {
                  this.release();
                }
              };
              this.mediaRecorder.start(1e3);
              this.isRecording = true;
              return;
            }
          }
          if (this.chunks.length === 0) {
            throw new Error("No audio data recorded");
          }
          const blob = new Blob(this.chunks, { type: this.mimeType });
          const arrayBuffer = await blob.arrayBuffer();
          await app.vault.adapter.writeBinary(outputPath, arrayBuffer);
          this.onStatus("Recording saved");
          this.onComplete(outputPath, blob);
        } catch (error) {
          this.onError(new Error(`Save failed: ${error instanceof Error ? error.message : String(error)}`));
        } finally {
          this.release();
        }
      };
      this.mediaRecorder.start(1e3);
      this.isRecording = true;
    } catch (error) {
      this.release();
      let errorMessage = "Failed to start recording";
      if (error instanceof Error) {
        if (error.message.includes("Permission denied") || error.message.includes("permission") || error.message.includes("NotAllowedError")) {
          errorMessage = "Microphone access denied. Please check your browser permissions and try again.";
        } else if (error.message.includes("not found") || error.message.includes("NotFoundError")) {
          errorMessage = "No microphone detected. Please connect a microphone and try again.";
        } else if (error.message.includes("timeout")) {
          errorMessage = "Browser took too long to respond. Try refreshing the page or check microphone permissions.";
        } else {
          errorMessage = `Recording failed: ${error.message}`;
        }
      }
      this.onError(new Error(errorMessage));
    }
  }
  /**
   * Stop the current recording
   */
  stop() {
    if (!this.isRecording || !this.mediaRecorder) {
      return;
    }
    try {
      if (this.mediaRecorder.state !== "inactive") {
        this.mediaRecorder.stop();
      }
      this.onStatus("Processing recording...");
    } catch (error) {
      this.onError(new Error(`Stop failed: ${error instanceof Error ? error.message : String(error)}`));
      this.release();
    }
  }
  /**
   * Release all resources
   */
  release() {
    if (this.mediaRecorder) {
      try {
        if (this.mediaRecorder.state !== "inactive") {
          this.mediaRecorder.stop();
        }
      } catch (e) {
      }
      this.mediaRecorder = null;
    }
    if (this.mediaStream) {
      this.detachDeviceAndTrackListeners(this.mediaStream);
      this.mediaStream.getTracks().forEach((track) => track.stop());
      this.mediaStream = null;
    }
    if (this.deviceChangeListener) {
      try {
        navigator.mediaDevices.removeEventListener("devicechange", this.deviceChangeListener);
      } catch (e) {
      }
      this.deviceChangeListener = null;
    }
    this.pendingStream = null;
    this.isRecording = false;
  }
  /**
   * Clean up all resources
   */
  cleanup() {
    this.release();
  }
  /**
   * Check if currently recording
   */
  get recording() {
    return this.isRecording;
  }
  /**
   * Get the current media stream for visualization
   */
  getMediaStream() {
    return this.mediaStream;
  }
  /**
   * Attach devicechange and track end listeners to enable recovery
   */
  attachDeviceAndTrackListeners(stream) {
    const track = stream.getAudioTracks()[0];
    if (track) {
      this.trackEndListener = () => {
        this.recoverFromDeviceChange().catch(() => {
          this.onError(new Error("Microphone disconnected during recording"));
        });
      };
      try {
        track.onended = this.trackEndListener;
      } catch (e) {
      }
    }
    if (!this.deviceChangeListener) {
      this.deviceChangeListener = () => {
        if (!this.isRecording || this.recovering) return;
        this.recoverFromDeviceChange().catch(() => {
        });
      };
      try {
        navigator.mediaDevices.addEventListener("devicechange", this.deviceChangeListener);
      } catch (e) {
      }
    }
  }
  /**
   * Detach listeners from a given stream
   */
  detachDeviceAndTrackListeners(stream) {
    const track = stream.getAudioTracks()[0];
    if (track) {
      try {
        track.onended = null;
      } catch (e) {
      }
    }
  }
  /**
   * Replace the active media stream and notify listeners/visualizers
   */
  replaceStream(nextStream) {
    var _a;
    if (this.mediaStream) {
      this.detachDeviceAndTrackListeners(this.mediaStream);
      this.mediaStream.getTracks().forEach((t) => t.stop());
    }
    this.mediaStream = nextStream;
    this.attachDeviceAndTrackListeners(this.mediaStream);
    if (this.onStreamChanged) {
      try {
        this.onStreamChanged(this.mediaStream);
      } catch (e) {
      }
    }
    const micLabel = ((_a = this.mediaStream.getAudioTracks()[0]) == null ? void 0 : _a.label) || "Default Microphone";
    this.onStatus(`Recording with: ${micLabel}`);
  }
  /**
   * Attempt to recover recording after device change by re-acquiring a stream
   */
  async recoverFromDeviceChange() {
    if (!this.isRecording || this.recovering) return;
    this.recovering = true;
    this.onStatus("Input device changed, reconnecting...");
    const constraints = this.preferredMicrophoneId ? {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true,
      deviceId: { ideal: this.preferredMicrophoneId }
    } : {
      echoCancellation: true,
      noiseSuppression: true,
      autoGainControl: true
    };
    let newStream = null;
    try {
      newStream = await navigator.mediaDevices.getUserMedia({ audio: constraints });
    } catch (e) {
      newStream = await navigator.mediaDevices.getUserMedia({ audio: true });
    }
    this.pendingStream = newStream;
    try {
      if (this.mediaRecorder && this.mediaRecorder.state !== "inactive") {
        this.mediaRecorder.stop();
      } else {
        const next = this.pendingStream;
        this.pendingStream = null;
        this.recovering = false;
        if (next) this.replaceStream(next);
      }
    } catch (e) {
      this.recovering = false;
      throw e;
    }
  }
};
var _RecorderService = class _RecorderService {
  /**
   * Private constructor - use getInstance() instead
   */
  constructor(app, plugin, options = {}) {
    // Recording state
    this.recorder = null;
    this.isRecording = false;
    this.lastRecordingPath = null;
    this.recordingStartTime = 0;
    this.isInChat = false;
    this.onTranscriptionDone = null;
    // UI elements
    this.recordingModal = null;
    // Desktop hover widget
    this.nativeModal = null;
    // Mobile native modal
    this.statusEl = null;
    this.timerEl = null;
    this.timerInterval = null;
    // Audio visualization
    this.visualizerCanvas = null;
    this.visualizerCtx = null;
    this.audioContext = null;
    this.analyser = null;
    this.animationId = null;
    // State change listeners
    this.listeners = /* @__PURE__ */ new Set();
    this.offlineRecordings = /* @__PURE__ */ new Map();
    var _a, _b;
    this.app = app;
    this.plugin = plugin;
    this.isInChat = (_a = options.isInChat) != null ? _a : false;
    this.onTranscriptionDone = (_b = options.onTranscriptionComplete) != null ? _b : null;
    this.platform = PlatformContext.get();
  }
  /**
   * Get the singleton instance of RecorderService
   */
  static getInstance(app, plugin, options = {}) {
    var _a, _b;
    if (!_RecorderService.instance && app && plugin) {
      _RecorderService.instance = new _RecorderService(app, plugin, options);
    } else if (_RecorderService.instance && (options.isInChat !== void 0 || options.onTranscriptionComplete)) {
      _RecorderService.instance.isInChat = (_a = options.isInChat) != null ? _a : _RecorderService.instance.isInChat;
      _RecorderService.instance.onTranscriptionDone = (_b = options.onTranscriptionComplete) != null ? _b : _RecorderService.instance.onTranscriptionDone;
    }
    return _RecorderService.instance;
  }
  /**
   * Toggle recording state (start/stop)
   */
  async toggleRecording() {
    if (this.isRecording) {
      await this.stopRecording();
    } else {
      await this.startRecording();
    }
  }
  /**
   * Start a new recording
   */
  async startRecording() {
    if (this.isRecording) {
      return;
    }
    try {
      this.showRecordingModal();
      this.updateStatus("Preparing recorder...");
      const dirPath = this.plugin.settings.recordingsDirectory || "SystemSculpt/Recordings";
      try {
        await this.plugin.directoryManager.ensureDirectoryByPath(dirPath);
        const dirExists = await this.app.vault.adapter.exists(dirPath);
        if (!dirExists) {
          throw new Error(`Failed to create recordings directory: ${dirPath}`);
        }
      } catch (error) {
        this.updateStatus(`Error with directory: ${dirPath}`);
        throw new Error(`Cannot access recordings directory. Please check settings and permissions.`);
      }
      const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-").replace("T", "_").split(".")[0];
      const mimeType = this.getSupportedMimeType();
      const extension = this.getExtensionForMimeType(mimeType);
      const outputPath = `${dirPath}/${timestamp}.${extension}`;
      this.startTimer();
      this.recorder = new MicrophoneRecorder(
        mimeType,
        extension,
        this.handleError.bind(this),
        this.updateStatus.bind(this),
        this.handleRecordingComplete.bind(this),
        this.plugin.settings.preferredMicrophoneId,
        // When stream changes (device switch), restart visualization
        (stream) => {
          try {
            this.stopVisualization();
            this.startVisualization(stream);
          } catch (e) {
          }
        }
      );
      await this.recorder.start(this.app, outputPath);
      this.isRecording = true;
      this.notifyListeners();
      setTimeout(() => {
        if (this.recorder) {
          const mediaStream = this.recorder.getMediaStream();
          if (mediaStream) {
            this.startVisualization(mediaStream);
          }
        }
      }, 100);
    } catch (error) {
      this.handleError(error instanceof Error ? error : new Error(String(error)));
    }
  }
  /**
   * Stop the current recording
   */
  async stopRecording() {
    if (!this.isRecording || !this.recorder) {
      return;
    }
    try {
      this.updateStatus("Stopping recording...");
      this.recorder.stop();
      this.isRecording = false;
      this.notifyListeners();
      this.stopTimer();
    } catch (error) {
      this.handleError(error instanceof Error ? error : new Error(String(error)));
      this.cleanup(true);
    }
  }
  /**
   * Handle recording completion
   */
  async handleRecordingComplete(filePath, audioBlob) {
    this.lastRecordingPath = filePath;
    this.storeRecordingInMemory(filePath, audioBlob);
    const isMobile = this.platform.isMobile();
    const successMessage = isMobile ? "\u{1F399}\uFE0F Recording saved securely! Transcription starting..." : `\u{1F399}\uFE0F Recording saved to ${filePath.split("/").pop()}`;
    new import_obsidian93.Notice(successMessage);
    this.hideRecordingModal();
    if (this.plugin.settings.autoTranscribeRecordings) {
      await this.transcribeRecording(filePath);
    } else {
      new import_obsidian93.Notice(`\u{1F399}\uFE0F Recording saved to ${filePath.split("/").pop()}`);
    }
  }
  /**
   * Transcribe the recorded audio using the AudioTranscriptionModal
   */
  async transcribeRecording(filePath) {
    var _a;
    try {
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (!file || !(file instanceof import_obsidian93.TFile)) {
        throw new Error("Recording file not found");
      }
      const activeLeaf = this.app.workspace.activeLeaf;
      const isCurrentlyInChat = ((_a = activeLeaf == null ? void 0 : activeLeaf.view) == null ? void 0 : _a.getViewType()) === CHAT_VIEW_TYPE;
      const modal = new AudioTranscriptionModal(
        this.app,
        {
          file,
          isChat: isCurrentlyInChat,
          onTranscriptionComplete: (text) => {
            this.handleTranscriptionComplete(text, file);
          },
          plugin: this.plugin
        }
      );
      modal.open();
    } catch (error) {
      const isMobile = this.platform.isMobile();
      const fileName = filePath.split("/").pop();
      const errorMessage = isMobile ? `\u26A0\uFE0F Transcription failed, but your recording "${fileName}" is safely saved` : `\u274C Transcription failed: ${error instanceof Error ? error.message : String(error)}`;
      new import_obsidian93.Notice(errorMessage);
      if (isMobile) {
        setTimeout(() => {
          new import_obsidian93.Notice("\u{1F4A1} You can manually transcribe the recording later from your recordings folder.", 8e3);
        }, 1500);
      }
    }
  }
  /**
   * Handle transcription completion
   */
  handleTranscriptionComplete(text, file) {
    try {
      if (this.onTranscriptionDone) {
        this.onTranscriptionDone(text);
      } else {
        new import_obsidian93.Notice("\u2713 Transcription complete. Check the transcription modal for results.");
      }
      if (!this.plugin.settings.keepRecordingsAfterTranscription) {
        this.app.vault.delete(file).catch((error) => {
        });
      }
    } catch (error) {
      new import_obsidian93.Notice(`\u274C Failed to process transcription: ${error instanceof Error ? error.message : String(error)}`);
    }
  }
  /**
   * Store recording blob in memory as backup
   */
  storeRecordingInMemory(filePath, audioBlob) {
    try {
      this.offlineRecordings.set(filePath, audioBlob);
    } catch (error) {
    }
  }
  /**
   * Show the recording modal UI
   */
  showRecordingModal() {
    this.hideRecordingModal();
    const uiVariant = this.platform.uiVariant();
    const isMobile = uiVariant === "mobile";
    if (isMobile) {
      this.showNativeRecordingModal();
    } else {
      this.showDesktopRecordingWidget(uiVariant);
    }
  }
  /**
   * Show native Obsidian modal for mobile recording
   */
  showNativeRecordingModal() {
    this.nativeModal = new RecordingModal(
      this.app,
      this.plugin,
      {
        onStop: () => {
          this.stopRecording();
        },
        onStatusUpdate: (status) => {
        }
      }
    );
    this.nativeModal.open();
  }
  /**
   * Show desktop hover widget
   */
  showDesktopRecordingWidget(uiVariant) {
    this.recordingModal = document.createElement("div");
    this.recordingModal.className = "systemsculpt-recording-modal systemsculpt-recording-modal-desktop";
    this.recordingModal.classList.add(`platform-ui-${uiVariant}`);
    this.createDesktopRecordingUI();
    document.body.appendChild(this.recordingModal);
    this.recordingModal.classList.add("recording");
    setTimeout(() => {
      if (this.recordingModal) {
        this.recordingModal.classList.add("visible");
      }
    }, 10);
  }
  /**
   * Create desktop recording UI (original hover widget)
   */
  createDesktopRecordingUI() {
    if (!this.recordingModal) return;
    const titleBar = document.createElement("div");
    titleBar.className = "systemsculpt-recording-title";
    titleBar.innerHTML = `
      <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2" fill="none"
           stroke-linecap="round" stroke-linejoin="round">
        <path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path>
        <path d="M19 10v2a7 7 0 0 1-14 0v-2"></path>
        <line x1="12" y1="19" x2="12" y2="23"></line>
        <line x1="8" y1="23" x2="16" y2="23"></line>
      </svg>
      Recording
    `;
    this.makeDraggable(this.recordingModal, titleBar);
    this.recordingModal.appendChild(titleBar);
    this.statusEl = document.createElement("div");
    this.statusEl.className = "systemsculpt-recording-status";
    this.statusEl.textContent = "Initializing...";
    this.recordingModal.appendChild(this.statusEl);
    this.timerEl = document.createElement("div");
    this.timerEl.className = "systemsculpt-recording-timer";
    this.timerEl.textContent = "00:00";
    this.recordingModal.appendChild(this.timerEl);
    this.visualizerCanvas = document.createElement("canvas");
    this.visualizerCanvas.className = "systemsculpt-recording-visualizer";
    this.visualizerCanvas.width = 270;
    this.visualizerCanvas.height = 60;
    this.recordingModal.appendChild(this.visualizerCanvas);
    this.visualizerCtx = this.visualizerCanvas.getContext("2d");
    if (this.visualizerCtx) {
      this.visualizerCtx.fillStyle = "var(--background-secondary)";
      this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    }
    const stopButton = document.createElement("button");
    stopButton.className = "systemsculpt-recording-stop";
    stopButton.innerHTML = `
      <svg viewBox="0 0 24 24" width="16" height="16" stroke="currentColor" stroke-width="2"
           fill="none" stroke-linecap="round" stroke-linejoin="round">
        <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
      </svg>
      Stop Recording
    `;
    stopButton.onclick = (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.stopRecording();
    };
    this.recordingModal.appendChild(stopButton);
  }
  /**
   * Hide and remove the recording modal
   */
  hideRecordingModal() {
    this.stopVisualization();
    if (this.nativeModal) {
      this.nativeModal.close();
      this.nativeModal = null;
    }
    if (this.recordingModal) {
      this.recordingModal.remove();
      this.recordingModal = null;
      this.statusEl = null;
      this.timerEl = null;
      this.visualizerCanvas = null;
      this.visualizerCtx = null;
    }
    this.stopTimer();
  }
  /**
   * Make an element draggable by its handle
   */
  makeDraggable(element, handle) {
    let isDragging = false;
    let offsetX = 0, offsetY = 0;
    const onMouseDown = (e) => {
      isDragging = true;
      offsetX = e.clientX - element.getBoundingClientRect().left;
      offsetY = e.clientY - element.getBoundingClientRect().top;
      document.addEventListener("mousemove", onMouseMove);
      document.addEventListener("mouseup", onMouseUp);
    };
    const onMouseMove = (e) => {
      if (!isDragging) return;
      const x = Math.max(0, Math.min(e.clientX - offsetX, window.innerWidth - element.offsetWidth));
      const y = Math.max(0, Math.min(e.clientY - offsetY, window.innerHeight - element.offsetHeight));
      element.style.left = `${x}px`;
      element.style.top = `${y}px`;
    };
    const onMouseUp = () => {
      isDragging = false;
      document.removeEventListener("mousemove", onMouseMove);
      document.removeEventListener("mouseup", onMouseUp);
    };
    handle.addEventListener("mousedown", onMouseDown);
  }
  /**
   * Update the status message in the recording modal
   */
  updateStatus(status) {
    if (this.nativeModal) {
      this.nativeModal.updateStatus(status);
    }
    if (this.statusEl) {
      this.statusEl.textContent = status;
    }
  }
  /**
   * Start the recording timer
   */
  startTimer() {
    this.recordingStartTime = Date.now();
    this.stopTimer();
    this.timerInterval = window.setInterval(() => {
      if (!this.timerEl) return;
      const elapsed = Math.floor((Date.now() - this.recordingStartTime) / 1e3);
      const minutes = Math.floor(elapsed / 60);
      const seconds = elapsed % 60;
      this.timerEl.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
    }, 1e3);
  }
  /**
   * Stop the recording timer
   */
  stopTimer() {
    if (this.timerInterval) {
      window.clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
  }
  /**
   * Start audio visualization
   */
  async startVisualization(mediaStream) {
    try {
      if (this.nativeModal) {
        await this.nativeModal.startVisualization(mediaStream);
        return;
      }
      if (!this.visualizerCanvas || !this.visualizerCtx) return;
      this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
      this.analyser = this.audioContext.createAnalyser();
      this.analyser.fftSize = 256;
      this.analyser.smoothingTimeConstant = 0.8;
      const source = this.audioContext.createMediaStreamSource(mediaStream);
      source.connect(this.analyser);
      this.drawVisualization();
    } catch (error) {
    }
  }
  /**
   * Draw the audio visualization
   */
  drawVisualization() {
    if (!this.analyser || !this.visualizerCtx || !this.visualizerCanvas) {
      return;
    }
    const bufferLength = this.analyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);
    this.analyser.getByteFrequencyData(dataArray);
    this.visualizerCtx.fillStyle = getComputedStyle(document.body).getPropertyValue("--background-secondary");
    this.visualizerCtx.fillRect(0, 0, this.visualizerCanvas.width, this.visualizerCanvas.height);
    const barWidth = this.visualizerCanvas.width / bufferLength * 2.5;
    const barSpacing = 1;
    let x = 0;
    const accentColor = getComputedStyle(document.body).getPropertyValue("--text-accent");
    const mutedAccent = getComputedStyle(document.body).getPropertyValue("--text-muted");
    for (let i = 0; i < bufferLength; i++) {
      const barHeight = dataArray[i] / 255 * this.visualizerCanvas.height * 0.8;
      const gradient = this.visualizerCtx.createLinearGradient(0, this.visualizerCanvas.height - barHeight, 0, this.visualizerCanvas.height);
      gradient.addColorStop(0, accentColor);
      gradient.addColorStop(1, mutedAccent);
      this.visualizerCtx.fillStyle = gradient;
      this.visualizerCtx.fillRect(x, this.visualizerCanvas.height - barHeight, barWidth - barSpacing, barHeight);
      x += barWidth;
      if (x > this.visualizerCanvas.width) break;
    }
    this.animationId = requestAnimationFrame(() => this.drawVisualization());
  }
  /**
   * Stop audio visualization
   */
  stopVisualization() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    if (this.audioContext) {
      this.audioContext.close().catch(() => {
      });
      this.audioContext = null;
    }
    this.analyser = null;
  }
  /**
   * Handle recording errors
   */
  handleError(error) {
    var _a;
    const isMobile = this.platform.isMobile();
    const hasBackup = this.lastRecordingPath && this.offlineRecordings.has(this.lastRecordingPath);
    let errorMessage;
    if (hasBackup) {
      errorMessage = isMobile ? "\u26A0\uFE0F Recording saved, but processing failed. Your audio is safe!" : `\u26A0\uFE0F Recording saved to ${(_a = this.lastRecordingPath) == null ? void 0 : _a.split("/").pop()}, but processing failed`;
    } else {
      errorMessage = `\u274C Recording error: ${error.message}`;
    }
    new import_obsidian93.Notice(errorMessage);
    const statusMessage = hasBackup ? "Recording saved, processing failed" : `Error: ${error.message}`;
    this.updateStatus(statusMessage);
    if (isMobile && hasBackup) {
      setTimeout(() => {
        new import_obsidian93.Notice("\u{1F4BE} Your recording is saved offline and can be transcribed later.", 5e3);
      }, 1e3);
    }
    setTimeout(() => {
      this.cleanup(true);
    }, hasBackup ? 3e3 : 2e3);
  }
  /**
   * Register a callback for recording state changes
   */
  onToggle(callback) {
    this.listeners.add(callback);
    return () => this.listeners.delete(callback);
  }
  /**
   * Notify all listeners of recording state change
   */
  notifyListeners() {
    for (const listener of this.listeners) {
      try {
        listener(this.isRecording);
      } catch (error) {
      }
    }
  }
  /**
   * Get supported MIME type for recording
   */
  getSupportedMimeType() {
    const formats = [
      "audio/webm;codecs=opus",
      "audio/webm",
      "audio/ogg;codecs=opus",
      "audio/wav"
    ];
    for (const format of formats) {
      try {
        if (MediaRecorder.isTypeSupported(format)) {
          return format;
        }
      } catch (e) {
      }
    }
    return "audio/webm";
  }
  /**
   * Get file extension for MIME type
   */
  getExtensionForMimeType(mimeType) {
    if (mimeType.includes("webm")) return "webm";
    if (mimeType.includes("ogg")) return "ogg";
    if (mimeType.includes("wav")) return "wav";
    return "audio";
  }
  /**
   * Clean up all resources
   */
  cleanup(hideUI = false) {
    if (this.recorder) {
      this.recorder.cleanup();
      this.recorder = null;
    }
    this.isRecording = false;
    this.stopTimer();
    this.stopVisualization();
    this.notifyListeners();
    if (hideUI) {
      this.hideRecordingModal();
    }
  }
  /**
   * Clean up for plugin unload
   */
  unload() {
    if (this.isRecording) {
      this.stopRecording().catch((e) => {
      });
    }
    this.cleanup(true);
    this.listeners.clear();
  }
};
_RecorderService.instance = null;
var RecorderService = _RecorderService;

// src/context-menu/FileContextMenuService.ts
var import_obsidian95 = require("obsidian");
init_fileTypes();
init_DocumentProcessingService();
init_errorLogger();

// src/modals/DocumentProcessingModal.ts
var import_obsidian94 = require("obsidian");
init_FileValidator();
var TIMELINE_ORDER = [
  "queued",
  "uploading",
  "processing",
  "contextualizing",
  "ready"
];
var STEP_LABEL2 = {
  queued: "Preparing",
  uploading: "Uploading",
  processing: "Processing",
  contextualizing: "Context",
  ready: "Ready"
};
var STAGE_TO_TIMELINE2 = {
  queued: "queued",
  validating: "queued",
  uploading: "uploading",
  processing: "processing",
  downloading: "processing",
  contextualizing: "contextualizing",
  ready: "ready",
  error: "processing"
};
var STAGE_ICON = {
  queued: "inbox",
  validating: "shield-check",
  uploading: "upload",
  processing: "cpu",
  downloading: "download",
  contextualizing: "sparkles",
  ready: "check-circle",
  complete: "check-circle",
  error: "x-circle"
};
var DocumentProcessingModal = class {
  constructor(options) {
    this.steps = /* @__PURE__ */ new Map();
    this.autoCloseTimer = null;
    this.destroyed = false;
    var _a, _b;
    this.app = options.app;
    this.file = options.file;
    this.onCancel = options.onCancel;
    this.container = document.body.createDiv({ cls: "systemsculpt-progress-modal" });
    const header = this.container.createDiv({ cls: "systemsculpt-progress-header" });
    const headerIcon = header.createDiv({ cls: "systemsculpt-progress-icon" });
    (0, import_obsidian94.setIcon)(headerIcon, "file-text");
    const headerContent = header.createDiv({ cls: "systemsculpt-progress-title" });
    headerContent.setText("Convert to Markdown");
    const fileMeta = this.container.createDiv({ cls: "systemsculpt-progress-status" });
    const fileIcon = fileMeta.createSpan({ cls: "systemsculpt-progress-status-icon" });
    (0, import_obsidian94.setIcon)(fileIcon, "file");
    const metaText = fileMeta.createSpan();
    const parts = [options.file.name];
    if (typeof ((_a = options.file.stat) == null ? void 0 : _a.size) === "number") {
      parts.push(formatFileSize(options.file.stat.size));
    }
    metaText.setText(parts.join(" \xB7 "));
    const statusRow = this.container.createDiv({ cls: "systemsculpt-progress-status" });
    this.statusIcon = statusRow.createSpan({ cls: "systemsculpt-progress-status-icon" });
    this.statusLabel = statusRow.createSpan({ cls: "systemsculpt-progress-status-text" });
    this.percentLabel = statusRow.createSpan({ cls: "systemsculpt-progress-percent" });
    const progressTrack = this.container.createDiv({
      cls: "systemsculpt-progress-bar-track"
    });
    this.progressFill = progressTrack.createDiv({ cls: "systemsculpt-progress-bar" });
    const stepsWrapper = this.container.createDiv({ cls: "systemsculpt-progress-steps" });
    TIMELINE_ORDER.forEach((step) => {
      const wrapper = stepsWrapper.createDiv({ cls: "systemsculpt-progress-step" });
      const icon = wrapper.createDiv({ cls: "systemsculpt-progress-step-icon" });
      (0, import_obsidian94.setIcon)(icon, "circle");
      const label = wrapper.createDiv({
        cls: "systemsculpt-progress-step-text",
        text: STEP_LABEL2[step]
      });
      this.steps.set(step, { wrapper, icon, label });
    });
    this.detailEl = this.container.createDiv({
      cls: "systemsculpt-progress-detail is-hidden"
    });
    this.buttonsContainer = this.container.createDiv({
      cls: "systemsculpt-progress-buttons"
    });
    this.setButtons([
      {
        label: "Hide",
        onClick: () => {
          var _a2;
          (_a2 = this.onCancel) == null ? void 0 : _a2.call(this);
          this.close();
        }
      }
    ]);
    this.updateProgress({
      stage: "queued",
      progress: 2,
      label: "Preparing conversion\u2026",
      flow: "document",
      icon: (_b = STAGE_ICON.validating) != null ? _b : "inbox"
    });
  }
  updateProgress(event) {
    var _a, _b;
    if (this.destroyed) {
      return;
    }
    const progress = clampPercentage((_a = event.progress) != null ? _a : 0);
    this.progressFill.style.width = `${progress}%`;
    this.percentLabel.setText(`${Math.round(progress)}%`);
    const icon = event.icon || STAGE_ICON[event.stage] || "loader";
    this.statusIcon.empty();
    (0, import_obsidian94.setIcon)(this.statusIcon, icon);
    this.statusLabel.setText((_b = event.label) != null ? _b : "Working\u2026");
    this.container.removeClass("is-error", "is-complete");
    this.updateSteps(event.stage);
  }
  markSuccess(payload) {
    var _a;
    if (this.destroyed) {
      return;
    }
    this.updateProgress({
      stage: "ready",
      progress: 100,
      label: "Conversion complete",
      flow: "document",
      icon: (_a = STAGE_ICON.complete) != null ? _a : "check-circle"
    });
    this.container.addClass("is-complete");
    this.detailEl.removeClass("is-hidden");
    const seconds = payload.durationMs / 1e3;
    this.detailEl.setText(
      `Saved to ${payload.extractionPath} in ${seconds.toFixed(seconds < 10 ? 1 : 0)}s.`
    );
    this.setButtons([
      {
        label: "Open Markdown",
        variant: "primary",
        onClick: async () => {
          try {
            await payload.openOutput();
          } catch (error) {
            new import_obsidian94.Notice("Unable to open converted file. See console for details.", 4e3);
          }
          this.close();
        }
      },
      {
        label: "Close",
        onClick: () => this.close()
      }
    ]);
    this.scheduleAutoClose();
  }
  markFailure(payload) {
    var _a, _b;
    if (this.destroyed) {
      return;
    }
    this.container.addClass("is-error");
    this.statusIcon.empty();
    (0, import_obsidian94.setIcon)(this.statusIcon, (_a = STAGE_ICON.error) != null ? _a : "x-circle");
    const message = payload.error instanceof Error ? payload.error.message : String((_b = payload.error) != null ? _b : "Unknown error");
    this.statusLabel.setText("Conversion failed");
    this.percentLabel.setText("");
    this.detailEl.removeClass("is-hidden");
    this.detailEl.setText(message);
    this.updateSteps("error");
    const supportsClipboard = typeof navigator !== "undefined" && Boolean(navigator.clipboard);
    const buttons = supportsClipboard ? [
      {
        label: "Copy error",
        onClick: async () => {
          try {
            await navigator.clipboard.writeText(message);
            new import_obsidian94.Notice("Error copied to clipboard", 2500);
          } catch (error) {
            console.error(error);
          }
          this.close();
        }
      },
      {
        label: "Close",
        variant: "primary",
        onClick: () => this.close()
      }
    ] : [
      {
        label: "Close",
        variant: "primary",
        onClick: () => this.close()
      }
    ];
    this.setButtons(buttons);
  }
  close() {
    if (this.destroyed) {
      return;
    }
    this.destroyed = true;
    if (this.autoCloseTimer !== null) {
      window.clearTimeout(this.autoCloseTimer);
      this.autoCloseTimer = null;
    }
    if (this.container.parentElement) {
      this.container.parentElement.removeChild(this.container);
    } else if (this.container.isConnected) {
      this.container.remove();
    }
  }
  updateSteps(stage) {
    var _a;
    const activeStep = stage === "error" ? "processing" : (_a = STAGE_TO_TIMELINE2[stage]) != null ? _a : "processing";
    const activeIndex = TIMELINE_ORDER.indexOf(activeStep);
    TIMELINE_ORDER.forEach((step, index) => {
      var _a2, _b;
      const elements = this.steps.get(step);
      if (!elements) {
        return;
      }
      elements.wrapper.removeClass("active", "completed", "error");
      if (stage === "error" && index === activeIndex) {
        elements.wrapper.addClass("error");
        elements.icon.empty();
        (0, import_obsidian94.setIcon)(elements.icon, (_a2 = STAGE_ICON.error) != null ? _a2 : "x-circle");
        return;
      }
      if (index < activeIndex) {
        elements.wrapper.addClass("completed");
        elements.icon.empty();
        (0, import_obsidian94.setIcon)(elements.icon, "check");
        return;
      }
      if (index === activeIndex) {
        elements.wrapper.addClass("active");
        elements.icon.empty();
        (0, import_obsidian94.setIcon)(elements.icon, (_b = STAGE_ICON[stage]) != null ? _b : "loader");
        return;
      }
      elements.icon.empty();
      (0, import_obsidian94.setIcon)(elements.icon, "circle");
    });
  }
  setButtons(descriptors) {
    this.buttonsContainer.empty();
    descriptors.forEach((descriptor) => {
      const button = this.buttonsContainer.createEl("button", {
        cls: "systemsculpt-progress-button" + (descriptor.variant === "primary" ? " primary" : ""),
        text: descriptor.label
      });
      button.addEventListener("click", descriptor.onClick);
    });
  }
  scheduleAutoClose() {
    if (this.autoCloseTimer !== null) {
      window.clearTimeout(this.autoCloseTimer);
    }
    this.autoCloseTimer = window.setTimeout(() => this.close(), 6e3);
  }
};
var launchDocumentProcessingModal = (options) => {
  const modal = new DocumentProcessingModal(options);
  options.plugin.register(() => modal.close());
  return modal;
};
function clampPercentage(value) {
  if (!Number.isFinite(value)) {
    return value > 0 ? 100 : 0;
  }
  return Math.min(100, Math.max(0, value));
}

// src/context-menu/FileContextMenuService.ts
var CHAT_TEXT_EXTENSIONS = /* @__PURE__ */ new Set(["md", "txt", "markdown"]);
var CHAT_IMAGE_EXTENSIONS = /* @__PURE__ */ new Set([
  "jpg",
  "jpeg",
  "png",
  "gif",
  "webp",
  "svg"
]);
var CONVERT_MENU_TITLE = "Convert to Markdown";
var DefaultChatWithFileLauncher = class {
  constructor(app, plugin) {
    this.app = app;
    this.plugin = plugin;
  }
  async open(file) {
    const leaf = this.app.workspace.getLeaf("tab");
    const view = new ChatView(leaf, this.plugin);
    await leaf.open(view);
    await this.focusLeaf(leaf);
    await view.addFileToContext(file);
  }
  async focusLeaf(leaf) {
    await new Promise((resolve) => setTimeout(resolve, 50));
    this.app.workspace.setActiveLeaf(leaf, { focus: true });
  }
};
var FileContextMenuService = class {
  constructor(options) {
    this.eventRefs = [];
    this.started = false;
    this.awaitingLayoutReady = false;
    this.cleanupRegistered = false;
    var _a, _b, _c, _d;
    this.app = options.app;
    this.plugin = options.plugin;
    this.documentProcessor = (_a = options.documentProcessor) != null ? _a : DocumentProcessingService.getInstance(this.app, this.plugin);
    this.chatLauncher = (_b = options.chatLauncher) != null ? _b : new DefaultChatWithFileLauncher(this.app, this.plugin);
    this.pluginLogger = (_c = options.pluginLogger) != null ? _c : typeof this.plugin.getPluginLogger === "function" ? this.plugin.getPluginLogger() : null;
    this.launchProcessingModal = (_d = options.launchProcessingModal) != null ? _d : ((modalOptions) => {
      var _a2, _b2;
      return launchDocumentProcessingModal({
        app: (_a2 = modalOptions.app) != null ? _a2 : this.app,
        plugin: (_b2 = modalOptions.plugin) != null ? _b2 : this.plugin,
        file: modalOptions.file,
        onCancel: modalOptions.onCancel,
        source: modalOptions.source
      });
    });
    this.start();
  }
  start() {
    if (this.started) {
      return;
    }
    if (!this.cleanupRegistered) {
      this.plugin.register(() => this.stop());
      this.cleanupRegistered = true;
    }
    const workspaceAny = this.app.workspace;
    const bindHandlers = () => {
      if (this.started) {
        return;
      }
      const fileRef = this.app.workspace.on(
        "file-menu",
        (menu, file, source, leaf) => this.handleFileMenu(menu, file, source, leaf)
      );
      const filesRef = this.app.workspace.on(
        "files-menu",
        (menu, files, source, leaf) => this.handleFilesMenu(menu, files, source, leaf)
      );
      this.eventRefs = [fileRef, filesRef];
      this.eventRefs.forEach((ref) => this.plugin.registerEvent(ref));
      this.started = true;
      this.awaitingLayoutReady = false;
      this.info("File context menu service started", {
        layoutReady: Boolean(workspaceAny == null ? void 0 : workspaceAny.layoutReady)
      });
    };
    if (workspaceAny == null ? void 0 : workspaceAny.layoutReady) {
      bindHandlers();
      return;
    }
    if (typeof (workspaceAny == null ? void 0 : workspaceAny.onLayoutReady) === "function") {
      if (this.awaitingLayoutReady) {
        this.debug("Layout ready listener already registered");
        return;
      }
      this.awaitingLayoutReady = true;
      workspaceAny.onLayoutReady(() => {
        this.awaitingLayoutReady = false;
        bindHandlers();
      });
      this.info("File context menu service awaiting layout ready", {
        layoutReady: false
      });
      return;
    }
    this.debug("Workspace missing onLayoutReady hook, binding immediately", {
      typeofOnLayoutReady: typeof (workspaceAny == null ? void 0 : workspaceAny.onLayoutReady)
    });
    bindHandlers();
  }
  stop() {
    if (!this.started) {
      return;
    }
    for (const ref of this.eventRefs) {
      this.app.workspace.offref(ref);
    }
    this.eventRefs = [];
    this.started = false;
    this.awaitingLayoutReady = false;
    this.cleanupRegistered = false;
    this.info("File context menu service stopped");
  }
  handleFileMenu(menu, file, source, leaf) {
    var _a;
    if (!(file instanceof import_obsidian95.TFile)) {
      return;
    }
    this.populateMenu(menu, file, { source, leafType: (_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.getViewType() });
  }
  handleFilesMenu(menu, files, source, leaf) {
    var _a, _b, _c;
    this.info("Files menu opened", {
      source,
      leafType: (_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.getViewType(),
      selectionCount: files.length
    });
    const convertibleFiles = files.filter(
      (candidate) => candidate instanceof import_obsidian95.TFile && this.hasAnyActions(candidate)
    );
    if (convertibleFiles.length !== 1) {
      this.info("Skipping SystemSculpt menu for selection", {
        source,
        leafType: (_b = leaf == null ? void 0 : leaf.view) == null ? void 0 : _b.getViewType(),
        selectionCount: files.length,
        convertibleCount: convertibleFiles.length
      });
      return;
    }
    this.populateMenu(menu, convertibleFiles[0], {
      source,
      leafType: (_c = leaf == null ? void 0 : leaf.view) == null ? void 0 : _c.getViewType(),
      multiSelectCount: files.length
    });
  }
  populateMenu(menu, file, context) {
    const extension = normalizeFileExtension(file.extension);
    this.logMenuOpen(file, extension, context);
    const shouldChat = this.shouldOfferChatWithFile(extension);
    const shouldConvertDocument = isDocumentFileExtension(extension);
    const shouldConvertAudio = isAudioFileExtension(extension);
    this.debug("Evaluating menu population", {
      filePath: file.path,
      extension,
      source: context.source,
      leafType: context.leafType,
      multiSelectCount: context.multiSelectCount,
      shouldChat,
      shouldConvertDocument,
      shouldConvertAudio
    });
    if (!shouldChat && !shouldConvertDocument && !shouldConvertAudio) {
      return;
    }
    menu.setUseNativeMenu(false);
    menu.addSeparator();
    if (shouldChat) {
      this.addChatWithFileMenuItem(menu, file, context);
    }
    if (shouldConvertDocument) {
      this.addProcessIntoMarkdownMenuItem(menu, file, "document", context);
    }
    if (shouldConvertAudio) {
      this.addProcessIntoMarkdownMenuItem(menu, file, "audio", context);
    }
  }
  logMenuOpen(file, extension, context) {
    var _a;
    this.info("File menu opened", {
      filePath: file.path,
      extension,
      rawExtension: file.extension,
      source: context.source,
      leafType: context.leafType,
      multiSelectCount: (_a = context.multiSelectCount) != null ? _a : 1
    });
  }
  shouldOfferChatWithFile(extension) {
    if (!extension) {
      return false;
    }
    return CHAT_TEXT_EXTENSIONS.has(extension) || isDocumentFileExtension(extension) || isAudioFileExtension(extension) || CHAT_IMAGE_EXTENSIONS.has(extension);
  }
  hasAnyActions(file) {
    const ext = normalizeFileExtension(file.extension);
    return this.shouldOfferChatWithFile(ext) || isDocumentFileExtension(ext) || isAudioFileExtension(ext);
  }
  addChatWithFileMenuItem(menu, file, context) {
    menu.addItem((item) => {
      item.setTitle("SystemSculpt - Chat with File").setIcon("message-square").setSection("systemsculpt").onClick(async () => {
        this.info("Chat with file triggered", {
          filePath: file.path,
          source: context.source
        });
        try {
          await this.chatLauncher.open(file);
          this.info("Chat with file completed", { filePath: file.path });
        } catch (error) {
          this.error("Chat with file failed", error, { filePath: file.path });
          new import_obsidian95.Notice("Failed to open chat with file", 5e3);
        }
      });
    });
  }
  addProcessIntoMarkdownMenuItem(menu, file, flow, context) {
    const hasValidLicense = this.hasValidProcessingLicense();
    const title = flow === "document" ? this.buildConvertMenuTitle(hasValidLicense) : this.buildAudioMenuTitle(hasValidLicense);
    const icon = flow === "document" ? "file-text" : "file-audio";
    menu.addItem((item) => {
      item.setTitle(title).setIcon(icon).setSection("systemsculpt").onClick(async () => {
        this.info("Convert to Markdown triggered", {
          filePath: file.path,
          flow,
          hasValidLicense,
          source: context.source
        });
        if (flow === "document") {
          await this.handleDocumentConversion(file);
        } else {
          await this.handleAudioConversion(file);
        }
      });
    });
  }
  hasValidProcessingLicense() {
    var _a;
    const { licenseKey, licenseValid } = (_a = this.plugin.settings) != null ? _a : {};
    return Boolean((licenseKey == null ? void 0 : licenseKey.trim()) && licenseValid);
  }
  buildConvertMenuTitle(hasValidLicense) {
    return hasValidLicense ? CONVERT_MENU_TITLE : `${CONVERT_MENU_TITLE} (Pro)`;
  }
  buildAudioMenuTitle(hasValidLicense) {
    const base = "Convert Audio to Markdown";
    return hasValidLicense ? base : `${base} (Pro)`;
  }
  async handleDocumentConversion(file) {
    const startedAt = Date.now();
    this.info("Document conversion started", { filePath: file.path });
    let modalHandle = null;
    try {
      modalHandle = this.launchProcessingModal({
        app: this.app,
        plugin: this.plugin,
        file,
        source: "context-menu"
      });
      const extractionPath = await this.documentProcessor.processDocument(file, {
        onProgress: (event) => {
          this.handleProgressEvent(file, event);
          modalHandle == null ? void 0 : modalHandle.updateProgress(event);
        },
        showNotices: false,
        addToContext: false,
        flow: "document"
      });
      const durationMs = Date.now() - startedAt;
      await this.handleDocumentSuccess(file, extractionPath, durationMs);
      const openOutput = async () => {
        await this.openExtractionFile(extractionPath);
      };
      modalHandle == null ? void 0 : modalHandle.markSuccess({
        extractionPath,
        durationMs,
        file,
        openOutput
      });
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      this.error("Document conversion failed", error, {
        filePath: file.path
      });
      modalHandle == null ? void 0 : modalHandle.markFailure({
        error,
        file
      });
      if (message == null ? void 0 : message.toLowerCase().includes("license")) {
        new import_obsidian95.Notice(
          "Document conversion requires an active SystemSculpt Pro license.",
          6e3
        );
        return;
      }
      new import_obsidian95.Notice(`Document conversion failed: ${message}`, 6e3);
    }
  }
  handleProgressEvent(file, event) {
    this.debug("Document conversion progress", {
      filePath: file.path,
      stage: event.stage,
      progress: event.progress,
      label: event.label
    });
  }
  async handleDocumentSuccess(file, extractionPath, durationMs) {
    this.info("Document conversion complete", {
      filePath: file.path,
      extractionPath,
      durationMs
    });
    new import_obsidian95.Notice(`Converted ${file.name} to Markdown`, 4e3);
    const output = await this.openExtractionFile(extractionPath);
    return output;
  }
  async openExtractionFile(extractionPath) {
    const output = this.app.vault.getAbstractFileByPath(extractionPath);
    if (!(output instanceof import_obsidian95.TFile)) {
      return null;
    }
    const leaf = this.app.workspace.getLeaf("tab");
    await leaf.openFile(output);
    this.app.workspace.setActiveLeaf(leaf, { focus: true });
    return output;
  }
  async handleAudioConversion(file) {
    this.info("Audio conversion started", { filePath: file.path });
    try {
      await this.handleAudioTranscription(file, true);
      this.info("Audio conversion completed", { filePath: file.path });
    } catch (error) {
      this.error("Audio conversion failed", error, { filePath: file.path });
      new import_obsidian95.Notice("Audio conversion failed. Check logs for details.", 6e3);
    }
  }
  async handleAudioTranscription(file, timestamped) {
    await showAudioTranscriptionModal(this.app, {
      file,
      timestamped,
      plugin: this.plugin,
      onTranscriptionComplete: async (text) => {
        var _a;
        const baseName = file.basename;
        const fileExtension = timestamped ? "srt" : "md";
        const outputPath = `${((_a = file.parent) == null ? void 0 : _a.path) || ""}/${baseName}.${fileExtension}`;
        const content = text;
        const existingFile = this.app.vault.getAbstractFileByPath(outputPath);
        let transcriptionFile;
        if (existingFile instanceof import_obsidian95.TFile) {
          await this.app.vault.modify(existingFile, content);
          transcriptionFile = existingFile;
        } else {
          transcriptionFile = await this.app.vault.create(outputPath, content);
        }
        const leaf = this.app.workspace.getLeaf("tab");
        await leaf.openFile(transcriptionFile);
        this.app.workspace.setActiveLeaf(leaf, { focus: true });
      }
    });
  }
  info(message, metadata) {
    var _a;
    errorLogger.info(message, {
      source: "FileContextMenuService",
      metadata
    });
    (_a = this.pluginLogger) == null ? void 0 : _a.info(message, {
      source: "FileContextMenuService",
      metadata
    });
  }
  debug(message, metadata) {
    var _a;
    errorLogger.debug(message, {
      source: "FileContextMenuService",
      metadata
    });
    (_a = this.pluginLogger) == null ? void 0 : _a.debug(message, {
      source: "FileContextMenuService",
      metadata
    });
  }
  error(message, error, metadata) {
    errorLogger.error(message, error, {
      source: "FileContextMenuService",
      metadata
    });
    if (this.pluginLogger) {
      this.pluginLogger.error(
        message,
        void 0,
        {
          source: "FileContextMenuService",
          metadata: {
            ...metadata != null ? metadata : {},
            error: error instanceof Error ? error.message : String(error)
          }
        }
      );
    }
  }
};

// src/core/settings/SettingsManager.ts
init_types();
init_agent();

// src/core/settings/AutomaticBackupService.ts
var import_obsidian96 = require("obsidian");
var AutomaticBackupService = class {
  // Check every hour
  constructor(plugin) {
    this.backupTimer = null;
    this.CHECK_INTERVAL_MS = 60 * 60 * 1e3;
    this.plugin = plugin;
  }
  /**
   * Start the automatic backup service
   */
  start() {
    this.stop();
    this.backupTimer = setInterval(() => {
      this.checkAndCreateBackup();
    }, this.CHECK_INTERVAL_MS);
    this.checkAndCreateBackup();
  }
  /**
   * Stop the automatic backup service
   */
  stop() {
    if (this.backupTimer) {
      clearInterval(this.backupTimer);
      this.backupTimer = null;
    }
  }
  /**
   * Check if a backup is needed and create one if so
   */
  async checkAndCreateBackup() {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      if (!settings.automaticBackupsEnabled) {
        return;
      }
      const now = Date.now();
      const intervalMs = settings.automaticBackupInterval * 60 * 60 * 1e3;
      const lastBackup = settings.lastAutomaticBackup;
      if (now - lastBackup >= intervalMs) {
        await this.createAutomaticBackup();
      }
    } catch (error) {
    }
  }
  /**
   * Force create an automatic backup now
   */
  async createAutomaticBackup() {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const backupData = {
        ...settings,
        _backupMeta: {
          type: "automatic",
          timestamp: Date.now(),
          createdAt: (/* @__PURE__ */ new Date()).toISOString(),
          version: "1.0"
        }
      };
      const dateStr = (/* @__PURE__ */ new Date()).toISOString().split("T")[0];
      const fileName = `settings-backup-${dateStr}.json`;
      await this.saveBackupToMultipleLocations(fileName, backupData);
      await this.plugin.getSettingsManager().updateSettings({
        lastAutomaticBackup: Date.now()
      });
      await this.cleanupOldBackups();
      return true;
    } catch (error) {
      new import_obsidian96.Notice("Failed to create automatic settings backup", 3e3);
      return false;
    }
  }
  /**
   * Save backup to multiple locations for redundancy
   */
  async saveBackupToMultipleLocations(fileName, backupData) {
    const backupJson = JSON.stringify(backupData, null, 2);
    const errors = [];
    try {
      const backupDir = ".systemsculpt/settings-backups";
      try {
        await this.plugin.app.vault.createFolder(backupDir);
      } catch (e) {
      }
      const backupPath = `.systemsculpt/settings-backups/${fileName}`;
      await this.plugin.app.vault.adapter.write(backupPath, backupJson);
    } catch (error) {
      errors.push(`Vault backup directory: ${error}`);
    }
    try {
      if (this.plugin.storage) {
        await this.plugin.storage.writeFile("settings", `backups/${fileName}`, backupData);
      }
    } catch (error) {
      errors.push(`Vault storage: ${error}`);
    }
    if (errors.length === 2) {
      throw new Error(`Failed to save backup to any location: ${errors.join(", ")}`);
    }
  }
  /**
   * Clean up old automatic backups based on retention settings
   */
  async cleanupOldBackups() {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const retentionMs = settings.automaticBackupRetentionDays * 24 * 60 * 60 * 1e3;
      const cutoffTime = Date.now() - retentionMs;
      await this.cleanupVaultRootBackups(cutoffTime);
      await this.cleanupVaultStorageBackups(cutoffTime);
    } catch (error) {
    }
  }
  /**
   * Clean up old backups from vault root directory
   */
  async cleanupVaultRootBackups(cutoffTime) {
    try {
      const backupDir = ".systemsculpt/settings-backups";
      const exists = await this.plugin.app.vault.adapter.exists(backupDir);
      if (!exists) {
        return;
      }
      const files = await this.plugin.app.vault.adapter.list(backupDir);
      const automaticBackupFiles = files.files.filter(
        (f) => f.includes("settings-backup-") && f.endsWith(".json") && !f.includes("latest") && !f.includes("manual") && !f.includes("emergency") && f.match(/settings-backup-\d{4}-\d{2}-\d{2}\.json$/)
        // Only date-based automatic backups
      );
      for (const filePath of automaticBackupFiles) {
        try {
          const stats = await this.plugin.app.vault.adapter.stat(filePath);
          if (stats && stats.mtime < cutoffTime) {
            await this.plugin.app.vault.adapter.remove(filePath);
          }
        } catch (error) {
        }
      }
    } catch (error) {
    }
  }
  /**
   * Clean up old backups from vault storage
   */
  async cleanupVaultStorageBackups(cutoffTime) {
    try {
      if (!this.plugin.storage) {
        return;
      }
      const backupFiles = await this.plugin.storage.listFiles("settings", "backups");
      const automaticBackupFiles = backupFiles.filter(
        (f) => f.startsWith("settings-backup-") && f.endsWith(".json") && !f.includes("latest") && !f.includes("manual") && !f.includes("emergency")
      );
      for (const fileName of automaticBackupFiles) {
        try {
          const dateMatch = fileName.match(/settings-backup-(\d{4}-\d{2}-\d{2})\.json/);
          if (dateMatch) {
            const backupDate = new Date(dateMatch[1]).getTime();
            if (backupDate < cutoffTime) {
              await this.plugin.storage.deleteFile("settings", `backups/${fileName}`);
            }
          }
        } catch (error) {
        }
      }
    } catch (error) {
    }
  }
  /**
   * Get the status of the automatic backup system
   */
  getBackupStatus() {
    const settings = this.plugin.getSettingsManager().getSettings();
    const nextBackup = settings.lastAutomaticBackup + settings.automaticBackupInterval * 60 * 60 * 1e3;
    return {
      enabled: settings.automaticBackupsEnabled,
      lastBackup: settings.lastAutomaticBackup,
      nextBackup,
      intervalHours: settings.automaticBackupInterval,
      retentionDays: settings.automaticBackupRetentionDays
    };
  }
};

// src/core/settings/SettingsManager.ts
var SettingsManager = class {
  constructor(plugin) {
    this.isInitialized = false;
    this.ongoingBackup = null;
    this.backupQueue = [];
    this.isProcessingBackupQueue = false;
    this.plugin = plugin;
    this.settings = DEFAULT_SETTINGS;
    this.automaticBackupService = new AutomaticBackupService(plugin);
  }
  // Migrate settings to ensure all fields are properly initialized
  migrateSettings(settingsToMigrate) {
    const migratedSettings = { ...settingsToMigrate };
    if (!migratedSettings.settingsMode || migratedSettings.settingsMode !== "standard" && migratedSettings.settingsMode !== "advanced") {
      migratedSettings.settingsMode = DEFAULT_SETTINGS.settingsMode;
    }
    if ("cachedEmbeddingStats" in migratedSettings) {
      delete migratedSettings.cachedEmbeddingStats;
    }
    if (!migratedSettings.favoritesFilterSettings) {
      migratedSettings.favoritesFilterSettings = DEFAULT_SETTINGS.favoritesFilterSettings;
    }
    if (!migratedSettings.modelFilterSettings) {
      migratedSettings.modelFilterSettings = DEFAULT_SETTINGS.modelFilterSettings;
    }
    if (!migratedSettings.activeProvider) {
      migratedSettings.activeProvider = DEFAULT_SETTINGS.activeProvider;
    }
    if (!Array.isArray(migratedSettings.customProviders)) {
      migratedSettings.customProviders = DEFAULT_SETTINGS.customProviders;
    }
    if (!Array.isArray(migratedSettings.favoriteModels)) {
      migratedSettings.favoriteModels = DEFAULT_SETTINGS.favoriteModels;
    }
    if (!Array.isArray(migratedSettings.mcpEnabledTools)) {
      migratedSettings.mcpEnabledTools = DEFAULT_SETTINGS.mcpEnabledTools;
    }
    if (!Array.isArray(migratedSettings.mcpAutoAcceptTools)) {
      migratedSettings.mcpAutoAcceptTools = DEFAULT_SETTINGS.mcpAutoAcceptTools;
    }
    if (!Array.isArray(migratedSettings.mcpServers)) {
      migratedSettings.mcpServers = DEFAULT_SETTINGS.mcpServers;
    }
    if (typeof migratedSettings.debugMode !== "boolean") {
      migratedSettings.debugMode = DEFAULT_SETTINGS.debugMode;
    }
    if (typeof migratedSettings.logLevel !== "number") {
      migratedSettings.logLevel = DEFAULT_SETTINGS.logLevel;
    } else if (!migratedSettings.debugMode && migratedSettings.logLevel > 1 /* WARNING */) {
      migratedSettings.logLevel = 1 /* WARNING */;
    }
    if ("excludedFolders" in migratedSettings) {
      delete migratedSettings.excludedFolders;
    }
    if ("excludedFiles" in migratedSettings) {
      delete migratedSettings.excludedFiles;
    }
    if (!Array.isArray(migratedSettings.favoriteChats)) {
      migratedSettings.favoriteChats = DEFAULT_SETTINGS.favoriteChats;
    }
    if (typeof migratedSettings.automaticBackupsEnabled !== "boolean") {
      migratedSettings.automaticBackupsEnabled = DEFAULT_SETTINGS.automaticBackupsEnabled;
    }
    if (typeof migratedSettings.automaticBackupInterval !== "number") {
      migratedSettings.automaticBackupInterval = DEFAULT_SETTINGS.automaticBackupInterval;
    }
    if (typeof migratedSettings.automaticBackupRetentionDays !== "number") {
      migratedSettings.automaticBackupRetentionDays = DEFAULT_SETTINGS.automaticBackupRetentionDays;
    }
    if (typeof migratedSettings.lastAutomaticBackup !== "number") {
      migratedSettings.lastAutomaticBackup = DEFAULT_SETTINGS.lastAutomaticBackup;
    }
    if (!Array.isArray(migratedSettings.selectedModelProviders)) {
      migratedSettings.selectedModelProviders = DEFAULT_SETTINGS.selectedModelProviders;
    }
    if (typeof migratedSettings.preserveReasoningVerbatim !== "boolean") {
      migratedSettings.preserveReasoningVerbatim = DEFAULT_SETTINGS.preserveReasoningVerbatim;
    }
    return migratedSettings;
  }
  /**
   * Load settings from Obsidian's data storage
   * Implements robust error handling to prevent settings loss
   */
  /**
   * Attempt to restore settings from the latest backup
   * Checks both the new vault-based location and the old plugin directory location
   * @returns The restored settings or null if restoration failed
   */
  async restoreFromBackup() {
    try {
      if (this.plugin.storage) {
        try {
          const latestBackup = await this.plugin.storage.readFile("settings", "backups/settings-backup-latest.json", true);
          if (latestBackup) {
            return latestBackup;
          }
          const backupFiles = await this.plugin.storage.listFiles("settings", "backups");
          const dailyBackups = backupFiles.filter((f) => f.match(/settings-backup-\d{4}-\d{2}-\d{2}\.json$/)).sort().reverse();
          if (dailyBackups.length > 0) {
            const newestBackup = await this.plugin.storage.readFile("settings", `backups/${dailyBackups[0]}`, true);
            if (newestBackup) {
              return newestBackup;
            }
          }
        } catch (e) {
        }
      }
      const backupDir = ".systemsculpt/settings-backups";
      const latestBackupPath = ".systemsculpt/settings-backups/settings-backup-latest.json";
      const exists = await this.plugin.app.vault.adapter.exists(latestBackupPath);
      if (exists) {
        const backupData = await this.plugin.app.vault.adapter.read(latestBackupPath);
        const backupSettings = JSON.parse(backupData);
        return backupSettings;
      }
      try {
        const files = await this.plugin.app.vault.adapter.list(backupDir);
        const backupFiles = files.files.filter((f) => f.match(/settings-backup-\d{4}-\d{2}-\d{2}\.json$/)).sort().reverse();
        if (backupFiles.length > 0) {
          const newestBackup = backupFiles[0];
          const backupData = await this.plugin.app.vault.adapter.read(newestBackup);
          const backupSettings = JSON.parse(backupData);
          return backupSettings;
        }
      } catch (e) {
      }
      return null;
    } catch (error) {
      return null;
    }
  }
  async loadSettings() {
    let loadedData = null;
    try {
      loadedData = await this.plugin.loadData();
      if (!loadedData) {
        this.settings = { ...DEFAULT_SETTINGS };
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      } else {
        let mergedSettings = { ...DEFAULT_SETTINGS, ...loadedData };
        mergedSettings = this.migrateSettings(mergedSettings);
        this.settings = await this.validateSettingsAsync(mergedSettings);
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      }
    } catch (loadError) {
      const backupSettings = await this.restoreFromBackup();
      if (backupSettings) {
        let restored = this.migrateSettings(backupSettings);
        this.settings = await this.validateSettingsAsync(restored);
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      } else {
        this.settings = { ...DEFAULT_SETTINGS };
        this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
        this.isInitialized = true;
        await this.saveSettings();
      }
    }
    this.plugin.app.workspace.trigger("systemsculpt:settings-loaded", this.settings);
    this.automaticBackupService.start();
  }
  /**
   * Validate settings to ensure critical fields are present and properly formatted
   * @param settings The settings object to validate
   * @returns The validated settings object
   */
  validateSettings(settings) {
    const validatedSettings = { ...settings };
    if (validatedSettings.settingsMode !== "standard" && validatedSettings.settingsMode !== "advanced") {
      validatedSettings.settingsMode = DEFAULT_SETTINGS.settingsMode;
    }
    const defaultSettings = DEFAULT_SETTINGS;
    if (!Array.isArray(validatedSettings.customProviders)) {
      validatedSettings.customProviders = [];
    }
    if (!Array.isArray(validatedSettings.favoriteModels)) {
      validatedSettings.favoriteModels = [];
    }
    if (!Array.isArray(validatedSettings.mcpEnabledTools)) {
      validatedSettings.mcpEnabledTools = defaultSettings.mcpEnabledTools;
    } else {
      const originalLength = validatedSettings.mcpEnabledTools.length;
      validatedSettings.mcpEnabledTools = [...new Set(validatedSettings.mcpEnabledTools)];
      const deduplicatedLength = validatedSettings.mcpEnabledTools.length;
      if (originalLength !== deduplicatedLength) {
      }
    }
    if (!Array.isArray(validatedSettings.mcpAutoAcceptTools)) {
      validatedSettings.mcpAutoAcceptTools = defaultSettings.mcpAutoAcceptTools;
    } else {
      const originalLength = validatedSettings.mcpAutoAcceptTools.length;
      validatedSettings.mcpAutoAcceptTools = [...new Set(validatedSettings.mcpAutoAcceptTools)];
      const deduplicatedLength = validatedSettings.mcpAutoAcceptTools.length;
      if (originalLength !== deduplicatedLength) {
      }
    }
    if (typeof validatedSettings.chatsDirectory !== "string") {
      validatedSettings.chatsDirectory = defaultSettings.chatsDirectory;
    }
    if (typeof validatedSettings.recordingsDirectory !== "string") {
      validatedSettings.recordingsDirectory = defaultSettings.recordingsDirectory;
    }
    if (typeof validatedSettings.attachmentsDirectory !== "string") {
      validatedSettings.attachmentsDirectory = defaultSettings.attachmentsDirectory;
    }
    if (typeof validatedSettings.extractionsDirectory !== "string") {
      validatedSettings.extractionsDirectory = defaultSettings.extractionsDirectory;
    }
    if (typeof validatedSettings.systemPromptsDirectory !== "string") {
      validatedSettings.systemPromptsDirectory = defaultSettings.systemPromptsDirectory;
    }
    if (typeof validatedSettings.savedChatsDirectory !== "string") {
      validatedSettings.savedChatsDirectory = defaultSettings.savedChatsDirectory;
    }
    if (typeof validatedSettings.licenseValid !== "boolean") {
      validatedSettings.licenseValid = defaultSettings.licenseValid;
    }
    if (typeof validatedSettings.autoTranscribeRecordings !== "boolean") {
      validatedSettings.autoTranscribeRecordings = defaultSettings.autoTranscribeRecordings;
    }
    if (typeof validatedSettings.autoPasteTranscription !== "boolean") {
      validatedSettings.autoPasteTranscription = defaultSettings.autoPasteTranscription;
    }
    if (typeof validatedSettings.keepRecordingsAfterTranscription !== "boolean") {
      validatedSettings.keepRecordingsAfterTranscription = defaultSettings.keepRecordingsAfterTranscription;
    }
    if (typeof validatedSettings.postProcessingEnabled !== "boolean") {
      validatedSettings.postProcessingEnabled = defaultSettings.postProcessingEnabled;
    }
    if (typeof validatedSettings.cleanTranscriptionOutput !== "boolean") {
      validatedSettings.cleanTranscriptionOutput = defaultSettings.cleanTranscriptionOutput;
    }
    if (typeof validatedSettings.skipEmptyNoteWarning !== "boolean") {
      validatedSettings.skipEmptyNoteWarning = defaultSettings.skipEmptyNoteWarning;
    }
    if (typeof validatedSettings.automaticTitleGeneration !== "boolean") {
      validatedSettings.automaticTitleGeneration = defaultSettings.automaticTitleGeneration;
    }
    if (typeof validatedSettings.enableTemplateHotkey !== "boolean") {
      validatedSettings.enableTemplateHotkey = defaultSettings.enableTemplateHotkey;
    }
    if ("autoUpdateSimilarNotes" in validatedSettings) {
      delete validatedSettings.autoUpdateSimilarNotes;
    }
    if ("hideSimilarNotesAlreadyInContext" in validatedSettings) {
      delete validatedSettings.hideSimilarNotesAlreadyInContext;
    }
    if ("backgroundEmbeddingUpdates" in validatedSettings) {
      delete validatedSettings.backgroundEmbeddingUpdates;
    }
    if (typeof validatedSettings.embeddingsEnabled !== "boolean") {
      validatedSettings.embeddingsEnabled = defaultSettings.embeddingsEnabled;
    }
    if (typeof validatedSettings.selectedModelId !== "string") {
      validatedSettings.selectedModelId = defaultSettings.selectedModelId;
    }
    if (!validatedSettings.selectedModelId || validatedSettings.selectedModelId.trim().length === 0) {
      validatedSettings.selectedModelId = AGENT_CONFIG.MODEL_ID;
    }
    if (typeof validatedSettings.titleGenerationModelId !== "string") {
      validatedSettings.titleGenerationModelId = defaultSettings.titleGenerationModelId;
    }
    if (typeof validatedSettings.licenseKey !== "string") {
      validatedSettings.licenseKey = defaultSettings.licenseKey;
    }
    if (!validatedSettings.openAiApiKey) {
      validatedSettings.openAiApiKey = "";
    }
    if (typeof validatedSettings.systemPromptType !== "string") {
      validatedSettings.systemPromptType = defaultSettings.systemPromptType;
    }
    if (validatedSettings.systemPromptType === "agent") {
      validatedSettings.systemPromptType = "general-use";
      validatedSettings.systemPromptPath = "";
    }
    if (!validatedSettings.activeProvider || typeof validatedSettings.activeProvider !== "object" || !validatedSettings.activeProvider.id || !validatedSettings.activeProvider.name || !validatedSettings.activeProvider.type) {
      validatedSettings.activeProvider = { ...defaultSettings.activeProvider };
    }
    if (!validatedSettings.favoritesFilterSettings || typeof validatedSettings.favoritesFilterSettings !== "object") {
      validatedSettings.favoritesFilterSettings = { ...defaultSettings.favoritesFilterSettings };
    } else {
      if (typeof validatedSettings.favoritesFilterSettings.showFavoritesOnly !== "boolean") {
        validatedSettings.favoritesFilterSettings.showFavoritesOnly = defaultSettings.favoritesFilterSettings.showFavoritesOnly;
      }
      if (typeof validatedSettings.favoritesFilterSettings.favoritesFirst !== "boolean") {
        validatedSettings.favoritesFilterSettings.favoritesFirst = defaultSettings.favoritesFilterSettings.favoritesFirst;
      }
      if (typeof validatedSettings.favoritesFilterSettings.modelSortOrder !== "string") {
        validatedSettings.favoritesFilterSettings.modelSortOrder = defaultSettings.favoritesFilterSettings.modelSortOrder;
      }
    }
    if ("cachedEmbeddingStats" in validatedSettings) {
      delete validatedSettings.cachedEmbeddingStats;
    }
    const currentServerUrl = validatedSettings.serverUrl;
    const { API_BASE_URL: API_BASE_URL2 } = (init_api(), __toCommonJS(api_exports));
    const correctUrl = API_BASE_URL2.replace("/api/v1", "");
    if (typeof currentServerUrl !== "string" || currentServerUrl.trim() === "") {
      validatedSettings.serverUrl = correctUrl;
    } else if (currentServerUrl.includes("localhost") && correctUrl.includes("api.systemsculpt.com")) {
      validatedSettings.serverUrl = correctUrl;
    } else if (currentServerUrl.includes("api.systemsculpt.com") && correctUrl.includes("localhost")) {
      validatedSettings.serverUrl = correctUrl;
    } else {
    }
    return validatedSettings;
  }
  /**
   * Create a backup of the current settings
   * This provides a safety net in case the main settings file becomes corrupted
   * Uses the vault-based .systemsculpt directory for backups
   */
  async backupSettings() {
    if (!this.isInitialized || !this.settings) return;
    try {
      const backupData = JSON.stringify(this.settings, null, 2);
      const backupDir = ".systemsculpt/settings-backups";
      const backupPath = ".systemsculpt/settings-backups/settings-backup-latest.json";
      const dirExists = await this.plugin.app.vault.adapter.exists(backupDir);
      if (!dirExists) {
        await this.plugin.app.vault.createFolder(backupDir);
      }
      await this.plugin.app.vault.adapter.write(backupPath, backupData);
    } catch (error) {
    }
  }
  /**
   * Save settings using Obsidian's native data API
   * This ensures settings are properly saved with fallback options
   */
  async saveSettings() {
    if (!this.isInitialized) {
      return;
    }
    try {
      const oldSettings = { ...this.plugin._internal_settings_systemsculpt_plugin || DEFAULT_SETTINGS };
      this.settings = { ...this.plugin._internal_settings_systemsculpt_plugin };
      await this.plugin.saveData(this.plugin._internal_settings_systemsculpt_plugin);
      this.plugin.app.workspace.trigger("systemsculpt:settings-updated", oldSettings, this.plugin._internal_settings_systemsculpt_plugin);
      await this.backupSettings();
    } catch (error) {
    }
  }
  /**
   * Get the current settings
   */
  getSettings() {
    if (!this.isInitialized) {
      return { ...DEFAULT_SETTINGS };
    }
    return { ...this.settings };
  }
  /**
   * Update settings with partial changes
   */
  async updateSettings(newSettings) {
    if (!this.isInitialized) {
      await this.loadSettings();
    }
    const oldSettingsState = { ...this.settings };
    let updatedSettings = { ...this.settings, ...newSettings };
    if (updatedSettings.mcpEnabledTools && Array.isArray(updatedSettings.mcpEnabledTools)) {
      const originalLength = updatedSettings.mcpEnabledTools.length;
      updatedSettings.mcpEnabledTools = [...new Set(updatedSettings.mcpEnabledTools)];
      const deduplicatedLength = updatedSettings.mcpEnabledTools.length;
      if (originalLength !== deduplicatedLength) {
      }
    }
    if (updatedSettings.mcpAutoAcceptTools && Array.isArray(updatedSettings.mcpAutoAcceptTools)) {
      const originalLength = updatedSettings.mcpAutoAcceptTools.length;
      updatedSettings.mcpAutoAcceptTools = [...new Set(updatedSettings.mcpAutoAcceptTools)];
      const deduplicatedLength = updatedSettings.mcpAutoAcceptTools.length;
      if (originalLength !== deduplicatedLength) {
      }
    }
    this.settings = await this.validateSettingsAsync(updatedSettings);
    this.plugin._internal_settings_systemsculpt_plugin = { ...this.settings };
    await this.saveSettings();
  }
  // ... other methods like getLicenseKey, setLicenseKey, validateLicenseKey, etc.
  // These should use this.updateSettings if they modify settings.
  async validateLicenseKey(key) {
    const currentSettings = this.getSettings();
    const isValid = key === "valid-license";
    if (currentSettings.licenseKey !== key || currentSettings.licenseValid !== isValid) {
      await this.updateSettings({ licenseKey: key, licenseValid: isValid });
    }
    return isValid;
  }
  getLicenseKey() {
    return this.getSettings().licenseKey;
  }
  isLicenseValid() {
    return this.getSettings().licenseValid;
  }
  async setLicenseKey(key) {
    await this.updateSettings({ licenseKey: key });
  }
  getServerUrl() {
    return this.getSettings().serverUrl;
  }
  async setServerUrl(url) {
    await this.updateSettings({ serverUrl: url });
  }
  /**
   * Clean up phantom tools from settings by removing tools that no longer exist in any server
   */
  async cleanupPhantomTools(settings) {
    try {
      const validToolKeys = /* @__PURE__ */ new Set();
      if (settings.mcpEnabled) {
        const { MCPFilesystemServer: MCPFilesystemServer2 } = await Promise.resolve().then(() => (init_MCPFilesystemServer(), MCPFilesystemServer_exports));
        const filesystemServer = new MCPFilesystemServer2(this.plugin, this.plugin.app);
        const filesystemTools = await filesystemServer.getTools();
        for (const tool of filesystemTools) {
          validToolKeys.add(`mcp-filesystem:${tool.name}`);
        }
        const { MCPService: MCPService2 } = await Promise.resolve().then(() => (init_MCPService2(), MCPService_exports));
        const mcpService = new MCPService2(this.plugin, this.plugin.app);
        for (const server of settings.mcpServers || []) {
          if (!server.isEnabled || server.id === "mcp-filesystem") {
            continue;
          }
          try {
            const result = await mcpService.testConnection(server);
            if (result.success && result.tools) {
              for (const tool of result.tools) {
                validToolKeys.add(`${server.id}:${tool.name}`);
              }
            }
          } catch (error) {
          }
        }
      }
      const originalEnabledTools = settings.mcpEnabledTools || [];
      const cleanedEnabledTools = originalEnabledTools.filter((toolKey) => {
        const isValid = validToolKeys.has(toolKey);
        if (!isValid) {
        }
        return isValid;
      });
      const originalAutoAcceptTools = settings.mcpAutoAcceptTools || [];
      const cleanedAutoAcceptTools = originalAutoAcceptTools.filter((toolKey) => {
        const isValid = validToolKeys.has(toolKey);
        if (!isValid) {
        }
        return isValid;
      });
      const removedEnabledCount = originalEnabledTools.length - cleanedEnabledTools.length;
      const removedAutoAcceptCount = originalAutoAcceptTools.length - cleanedAutoAcceptTools.length;
      if (removedEnabledCount > 0 || removedAutoAcceptCount > 0) {
      }
      return {
        ...settings,
        mcpEnabledTools: cleanedEnabledTools,
        mcpAutoAcceptTools: cleanedAutoAcceptTools
      };
    } catch (error) {
      return settings;
    }
  }
  /**
   * Perform async validation including phantom tool cleanup
   */
  async validateSettingsAsync(settings) {
    const syncValidatedSettings = this.validateSettings(settings);
    const asyncValidatedSettings = await this.cleanupPhantomTools(syncValidatedSettings);
    return asyncValidatedSettings;
  }
  /**
   * Manually trigger phantom tool cleanup
   * This can be called by users or automatically when needed
   */
  async cleanupPhantomToolsManually() {
    if (!this.isInitialized) {
      await this.loadSettings();
    }
    const cleanedSettings = await this.cleanupPhantomTools(this.settings);
    if (cleanedSettings.mcpEnabledTools.length !== this.settings.mcpEnabledTools.length || cleanedSettings.mcpAutoAcceptTools.length !== this.settings.mcpAutoAcceptTools.length) {
      this.settings = cleanedSettings;
      await this.saveSettings();
    } else {
    }
  }
  /**
   * Clean up resources when the plugin is unloaded
   */
  destroy() {
    if (this.automaticBackupService) {
      this.automaticBackupService.stop();
    }
  }
  /**
   * Get the automatic backup service instance for external access
   */
  getAutomaticBackupService() {
    return this.automaticBackupService;
  }
};

// src/core/license/LicenseManager.ts
var import_obsidian97 = require("obsidian");
var LicenseManager = class {
  // 24 hours
  constructor(plugin, app) {
    this.lastValidationTime = 0;
    this.plugin = plugin;
    this.app = app;
  }
  async initializeLicense() {
    var _a;
    const licenseKey = (_a = this.plugin.settings.licenseKey) == null ? void 0 : _a.trim();
    const SPath = "licenseValid";
    const previousLicenseValidState = this.plugin.settings.licenseValid;
    if (!licenseKey) {
      if (previousLicenseValidState === true) {
        await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
        new import_obsidian97.Notice("SystemSculpt license key is empty. Pro features disabled.", 5e3);
      } else if (typeof previousLicenseValidState === "undefined") {
        await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
      }
      return;
    }
    let isValidNow = false;
    try {
      isValidNow = await this.validateLicenseKey(true, false);
    } catch (error) {
      isValidNow = false;
    }
    if (previousLicenseValidState === true && !isValidNow) {
      new import_obsidian97.Notice("Your SystemSculpt Pro license is no longer valid or failed to validate. Pro features may be unavailable.", 7e3);
    }
  }
  async validateLicenseKey(force = false, showReloadPrompt = true) {
    if (!this.plugin.settings.licenseKey) {
      await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
      return false;
    }
    try {
      const isValid = await this.plugin.aiService.validateLicense(force);
      await this.plugin.getSettingsManager().updateSettings({ licenseValid: isValid });
      if (isValid) {
        this.lastValidationTime = Date.now();
      }
      return isValid;
    } catch (error) {
      await this.plugin.getSettingsManager().updateSettings({ licenseValid: false });
      return false;
    }
  }
};
LicenseManager.VALIDATION_INTERVAL = 24 * 60 * 60 * 1e3;

// src/core/plugin/views.ts
var import_obsidian103 = require("obsidian");

// src/modals/JanitorModal.ts
var import_obsidian98 = require("obsidian");
init_ui();
init_StandardModal();
var JanitorModal = class extends StandardModal {
  constructor(app, plugin) {
    super(app);
    this.cachedData = null;
    this.isScanning = false;
    this.plugin = plugin;
    this.setSize("large");
  }
  onOpen() {
    super.onOpen();
    this.modalEl.addClass("ss-janitor-modal");
    this.addTitle(
      "\u{1F9F9} SystemSculpt Janitor",
      "Clean up and optimize your SystemSculpt workspace. Review items before deletion."
    );
    this.createMainContainer();
    this.addActionButton("Refresh", () => this.refreshData(), false, "refresh-cw");
    this.addActionButton("Close", () => this.close(), false);
    this.loadJanitorData();
  }
  createMainContainer() {
    this.mainContainer = this.contentEl.createDiv({ cls: "ss-janitor-main" });
    this.loadingOverlay = this.contentEl.createDiv({ cls: "ss-janitor-loading-overlay" });
    const loadingContent = this.loadingOverlay.createDiv({ cls: "ss-janitor-loading-content" });
    const loadingIcon = loadingContent.createDiv({ cls: "ss-janitor-loading-icon" });
    (0, import_obsidian98.setIcon)(loadingIcon, "loader-2");
    const loadingText = loadingContent.createDiv({ cls: "ss-janitor-loading-text" });
    loadingText.createDiv({ text: "Scanning Vault", cls: "ss-janitor-loading-title" });
    loadingText.createDiv({ text: "Analyzing files and folders...", cls: "ss-janitor-loading-subtitle" });
    this.showLoading(true);
  }
  /**
   * Efficiently scan the entire vault once and categorize all files
   */
  async scanVault() {
    const emptyFiles = [];
    const emptyFolders = [];
    const chatFiles = [];
    const extractionFiles = [];
    const recordingFiles = [];
    const allFiles = this.app.vault.getFiles();
    const allFolders = this.app.vault.getAllLoadedFiles().filter((f) => f instanceof import_obsidian98.TFolder);
    for (const file of allFiles) {
      if (file.path.startsWith(this.plugin.settings.chatsDirectory)) {
        chatFiles.push(file);
      } else if (file.path.startsWith(this.plugin.settings.extractionsDirectory)) {
        extractionFiles.push(file);
      } else if (file.path.startsWith(this.plugin.settings.recordingsDirectory)) {
        recordingFiles.push(file);
      }
      if (await this.isEmptyFile(file)) {
        emptyFiles.push(file);
      }
    }
    for (const folder of allFolders) {
      if (this.isEmptyFolder(folder)) {
        emptyFolders.push(folder);
      }
    }
    const sizes = {
      empty: this.calculateSize(emptyFiles),
      chat: this.calculateSize(chatFiles),
      extraction: this.calculateSize(extractionFiles),
      recording: this.calculateSize(recordingFiles)
    };
    return {
      emptyFiles,
      emptyFolders,
      chatFiles,
      extractionFiles,
      recordingFiles,
      sizes,
      stats: {
        emptyFileCount: emptyFiles.length,
        emptyFolderCount: emptyFolders.length,
        totalEmptyCount: emptyFiles.length + emptyFolders.length
      }
    };
  }
  /**
   * Load all janitor data efficiently
   */
  async loadJanitorData() {
    if (this.isScanning) return;
    try {
      this.isScanning = true;
      this.showLoading(true);
      const data = await this.scanVault();
      this.cachedData = data;
      this.showLoading(false);
      this.populateAllSections(data);
    } catch (error) {
      this.showError("Failed to scan vault. Please try refreshing.");
    } finally {
      this.isScanning = false;
    }
  }
  /**
   * Populate all sections with scanned data
   */
  populateAllSections(data) {
    this.mainContainer.empty();
    const sectionsContainer = this.mainContainer.createDiv({ cls: "ss-janitor-sections" });
    this.createEmptyContentSection(sectionsContainer, data);
    this.createChatHistorySection(sectionsContainer, data);
    this.createExtractionsSection(sectionsContainer, data);
    this.createRecordingsSection(sectionsContainer, data);
  }
  /**
   * Create empty content section with pre-loaded data
   */
  createEmptyContentSection(container, data) {
    const section = this.createModernSection(
      container,
      "\u{1F4C4} Empty Content",
      "Remove empty files and folders that are taking up space"
    );
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { emptyFiles, emptyFolders, stats } = data;
    this.createStatCard(statsContainer, "Files", stats.emptyFileCount, "file-text");
    this.createStatCard(statsContainer, "Folders", stats.emptyFolderCount, "folder");
    this.createStatCard(statsContainer, "Total", stats.totalEmptyCount, "trash-2", stats.totalEmptyCount > 0 ? "warning" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: stats.totalEmptyCount > 0 ? "ss-button ss-button--danger" : "ss-button",
      text: stats.totalEmptyCount > 0 ? `Clear ${stats.totalEmptyCount} Empty Items` : "No Empty Content"
    });
    if (stats.totalEmptyCount === 0) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showEmptyContentConfirmation(emptyFiles, emptyFolders, () => {
          this.refreshData();
        });
      });
    }
  }
  createChatHistorySection(container, data) {
    const section = this.createModernSection(
      container,
      "\u{1F4AC} Chat History",
      "Delete all saved chat conversations and message history"
    );
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { chatFiles, sizes } = data;
    const hasChatFiles = chatFiles.length > 0;
    this.createStatCard(statsContainer, "Chats", chatFiles.length, "message-circle");
    this.createStatCard(statsContainer, "Size", sizes.chat, "hard-drive");
    this.createStatCard(statsContainer, "Status", hasChatFiles ? "Active" : "Empty", "activity", hasChatFiles ? "success" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: hasChatFiles ? "ss-button ss-button--danger" : "ss-button",
      text: hasChatFiles ? `Clear All Chat History (${sizes.chat})` : "No Chat History"
    });
    if (!hasChatFiles) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showConfirmationDialog(
          chatFiles,
          "Chat History",
          this.plugin.settings.chatsDirectory,
          () => this.refreshData()
        );
      });
    }
  }
  createExtractionsSection(container, data) {
    const section = this.createModernSection(
      container,
      "\u{1F4C4} Document Extractions",
      "Delete extracted content from PDFs, documents, and other processed files"
    );
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { extractionFiles, sizes } = data;
    const hasExtractionFiles = extractionFiles.length > 0;
    this.createStatCard(statsContainer, "Files", extractionFiles.length, "file-text");
    this.createStatCard(statsContainer, "Size", sizes.extraction, "hard-drive");
    this.createStatCard(statsContainer, "Status", hasExtractionFiles ? "Active" : "Empty", "activity", hasExtractionFiles ? "success" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: hasExtractionFiles ? "ss-button ss-button--danger" : "ss-button",
      text: hasExtractionFiles ? `Clear All Extractions (${sizes.extraction})` : "No Extractions"
    });
    if (!hasExtractionFiles) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showConfirmationDialog(
          extractionFiles,
          "Extractions",
          this.plugin.settings.extractionsDirectory,
          () => this.refreshData()
        );
      });
    }
  }
  createRecordingsSection(container, data) {
    const section = this.createModernSection(
      container,
      "\u{1F399}\uFE0F Audio Recordings",
      "Delete audio recording files (transcribed text files will remain intact)"
    );
    const statsContainer = section.content.createDiv({ cls: "ss-janitor-stats" });
    const actionContainer = section.content.createDiv({ cls: "ss-janitor-actions" });
    const { recordingFiles, sizes } = data;
    const hasRecordingFiles = recordingFiles.length > 0;
    this.createStatCard(statsContainer, "Files", recordingFiles.length, "audio-lines");
    this.createStatCard(statsContainer, "Size", sizes.recording, "hard-drive");
    this.createStatCard(statsContainer, "Status", hasRecordingFiles ? "Active" : "Empty", "activity", hasRecordingFiles ? "success" : "muted");
    const clearButton = actionContainer.createEl("button", {
      cls: hasRecordingFiles ? "ss-button ss-button--danger" : "ss-button",
      text: hasRecordingFiles ? `Clear All Recordings (${sizes.recording})` : "No Recordings"
    });
    if (!hasRecordingFiles) {
      clearButton.disabled = true;
      clearButton.addClass("ss-disabled");
    } else {
      this.registerDomEvent(clearButton, "click", async () => {
        await this.showConfirmationDialog(
          recordingFiles,
          "Recordings",
          this.plugin.settings.recordingsDirectory,
          () => this.refreshData()
        );
      });
    }
  }
  createModernSection(container, title, description) {
    const section = container.createDiv({ cls: "ss-janitor-section" });
    const header = section.createDiv({ cls: "ss-janitor-section-header" });
    const titleEl = header.createDiv({ cls: "ss-janitor-section-title", text: title });
    const descEl = header.createDiv({ cls: "ss-janitor-section-description", text: description });
    const content = section.createDiv({ cls: "ss-janitor-section-content" });
    return {
      section,
      header,
      content
    };
  }
  createStatCard(container, label, value, icon, variant = "normal") {
    const card = container.createDiv({ cls: `ss-janitor-stat-card ss-janitor-stat-card--${variant}` });
    const iconEl = card.createDiv({ cls: "ss-janitor-stat-icon" });
    (0, import_obsidian98.setIcon)(iconEl, icon);
    const content = card.createDiv({ cls: "ss-janitor-stat-content" });
    content.createDiv({ cls: "ss-janitor-stat-value", text: value.toString() });
    content.createDiv({ cls: "ss-janitor-stat-label", text: label });
    return card;
  }
  /**
   * Efficient refresh that clears cache and reloads
   */
  refreshData() {
    this.cachedData = null;
    this.loadJanitorData();
  }
  /**
   * Show/hide loading overlay
   */
  showLoading(show) {
    this.loadingOverlay.style.display = show ? "flex" : "none";
    this.mainContainer.style.display = show ? "none" : "block";
  }
  /**
   * Show error state
   */
  showError(message) {
    this.showLoading(false);
    this.mainContainer.empty();
    const errorContainer = this.mainContainer.createDiv({ cls: "ss-janitor-error" });
    const errorIcon = errorContainer.createDiv({ cls: "ss-janitor-error-icon" });
    (0, import_obsidian98.setIcon)(errorIcon, "alert-circle");
    const errorText = errorContainer.createDiv({ cls: "ss-janitor-error-text" });
    errorText.createDiv({ text: "Error", cls: "ss-janitor-error-title" });
    errorText.createDiv({ text: message, cls: "ss-janitor-error-message" });
    const retryButton = errorContainer.createEl("button", {
      cls: "ss-button ss-button--primary",
      text: "Retry"
    });
    this.registerDomEvent(retryButton, "click", () => {
      this.refreshData();
    });
  }
  calculateSize(files) {
    const totalBytes = files.reduce((acc, file) => acc + file.stat.size, 0);
    if (totalBytes === 0) return "empty";
    if (totalBytes < 1024) return `${totalBytes} bytes`;
    if (totalBytes < 1024 * 1024) return `${(totalBytes / 1024).toFixed(1)} KB`;
    if (totalBytes < 1024 * 1024 * 1024) return `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(totalBytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
  async cleanDirectory(directory) {
    if (!directory || directory === "/" || directory === "." || directory === "..") {
      throw new Error("Cannot delete root or system directories");
    }
    const files = this.app.vault.getFiles().filter((file) => file.path.startsWith(directory));
    for (const file of files) {
      await this.app.vault.trash(file, true);
    }
    const folder = this.app.vault.getAbstractFileByPath(directory);
    if (folder instanceof import_obsidian98.TFolder) {
      const subdirs = folder.children.filter((child) => child instanceof import_obsidian98.TFolder).sort((a, b) => b.path.length - a.path.length);
      for (const subdir of subdirs) {
        if (subdir.children.length === 0) {
          await this.app.vault.trash(subdir, true);
        }
      }
      if (folder.children.length === 0) {
        await this.app.vault.trash(folder, true);
      }
    }
  }
  async showConfirmationDialog(files, type, directory, onSuccess) {
    const confirmModal = new ConfirmationModal(
      this.app,
      `Clear ${type}`,
      `\u26A0\uFE0F The following ${files.length} ${type.toLowerCase()} files will be moved to the Obsidian trash. You can restore them from the trash if needed.`,
      files,
      type
    );
    const result = await confirmModal.open();
    if (result) {
      try {
        await this.cleanDirectory(directory);
        showPopup(
          this.app,
          `Successfully moved ${files.length} ${type.toLowerCase()} files (${this.calculateSize(files)}) to trash`,
          { title: "Success" }
        );
        onSuccess();
      } catch (error) {
        showPopup(this.app, `Failed to clear ${type.toLowerCase()}`, {
          title: "Error"
        });
      }
    }
  }
  async showEmptyContentConfirmation(emptyFiles, emptyFolders, onSuccess) {
    const confirmModal = new EmptyContentConfirmationModal(
      this.app,
      emptyFiles,
      emptyFolders
    );
    const result = await confirmModal.open();
    if (result) {
      try {
        for (const file of emptyFiles) {
          await this.app.vault.trash(file, true);
        }
        const sortedFolders = emptyFolders.sort(
          (a, b) => b.path.length - a.path.length
        );
        for (const folder of sortedFolders) {
          await this.app.vault.trash(folder, true);
        }
        const totalEmpty = emptyFiles.length + emptyFolders.length;
        showPopup(
          this.app,
          `Successfully moved ${totalEmpty} empty items to trash`,
          { title: "Success" }
        );
        onSuccess();
      } catch (error) {
        showPopup(this.app, "Failed to clear empty content", {
          title: "Error"
        });
      }
    }
  }
  async isEmptyFile(file) {
    if (file.stat.size === 0) return true;
    if (file.stat.size < 1024) {
      const extension = file.extension.toLowerCase();
      if (["md", "txt", "markdown"].includes(extension)) {
        try {
          const content = await this.app.vault.read(file);
          const contentWithoutFrontmatter = content.replace(/^---[\s\S]*?---/, "").trim();
          return !contentWithoutFrontmatter;
        } catch (e) {
          return false;
        }
      }
    }
    return false;
  }
  /**
   * Optimized empty folder check
   */
  isEmptyFolder(folder) {
    return folder.children.length === 0;
  }
  onClose() {
    this.cachedData = null;
    this.isScanning = false;
    super.onClose();
  }
};
var ConfirmationModal = class extends StandardModal {
  constructor(app, title, description, files, type) {
    super(app);
    this.resolvePromise = null;
    this.files = files;
    this.type = type;
    this.title = title;
    this.description = description;
    this.setSize("medium");
  }
  onOpen() {
    super.onOpen();
    this.addTitle(this.title, this.description);
    this.createFilePreview();
    this.createFooterButtons();
  }
  createFilePreview() {
    if (this.files.length === 0) return;
    const previewContainer = this.contentEl.createDiv({ cls: "ss-janitor-preview" });
    const headerEl = previewContainer.createDiv({ cls: "ss-janitor-preview-header" });
    headerEl.createSpan({ text: `${this.files.length} files (${this.calculateSize(this.files)})`, cls: "ss-janitor-preview-count" });
    const listContainer = previewContainer.createDiv({ cls: "ss-janitor-preview-list" });
    const filesToShow = this.files.slice(0, 10);
    for (const file of filesToShow) {
      const fileItem = listContainer.createDiv({ cls: "ss-janitor-preview-item" });
      const iconEl = fileItem.createDiv({ cls: "ss-janitor-preview-icon" });
      (0, import_obsidian98.setIcon)(iconEl, this.getFileIcon(file));
      const pathEl = fileItem.createDiv({ cls: "ss-janitor-preview-path", text: file.path });
      const sizeEl = fileItem.createDiv({ cls: "ss-janitor-preview-size", text: this.calculateSize([file]) });
    }
    if (this.files.length > 10) {
      const moreEl = listContainer.createDiv({ cls: "ss-janitor-preview-more" });
      moreEl.createSpan({ text: `... and ${this.files.length - 10} more files` });
    }
  }
  getFileIcon(file) {
    const extension = file.extension.toLowerCase();
    if (["md", "txt", "markdown"].includes(extension)) return "file-text";
    if (["jpg", "jpeg", "png", "gif", "webp", "svg"].includes(extension)) return "image";
    if (["mp3", "wav", "ogg", "m4a"].includes(extension)) return "audio-lines";
    if (["pdf"].includes(extension)) return "file-text";
    return "file";
  }
  calculateSize(files) {
    const totalBytes = files.reduce((acc, file) => acc + file.stat.size, 0);
    if (totalBytes === 0) return "empty";
    if (totalBytes < 1024) return `${totalBytes} bytes`;
    if (totalBytes < 1024 * 1024) return `${(totalBytes / 1024).toFixed(1)} KB`;
    if (totalBytes < 1024 * 1024 * 1024) return `${(totalBytes / (1024 * 1024)).toFixed(1)} MB`;
    return `${(totalBytes / (1024 * 1024 * 1024)).toFixed(1)} GB`;
  }
  createFooterButtons() {
    this.addActionButton("Cancel", () => this.resolve(false), false);
    this.addActionButton("Move to Trash", () => this.resolve(true), true, "trash-2");
  }
  resolve(value) {
    if (this.resolvePromise) {
      this.resolvePromise(value);
      this.resolvePromise = null;
    }
    this.close();
  }
  async open() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      super.open();
    });
  }
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(false);
      this.resolvePromise = null;
    }
    super.onClose();
  }
};
var EmptyContentConfirmationModal = class extends StandardModal {
  constructor(app, emptyFiles, emptyFolders) {
    super(app);
    this.resolvePromise = null;
    this.emptyFiles = emptyFiles;
    this.emptyFolders = emptyFolders;
    this.totalEmpty = emptyFiles.length + emptyFolders.length;
    this.setSize("medium");
  }
  onOpen() {
    super.onOpen();
    this.addTitle(
      "Clear Empty Content",
      `\u26A0\uFE0F The following ${this.totalEmpty} empty items will be moved to the Obsidian trash. You can restore them from the trash if needed.`
    );
    this.createEmptyContentPreview();
    this.createFooterButtons();
  }
  createEmptyContentPreview() {
    const previewContainer = this.contentEl.createDiv({ cls: "ss-janitor-preview" });
    if (this.emptyFiles.length > 0) {
      const filesSection = previewContainer.createDiv({ cls: "ss-janitor-preview-section" });
      const filesHeader = filesSection.createDiv({ cls: "ss-janitor-preview-section-header" });
      const filesHeaderIcon = filesHeader.createDiv({ cls: "ss-janitor-preview-section-icon" });
      (0, import_obsidian98.setIcon)(filesHeaderIcon, "file-text");
      filesHeader.createSpan({ text: `Empty Files (${this.emptyFiles.length})`, cls: "ss-janitor-preview-section-title" });
      const filesList = filesSection.createDiv({ cls: "ss-janitor-preview-list" });
      const filesToShow = this.emptyFiles.slice(0, 5);
      for (const file of filesToShow) {
        const item = filesList.createDiv({ cls: "ss-janitor-preview-item" });
        const icon = item.createDiv({ cls: "ss-janitor-preview-icon" });
        (0, import_obsidian98.setIcon)(icon, "file-text");
        item.createSpan({ text: file.path, cls: "ss-janitor-preview-path" });
      }
      if (this.emptyFiles.length > 5) {
        filesList.createDiv({ cls: "ss-janitor-preview-more", text: `... and ${this.emptyFiles.length - 5} more files` });
      }
    }
    if (this.emptyFolders.length > 0) {
      const foldersSection = previewContainer.createDiv({ cls: "ss-janitor-preview-section" });
      const foldersHeader = foldersSection.createDiv({ cls: "ss-janitor-preview-section-header" });
      const foldersHeaderIcon = foldersHeader.createDiv({ cls: "ss-janitor-preview-section-icon" });
      (0, import_obsidian98.setIcon)(foldersHeaderIcon, "folder");
      foldersHeader.createSpan({ text: `Empty Folders (${this.emptyFolders.length})`, cls: "ss-janitor-preview-section-title" });
      const foldersList = foldersSection.createDiv({ cls: "ss-janitor-preview-list" });
      const foldersToShow = this.emptyFolders.slice(0, 5);
      for (const folder of foldersToShow) {
        const item = foldersList.createDiv({ cls: "ss-janitor-preview-item" });
        const icon = item.createDiv({ cls: "ss-janitor-preview-icon" });
        (0, import_obsidian98.setIcon)(icon, "folder");
        item.createSpan({ text: folder.path, cls: "ss-janitor-preview-path" });
      }
      if (this.emptyFolders.length > 5) {
        foldersList.createDiv({ cls: "ss-janitor-preview-more", text: `... and ${this.emptyFolders.length - 5} more folders` });
      }
    }
  }
  createFooterButtons() {
    this.addActionButton("Cancel", () => this.resolve(false), false);
    this.addActionButton("Move to Trash", () => this.resolve(true), true, "trash-2");
  }
  resolve(value) {
    if (this.resolvePromise) {
      this.resolvePromise(value);
      this.resolvePromise = null;
    }
    this.close();
  }
  async open() {
    return new Promise((resolve) => {
      this.resolvePromise = resolve;
      super.open();
    });
  }
  onClose() {
    if (this.resolvePromise) {
      this.resolvePromise(false);
      this.resolvePromise = null;
    }
    super.onClose();
  }
};

// src/views/chatview/LoadChatModal.ts
var import_obsidian100 = require("obsidian");
init_ui();
init_SearchService();
init_StandardModal();
init_FavoritesService();

// src/views/chatview/ChatFavoritesService.ts
var ChatFavoritesService = class _ChatFavoritesService {
  constructor(plugin) {
    this.plugin = plugin;
  }
  /**
   * Get the ChatFavoritesService instance
   */
  static getInstance(plugin) {
    if (!_ChatFavoritesService.instance) {
      _ChatFavoritesService.instance = new _ChatFavoritesService(plugin);
    }
    return _ChatFavoritesService.instance;
  }
  /** Add a chat to favorites */
  async addFavorite(chatId) {
    if (this.plugin.settings.favoriteChats.includes(chatId)) return;
    const updated = [...this.plugin.settings.favoriteChats, chatId];
    await this.plugin.getSettingsManager().updateSettings({ favoriteChats: updated });
    this.emitFavoritesChanged();
  }
  /** Remove a chat from favorites */
  async removeFavorite(chatId) {
    const updated = this.plugin.settings.favoriteChats.filter((id) => id !== chatId);
    await this.plugin.getSettingsManager().updateSettings({ favoriteChats: updated });
    this.emitFavoritesChanged();
  }
  /** Toggle favorite status */
  async toggleFavorite(chatId) {
    if (this.isFavorite(chatId)) {
      await this.removeFavorite(chatId);
    } else {
      await this.addFavorite(chatId);
    }
  }
  /** Check if a chat is a favorite */
  isFavorite(chatId) {
    return this.plugin.settings.favoriteChats.includes(chatId);
  }
  /** Get all favorite chat IDs */
  getFavorites() {
    return [...this.plugin.settings.favoriteChats];
  }
  /** Emit an event when favorites change */
  emitFavoritesChanged() {
    document.dispatchEvent(
      new CustomEvent("systemsculpt:chat-favorites-changed", {
        detail: { favorites: this.plugin.settings.favoriteChats }
      })
    );
  }
};

// src/views/chatview/ChatFavoriteToggle.ts
var import_obsidian99 = require("obsidian");
var ChatFavoriteToggle = class {
  constructor(container, chatId, service, callback) {
    this.chatId = chatId;
    this.service = service;
    this.callback = callback;
    this.element = container.createDiv({
      cls: "systemsculpt-favorite-toggle",
      attr: { role: "button", tabindex: "0" }
    });
    this.updateAppearance();
    this.addEventListeners();
  }
  updateAppearance() {
    this.element.empty();
    const isFav = this.service.isFavorite(this.chatId);
    const icon = this.element.createSpan();
    (0, import_obsidian99.setIcon)(icon, "star");
    if (isFav) this.element.addClass("is-favorite");
    else this.element.removeClass("is-favorite");
    this.element.setAttribute("aria-pressed", isFav ? "true" : "false");
  }
  addEventListeners() {
    this.element.addEventListener("click", this.handleClick.bind(this));
    this.element.addEventListener("keydown", (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        this.handleClick(e);
      }
    });
  }
  handleClick(e) {
    e.preventDefault();
    e.stopPropagation();
    this.service.toggleFavorite(this.chatId).then(() => {
      const isFav = this.service.isFavorite(this.chatId);
      this.updateAppearance();
      if (this.callback) this.callback(this.chatId, isFav);
    });
  }
};

// src/views/chatview/LoadChatModal.ts
var LoadChatModal = class extends StandardModal {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
    this.chatItems = [];
    this.isLoading = false;
    this.modelNameCache = /* @__PURE__ */ new Map();
    this.allChats = [];
    this.filteredChats = [];
    this.showFavoritesOnlyChats = false;
    // Keyboard navigation
    this.keyboardSelectedIndex = -1;
    this.chatItemElements = [];
    // Guard against multiple opens
    this.isOpening = false;
    this.searchService = new SearchService();
    this.chatStorage = new ChatStorageService(plugin.app, plugin.settings.chatsDirectory || "SystemSculpt/Chats");
    this.favoritesService = FavoritesService.getInstance(plugin);
    this.chatFavoritesService = ChatFavoritesService.getInstance(plugin);
    this.setSize("large");
    this.modalEl.addClass("systemsculpt-load-chat-modal");
  }
  async onOpen() {
    super.onOpen();
    this.addTitle("Load Chat", "Select a chat to continue your conversation");
    this.createSearchBar();
    this.chatListContainer = this.contentEl.createDiv("systemsculpt-chat-list");
    this.chatListContainer.style.height = "400px";
    this.chatListContainer.style.overflow = "auto";
    this.emptyStateEl = this.contentEl.createDiv("systemsculpt-empty-state");
    this.emptyStateEl.style.display = "none";
    this.emptyStateEl.style.textAlign = "center";
    this.emptyStateEl.style.padding = "20px";
    this.emptyStateEl.style.color = "var(--text-muted)";
    (0, import_obsidian100.setIcon)(this.emptyStateEl.createDiv(), "message-square");
    this.emptyStateEl.createDiv().setText("No chats found");
    const cancelButton = this.addActionButton("Cancel", () => {
      this.close();
    }, false);
    const newChatButton = this.addActionButton("Open New Chat Instead", () => {
      this.openNewChat();
    }, false);
    newChatButton.style.marginRight = "auto";
    this.modalEl.addEventListener("keydown", (e) => {
      this.handleModalKeydown(e);
    });
    this.isLoading = true;
    await this.loadAndDisplayChats();
  }
  createSearchBar() {
    const searchContainer = this.contentEl.createDiv("systemsculpt-search-container");
    searchContainer.style.marginBottom = "16px";
    searchContainer.style.display = "flex";
    searchContainer.style.gap = "8px";
    this.searchInput = new import_obsidian100.SearchComponent(searchContainer);
    this.searchInput.setPlaceholder("Search chats by title & content...");
    this.searchInput.inputEl.style.flexGrow = "1";
    const favContainer = searchContainer.createDiv();
    const favToggle = favContainer.createDiv({
      cls: "systemsculpt-favorites-filter",
      attr: { role: "button", tabindex: "0" }
    });
    const starIcon = favToggle.createSpan({ cls: "systemsculpt-favorites-icon" });
    (0, import_obsidian100.setIcon)(starIcon, "star");
    const label = favToggle.createSpan({ cls: "systemsculpt-favorites-label" });
    const updateFavToggle = () => {
      if (this.showFavoritesOnlyChats) {
        favToggle.addClass("is-active");
        favToggle.setAttr("aria-pressed", "true");
        label.setText("Favorites only");
      } else {
        favToggle.removeClass("is-active");
        favToggle.setAttr("aria-pressed", "false");
        label.setText("Show favorites");
      }
    };
    updateFavToggle();
    favToggle.addEventListener("click", async (e) => {
      e.preventDefault();
      e.stopPropagation();
      this.showFavoritesOnlyChats = !this.showFavoritesOnlyChats;
      updateFavToggle();
      await this.filterAndDisplayChats();
    });
    favToggle.addEventListener("keydown", async (e) => {
      if (e.key === "Enter" || e.key === " ") {
        e.preventDefault();
        e.stopPropagation();
        this.showFavoritesOnlyChats = !this.showFavoritesOnlyChats;
        updateFavToggle();
        await this.filterAndDisplayChats();
      }
    });
    this.searchInput.onChange(async (value) => {
      this.keyboardSelectedIndex = -1;
      await this.filterAndDisplayChats();
    });
    this.searchInput.inputEl.addEventListener("keydown", (e) => {
      this.handleSearchKeydown(e);
    });
  }
  async loadAndDisplayChats() {
    this.emptyStateEl.setText("Loading chats...");
    this.emptyStateEl.style.display = "block";
    this.chatListContainer.empty();
    this.chatListContainer.appendChild(this.emptyStateEl);
    try {
      const allSummaries = await this.chatStorage.loadChats();
      this.allChats = allSummaries.map((summary) => ({
        id: summary.id,
        title: summary.title || `Chat from ${this.formatRelativeDate(summary.lastModified)}`,
        lastModified: summary.lastModified,
        selectedModelId: summary.selectedModelId || this.plugin.settings.selectedModelId,
        messages: summary.messages || [],
        // Keep messages for content search
        isFavorite: this.chatFavoritesService.isFavorite(summary.id)
      }));
      const favoritesFirst = this.favoritesService.getFavoritesFirst();
      this.allChats.sort((a, b) => {
        if (favoritesFirst) {
          if (a.isFavorite && !b.isFavorite) return -1;
          if (!a.isFavorite && b.isFavorite) return 1;
        }
        return b.lastModified - a.lastModified;
      });
    } catch (error) {
      this.emptyStateEl.setText("Failed to load chats.");
      this.allChats = [];
    }
    this.filterAndDisplayChats();
  }
  async filterAndDisplayChats() {
    const searchTerm = this.searchInput.getValue().trim();
    let baseList = this.showFavoritesOnlyChats ? this.allChats.filter((c) => c.isFavorite) : [...this.allChats];
    if (!searchTerm) {
      this.filteredChats = baseList;
      this.displayChats();
      return;
    }
    const searchTerms = searchTerm.toLowerCase().split(/\s+/).filter((t) => t.length > 0);
    if (searchTerms.length === 0) {
      this.filteredChats = [...this.allChats];
      this.displayChats();
      return;
    }
    this.filteredChats = baseList.filter((chat) => {
      if (chat.title && searchTerms.some((term) => chat.title.toLowerCase().includes(term))) {
        return true;
      }
      if (chat.messages && chat.messages.length > 0) {
        return chat.messages.some((msg) => {
          if (typeof msg.content !== "string") return false;
          const content = msg.content.toLowerCase();
          return searchTerms.some((term) => content.includes(term));
        });
      }
      return false;
    });
    const favoritesFirst = this.favoritesService.getFavoritesFirst();
    this.filteredChats.sort((a, b) => {
      if (favoritesFirst) {
        if (a.isFavorite && !b.isFavorite) return -1;
        if (!a.isFavorite && b.isFavorite) return 1;
      }
      return b.lastModified - a.lastModified;
    });
    this.displayChats(searchTerms);
  }
  displayChats(searchTerms = []) {
    this.chatListContainer.empty();
    this.chatItemElements = [];
    this.keyboardSelectedIndex = -1;
    if (this.filteredChats.length === 0) {
      const searchTerm = this.searchInput.getValue().trim();
      this.emptyStateEl.setText(searchTerm ? "No chats match your search." : "No chats found.");
      this.emptyStateEl.style.display = "block";
      this.chatListContainer.appendChild(this.emptyStateEl);
      return;
    }
    this.emptyStateEl.style.display = "none";
    if (searchTerms.length > 0) {
      const headerEl = this.chatListContainer.createEl("h3", {
        text: `Search Results (${this.filteredChats.length})`,
        cls: "systemsculpt-section-header"
      });
    }
    this.filteredChats.forEach((chat) => {
      const chatItemEl = this.chatListContainer.createDiv("systemsculpt-modal-list-item");
      chatItemEl.dataset.chatId = chat.id;
      chatItemEl.dataset.favorite = chat.isFavorite ? "true" : "false";
      const favContainer = chatItemEl.createDiv("systemsculpt-chat-favorite");
      new ChatFavoriteToggle(favContainer, chat.id, this.chatFavoritesService, async (chatId, isFavorite) => {
        chat.isFavorite = isFavorite;
        chatItemEl.dataset.favorite = isFavorite ? "true" : "false";
        if (this.favoritesService.getFavoritesFirst()) {
          await this.filterAndDisplayChats();
        }
      });
      const contentEl = chatItemEl.createDiv("systemsculpt-modal-list-item-content");
      this.chatItemElements.push(chatItemEl);
      const titleEl = contentEl.createDiv("systemsculpt-modal-list-item-title");
      if (searchTerms.length > 0) {
        const { html: highlightedTitle } = this.highlightText(chat.title, searchTerms);
        titleEl.appendChild(highlightedTitle);
      } else {
        titleEl.textContent = chat.title;
      }
      const previewEl = contentEl.createDiv("systemsculpt-modal-list-item-preview");
      if (searchTerms.length > 0) {
        let foundMatchContext = false;
        const allContent = chat.messages.map((m) => typeof m.content === "string" ? m.content : "").join(" ");
        if (allContent) {
          const matchContext = this.getMatchContext(allContent, searchTerms);
          if (matchContext !== allContent) {
            foundMatchContext = true;
            const { html } = this.highlightText(matchContext, searchTerms);
            previewEl.appendChild(html);
          }
        }
        if (!foundMatchContext) {
          this.renderLastMessages(previewEl, chat);
        }
      } else {
        this.renderLastMessages(previewEl, chat);
      }
      const metadataEl = contentEl.createDiv("systemsculpt-modal-list-item-meta");
      const dateEl = metadataEl.createDiv("systemsculpt-modal-list-item-date");
      dateEl.textContent = this.formatRelativeDate(chat.lastModified);
      const countEl = metadataEl.createDiv("systemsculpt-modal-list-item-count");
      countEl.textContent = `${chat.messages.length} messages`;
      chatItemEl.addEventListener("click", () => {
        this.openChat(chat.id, chat.selectedModelId);
      });
    });
  }
  renderLastMessages(container, chat) {
    if (!chat.messages || chat.messages.length === 0) {
      container.textContent = "Empty chat";
      return;
    }
    const lastMessages = this.getRecentMessages(chat);
    lastMessages.forEach((msg) => {
      const msgEl = document.createElement("div");
      msgEl.className = "systemsculpt-modal-message";
      let content = typeof msg.content === "string" ? msg.content : "Complex message with images or attachments";
      if (content.length > 200) {
        content = content.substring(0, 200) + "...";
      }
      msgEl.textContent = content;
      container.appendChild(msgEl);
    });
  }
  getRecentMessages(chat) {
    const messages = chat.messages;
    if (!messages || messages.length === 0) return [];
    if (messages.length === 1) return [messages[0]];
    let lastUserIndex = -1;
    for (let i = messages.length - 1; i >= 0; i--) {
      if (messages[i].role === "user") {
        lastUserIndex = i;
        break;
      }
    }
    if (lastUserIndex === -1) {
      return [messages[messages.length - 1]];
    }
    const userMessage = messages[lastUserIndex];
    const assistantMessage = lastUserIndex + 1 < messages.length ? messages[lastUserIndex + 1] : null;
    return assistantMessage ? [userMessage, assistantMessage] : [userMessage];
  }
  formatRelativeDate(timestamp) {
    const now = Date.now();
    const diffSeconds = Math.round((now - timestamp) / 1e3);
    const diffMinutes = Math.round(diffSeconds / 60);
    const diffHours = Math.round(diffMinutes / 60);
    const diffDays = Math.round(diffHours / 24);
    const diffWeeks = Math.round(diffDays / 7);
    if (diffSeconds < 60) return `${diffSeconds}s ago`;
    if (diffMinutes < 60) return `${diffMinutes}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    if (diffDays < 7) return `${diffDays}d ago`;
    if (diffWeeks < 5) return `${diffWeeks}w ago`;
    const date = new Date(timestamp);
    return date.toLocaleDateString();
  }
  async getModelName(modelId) {
    if (this.modelNameCache.has(modelId)) {
      return this.modelNameCache.get(modelId) || "Unknown Model";
    }
    try {
      const models = await this.plugin.modelService.getModels();
      const model = models.find((m) => m.id === modelId);
      const name = model ? model.name : "Unknown Model";
      this.modelNameCache.set(modelId, name);
      return name;
    } catch (error) {
      return "Unknown Model";
    }
  }
  highlightText(text, searchTerms) {
    const container = document.createElement("div");
    if (!searchTerms || searchTerms.length === 0 || !text) {
      container.textContent = text || "";
      return { html: container, hasMatches: false };
    }
    const lowerText = text.toLowerCase();
    let lastIndex = 0;
    let hasMatches = false;
    const allMatches = [];
    searchTerms.forEach((term) => {
      if (!term) return;
      let index = 0;
      while ((index = lowerText.indexOf(term, index)) > -1) {
        allMatches.push({ term, index });
        index += term.length;
      }
    });
    if (allMatches.length === 0) {
      container.textContent = text;
      return { html: container, hasMatches: false };
    }
    allMatches.sort((a, b) => a.index - b.index);
    allMatches.forEach((match) => {
      const { term, index } = match;
      if (index < lastIndex) return;
      if (index > lastIndex) {
        container.appendChild(document.createTextNode(
          text.substring(lastIndex, index)
        ));
      }
      const highlight = document.createElement("span");
      highlight.className = "systemsculpt-search-highlight";
      highlight.textContent = text.substr(index, term.length);
      container.appendChild(highlight);
      lastIndex = index + term.length;
      hasMatches = true;
    });
    if (lastIndex < text.length) {
      container.appendChild(document.createTextNode(
        text.substring(lastIndex)
      ));
    }
    return { html: container, hasMatches };
  }
  getMatchContext(text, searchTerms) {
    if (!searchTerms || searchTerms.length === 0 || !text) {
      return text;
    }
    const lowerText = text.toLowerCase();
    const matches = [];
    searchTerms.forEach((term) => {
      if (!term) return;
      let index = 0;
      while ((index = lowerText.indexOf(term, index)) > -1) {
        matches.push({ term, index });
        index += term.length;
      }
    });
    if (matches.length === 0) return text;
    matches.sort((a, b) => a.index - b.index);
    const CONTEXT_SIZE = 75;
    let bestStart = matches[0].index;
    let bestEnd = matches[0].index + matches[0].term.length;
    for (let i = 0; i < matches.length; i++) {
      let windowStart = matches[i].index;
      let windowEnd = matches[i].index + matches[i].term.length;
      let matchCount = 1;
      for (let j = i + 1; j < matches.length; j++) {
        if (matches[j].index - windowEnd > CONTEXT_SIZE) break;
        windowEnd = matches[j].index + matches[j].term.length;
        matchCount++;
      }
      if (matchCount > 1 && windowEnd - windowStart < bestEnd - bestStart) {
        bestStart = windowStart;
        bestEnd = windowEnd;
      }
    }
    const contextStart = Math.max(0, bestStart - CONTEXT_SIZE);
    const contextEnd = Math.min(text.length, bestEnd + CONTEXT_SIZE);
    let previewStart = contextStart;
    while (previewStart > 0 && !/[\s.!?\n]/.test(text[previewStart - 1])) {
      previewStart--;
    }
    let previewEnd = contextEnd;
    while (previewEnd < text.length && !/[\s.!?\n]/.test(text[previewEnd])) {
      previewEnd++;
    }
    let preview = text.slice(previewStart, previewEnd).trim();
    if (previewStart > 0) preview = "..." + preview;
    if (previewEnd < text.length) preview = preview + "...";
    return preview;
  }
  async openChat(chatId, selectedModelId) {
    if (this.isOpening) {
      return;
    }
    this.isOpening = true;
    this.close();
    try {
      const fullChatData = await this.chatStorage.loadChat(chatId);
      const { workspace } = this.app;
      const leaf = workspace.getLeaf("tab");
      const state = {
        chatId,
        selectedModelId
      };
      if (fullChatData) {
        state.systemPromptType = fullChatData.systemPromptType;
        state.systemPromptPath = fullChatData.systemPromptPath;
        state.agentMode = fullChatData.agentMode;
        state.includeVaultStructure = fullChatData.includeVaultStructure;
        state.chatFontSize = fullChatData.chatFontSize;
        state.chatTitle = fullChatData.title;
        state.version = fullChatData.version;
      }
      leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state
      }).then(() => {
        workspace.setActiveLeaf(leaf, { focus: true });
      });
    } catch (e) {
      new import_obsidian100.Notice("Error opening chat. Please try again.");
      this.openChatFile(chatId);
    }
  }
  openNewChat() {
    if (this.isOpening) {
      return;
    }
    this.isOpening = true;
    this.close();
    try {
      const { workspace } = this.app;
      const leaf = workspace.getLeaf("tab");
      leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state: {
          chatId: "",
          // Empty ID for new chat
          selectedModelId: this.plugin.settings.selectedModelId,
          // Default model
          includeVaultStructure: !!this.plugin.settings.defaultAgentMode
        }
      }).then(() => {
        workspace.setActiveLeaf(leaf, { focus: true });
      });
    } catch (e) {
      new import_obsidian100.Notice("Unable to open new chat.");
    }
  }
  async openChatFile(chatId) {
    if (this.isOpening) {
      return;
    }
    try {
      const filePath = `${this.plugin.settings.chatsDirectory || "SystemSculpt/Chats"}/${chatId}.json`;
      const file = this.app.vault.getAbstractFileByPath(filePath);
      if (file instanceof import_obsidian100.TFile) {
        await this.app.workspace.getLeaf(true).openFile(file);
        this.close();
      } else {
        throw new Error("Chat file not found");
      }
    } catch (error) {
      showPopup(this.app, "", {
        title: "Error",
        description: "Failed to open chat file",
        primaryButton: "OK"
      });
    }
  }
  onClose() {
    this.isOpening = false;
  }
  handleModalKeydown(e) {
    if (document.activeElement === this.searchInput.inputEl && e.key !== "Escape" && e.key !== "Tab") {
      return;
    }
    switch (e.key) {
      case "ArrowUp":
        e.preventDefault();
        this.selectPreviousItem();
        break;
      case "ArrowDown":
        e.preventDefault();
        this.selectNextItem();
        break;
      case "Enter":
        e.preventDefault();
        if (this.keyboardSelectedIndex >= 0 && this.keyboardSelectedIndex < this.filteredChats.length) {
          const chat = this.filteredChats[this.keyboardSelectedIndex];
          this.openChat(chat.id, chat.selectedModelId);
        }
        break;
      case "Escape":
        e.preventDefault();
        this.close();
        break;
      case "Tab":
        e.preventDefault();
        if (e.shiftKey) {
          this.selectPreviousItem();
        } else {
          this.selectNextItem();
        }
        break;
    }
  }
  selectNextItem() {
    if (this.chatItemElements.length === 0) return;
    if (this.keyboardSelectedIndex < 0) {
      this.keyboardSelectedIndex = 0;
    } else {
      this.keyboardSelectedIndex = (this.keyboardSelectedIndex + 1) % this.chatItemElements.length;
    }
    this.updateSelectedItemFromKeyboard();
  }
  selectPreviousItem() {
    if (this.chatItemElements.length === 0) return;
    if (this.keyboardSelectedIndex < 0) {
      this.keyboardSelectedIndex = this.chatItemElements.length - 1;
    } else {
      this.keyboardSelectedIndex = (this.keyboardSelectedIndex - 1 + this.chatItemElements.length) % this.chatItemElements.length;
    }
    this.updateSelectedItemFromKeyboard();
  }
  updateSelectedItemFromKeyboard() {
    if (this.keyboardSelectedIndex < 0 || this.keyboardSelectedIndex >= this.chatItemElements.length) {
      return;
    }
    this.chatItemElements.forEach((el) => {
      el.classList.remove("is-selected");
    });
    const selectedEl = this.chatItemElements[this.keyboardSelectedIndex];
    selectedEl.classList.add("is-selected");
    selectedEl.scrollIntoView({ block: "nearest", behavior: "smooth" });
  }
  handleSearchKeydown(e) {
    switch (e.key) {
      case "ArrowDown":
        e.preventDefault();
        this.selectNextItem();
        break;
      case "Enter":
        if (this.keyboardSelectedIndex >= 0 && this.keyboardSelectedIndex < this.filteredChats.length) {
          e.preventDefault();
          e.stopPropagation();
          const chat = this.filteredChats[this.keyboardSelectedIndex];
          this.openChat(chat.id, chat.selectedModelId);
        }
        break;
    }
  }
};

// src/core/plugin/ribbons.ts
init_titleUtils();
var RibbonManager = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
    this.chatStorage = new ChatStorageService(app, plugin.settings.chatsDirectory);
  }
  /**
   * Initialize the ribbon manager and register all ribbon icons
   */
  initialize() {
    this.registerRibbonIcons();
  }
  /**
   * Register all ribbon icons in the correct order:
   * 1. SystemSculpt Chat
   * 2. SystemSculpt Chat History
   * 3. SystemSculpt Janitor
   * 4. Similar Notes
   */
  registerRibbonIcons() {
    this.plugin.addRibbonIcon(
      "message-square",
      "Open SystemSculpt Chat",
      async () => {
        await this.openChatView();
      }
    );
    this.plugin.addRibbonIcon(
      "history",
      "Open SystemSculpt Chat History",
      () => {
        this.openChatHistoryModal();
      }
    );
    this.plugin.addRibbonIcon("trash", "Open SystemSculpt Janitor", () => {
      this.openJanitorModal();
    });
    this.plugin.addRibbonIcon("network", "Open Similar Notes Panel", async () => {
      await this.openSimilarNotesView();
    });
    this.plugin.addRibbonIcon("search", "Open SystemSculpt Search", async () => {
      const { SystemSculptSearchModal: SystemSculptSearchModal2 } = await Promise.resolve().then(() => (init_SystemSculptSearchModal(), SystemSculptSearchModal_exports));
      const modal = new SystemSculptSearchModal2(this.plugin);
      modal.open();
    });
  }
  /**
   * Open a new SystemSculpt Chat view in a new tab
   */
  async openChatView() {
    const { workspace } = this.app;
    const leaf = workspace.getLeaf("tab");
    await leaf.setViewState({
      type: CHAT_VIEW_TYPE,
      state: {
        chatId: "",
        selectedModelId: this.plugin.settings.selectedModelId,
        chatTitle: generateDefaultChatTitle(),
        includeVaultStructure: !!this.plugin.settings.defaultAgentMode
      }
    });
    const view = new ChatView(leaf, this.plugin);
    await leaf.open(view);
    workspace.setActiveLeaf(leaf, { focus: true });
  }
  /**
   * Open the SystemSculpt Chat History modal
   */
  openChatHistoryModal() {
    const modal = new LoadChatModal(this.plugin);
    modal.open();
  }
  /**
   * Open the SystemSculpt Janitor modal
   */
  openJanitorModal() {
    new JanitorModal(this.app, this.plugin).open();
  }
  /**
   * Open the Similar Notes view in the right sidebar
   */
  async openSimilarNotesView() {
    await this.plugin.getViewManager().activateEmbeddingsView();
  }
};

// src/views/EmbeddingsView.ts
var import_obsidian102 = require("obsidian");
var EMBEDDINGS_VIEW_TYPE = "systemsculpt-embeddings-view";
var EmbeddingsView = class extends import_obsidian102.ItemView {
  // 300ms delay
  constructor(leaf, plugin) {
    super(leaf);
    this.currentFile = null;
    this.currentChatView = null;
    this.currentResults = [];
    this.isLoading = false;
    this.lastSearchContent = "";
    this.lastFileHash = "";
    this.fileExists = false;
    this.isDragging = false;
    // Track drag state to prevent clearing results
    this.dragTimeout = null;
    this.pendingSearch = null;
    // Debouncing for active leaf changes
    this.searchTimeout = null;
    this.SEARCH_DELAY = 300;
    this.plugin = plugin;
  }
  getViewType() {
    return EMBEDDINGS_VIEW_TYPE;
  }
  getDisplayText() {
    return "Similar Notes";
  }
  getIcon() {
    return "network";
  }
  async onOpen() {
    this.contentEl = this.containerEl.children[1];
    this.contentEl.empty();
    this.contentEl.addClass("systemsculpt-embeddings-view");
    this.setupUI();
    this.registerEvents();
    this.showEmptyState();
    this.debouncedCheckActiveFile();
  }
  setupUI() {
    this.headerEl = this.contentEl.createDiv({ cls: "embeddings-view-header" });
    this.titleEl = this.headerEl.createDiv({ cls: "embeddings-view-title" });
    const titleRowEl = this.titleEl.createDiv({ cls: "embeddings-view-title-row" });
    const iconEl = titleRowEl.createDiv({ cls: "embeddings-view-icon" });
    (0, import_obsidian102.setIcon)(iconEl, "network");
    titleRowEl.createSpan({ text: "Similar Notes" });
    this.fileNameEl = this.titleEl.createDiv({ cls: "embeddings-view-file-name" });
    this.fileNameEl.style.display = "none";
    this.statusEl = this.contentEl.createDiv({ cls: "embeddings-view-status", attr: { style: "display: none;" } });
    this.resultsEl = this.contentEl.createDiv({ cls: "embeddings-view-results" });
    this.showEmptyState();
  }
  registerEvents() {
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        var _a, _b;
        try {
          (_b = (_a = window.FreezeMonitor) == null ? void 0 : _a.mark) == null ? void 0 : _b.call(_a, "embeddings:active-leaf-change");
        } catch (e) {
        }
        this.debouncedCheckActiveFile();
        this.flushPendingSearchIfVisible();
      })
    );
    this.registerEvent(
      // @ts-ignore - 'file-open' exists on workspace event bus
      this.app.workspace.on("file-open", () => {
        this.debouncedCheckActiveFile();
      })
    );
    this.registerEvent(
      this.app.workspace.on("layout-change", () => {
        this.flushPendingSearchIfVisible();
      })
    );
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        var _a, _b;
        if (file instanceof import_obsidian102.TFile && file === this.currentFile) {
          try {
            (_b = (_a = window.FreezeMonitor) == null ? void 0 : _a.mark) == null ? void 0 : _b.call(_a, "embeddings:file-modify");
          } catch (e) {
          }
          this.debouncedSearchCurrentFile();
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("systemsculpt:chat-loaded", (chatId) => {
        if (this.currentChatView && this.currentChatView.chatId === chatId) {
          this.debouncedSearchCurrentChat();
        }
      })
    );
    this.registerEvent(
      this.app.workspace.on("systemsculpt:chat-message-added", (chatId) => {
        if (this.currentChatView && this.currentChatView.chatId === chatId) {
          this.debouncedSearchCurrentChat();
        }
      })
    );
    this.contextChangeHandler = () => {
      if (this.currentChatView && this.currentResults.length > 0) {
        this.updateContextIndicators();
      }
    };
    document.addEventListener("systemsculpt:context-changed", this.contextChangeHandler);
  }
  debouncedCheckActiveFile() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = window.setTimeout(() => {
      this.checkActiveFile();
    }, this.SEARCH_DELAY);
  }
  debouncedSearchCurrentFile() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = window.setTimeout(() => {
      if (this.currentFile) {
        this.searchForSimilar(this.currentFile);
      }
    }, this.SEARCH_DELAY * 2);
  }
  debouncedSearchCurrentChat() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    this.searchTimeout = window.setTimeout(() => {
      if (this.currentChatView) {
        this.searchForSimilarFromChat(this.currentChatView);
      }
    }, this.SEARCH_DELAY * 2);
  }
  startRefreshAnimation() {
    this.titleEl.addClass("refreshing");
  }
  stopRefreshAnimation() {
    this.titleEl.removeClass("refreshing");
  }
  updateFileName(fileName) {
    this.fileNameEl.textContent = fileName;
    this.fileNameEl.style.display = "block";
  }
  hideFileName() {
    this.fileNameEl.style.display = "none";
  }
  isViewVisible() {
    var _a, _b, _c;
    const leafEl = (_b = (_a = this.containerEl) == null ? void 0 : _a.closest) == null ? void 0 : _b.call(_a, ".workspace-leaf");
    if (!leafEl) return false;
    const isHidden = leafEl.classList.contains("is-hidden");
    const isConnected = leafEl.isConnected;
    const rect = (_c = leafEl.getBoundingClientRect) == null ? void 0 : _c.call(leafEl);
    const hasSize = !!rect && rect.width > 0 && rect.height > 0;
    return isConnected && !isHidden && hasSize;
  }
  checkActiveFile() {
    var _a, _b;
    if (this.isDragging) {
      return;
    }
    if (!this.plugin.settings.embeddingsEnabled) {
      this.showDisabledState();
      return;
    }
    const activeMarkdownView = this.app.workspace.getActiveViewOfType(import_obsidian102.MarkdownView);
    const activeChatView = this.app.workspace.getActiveViewOfType(ChatView);
    const activeFile = (activeMarkdownView == null ? void 0 : activeMarkdownView.file) || null;
    const hasNewFile = activeFile && activeFile !== this.currentFile;
    const hasNewChat = activeChatView && activeChatView !== this.currentChatView;
    const isRefocusingOnChat = activeChatView && activeChatView === this.currentChatView && !activeFile;
    const switchingFromNonContentView = !this.currentFile && !this.currentChatView && (activeFile || activeChatView);
    if (hasNewFile) {
      if (((_a = this.currentFile) == null ? void 0 : _a.path) !== activeFile.path) {
      }
      this.currentFile = activeFile;
      this.currentChatView = null;
      this.updateFileName(activeFile.basename);
      setTimeout(() => this.searchForSimilar(activeFile), 50);
    } else if (hasNewChat) {
      const chatTitle = activeChatView.getChatTitle();
      if (((_b = this.currentChatView) == null ? void 0 : _b.chatId) !== activeChatView.chatId) {
      }
      this.currentChatView = activeChatView;
      this.currentFile = null;
      this.updateFileName(chatTitle || "Chat");
      setTimeout(() => this.searchForSimilarFromChat(activeChatView), 50);
    } else if (isRefocusingOnChat) {
      const chatContent = this.extractChatContent(activeChatView);
      const contentHash = this.hashContent(chatContent);
      if (contentHash !== this.lastFileHash) {
        setTimeout(() => this.searchForSimilarFromChat(activeChatView), 50);
      }
    } else if (switchingFromNonContentView) {
      if (activeFile) {
        this.currentFile = activeFile;
        this.currentChatView = null;
        this.updateFileName(activeFile.basename);
        setTimeout(() => this.searchForSimilar(activeFile), 50);
      } else if (activeChatView) {
        this.currentChatView = activeChatView;
        this.currentFile = null;
        this.updateFileName(activeChatView.getChatTitle() || "Chat");
        setTimeout(() => this.searchForSimilarFromChat(activeChatView), 50);
      }
    }
  }
  async searchForSimilar(file) {
    try {
      if (!this.isViewVisible()) {
        this.pendingSearch = { type: "file", file };
        return;
      }
      const manager = this.plugin.getOrCreateEmbeddingsManager();
      await manager.awaitReady();
      const stats = manager.getStats();
      const hasAnyEmbeddings = stats.processed > 0;
      if (stats.total === 0 && stats.processed === 0) {
        this.showProcessingPrompt();
        return;
      }
      const fingerprint = `${file.stat.mtime}-${file.stat.size}`;
      const fileInEmbeddings = manager.hasVector(file.path);
      if (!fileInEmbeddings || fingerprint !== this.lastFileHash) {
        this.showSmartLoading(file.basename, !fileInEmbeddings);
        this.lastFileHash = fingerprint;
        this.fileExists = fileInEmbeddings;
      } else {
        this.showQuickLoading(file.basename);
      }
      this.lastSearchContent = file.path;
      if (!manager.hasVector(file.path)) {
        if (hasAnyEmbeddings) {
          const content = await this.app.vault.read(file);
          if (!content.trim()) {
            this.showEmptyContent();
            return;
          }
          this.showQuickLoading(file.basename);
          const results2 = await manager.searchSimilar(content, 15);
          if (this.isViewVisible() && this.lastSearchContent === file.path) {
            await this.updateResults(results2, file);
          }
          return;
        } else {
          this.showProcessingPrompt();
          return;
        }
      }
      const results = await manager.findSimilar(file.path, 15);
      if (this.isViewVisible() && this.lastSearchContent === file.path) {
        await this.updateResults(results, file);
      }
    } catch (error) {
      this.showError(`Failed to find similar notes: ${error.message}`);
    }
  }
  async searchForSimilarFromChat(chatView) {
    try {
      if (!this.isViewVisible()) {
        this.pendingSearch = { type: "chat", chatView };
        return;
      }
      const manager = this.plugin.getOrCreateEmbeddingsManager();
      await manager.awaitReady();
      const stats = manager.getStats();
      if (stats.total === 0 && stats.processed === 0) {
        this.showProcessingPrompt();
        return;
      }
      const chatContent = this.extractChatContent(chatView);
      if (!chatContent.trim()) {
        this.showEmptyContent();
        return;
      }
      const contentHash = this.hashContent(chatContent);
      if (contentHash !== this.lastFileHash) {
        this.showSmartLoading(chatView.getChatTitle() || "Chat", false);
        this.lastFileHash = contentHash;
      } else {
        this.showQuickLoading(chatView.getChatTitle() || "Chat");
      }
      this.lastSearchContent = `chat:${chatView.chatId}`;
      const results = await manager.searchSimilar(chatContent, 15);
      const expectedSearchContent = `chat:${chatView.chatId}`;
      if (this.isViewVisible() && this.lastSearchContent === expectedSearchContent) {
        await this.updateResults(results, null, chatView.getChatTitle() || "Chat");
      }
    } catch (error) {
      this.showError(`Failed to find similar notes: ${error.message}`);
    }
  }
  extractChatContent(chatView) {
    const messages = chatView.getMessages();
    if (!messages || messages.length === 0) {
      return "";
    }
    const selectedMessages = [];
    for (let i = 0; i < Math.min(3, messages.length); i++) {
      selectedMessages.push(messages[i]);
    }
    if (messages.length > 3) {
      const latestStart = Math.max(3, messages.length - 2);
      for (let i = latestStart; i < messages.length; i++) {
        if (!selectedMessages.find((m) => m.message_id === messages[i].message_id)) {
          selectedMessages.push(messages[i]);
        }
      }
    }
    const extractedContent = selectedMessages.map((message) => {
      if (typeof message.content === "string") {
        return message.content;
      } else if (Array.isArray(message.content)) {
        return message.content.map((part) => {
          if (part.type === "text") {
            return part.text;
          }
          return "";
        }).join(" ");
      }
      return "";
    }).filter((content) => content.trim().length > 0).join("\n\n");
    return extractedContent;
  }
  /**
   * Check if a note is already in the current chat's context
   */
  isNoteInContext(notePath) {
    if (!this.currentChatView || !this.currentChatView.contextManager) {
      return false;
    }
    const contextFiles = this.currentChatView.contextManager.getContextFiles();
    const wikiLink = `[[${notePath}]]`;
    const fileName = notePath.split("/").pop() || notePath;
    const fileNameWikiLink = `[[${fileName}]]`;
    return contextFiles.has(notePath) || contextFiles.has(wikiLink) || contextFiles.has(fileName) || contextFiles.has(fileNameWikiLink);
  }
  /**
   * Update context indicators for all currently displayed results
   */
  updateContextIndicators() {
    const resultElements = this.resultsEl.querySelectorAll(".similar-note-item");
    resultElements.forEach((el, index) => {
      if (index < this.currentResults.length) {
        const result = this.currentResults[index];
        const isInContext = this.isNoteInContext(result.path);
        el.classList.toggle("similar-note-in-context", isInContext);
      }
    });
  }
  /**
   * Smart loading - uses subtle header animation instead of loading screen
   */
  showSmartLoading(fileName, needsProcessing) {
    this.isLoading = true;
    this.startRefreshAnimation();
  }
  /**
   * Quick loading - uses subtle header animation instead of loading screen
   */
  showQuickLoading(fileName) {
    this.isLoading = true;
    this.startRefreshAnimation();
  }
  showEmptyState() {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.hideFileName();
    this.statusEl.empty();
    this.resultsEl.empty();
    this.currentFile = null;
    this.currentChatView = null;
    this.lastSearchContent = "";
    const emptyEl = this.resultsEl.createDiv({ cls: "embeddings-view-empty" });
    const iconEl = emptyEl.createDiv({ cls: "empty-icon" });
    (0, import_obsidian102.setIcon)(iconEl, "file-text");
    emptyEl.createDiv({
      text: "Open a note or chat to see similar content",
      cls: "empty-title"
    });
    emptyEl.createDiv({
      text: "Switch to any markdown note or chat view and this panel will show related notes from your vault.",
      cls: "empty-description"
    });
  }
  showEmptyContent() {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.statusEl.empty();
    this.resultsEl.empty();
    const emptyEl = this.resultsEl.createDiv({ cls: "embeddings-view-empty" });
    const iconEl = emptyEl.createDiv({ cls: "empty-icon" });
    (0, import_obsidian102.setIcon)(iconEl, "file-x");
    emptyEl.createDiv({
      text: "Note is empty",
      cls: "empty-title"
    });
    emptyEl.createDiv({
      text: "Add some content to this note or chat to find similar notes.",
      cls: "empty-description"
    });
  }
  showError(message) {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.statusEl.empty();
    this.resultsEl.empty();
    const errorEl = this.resultsEl.createDiv({ cls: "embeddings-view-error" });
    const iconEl = errorEl.createDiv({ cls: "error-icon" });
    (0, import_obsidian102.setIcon)(iconEl, "alert-circle");
    errorEl.createDiv({
      text: "Error finding similar notes",
      cls: "error-title"
    });
    errorEl.createDiv({
      text: message,
      cls: "error-message"
    });
  }
  showDisabledState() {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.hideFileName();
    this.statusEl.empty();
    this.resultsEl.empty();
    this.currentFile = null;
    this.currentChatView = null;
    this.lastSearchContent = "";
    const disabledEl = this.resultsEl.createDiv({ cls: "embeddings-view-disabled" });
    const iconEl = disabledEl.createDiv({ cls: "disabled-icon" });
    (0, import_obsidian102.setIcon)(iconEl, "power");
    disabledEl.createDiv({
      text: "Embeddings Disabled",
      cls: "disabled-title"
    });
    disabledEl.createDiv({
      text: "Enable embeddings in Settings > SystemSculpt AI > Embeddings to find similar notes.",
      cls: "disabled-description"
    });
  }
  async updateResults(results, sourceFile, sourceName) {
    this.isLoading = false;
    this.stopRefreshAnimation();
    this.currentResults = results;
    const displayName = sourceName || (sourceFile == null ? void 0 : sourceFile.basename) || "Unknown";
    this.statusEl.empty();
    if (results.length > 0) {
      this.statusEl.createSpan({
        text: `${results.length} similar notes found for "${displayName}"`,
        cls: "systemsculpt-status-text"
      });
    } else {
      this.statusEl.createSpan({
        text: `No similar notes found for "${displayName}"`,
        cls: "systemsculpt-status-text muted"
      });
    }
    this.resultsEl.empty();
    if (results.length === 0) {
      const noResultsEl = this.resultsEl.createDiv({ cls: "embeddings-view-no-results" });
      const iconEl = noResultsEl.createDiv({ cls: "no-results-icon" });
      (0, import_obsidian102.setIcon)(iconEl, "search-x");
      noResultsEl.createDiv({
        text: "No similar notes found",
        cls: "no-results-title"
      });
      noResultsEl.createDiv({
        text: "This note doesn't have similar content in your vault yet.",
        cls: "no-results-description"
      });
      return;
    }
    const resultsContainer = this.resultsEl.createDiv({ cls: "results-container" });
    for (const result of results) {
      await this.renderResult(resultsContainer, result);
    }
  }
  async renderResult(container, result) {
    const resultEl = container.createDiv({ cls: "similar-note-item cursor-pointer" });
    const isDraggableForChat = this.currentChatView !== null;
    if (isDraggableForChat) {
      const isInContext = this.isNoteInContext(result.path);
      if (isInContext) {
        resultEl.addClass("similar-note-in-context");
      }
    }
    if (isDraggableForChat) {
      resultEl.setAttribute("draggable", "true");
      resultEl.addClass("similar-note-draggable");
      resultEl.addEventListener("dragstart", (e) => {
        if (!e.dataTransfer) return;
        this.isDragging = true;
        if (this.dragTimeout) {
          window.clearTimeout(this.dragTimeout);
        }
        this.dragTimeout = window.setTimeout(() => {
          this.isDragging = false;
          this.dragTimeout = null;
        }, 5e3);
        e.dataTransfer.setData("text/plain", result.path);
        e.dataTransfer.setData("application/x-systemsculpt-similar-note", JSON.stringify({
          path: result.path,
          title: result.metadata.title || result.path.split("/").pop() || result.path,
          score: result.score,
          source: "similar-notes"
        }));
        e.dataTransfer.effectAllowed = "copy";
        resultEl.addClass("similar-note-dragging");
      });
      resultEl.addEventListener("dragend", (e) => {
        this.isDragging = false;
        if (this.dragTimeout) {
          window.clearTimeout(this.dragTimeout);
          this.dragTimeout = null;
        }
        resultEl.removeClass("similar-note-dragging");
        setTimeout(() => {
          this.debouncedCheckActiveFile();
        }, 100);
      });
    }
    resultEl.addEventListener("click", async (e) => {
      if (e.target.closest(".internal-link")) {
        return;
      }
      if (isDraggableForChat && e.defaultPrevented) {
        return;
      }
      e.preventDefault();
      await this.openFile(result.path);
    });
    const scorePercent = Math.round(result.score * 100);
    const scoreClass = scorePercent >= 75 ? "score-high" : scorePercent >= 50 ? "score-medium" : "score-low";
    const scoreEl = resultEl.createDiv({ cls: `note-score ${scoreClass}` });
    scoreEl.createSpan({ text: `${scorePercent}%` });
    const contentEl = resultEl.createDiv({ cls: "note-content" });
    const titleEl = contentEl.createDiv({ cls: "note-title" });
    const linkEl = titleEl.createEl("a", {
      cls: "internal-link",
      text: result.metadata.title || result.path.split("/").pop() || result.path,
      href: result.path
    });
    linkEl.addEventListener("click", async (e) => {
      e.preventDefault();
      await this.openFile(result.path);
    });
    if (result.metadata.excerpt) {
      const excerptEl = contentEl.createDiv({ cls: "note-excerpt" });
      excerptEl.textContent = result.metadata.excerpt;
    }
    const metaEl = contentEl.createDiv({ cls: "note-metadata" });
    const pathParts = result.path.split("/");
    if (pathParts.length > 1) {
      const pathEl = metaEl.createSpan({ cls: "note-path" });
      pathEl.textContent = pathParts.slice(0, -1).join("/");
    }
    if (result.metadata.lastModified) {
      const date = new Date(result.metadata.lastModified);
      metaEl.createSpan({
        cls: "note-date",
        text: this.formatDate(date)
      });
    }
  }
  async openFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file instanceof import_obsidian102.TFile) {
      await this.app.workspace.getLeaf(false).openFile(file);
    }
  }
  /**
   * Show processing prompt - now uses unified state
   */
  showProcessingPrompt() {
    this.showProcessingState(
      "No embeddings data found",
      "Process your vault to enable finding similar notes."
    );
  }
  /**
   * Start processing embeddings
   */
  async startProcessing() {
    try {
      const manager = this.plugin.getOrCreateEmbeddingsManager();
      await manager.awaitReady();
      manager.resumeProcessing();
      if (manager.isCurrentlyProcessing()) {
        new import_obsidian102.Notice("Processing already in progress");
        return;
      }
      this.showProcessingStatus();
      if (this.plugin.settings.embeddingsProvider === "custom") {
        const endpoint = (this.plugin.settings.embeddingsCustomEndpoint || "").trim();
        const model = (this.plugin.settings.embeddingsCustomModel || this.plugin.settings.embeddingsModel || "").trim();
        if (!endpoint || !model) {
          this.showError("Custom embeddings provider is not configured. Set API Endpoint and Model in settings.");
          return;
        }
      }
      await manager.processVault((progress) => {
        this.updateProcessingStatus(progress);
      });
      if (this.currentFile) {
        await this.searchForSimilar(this.currentFile);
      }
    } catch (error) {
      this.showError(`Failed to process embeddings: ${error.message}`);
    }
  }
  /**
   * Show processing status - simplified and user-friendly
   */
  showProcessingStatus() {
    this.showProcessingState(
      "Building semantic search...",
      "Preparing your notes for intelligent search. This happens once and runs in the background.",
      false
    );
    const processingEl = this.resultsEl.querySelector(".embeddings-view-processing");
    if (processingEl) {
      const progressEl = processingEl.createDiv({ cls: "processing-progress" });
      progressEl.createDiv({
        text: "Starting...",
        cls: "systemsculpt-progress-text"
      });
      const progressBar = progressEl.createDiv({ cls: "systemsculpt-progress-bar" });
      progressBar.createDiv({ cls: "systemsculpt-progress-fill" });
    }
  }
  /**
   * Update processing progress
   */
  updateProcessingStatus(progress) {
    const progressEl = this.resultsEl.querySelector(".processing-progress");
    if (!progressEl) return;
    const progressText = progressEl.querySelector(".systemsculpt-progress-text");
    const progressFill = progressEl.querySelector(".systemsculpt-progress-fill");
    if (progressText) {
      const safeCurrent = Math.min(progress.current, progress.total);
      const percentage = progress.total > 0 ? Math.round(safeCurrent / progress.total * 100) : 0;
      progressText.textContent = `Building embeddings... ${percentage}%`;
    }
    if (progressFill && progress.total > 0) {
      const safeCurrent = Math.min(progress.current, progress.total);
      const percentage = Math.min(100, safeCurrent / progress.total * 100);
      progressFill.style.width = `${percentage}%`;
      progressFill.classList.add("processing");
    }
  }
  formatDate(date) {
    const now = /* @__PURE__ */ new Date();
    const diff = now.getTime() - date.getTime();
    if (diff < 36e5) {
      const minutes = Math.floor(diff / 6e4);
      return `${minutes}min ago`;
    }
    if (diff < 864e5) {
      const hours = Math.floor(diff / 36e5);
      return `${hours}h ago`;
    }
    if (diff < 6048e5) {
      const days = Math.floor(diff / 864e5);
      return `${days}d ago`;
    }
    return date.toLocaleDateString();
  }
  async onClose() {
    if (this.searchTimeout) {
      window.clearTimeout(this.searchTimeout);
    }
    if (this.dragTimeout) {
      window.clearTimeout(this.dragTimeout);
    }
    if (this.contextChangeHandler) {
      document.removeEventListener("systemsculpt:context-changed", this.contextChangeHandler);
    }
  }
  flushPendingSearchIfVisible() {
    if (!this.isViewVisible() || !this.pendingSearch) return;
    const pending = this.pendingSearch;
    this.pendingSearch = null;
    if (pending.type === "file" && pending.file) {
      setTimeout(() => this.searchForSimilar(pending.file), 10);
    } else if (pending.type === "chat" && pending.chatView) {
      setTimeout(() => this.searchForSimilarFromChat(pending.chatView), 10);
    }
  }
  /**
   * Simple hash function for content comparison
   */
  hashContent(content) {
    let hash = 0;
    for (let i = 0; i < content.length; i++) {
      const char = content.charCodeAt(i);
      hash = (hash << 5) - hash + char;
      hash = hash & hash;
    }
    return hash.toString();
  }
  /**
   * Check if file exists in embeddings database
   */
  async checkFileExists(filePath, manager) {
    try {
      const stats = manager.getStats();
      return stats.total > 0;
    } catch (error) {
      return false;
    }
  }
  /**
   * Unified processing state - replaces multiple similar states
   */
  showProcessingState(title, description, showActions = true) {
    this.statusEl.empty();
    this.resultsEl.empty();
    const processingEl = this.resultsEl.createDiv({ cls: "embeddings-view-processing" });
    const iconEl = processingEl.createDiv({ cls: "processing-icon" });
    (0, import_obsidian102.setIcon)(iconEl, "database");
    processingEl.createDiv({
      text: title,
      cls: "processing-title"
    });
    processingEl.createDiv({
      text: description,
      cls: "processing-description"
    });
    if (showActions) {
      const actionsEl = processingEl.createDiv({ cls: "processing-actions" });
      const startBtn = actionsEl.createEl("button", {
        text: "Start Processing",
        cls: "mod-cta"
      });
      startBtn.addEventListener("click", async () => {
        await this.startProcessing();
      });
      const settingsBtn = actionsEl.createEl("button", {
        text: "Settings",
        cls: "mod-muted"
      });
      settingsBtn.addEventListener("click", () => {
        this.app.setting.open();
        this.app.setting.openTabById(this.plugin.manifest.id);
      });
    }
  }
};

// src/core/plugin/views.ts
var ViewManager = class {
  // Increased from 2000ms to 10000ms for network operations
  constructor(plugin, app) {
    this.isInitialized = false;
    this.isInitializing = false;
    this.initPromise = null;
    this.deferredViews = /* @__PURE__ */ new Map();
    this.initializationTimeout = 1e4;
    this.plugin = plugin;
    this.app = app;
    this.ribbonManager = new RibbonManager(plugin, app);
  }
  initialize() {
    this.registerView();
    setTimeout(() => this.ribbonManager.initialize(), 0);
    this.app.workspace.onLayoutReady(() => {
      var _a, _b;
      try {
        (_b = (_a = window.FreezeMonitor) == null ? void 0 : _a.mark) == null ? void 0 : _b.call(_a, "view-manager:onLayoutReady");
      } catch (e) {
      }
      this.initializeInBackground().catch((error) => {
      });
    });
  }
  async initializeInBackground() {
    if (this.isInitializing || this.isInitialized) return;
    this.isInitializing = true;
    const startTime = performance.now();
    try {
      const leaves = this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE);
      const visibleLeaves = leaves.filter((leaf) => !leaf.view.containerEl.hidden);
      for (const leaf of visibleLeaves) {
        const view = leaf.view;
        const state = leaf.getViewState();
        if (this.isValidChatState(state)) {
          await this.restoreView(view, state.state);
        }
      }
      this.isInitialized = true;
      for (const [id, initFn] of this.deferredViews) {
        try {
          initFn();
        } catch (error) {
        }
      }
      this.deferredViews.clear();
      const hiddenLeaves = leaves.filter((leaf) => leaf.view.containerEl.hidden);
      if (hiddenLeaves.length > 0) {
        setTimeout(() => {
          for (const leaf of hiddenLeaves) {
            const view = leaf.view;
            const state = leaf.getViewState();
            if (this.isValidChatState(state)) {
              this.restoreView(view, state.state).catch((error) => {
              });
            }
          }
        }, 0);
      }
    } catch (error) {
    } finally {
      this.isInitializing = false;
    }
  }
  async restoreView(view, state) {
    var _a;
    try {
      await view.setState(state);
    } catch (error) {
      try {
        const minimalState = {
          chatId: state.chatId,
          selectedModelId: state.selectedModelId || this.plugin.settings.selectedModelId,
          chatTitle: state.chatTitle || "Recovered Chat"
        };
        await view.setState(minimalState);
        new import_obsidian103.Notice("Chat was partially recovered due to an error", 5e3);
      } catch (fallbackError) {
        (_a = view.leaf) == null ? void 0 : _a.detach();
      }
    }
  }
  async initializeModels() {
    try {
      const models = await this.plugin.modelService.getModels();
      return models;
    } catch (error) {
      return [];
    }
  }
  // Method to defer a view initialization
  deferViewInitialization(id, initFn) {
    if (this.isInitialized) {
      initFn();
    } else {
      this.deferredViews.set(id, initFn);
    }
  }
  async restoreChatViews() {
    const leaves = this.app.workspace.getLeavesOfType(CHAT_VIEW_TYPE);
    if (leaves.length === 0) {
      return;
    }
    for (const leaf of leaves) {
      const view = leaf.view;
      const state = leaf.getViewState();
      if (!this.isValidChatState(state)) {
        continue;
      }
      const chatState = state.state;
      try {
        await this.retrySetState(view, chatState);
      } catch (error) {
        leaf.detach();
      }
    }
  }
  isValidChatState(state) {
    var _a, _b;
    if (!((_a = state == null ? void 0 : state.state) == null ? void 0 : _a.chatId)) {
      return false;
    }
    const chatId = state.state.chatId;
    if ("messages" in state.state) {
      if (!Array.isArray(state.state.messages)) {
        state.state.messages = [];
      }
    }
    if ("systemPromptType" in state.state) {
      const validTypes = ["general-use", "concise", "agent", "custom"];
      if (!validTypes.includes((_b = state.state.systemPromptType) == null ? void 0 : _b.toLowerCase())) {
        state.state.systemPromptType = "general-use";
      } else {
        const normalizedType = state.state.systemPromptType.toLowerCase();
        if (normalizedType !== state.state.systemPromptType) {
          state.state.systemPromptType = normalizedType;
        }
      }
    }
    if (!("messages" in state.state)) {
      state.state.messages = [];
    }
    return true;
  }
  async retrySetState(view, state, maxRetries = 3) {
    let lastError = null;
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        if (attempt > 1) {
          await new Promise((resolve) => setTimeout(resolve, Math.pow(2, attempt - 1) * 1e3));
        }
        await view.setState(state);
        if (attempt > 1) {
        }
        return;
      } catch (error) {
        lastError = error;
      }
    }
    throw new Error(`Failed to restore chat after ${maxRetries} attempts: ${lastError == null ? void 0 : lastError.message}`);
  }
  registerView() {
    this.plugin.registerView(
      CHAT_VIEW_TYPE,
      (leaf) => new ChatView(leaf, this.plugin)
    );
    this.plugin.registerView(
      EMBEDDINGS_VIEW_TYPE,
      (leaf) => new EmbeddingsView(leaf, this.plugin)
    );
  }
  async activateEmbeddingsView() {
    const existingLeaves = this.app.workspace.getLeavesOfType(EMBEDDINGS_VIEW_TYPE);
    if (existingLeaves.length > 0) {
      this.app.workspace.revealLeaf(existingLeaves[0]);
      return existingLeaves[0].view;
    }
    const rightLeaf = this.app.workspace.getRightLeaf(false);
    if (!rightLeaf) {
      throw new Error("Failed to create right sidebar leaf");
    }
    await rightLeaf.setViewState({
      type: EMBEDDINGS_VIEW_TYPE,
      active: true
    });
    this.app.workspace.revealLeaf(rightLeaf);
    return rightLeaf.view;
  }
  unloadViews() {
    this.app.workspace.detachLeavesOfType(CHAT_VIEW_TYPE);
    this.app.workspace.detachLeavesOfType(EMBEDDINGS_VIEW_TYPE);
  }
};

// src/core/plugin/commands.ts
var import_obsidian107 = require("obsidian");
init_StandardModelSelectionModal();
init_TitleGenerationService();

// src/modals/TemplateSelectionModal.ts
var import_obsidian104 = require("obsidian");
var TemplateSelectionModal = class extends import_obsidian104.Modal {
  constructor(app, plugin, onTemplateSelected) {
    super(app);
    this.templateFiles = [];
    this.isLoading = true;
    this.templatePreviews = /* @__PURE__ */ new Map();
    // Using any since we don't have the SearchService type here
    this.selectedCardIndex = -1;
    this.templateCards = [];
    this.currentSearchResults = [];
    this.listeners = [];
    this.plugin = plugin;
    this.onTemplateSelected = onTemplateSelected;
  }
  // Add method to register event listeners
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  // Add method to remove all registered event listeners
  removeAllListeners() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
  /**
   * Override the open method to ensure templates are loaded first
   */
  async onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("systemsculpt-template-modal");
    const loadingContainer = contentEl.createDiv({
      cls: "systemsculpt-progress-overlay"
    });
    const statusContainer = loadingContainer.createDiv({
      cls: "systemsculpt-progress-status"
    });
    const statusIcon = statusContainer.createDiv({
      cls: "systemsculpt-progress-status-icon"
    });
    (0, import_obsidian104.setIcon)(statusIcon, "loader-2");
    const progressText = statusContainer.createSpan({
      text: "Loading templates..."
    });
    this.isLoading = true;
    const searchContainer = contentEl.createDiv({
      cls: "systemsculpt-search-container"
    });
    this.searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search templates...",
      cls: "systemsculpt-search-input"
    });
    this.templateGrid = contentEl.createDiv({
      cls: "systemsculpt-template-grid"
    });
    try {
      await this.loadTemplateFiles();
      if (this.templateFiles.length > 0) {
        this.isLoading = false;
        this.renderTemplates(this.templateFiles);
      }
      this.setupEventListeners();
    } catch (error) {
      new import_obsidian104.Notice("Error loading templates", 3e3);
    } finally {
      loadingContainer.remove();
      this.searchInput.focus();
    }
  }
  // Load template files from the system prompts directory
  async loadTemplateFiles() {
    const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
    try {
      if (this.plugin.directoryManager) {
        await this.plugin.directoryManager.ensureDirectoryByPath(systemPromptsDir);
      } else {
        await this.app.vault.createFolder(systemPromptsDir).catch(() => {
        });
      }
      const files = this.app.vault.getMarkdownFiles().filter(
        (file) => file.path.startsWith(systemPromptsDir)
      );
      if (files.length > 0) {
        this.templateFiles = files.sort(
          (a, b) => a.basename.toLowerCase().localeCompare(b.basename.toLowerCase())
        );
        await this.loadTemplatePreviews();
        this.currentSearchResults = [...this.templateFiles];
      } else {
        new import_obsidian104.Notice("No templates found in your system prompts directory", 3e3);
        throw new Error("No templates found");
      }
    } catch (error) {
      throw error;
    }
  }
  // Load previews for all templates
  async loadTemplatePreviews() {
    this.templatePreviews.clear();
    for (const file of this.templateFiles) {
      try {
        const content = await this.app.vault.read(file);
        const preview = content.replace(/\n/g, " ").trim().slice(0, 100);
        const previewText = preview.length < content.length ? preview + "..." : preview;
        this.templatePreviews.set(file.path, previewText);
      } catch (error) {
        this.templatePreviews.set(file.path, "Error loading preview");
      }
    }
  }
  setupEventListeners() {
    this.registerListener(this.searchInput, "input", () => {
      const query = this.searchInput.value.toLowerCase();
      if (!query) {
        this.currentSearchResults = [...this.templateFiles];
        this.selectedCardIndex = -1;
        this.renderTemplates(this.currentSearchResults);
        return;
      }
      const results = this.templateFiles.filter(
        (file) => file.basename.toLowerCase().includes(query) || (this.templatePreviews.get(file.path) || "").toLowerCase().includes(query)
      );
      this.currentSearchResults = results;
      this.selectedCardIndex = -1;
      this.renderTemplates(results);
    });
    this.registerListener(this.contentEl, "keydown", (e) => {
      if (e.key === "Tab") {
        e.preventDefault();
        if (this.templateCards.length === 0) return;
        if (e.shiftKey) {
          this.selectedCardIndex = this.selectedCardIndex <= 0 ? this.templateCards.length - 1 : this.selectedCardIndex - 1;
        } else {
          this.selectedCardIndex = this.selectedCardIndex >= this.templateCards.length - 1 ? 0 : this.selectedCardIndex + 1;
        }
        this.templateCards.forEach((card, i) => {
          const isSelected = i === this.selectedCardIndex;
          card.classList.toggle("systemsculpt-keyboard-selected", isSelected);
          if (isSelected) {
            card.scrollIntoView({ behavior: "smooth", block: "nearest" });
          }
        });
      } else if (e.key === "Enter" && this.selectedCardIndex >= 0 && this.templateCards.length > 0) {
        e.preventDefault();
        const selectedCard = this.templateCards[this.selectedCardIndex];
        if (selectedCard == null ? void 0 : selectedCard.dataset.filePath) {
          const file = this.templateFiles.find((f) => f.path === selectedCard.dataset.filePath);
          if (file) {
            this.handleTemplateSelection(file);
          }
        }
      }
    });
  }
  renderTemplates(templates) {
    if (!this.templateGrid) return;
    this.templateGrid.empty();
    this.templateCards = [];
    if (templates.length === 0) {
      const emptyState = this.templateGrid.createDiv({
        cls: "systemsculpt-template-empty"
      });
      const searchIcon = emptyState.createDiv();
      (0, import_obsidian104.setIcon)(searchIcon, "search");
      emptyState.createDiv({
        text: this.searchInput.value ? "No templates found matching your search" : "No templates found in the system prompts directory",
        cls: "systemsculpt-empty-message"
      });
      return;
    }
    const header = this.templateGrid.createDiv({
      cls: "systemsculpt-provider-header"
    });
    header.createSpan({ text: "Available Templates" });
    templates.forEach((file) => {
      const card = this.renderTemplateCard(file);
      this.templateGrid.appendChild(card);
      this.templateCards.push(card);
    });
  }
  renderTemplateCard(file) {
    var _a;
    const card = document.createElement("div");
    card.className = "systemsculpt-template-card";
    card.dataset.filePath = file.path;
    const cardContent = card.createDiv({ cls: "systemsculpt-card-content" });
    const iconContainer = cardContent.createDiv({ cls: "systemsculpt-template-icon" });
    (0, import_obsidian104.setIcon)(iconContainer, "file-text");
    const textContainer = cardContent.createDiv({ cls: "systemsculpt-card-text" });
    textContainer.createDiv({
      cls: "systemsculpt-template-title",
      text: file.basename
    });
    const preview = this.templatePreviews.get(file.path) || "Preview not available";
    textContainer.createDiv({
      cls: "systemsculpt-template-preview",
      text: preview
    });
    const meta = textContainer.createDiv({ cls: "systemsculpt-template-meta" });
    const pathInfo = meta.createDiv({ cls: "systemsculpt-template-info" });
    (0, import_obsidian104.setIcon)(pathInfo, "folder");
    pathInfo.createSpan({ text: ((_a = file.parent) == null ? void 0 : _a.path) || "Unknown location" });
    const dateInfo = meta.createDiv({ cls: "systemsculpt-template-info" });
    (0, import_obsidian104.setIcon)(dateInfo, "calendar");
    dateInfo.createSpan({
      text: file.stat ? new Date(file.stat.mtime).toLocaleString() : "Unknown date"
    });
    this.registerListener(card, "click", () => {
      this.handleTemplateSelection(file);
    });
    return card;
  }
  async handleTemplateSelection(file) {
    await this.onTemplateSelected(file);
    this.close();
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
    this.removeAllListeners();
  }
};

// src/core/plugin/commands.ts
init_modelUtils();
init_debugLogger();
init_errorLogger();
var CommandManager = class {
  constructor(plugin, app) {
    this.plugin = plugin;
    this.app = app;
    this.ribbonManager = new RibbonManager(plugin, app);
  }
  registerCommands() {
    this.registerToggleAudioRecorder();
    this.registerOpenChat();
    this.registerOpenChatHistory();
    this.registerOpenJanitor();
    this.registerOpenSystemSculptSearch();
    this.registerReloadObsidian();
    this.registerOpenSettings();
    this.registerChangeChatModel();
    this.registerSetDefaultChatModel();
    this.registerChatWithFile();
    this.registerResumeChat();
    this.registerChangeChatTitle();
    this.registerOpenTemplateModal();
    this.registerOpenEmbeddingsView();
    this.registerQuickFileEdit();
    this.registerCleanupPhantomTools();
    this.registerDebugCommands();
    this.registerEmbeddingsDatabaseCommands();
  }
  registerToggleAudioRecorder() {
    this.plugin.addCommand({
      id: "toggle-audio-recorder",
      name: "Toggle Audio Recorder",
      callback: async () => {
        const alreadyInitialized = this.plugin.hasRecorderService();
        const logger = this.plugin.getLogger();
        logger.debug("Toggle audio recorder command received", {
          source: "CommandManager",
          method: "toggleAudioRecorder",
          metadata: {
            alreadyInitialized
          }
        });
        try {
          const recorderService = this.plugin.getRecorderService();
          await recorderService.toggleRecording();
          logger.info("Audio recorder toggled", {
            source: "CommandManager",
            method: "toggleAudioRecorder",
            metadata: {
              alreadyInitialized
            }
          });
        } catch (error) {
          logger.error("Failed to toggle audio recorder", error, {
            source: "CommandManager",
            method: "toggleAudioRecorder",
            metadata: {
              alreadyInitialized
            }
          });
          new import_obsidian107.Notice("Unable to toggle the audio recorder. Check the SystemSculpt logs for details.", 8e3);
        }
      },
      hotkeys: [{ modifiers: ["Mod"], key: "r" }]
    });
  }
  registerOpenChat() {
    this.plugin.addCommand({
      id: "open-systemsculpt-chat",
      name: "Open SystemSculpt Chat",
      callback: async () => {
        await this.ribbonManager.openChatView();
      }
    });
  }
  registerOpenChatHistory() {
    this.plugin.addCommand({
      id: "open-chat-history",
      name: "Open SystemSculpt Chat History",
      callback: () => {
        this.ribbonManager.openChatHistoryModal();
      }
    });
  }
  registerOpenJanitor() {
    this.plugin.addCommand({
      id: "open-systemsculpt-janitor",
      name: "Open SystemSculpt Janitor",
      callback: () => {
        this.ribbonManager.openJanitorModal();
      }
    });
  }
  registerOpenSystemSculptSearch() {
    this.plugin.addCommand({
      id: "open-systemsculpt-search",
      name: "Open SystemSculpt Search",
      callback: async () => {
        const { SystemSculptSearchModal: SystemSculptSearchModal2 } = await Promise.resolve().then(() => (init_SystemSculptSearchModal(), SystemSculptSearchModal_exports));
        const modal = new SystemSculptSearchModal2(this.plugin);
        modal.open();
      },
      hotkeys: [{ modifiers: ["Mod"], key: "k" }]
    });
  }
  registerReloadObsidian() {
    this.plugin.addCommand({
      id: "reload-obsidian",
      name: "Reload Obsidian",
      callback: () => {
        window.location.reload();
      }
    });
  }
  registerOpenSettings() {
    this.plugin.addCommand({
      id: "open-systemsculpt-settings",
      name: "Open SystemSculpt AI Settings",
      callback: () => {
        this.app.setting.open();
        this.app.setting.openTabById(this.plugin.manifest.id);
      }
    });
  }
  registerChangeChatModel() {
    this.plugin.addCommand({
      id: "change-chat-model",
      name: "Change Chat Model (Current Chat)",
      checkCallback: (checking) => {
        const chatView = this.app.workspace.getActiveViewOfType(ChatView);
        if (!chatView) {
          if (!checking) {
            new import_obsidian107.Notice("You need to be in an active SystemSculpt chat view to use this command.", 5e3);
          }
          return false;
        }
        if (!checking) {
          (async () => {
            try {
              await this.plugin.modelService.getModels();
              const modal = new StandardModelSelectionModal({
                app: this.app,
                plugin: this.plugin,
                currentModelId: chatView.getSelectedModelId() || "",
                onSelect: async (result) => {
                  const canonicalId = ensureCanonicalId(result.modelId);
                  await chatView.setSelectedModelId(canonicalId);
                  new import_obsidian107.Notice("Model updated for this chat.", 2e3);
                }
              });
              modal.open();
            } catch (err) {
              new import_obsidian107.Notice("Failed to fetch available models", 1e4);
            }
          })();
        }
        return true;
      }
    });
  }
  registerSetDefaultChatModel() {
    this.plugin.addCommand({
      id: "set-default-chat-model",
      name: "Set Default Chat Model",
      callback: async () => {
        if (!this.plugin) {
          new import_obsidian107.Notice("SystemSculpt plugin not available.", 1e4);
          return;
        }
        try {
          await this.plugin.modelService.getModels();
          const modal = new StandardModelSelectionModal({
            app: this.app,
            plugin: this.plugin,
            currentModelId: this.plugin.settings.selectedModelId || "",
            onSelect: async (result) => {
              try {
                const canonicalId = ensureCanonicalId(result.modelId);
                await this.plugin.getSettingsManager().updateSettings({ selectedModelId: canonicalId });
                new import_obsidian107.Notice("Default model for new chats updated.", 3e3);
              } catch (saveError) {
                new import_obsidian107.Notice("Failed to save default model setting.", 1e4);
              }
            }
          });
          modal.open();
        } catch (err) {
          new import_obsidian107.Notice("Failed to fetch available models", 1e4);
        }
      }
    });
  }
  registerChatWithFile() {
    this.plugin.addCommand({
      id: "chat-with-file",
      name: "Chat with File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) return false;
        const extension = activeFile.extension.toLowerCase();
        const supportedExtensions = [
          "md",
          "txt",
          "markdown",
          "pdf",
          "doc",
          "docx",
          "ppt",
          "pptx",
          "xls",
          "xlsx",
          "mp3",
          "wav",
          "m4a",
          "ogg",
          "webm",
          "jpg",
          "jpeg",
          "png",
          "gif",
          "webp",
          "svg"
        ];
        if (!supportedExtensions.includes(extension)) return false;
        if (!checking) {
          const leaf = this.app.workspace.getLeaf("tab");
          const view = new ChatView(leaf, this.plugin);
          leaf.open(view).then(async () => {
            await new Promise((resolve) => setTimeout(resolve, 50));
            this.app.workspace.setActiveLeaf(leaf, { focus: true });
            await view.addFileToContext(activeFile);
            view.focusInput();
          });
        }
        return true;
      }
    });
  }
  registerResumeChat() {
    this.plugin.addCommand({
      id: "resume-chat-from-history",
      name: "Resume Chat from Current History File",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile || !this.plugin.resumeChatService) return false;
        const isChatHistory = this.plugin.resumeChatService.isChatHistoryFile(activeFile);
        if (!checking && isChatHistory) {
          const chatId = this.plugin.resumeChatService.extractChatId(activeFile);
          const modelId = this.plugin.resumeChatService.getModelFromFile(activeFile);
          if (chatId) {
            this.plugin.resumeChatService.openChat(chatId, modelId);
          } else {
            new import_obsidian107.Notice("Could not extract chat ID from this file.", 5e3);
          }
        }
        return isChatHistory;
      }
    });
  }
  /**
   * Register command to change/generate title for chats and notes
   */
  registerChangeChatTitle() {
    this.plugin.addCommand({
      id: "change-chat-title",
      name: "Change/Generate Title",
      checkCallback: (checking) => {
        const chatView = this.app.workspace.getActiveViewOfType(ChatView);
        if (chatView) {
          if (chatView.messages.length === 0) return false;
          if (!checking) {
            (async () => {
              if (this.plugin.settings.automaticTitleGeneration) {
                const { TitleGenerationNotice: TitleGenerationNotice2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
                const notice = new TitleGenerationNotice2();
                notice.updateProgress(0, "Analyzing content...");
                try {
                  const titleService = TitleGenerationService.getInstance(this.plugin);
                  const title = await titleService.generateTitle(
                    chatView.getMessages(),
                    (title2) => {
                    },
                    (progress, status) => {
                      notice.updateProgress(progress, status);
                    }
                  );
                  if (title && title !== chatView.getChatTitle()) {
                    await chatView.setTitle(title);
                    notice.showCompletion("Chat title updated successfully!");
                  } else {
                    notice.hide();
                  }
                } catch (error) {
                  const errorMessage = error instanceof Error ? error.message : String(error);
                  notice.showError(`Failed to generate title: ${errorMessage}`);
                }
              } else {
                const { showTitleGenerationModal: showTitleGenerationModal2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
                const newTitle = await showTitleGenerationModal2(
                  this.app,
                  this.plugin,
                  chatView.getChatTitle(),
                  chatView.getMessages()
                );
                if (newTitle !== null && newTitle !== chatView.getChatTitle()) {
                  await chatView.setTitle(newTitle);
                  new import_obsidian107.Notice("Chat title updated", 3e3);
                }
              }
            })();
          }
          return true;
        }
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) {
          if (!checking) {
            new import_obsidian107.Notice("You need to be within a note or chat view to change the title.", 5e3);
          }
          return false;
        }
        if (activeFile.extension !== "md") {
          if (!checking) {
            new import_obsidian107.Notice("Title generation is only available for markdown files.", 5e3);
          }
          return false;
        }
        if (!checking) {
          (async () => {
            if (this.plugin.settings.automaticTitleGeneration) {
              const { TitleGenerationNotice: TitleGenerationNotice2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
              const notice = new TitleGenerationNotice2();
              notice.updateProgress(0, "Analyzing content...");
              try {
                const titleService = TitleGenerationService.getInstance(this.plugin);
                const title = await titleService.generateTitle(
                  activeFile,
                  (title2) => {
                  },
                  (progress, status) => {
                    notice.updateProgress(progress, status);
                  }
                );
                if (title && title !== activeFile.basename) {
                  const newPath = activeFile.path.replace(activeFile.basename, title);
                  try {
                    await this.app.fileManager.renameFile(activeFile, newPath);
                    notice.showCompletion("Note title updated successfully!");
                  } catch (error) {
                    const errorMessage = error instanceof Error ? error.message : String(error);
                    notice.showError(`Failed to rename file: ${errorMessage}`);
                  }
                } else {
                  notice.hide();
                }
              } catch (error) {
                const errorMessage = error instanceof Error ? error.message : String(error);
                notice.showError(`Failed to generate title: ${errorMessage}`);
              }
            } else {
              const { showTitleGenerationModal: showTitleGenerationModal2 } = await Promise.resolve().then(() => (init_TitleGenerationModal(), TitleGenerationModal_exports));
              const newTitle = await showTitleGenerationModal2(
                this.app,
                this.plugin,
                activeFile.basename,
                activeFile
              );
              if (newTitle !== null && newTitle !== activeFile.basename) {
                const newPath = activeFile.path.replace(activeFile.basename, newTitle);
                try {
                  await this.app.fileManager.renameFile(activeFile, newPath);
                  new import_obsidian107.Notice("Note title updated", 3e3);
                } catch (error) {
                  new import_obsidian107.Notice(`Failed to rename file: ${error}`, 1e4);
                }
              }
            }
          })();
        }
        return true;
      },
      hotkeys: [{ modifiers: ["Mod", "Shift"], key: "t" }]
    });
  }
  registerOpenTemplateModal() {
    this.plugin.addCommand({
      id: "open-template-modal",
      name: "Open Template Selection",
      checkCallback: (checking) => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian107.MarkdownView);
        if (!activeView) return false;
        if (!checking) {
          const editor = activeView.editor;
          const modal = new TemplateSelectionModal(
            this.app,
            this.plugin,
            async (file) => {
              var _a;
              try {
                const templateContent = await this.app.vault.read(file);
                const cursor = editor.getCursor();
                editor.replaceRange(templateContent, cursor);
                const lines = templateContent.split("\n");
                const endPosition = {
                  line: cursor.line + lines.length - 1,
                  ch: ((_a = lines[lines.length - 1]) == null ? void 0 : _a.length) || 0
                };
                editor.setCursor(endPosition);
                activeView.editor.focus();
                new import_obsidian107.Notice(`Template "${file.basename}" inserted`, 3e3);
              } catch (error) {
                new import_obsidian107.Notice("Error inserting template", 1e4);
              }
            }
          );
          modal.open();
        }
        return true;
      }
    });
  }
  registerOpenEmbeddingsView() {
    this.plugin.addCommand({
      id: "open-embeddings-view",
      name: "Open Similar Notes Panel",
      callback: async () => {
        try {
          await this.plugin.getViewManager().activateEmbeddingsView();
        } catch (error) {
          new import_obsidian107.Notice(`Error opening similar notes panel: ${error.message}`);
        }
      }
    });
  }
  registerQuickFileEdit() {
    this.plugin.addCommand({
      id: "quick-file-edit",
      name: "Quick Edit (Active File)",
      checkCallback: (checking) => {
        const activeFile = this.app.workspace.getActiveFile();
        if (!activeFile) return false;
        if (!checking) {
          (async () => {
            const { showQuickEditWidget: showQuickEditWidget2 } = await Promise.resolve().then(() => (init_QuickEditWidget(), QuickEditWidget_exports));
            showQuickEditWidget2(this.app, this.plugin);
          })();
        }
        return true;
      }
    });
  }
  registerCleanupPhantomTools() {
    this.plugin.addCommand({
      id: "cleanup-phantom-tools",
      name: "Clean Up Phantom MCP Tools",
      callback: async () => {
        try {
          new import_obsidian107.Notice("Cleaning up phantom MCP tools...", 3e3);
          await this.plugin.getSettingsManager().cleanupPhantomToolsManually();
          new import_obsidian107.Notice("Phantom tool cleanup completed! Check console for details.", 5e3);
        } catch (error) {
          new import_obsidian107.Notice("Failed to clean up phantom tools.", 1e4);
        }
      }
    });
  }
  registerDebugCommands() {
    this.plugin.addCommand({
      id: "clear-debug-log",
      name: "Clear SystemSculpt Debug Log",
      callback: async () => {
        const logger = DebugLogger.getInstance();
        if (logger) {
          await logger.clearLog();
          new import_obsidian107.Notice("Debug log cleared");
        } else {
          new import_obsidian107.Notice("Debug logger not initialized");
        }
      }
    });
    this.plugin.addCommand({
      id: "toggle-debug-logging",
      name: "Toggle SystemSculpt Debug Logging",
      callback: () => {
        const logger = DebugLogger.getInstance();
        if (logger) {
          const currentEnabled = true;
          logger.setEnabled(!currentEnabled);
          new import_obsidian107.Notice(`Debug logging ${!currentEnabled ? "enabled" : "disabled"}`);
        } else {
          new import_obsidian107.Notice("Debug logger not initialized");
        }
      }
    });
    this.plugin.addCommand({
      id: "toggle-error-debug-mode",
      name: "Toggle SystemSculpt Error Debug Mode",
      callback: () => {
        const currentDebugMode = this.plugin.settings.debugMode || false;
        const newDebugMode = !currentDebugMode;
        errorLogger.setDebugMode(newDebugMode);
        this.plugin.settings.debugMode = newDebugMode;
        this.plugin.saveSettings();
        new import_obsidian107.Notice(`Error debug mode ${newDebugMode ? "enabled" : "disabled"} - errors will be logged to console`);
      }
    });
    this.plugin.addCommand({
      id: "export-error-logs",
      name: "Export SystemSculpt Error Logs",
      callback: async () => {
        try {
          const logs = errorLogger.exportLogs();
          const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
          const filename = `SystemSculpt-Error-Logs-${timestamp}.txt`;
          const baseFolder = this.plugin.settings.savedChatsDirectory || this.plugin.settings.chatsDirectory || "SystemSculpt";
          const folder = `${baseFolder.replace(/\/$/, "")}/Logs`;
          const folderPath = this.app.vault.getAbstractFileByPath(folder);
          if (!folderPath) {
            await this.app.vault.createFolder(folder);
          }
          const filepath = `${folder}/${filename}`;
          await this.app.vault.create(filepath, logs);
          new import_obsidian107.Notice(`Error logs exported to: ${filepath}`, 8e3);
          const file = this.app.vault.getAbstractFileByPath(filepath);
          if (file && file instanceof import_obsidian107.TFile) {
            const leaf = this.app.workspace.getLeaf(true);
            await leaf.openFile(file);
          }
        } catch (error) {
          errorLogger.error("Failed to export error logs", error, {
            source: "CommandManager",
            method: "export-error-logs"
          });
          new import_obsidian107.Notice("Failed to export error logs");
        }
      }
    });
    this.plugin.addCommand({
      id: "clear-error-logs",
      name: "Clear SystemSculpt Error Log History",
      callback: () => {
        errorLogger.clearHistory();
        new import_obsidian107.Notice("Error log history cleared");
      }
    });
    this.plugin.addCommand({
      id: "export-mobile-debug-logs",
      name: "Export Mobile Debug Logs",
      callback: async () => {
        const logger = DebugLogger.getInstance();
        if (logger) {
          try {
            const exportPath = await logger.exportMobileLogs();
            new import_obsidian107.Notice(`Debug logs exported to: ${exportPath}`, 8e3);
            if (this.app.isMobile) {
              const file = this.app.vault.getAbstractFileByPath(exportPath);
              if (file) {
                await this.app.workspace.openLinkText(exportPath, "", true);
                new import_obsidian107.Notice("Export file opened. Use Share button to send logs.", 5e3);
              }
            }
          } catch (error) {
            new import_obsidian107.Notice(`Error exporting logs: ${error}`, 1e4);
          }
        } else {
          new import_obsidian107.Notice("Debug logger not initialized");
        }
      }
    });
    this.plugin.addCommand({
      id: "open-mobile-debugging-guide",
      name: "Open Mobile Debugging Guide",
      callback: async () => {
        try {
          const guidePath = "docs/mobile-debugging.md";
          const file = this.app.vault.getAbstractFileByPath(guidePath);
          if (file) {
            await this.app.workspace.openLinkText(guidePath, "", true);
          } else {
            const guideContent = this.getDebuggingGuideContent();
            await this.app.vault.create(guidePath, guideContent);
            await this.app.workspace.openLinkText(guidePath, "", true);
            new import_obsidian107.Notice("Mobile debugging guide created and opened", 4e3);
          }
        } catch (error) {
          new import_obsidian107.Notice(`Error opening guide: ${error}`, 1e4);
        }
      }
    });
  }
  getDebuggingGuideContent() {
    return `# SystemSculpt Mobile Debugging Guide

## Quick Start for Mobile Debugging

### 1. Export Logs on Mobile
1. Open Command Palette (\`Cmd/Ctrl + P\`)
2. Type "Export Mobile Debug Logs"
3. Run the command
4. A new file will be created and opened automatically
5. Use the Share button in Obsidian to send the file

### 2. Alternative Ways to Access Logs

#### Method A: Direct File Access
- Log file location: \`systemsculpt-debug.md\` (in vault root)
- Export files: \`systemsculpt-mobile-export-[timestamp].md\`

#### Method B: Console Logs (Development Mode)
- If you have Obsidian in developer mode, console logs are captured automatically
- Use "Export Mobile Debug Logs" to get all console output in a sharable format

## Debugging Commands Available

### Export Mobile Debug Logs
- **Command:** "Export Mobile Debug Logs"
- **Purpose:** Creates a comprehensive export file with all debug information
- **Mobile-friendly:** Automatically opens the file and shows sharing instructions

### Test Mobile Error Logging
- **Command:** "Test Mobile Error Logging" 
- **Purpose:** Creates a test error to verify logging is working
- **Use when:** Setting up debugging or testing the logging system

### Clear Debug Logs
- **Command:** "Clear SystemSculpt Debug Log"
- **Purpose:** Clears all debug logs to start fresh
- **Use when:** Logs are getting too large or you want to focus on new issues

### Open Mobile Debugging Guide
- **Command:** "Open Mobile Debugging Guide"
- **Purpose:** Opens this guide
- **Use when:** You need reference for debugging on mobile

## How to Share Logs with Developer

### From Mobile Device
1. Run "Export Mobile Debug Logs" command
2. File opens automatically
3. Tap Share button in Obsidian
4. Send via email, messaging app, or copy to clipboard

### From Desktop (Synced)
1. Logs sync automatically to all devices
2. Open the export file on desktop
3. Copy contents or share file directly

---

*This guide is specifically for SystemSculpt plugin mobile debugging. For complete documentation, see the full guide in the docs folder.*`;
  }
  registerEmbeddingsDatabaseCommands() {
    this.plugin.addCommand({
      id: "embeddings-database-stats",
      name: "Show Embeddings Database Statistics (Debug)",
      checkCallback: (checking) => {
        const embeddingsEnabled = this.plugin.settings.embeddingsEnabled;
        if (!embeddingsEnabled) return false;
        if (!checking) {
          this.showEmbeddingsDatabaseStats();
        }
        return true;
      }
    });
    this.plugin.addCommand({
      id: "rebuild-embeddings-current-model",
      name: "Rebuild Embeddings (Current Model)",
      checkCallback: (checking) => {
        const enabled = this.plugin.settings.embeddingsEnabled;
        if (!enabled) return false;
        if (!checking) {
          (async () => {
            try {
              const { Notice: Notice71 } = require("obsidian");
              const confirmed = confirm("This will delete and rebuild embeddings for the current provider/model/schema only. Continue?");
              if (!confirmed) return;
              new Notice71("Rebuilding embeddings for current model\u2026", 4e3);
              const manager = this.plugin.getOrCreateEmbeddingsManager();
              await manager.forceRefreshCurrentNamespace();
              new Notice71("Embeddings rebuild complete.", 4e3);
            } catch (e) {
              const { Notice: Notice71 } = require("obsidian");
              new Notice71(`Failed to rebuild embeddings: ${(e == null ? void 0 : e.message) || e}`, 8e3);
            }
          })();
        }
        return true;
      }
    });
  }
  async showEmbeddingsDatabaseStats() {
    try {
      const { Notice: Notice71 } = require("obsidian");
      const embeddingsManager = this.plugin.getOrCreateEmbeddingsManager();
      if (!embeddingsManager) {
        new Notice71("Embeddings manager not available", 5e3);
        return;
      }
      const isProcessing = embeddingsManager.isCurrentlyProcessing();
      const stats = embeddingsManager.getStats();
      const statsText = [
        `Embeddings Statistics:`,
        `Status: ${isProcessing ? "Processing" : "Idle"}`,
        `Total Files: ${stats.total}`,
        `Needs Processing: ${stats.needsProcessing}`,
        `Processed: ${stats.total - stats.needsProcessing}`
      ].filter(Boolean).join("\n");
      new Notice71(statsText, 8e3);
    } catch (error) {
      const { Notice: Notice71 } = require("obsidian");
      new Notice71(`Error getting database stats: ${error.message}`, 5e3);
    }
  }
};

// src/services/providers/adapters/BaseProviderAdapter.ts
var import_obsidian108 = require("obsidian");
init_httpClient();
var _BaseProviderAdapter = class _BaseProviderAdapter {
  constructor(provider) {
    this.provider = provider;
  }
  /**
   * Common request method using Obsidian's requestUrl
   */
  async makeRequest(url, options) {
    var _a, _b;
    let host = "";
    try {
      host = new URL(url).host;
    } catch (e) {
    }
    const now = Date.now();
    const hostState2 = _BaseProviderAdapter.requestUrlHostState.get(host);
    const disabled = (hostState2 == null ? void 0 : hostState2.disabledUntil) && hostState2.disabledUntil > now;
    if (disabled && typeof fetch === "function" && !import_obsidian108.Platform.isMobileApp) {
      try {
        const fetchHeaders = { ...options.headers };
        if (((_a = options.method) == null ? void 0 : _a.toUpperCase()) === "GET") {
          for (const k of Object.keys(fetchHeaders)) {
            if (k.toLowerCase() === "content-type") delete fetchHeaders[k];
          }
        } else if (options.body && !Object.keys(fetchHeaders).some((k) => k.toLowerCase() === "content-type")) {
          fetchHeaders["Content-Type"] = "application/json";
        }
        const fetchResponse = await fetch(url, {
          method: options.method,
          headers: fetchHeaders,
          body: options.body,
          cache: "no-store"
        });
        const text = await fetchResponse.text();
        let json = void 0;
        try {
          json = text ? JSON.parse(text) : void 0;
        } catch (e) {
        }
        const shimResult = {
          status: fetchResponse.status,
          text,
          json
        };
        if (!shimResult.status || shimResult.status >= 400) {
          const normalizedError = {
            status: shimResult.status || 500,
            data: shimResult.json || {},
            text: shimResult.text
          };
          normalizedError.message = shimResult.text || shimResult.json && (((_b = shimResult.json.error) == null ? void 0 : _b.message) || shimResult.json.message) || `HTTP ${normalizedError.status}`;
          throw normalizedError;
        }
        return shimResult;
      } catch (fetchErr) {
      }
    }
    try {
      const result = await httpRequest({
        url,
        method: options.method,
        headers: options.headers,
        body: options.body
      });
      return result;
    } catch (error) {
      throw error;
    }
  }
};
// Circuit breaker for requestUrl per-host when Electron net fails repeatedly
_BaseProviderAdapter.requestUrlHostState = /* @__PURE__ */ new Map();
var BaseProviderAdapter = _BaseProviderAdapter;

// src/services/providers/adapters/OpenAICompatibleAdapter.ts
init_errorLogger();
init_externalServices();
init_jsonRepair();
init_tooling();
var OpenAICompatibleAdapter = class extends BaseProviderAdapter {
  getCapabilities() {
    return {
      supportsModelsEndpoint: true,
      supportsStreaming: true,
      supportsTools: true
    };
  }
  async getModels() {
    const headers = this.getHeaders();
    const endpoint = this.getModelsEndpoint();
    try {
      try {
        const { isHostTemporarilyDisabled: isHostTemporarilyDisabled2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
        const status = isHostTemporarilyDisabled2(endpoint);
        if (status.disabled) {
          return [];
        }
      } catch (e) {
      }
      const result = await this.makeRequest(endpoint, {
        method: "GET",
        headers
      });
      const models = (result.json.data || []).filter((model) => !String(model.id || "").toLowerCase().includes("whisper")).map((model) => {
        var _a, _b, _c, _d;
        return {
          id: model.id,
          name: model.name || model.id,
          contextWindow: (_c = (_b = (_a = model.context_length) != null ? _a : model.context_window) != null ? _b : model.contextWindow) != null ? _c : 0,
          supportsStreaming: true,
          supportsTools: !!(((_d = model.supported_parameters) == null ? void 0 : _d.includes("tools")) || String(model.id).includes("gpt") || String(model.id).includes("claude"))
        };
      });
      return models;
    } catch (error) {
      const message = typeof (error == null ? void 0 : error.message) === "string" ? error.message : "";
      if (message.includes("net::ERR_FAILED") || message.includes("ENOTFOUND") || message.includes("ECONNREFUSED")) {
        if (this.provider.endpoint.includes("localhost")) {
          try {
            errorLogger.debug("Local provider unreachable; suppressing model error", {
              source: "OpenAICompatibleAdapter",
              method: "getModels",
              metadata: { endpoint }
            });
          } catch (e) {
          }
          return [];
        }
        throw new Error("Network error while contacting provider. Check the endpoint URL and your connection.");
      }
      if (error && typeof error.status === "undefined") {
        if (this.provider.endpoint.includes("localhost")) {
          try {
            errorLogger.debug("Local provider unreachable (no status); suppressing", {
              source: "OpenAICompatibleAdapter",
              method: "getModels",
              metadata: { endpoint }
            });
          } catch (e) {
          }
          return [];
        }
        throw new Error(message || "Failed to reach provider.");
      }
      throw this.handleError(error);
    }
  }
  async validateApiKey() {
    if (this.provider.endpoint.includes("openrouter.ai")) {
      await this.validateOpenRouterKey();
      return;
    }
    try {
      await this.getModels();
    } catch (error) {
      if (error.message.includes("401") || error.message.includes("Invalid API key")) {
        throw new Error("Invalid API key. Please check your API key and try again.");
      }
      throw error;
    }
  }
  async validateOpenRouterKey() {
    var _a, _b, _c, _d, _e;
    const headers = this.getHeaders();
    try {
      const result = await this.makeRequest(
        AI_PROVIDERS.OPENROUTER.CHAT_COMPLETIONS,
        {
          method: "POST",
          headers,
          body: JSON.stringify({
            messages: [{ role: "user", content: "Test" }],
            model: "mistralai/mistral-7b-instruct",
            max_tokens: 1
          })
        }
      );
    } catch (error) {
      if (error.status === 401) {
        throw new Error(
          "Invalid API key. Please check your OpenRouter API key and try again."
        );
      } else if (error.status === 402 && ((_c = (_b = (_a = error.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) == null ? void 0 : _c.includes("credit"))) {
        throw new Error(
          "Insufficient credits. Please add credits to your OpenRouter account."
        );
      } else if (error.status === 429) {
        throw new Error(
          "Rate limit exceeded. Please try again in a few minutes."
        );
      }
      throw new Error(
        `API key validation failed: ${((_e = (_d = error.data) == null ? void 0 : _d.error) == null ? void 0 : _e.message) || `HTTP ${error.status}`}`
      );
    }
  }
  getHeaders() {
    const headers = {};
    if (this.provider.endpoint.includes("openrouter.ai")) {
      headers["Authorization"] = `Bearer ${this.provider.apiKey}`;
      headers["HTTP-Referer"] = SERVICE_HEADERS.OPENROUTER["HTTP-Referer"];
      headers["X-Title"] = SERVICE_HEADERS.OPENROUTER["X-Title"];
    } else if (this.provider.endpoint.includes("openai.com")) {
      headers["Authorization"] = `Bearer ${this.provider.apiKey}`;
    } else {
      if (this.provider.apiKey && this.provider.apiKey.trim() !== "") {
        headers["Authorization"] = `Bearer ${this.provider.apiKey}`;
      }
    }
    return headers;
  }
  transformMessages(messages) {
    const transformedMessages = messages.map((msg) => {
      const mappedMessage = {
        role: msg.role,
        ...msg.tool_call_id && { tool_call_id: msg.tool_call_id },
        ...msg.name && { name: msg.name },
        ...msg.tool_calls && { tool_calls: msg.tool_calls }
      };
      if (msg.content !== null && typeof msg.content !== "undefined") {
        if (Array.isArray(msg.content)) {
          const parts = [];
          for (const part of msg.content) {
            if (part && part.type === "text" && typeof part.text === "string") {
              parts.push({ type: "text", text: part.text });
            } else if (part && part.type === "image_url" && part.image_url && typeof part.image_url.url === "string") {
              parts.push({ type: "image_url", image_url: { url: part.image_url.url } });
            }
          }
          mappedMessage.content = parts.length > 0 ? parts : "";
        } else {
          mappedMessage.content = msg.content;
        }
      }
      if (Array.isArray(msg.tool_calls) && msg.tool_calls.length > 0) {
        const rawToolCalls = msg.tool_calls;
        const normalizedToolCalls = rawToolCalls.map((tc) => {
          const fn = tc.function || {};
          const name = String(fn.name || tc.name || "");
          const id = typeof tc.id === "string" && tc.id.length > 0 ? tc.id : void 0;
          const argsString = normalizeJsonString(fn.arguments);
          return {
            ...id ? { id } : {},
            type: "function",
            function: {
              name,
              arguments: argsString
            }
          };
        });
        mappedMessage.tool_calls = normalizedToolCalls;
      }
      return mappedMessage;
    });
    return { messages: transformedMessages };
  }
  buildRequestBody(messages, modelId, mcpTools, streaming = true, extras) {
    let { messages: transformedMessages } = this.transformMessages(messages);
    try {
      const sys = transformedMessages.find((m) => m.role === "system");
      const sysContent = typeof (sys == null ? void 0 : sys.content) === "string" ? sys.content : "";
      if (sysContent) {
        const preview = sysContent.slice(0, 600);
        errorLogger.debug("OpenAI adapter: system prompt preview", {
          source: "OpenAICompatibleAdapter",
          method: "buildRequestBody",
          metadata: { modelId, preview, length: sysContent.length }
        });
      }
    } catch (e) {
    }
    const isGroq = this.provider.endpoint.includes("api.groq.com");
    const isVisionModel = (id) => {
      const lowered = id.toLowerCase();
      return lowered.includes("vision") || lowered.includes("llama-4-scout") || lowered.includes("llama-4v") || lowered.includes("llava");
    };
    if (isGroq && !isVisionModel(modelId)) {
      transformedMessages = transformedMessages.map((m) => {
        if (Array.isArray(m.content)) {
          const textParts = m.content.map((p) => {
            var _a;
            if ((p == null ? void 0 : p.type) === "text" && typeof p.text === "string") return p.text;
            if ((p == null ? void 0 : p.type) === "image_url" && ((_a = p.image_url) == null ? void 0 : _a.url)) {
              const url = String(p.image_url.url);
              if (url.startsWith("data:")) return "[image attached]";
              return `[image] ${url}`;
            }
            return "";
          }).filter((s) => s.length > 0);
          return { ...m, content: textParts.join("\n") };
        }
        return m;
      });
    }
    const nonVisionNameHints = /(text-only|no-vision)/i;
    if (nonVisionNameHints.test(modelId)) {
      transformedMessages = transformedMessages.map((m) => {
        if (Array.isArray(m.content)) {
          const textOnly = m.content.map((p) => (p == null ? void 0 : p.type) === "text" && typeof p.text === "string" ? p.text : (p == null ? void 0 : p.type) === "image_url" ? "[image attached]" : "").filter((s) => s.length > 0).join("\n");
          return { ...m, content: textOnly || "" };
        }
        return m;
      });
    }
    const requestBody = {
      model: modelId,
      messages: transformedMessages,
      stream: streaming
    };
    try {
      const isOpenRouter = this.provider.endpoint.includes("openrouter.ai");
      if (isOpenRouter && extras) {
        if (extras.plugins && extras.plugins.length > 0) requestBody.plugins = extras.plugins;
        if (extras.web_search_options) requestBody.web_search_options = extras.web_search_options;
        requestBody.include_reasoning = true;
      }
    } catch (e) {
    }
    if (mcpTools && mcpTools.length > 0) {
      const validTools = normalizeOpenAITools(mcpTools);
      if (validTools.length > 0) {
        requestBody.tools = transformToolsForModel(modelId, this.provider.endpoint, validTools);
      }
    }
    return requestBody;
  }
  validateTools(mcpTools) {
    return normalizeOpenAITools(mcpTools);
  }
  getChatEndpoint() {
    const baseUrl = this.provider.endpoint.trim().replace(/\/$/, "");
    if (baseUrl.endsWith("/v1")) {
      return `${baseUrl}/chat/completions`;
    } else if (baseUrl.endsWith("/chat/completions")) {
      return baseUrl;
    } else {
      return `${baseUrl}/v1/chat/completions`;
    }
  }
  getModelsEndpoint() {
    const baseUrl = this.provider.endpoint.trim().replace(/\/$/, "");
    let finalEndpoint;
    if (baseUrl.endsWith("/v1")) {
      finalEndpoint = `${baseUrl}/models`;
    } else if (baseUrl.endsWith("/models")) {
      finalEndpoint = baseUrl;
    } else {
      finalEndpoint = `${baseUrl}/v1/models`;
    }
    return finalEndpoint;
  }
  async transformStreamResponse(response, isMobile) {
    const contentType = (response.headers.get("content-type") || "").toLowerCase();
    const providerFormat = (response.headers.get("x-provider-format") || "").toLowerCase();
    if (contentType.includes("text/event-stream") && response.body) {
      return { stream: response.body, headers: { "Content-Type": "text/event-stream" } };
    }
    if (contentType.includes("application/json") || providerFormat === "openai-json") {
      const data = await response.json();
      const { createSSEStreamFromChatCompletionJSON: createSSEStreamFromChatCompletionJSON2 } = await Promise.resolve().then(() => (init_streaming(), streaming_exports));
      const stream = createSSEStreamFromChatCompletionJSON2(data, { chunkSize: 1024 });
      return { stream, headers: { "Content-Type": "text/event-stream" } };
    }
    return { stream: response.body, headers: { "Content-Type": "text/event-stream" } };
  }
  handleError(error) {
    var _a, _b;
    if (error.status === 401) {
      return new Error("Invalid API key. Please check your API key and try again.");
    } else if (error.status === 403) {
      return new Error("Access denied. Please verify your API key has the correct permissions.");
    } else if (error.status === 404) {
      return new Error("API endpoint not found. Please check the URL and try again.");
    } else if (error.status === 429) {
      return new Error("Rate limit exceeded. Please try again later.");
    }
    return new Error(
      ((_b = (_a = error.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) || error.message || `HTTP error: ${error.status || "unknown"}`
    );
  }
};

// src/constants/anthropic.ts
var ANTHROPIC_API_BASE_URL = "https://api.anthropic.com";
var ANTHROPIC_API_VERSION = "2023-06-01";
var ANTHROPIC_MODELS = [
  // Claude 4 models
  {
    id: "claude-opus-4-1-20250805",
    name: "Claude Opus 4.1",
    contextWindow: 2e5,
    maxOutput: 32e3,
    capabilities: ["text", "vision", "tools", "extended-thinking"],
    supportsStreaming: true,
    supportsTools: true,
    aliases: ["claude-opus-4-1"]
  },
  {
    id: "claude-opus-4-20250514",
    name: "Claude Opus 4",
    contextWindow: 2e5,
    maxOutput: 32e3,
    capabilities: ["text", "vision", "tools", "extended-thinking"],
    supportsStreaming: true,
    supportsTools: true,
    aliases: ["claude-opus-4-0"]
  },
  {
    id: "claude-sonnet-4-20250514",
    name: "Claude Sonnet 4",
    contextWindow: 2e5,
    // 1M context beta available with context-1m-2025-08-07 header
    maxOutput: 64e3,
    capabilities: ["text", "vision", "tools", "extended-thinking"],
    supportsStreaming: true,
    supportsTools: true,
    aliases: ["claude-sonnet-4-0"]
  },
  // Claude Haiku 3.5 - fastest model
  {
    id: "claude-3-5-haiku-20241022",
    name: "Claude Haiku 3.5",
    contextWindow: 2e5,
    maxOutput: 8192,
    capabilities: ["text", "vision", "tools"],
    supportsStreaming: true,
    supportsTools: true,
    aliases: ["claude-3-5-haiku-latest"]
  }
];
var ANTHROPIC_STREAM_EVENTS = {
  MESSAGE_START: "message_start",
  CONTENT_BLOCK_START: "content_block_start",
  CONTENT_BLOCK_DELTA: "content_block_delta",
  CONTENT_BLOCK_STOP: "content_block_stop",
  MESSAGE_DELTA: "message_delta",
  MESSAGE_STOP: "message_stop",
  PING: "ping",
  ERROR: "error"
};
function isAnthropicEndpoint(endpoint) {
  return endpoint.toLowerCase().includes("anthropic.com") || endpoint.toLowerCase().includes("claude.ai");
}
function correctAnthropicEndpoint(endpoint) {
  const original = endpoint.trim();
  const lower = original.toLowerCase();
  if (lower.includes("api.anthropic.com")) {
    if (original === ANTHROPIC_API_BASE_URL || original === `${ANTHROPIC_API_BASE_URL}/v1` || original === `${ANTHROPIC_API_BASE_URL}/`) {
      return {
        correctedEndpoint: original,
        wasCorrected: false,
        originalEndpoint: original
      };
    }
    return {
      correctedEndpoint: ANTHROPIC_API_BASE_URL,
      wasCorrected: true,
      originalEndpoint: original
    };
  }
  return {
    correctedEndpoint: original,
    wasCorrected: false,
    originalEndpoint: original
  };
}
function isCorrectableAnthropicEndpoint(endpoint) {
  return endpoint.toLowerCase().includes("api.anthropic.com");
}
function resolveAnthropicModelId(modelIdOrAlias) {
  const canonicalModel = ANTHROPIC_MODELS.find((m) => m.id === modelIdOrAlias);
  if (canonicalModel) {
    return canonicalModel.id;
  }
  const aliasedModel = ANTHROPIC_MODELS.find(
    (m) => m.aliases && m.aliases.includes(modelIdOrAlias)
  );
  if (aliasedModel) {
    return aliasedModel.id;
  }
  return modelIdOrAlias;
}

// src/services/providers/adapters/AnthropicAdapter.ts
init_errorLogger();
init_tooling();
var AnthropicAdapter = class extends BaseProviderAdapter {
  constructor(provider, plugin) {
    super(provider);
    this.plugin = plugin;
  }
  getCapabilities() {
    return {
      supportsModelsEndpoint: false,
      // Anthropic doesn't have a models endpoint
      supportsStreaming: true,
      supportsTools: true,
      requiresApiVersion: ANTHROPIC_API_VERSION
    };
  }
  async getModels() {
    return ANTHROPIC_MODELS.map((model) => ({
      id: model.id,
      name: model.name,
      contextWindow: model.contextWindow,
      maxOutput: model.maxOutput,
      capabilities: model.capabilities,
      supportsStreaming: model.supportsStreaming,
      supportsTools: model.supportsTools,
      aliases: model.aliases
    }));
  }
  async validateApiKey() {
    const headers = this.getHeaders();
    try {
      await this.makeRequest(this.getChatEndpoint(), {
        method: "POST",
        headers,
        body: JSON.stringify({
          model: "claude-3-haiku-20240307",
          // Use the smallest model
          messages: [{ role: "user", content: "Hi" }],
          max_tokens: 1
        })
      });
    } catch (error) {
      throw this.handleError(error);
    }
  }
  getHeaders() {
    return {
      "Content-Type": "application/json",
      "x-api-key": this.provider.apiKey,
      "anthropic-version": ANTHROPIC_API_VERSION
    };
  }
  transformMessages(messages) {
    let systemPrompt = "";
    const anthropicMessages = [];
    for (const msg of messages) {
      if (msg.role === "system") {
        systemPrompt = typeof msg.content === "string" ? msg.content : "";
      } else if (msg.role === "tool") {
        let toolContent;
        if (typeof msg.content === "string") {
          toolContent = msg.content;
        } else if (Array.isArray(msg.content)) {
          toolContent = JSON.stringify(msg.content);
        } else {
          toolContent = "";
        }
        if (!toolContent || toolContent.trim() === "") {
          toolContent = JSON.stringify({
            result: "Tool executed successfully but returned no content",
            status: "completed"
          });
        }
        anthropicMessages.push({
          role: "user",
          content: [
            {
              type: "tool_result",
              tool_use_id: msg.tool_call_id,
              content: toolContent,
              ...(function() {
                try {
                  const parsed = JSON.parse(toolContent);
                  if (parsed && typeof parsed === "object" && (parsed.error || parsed.is_error)) {
                    return { is_error: true };
                  }
                } catch (e) {
                }
                return {};
              })()
            }
          ]
        });
      } else if (msg.role === "assistant" && msg.tool_calls && msg.tool_calls.length > 0) {
        const toolUseBlocks = msg.tool_calls.map((toolCall) => {
          var _a, _b, _c;
          let input = {};
          try {
            const { repairAndParseJson: repairAndParseJson2 } = require("../../utils/jsonRepair");
            const res = repairAndParseJson2((_a = toolCall.function) == null ? void 0 : _a.arguments);
            input = res.ok ? (_b = res.value) != null ? _b : {} : {};
          } catch (e) {
          }
          return {
            type: "tool_use",
            id: toolCall.id,
            name: ((_c = toolCall.function) == null ? void 0 : _c.name) || toolCall.name,
            input
          };
        });
        const content = [];
        if (msg.content) {
          content.push({ type: "text", text: msg.content });
        }
        content.push(...toolUseBlocks);
        anthropicMessages.push({
          role: "assistant",
          content
        });
      } else {
        const mappedContentBlocks = [];
        if (Array.isArray(msg.content)) {
          for (const part of msg.content) {
            if (part && part.type === "text" && typeof part.text === "string") {
              if (part.text.length > 0) {
                mappedContentBlocks.push({ type: "text", text: part.text });
              }
            } else if (part && part.type === "image_url" && part.image_url && typeof part.image_url.url === "string") {
              const url = part.image_url.url;
              if (url.startsWith("data:")) {
                const match = url.match(/^data:([^;]+);base64,(.*)$/);
                if (match) {
                  const mediaType = match[1];
                  const data = match[2];
                  if (data && mediaType) {
                    mappedContentBlocks.push({
                      type: "image",
                      source: {
                        type: "base64",
                        media_type: mediaType,
                        data
                      }
                    });
                  }
                }
              } else {
                mappedContentBlocks.push({
                  type: "image",
                  source: {
                    type: "url",
                    url
                  }
                });
              }
            }
          }
        } else if (typeof msg.content === "string") {
          if (msg.content.length > 0) {
            mappedContentBlocks.push({ type: "text", text: msg.content });
          }
        }
        const finalContent = mappedContentBlocks.length > 0 ? mappedContentBlocks : "";
        anthropicMessages.push({
          role: msg.role,
          content: finalContent
        });
      }
    }
    return { messages: anthropicMessages, systemPrompt };
  }
  buildRequestBody(messages, modelId, mcpTools, streaming = true, _extras) {
    const { messages: anthropicMessages, systemPrompt } = this.transformMessages(messages);
    try {
      if (systemPrompt) {
        const preview = systemPrompt.slice(0, 600);
        errorLogger.debug("Anthropic adapter: system prompt preview", {
          source: "AnthropicAdapter",
          method: "buildRequestBody",
          metadata: { modelId, preview, length: systemPrompt.length }
        });
      }
    } catch (e) {
    }
    const resolvedModelId = resolveAnthropicModelId(modelId);
    const requestBody = {
      model: resolvedModelId,
      messages: anthropicMessages,
      stream: streaming,
      max_tokens: 4096
      // Anthropic requires this field
    };
    if (systemPrompt) {
      requestBody.system = systemPrompt;
    }
    if (mcpTools && mcpTools.length > 0) {
      const tools = this.buildAnthropicToolList(mcpTools);
      if (tools.length > 0) {
        requestBody.tools = tools;
        requestBody.tool_choice = { type: "auto" };
      }
    }
    return requestBody;
  }
  buildAnthropicToolList(mcpTools) {
    const validTools = normalizeOpenAITools(mcpTools);
    if (validTools.length === 0) return [];
    const seenNames = /* @__PURE__ */ new Set();
    const tools = [];
    for (const tool of validTools) {
      const name = tool.function.name;
      if (!name || seenNames.has(name)) continue;
      seenNames.add(name);
      const parameters = tool.function.parameters && typeof tool.function.parameters === "object" ? tool.function.parameters : {};
      const inputSchema = normalizeJsonSchema(parameters);
      tools.push({
        name,
        description: tool.function.description || "",
        input_schema: inputSchema
      });
    }
    return tools;
  }
  getChatEndpoint() {
    const { correctedEndpoint, wasCorrected, originalEndpoint } = correctAnthropicEndpoint(this.provider.endpoint);
    if (wasCorrected) {
      this.showEndpointCorrectionNotice(originalEndpoint, correctedEndpoint);
      this.updateProviderEndpointInSettings(correctedEndpoint);
    }
    const baseEndpoint = correctedEndpoint.trim().replace(/\/$/, "").replace(/\/v1\/?$/, "");
    return `${baseEndpoint}/v1/messages`;
  }
  /**
   * Permanently update the provider's endpoint in user settings
   */
  async updateProviderEndpointInSettings(correctedEndpoint) {
    if (!this.plugin) {
      return;
    }
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const providerIndex = settings.customProviders.findIndex((p) => p.id === this.provider.id);
      if (providerIndex !== -1) {
        const updatedProviders = [...settings.customProviders];
        updatedProviders[providerIndex] = {
          ...updatedProviders[providerIndex],
          endpoint: correctedEndpoint
        };
        await this.plugin.getSettingsManager().updateSettings({
          customProviders: updatedProviders
        });
      } else {
      }
    } catch (error) {
      errorLogger.debug("Failed to update provider endpoint in settings", {
        source: "AnthropicAdapter",
        method: "updateProviderEndpointInSettings",
        metadata: { providerId: this.provider.id, correctedEndpoint }
      });
    }
  }
  /**
   * Show a user-friendly notification when an endpoint is auto-corrected
   */
  async showEndpointCorrectionNotice(originalEndpoint, correctedEndpoint) {
    var _a;
    try {
      const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
      const message = `\u2705 Auto-corrected Anthropic endpoint and updated your settings:

"${originalEndpoint}" \u2192 "${correctedEndpoint}"

Your connection should now work properly!`;
      if ((_a = this.plugin) == null ? void 0 : _a.app) {
        showNoticeWhenReady2(
          this.plugin.app,
          message,
          { type: "info", duration: 8e3 }
        );
      } else {
        errorLogger.debug("Plugin app not available for notification", {
          source: "AnthropicAdapter",
          method: "showEndpointCorrectionNotice"
        });
      }
    } catch (error) {
      errorLogger.debug("Failed to show endpoint correction notice", {
        source: "AnthropicAdapter",
        method: "showEndpointCorrectionNotice",
        metadata: { originalEndpoint, correctedEndpoint }
      });
    }
  }
  /**
   * Transform Anthropic's response to OpenAI format
   * 
   * Note: Due to Obsidian's HTTP method limitations, streaming is not available.
   * We always get a complete JSON response when using requestUrl.
   * 
   * @param response - The response from Anthropic API
   * @param isMobile - Whether running on mobile (ignored for Anthropic)
   */
  async transformStreamResponse(response, isMobile) {
    const contentType = response.headers.get("content-type") || "";
    const providerFormat = response.headers.get("x-provider-format") || "";
    if (providerFormat === "openai-sse" && response.body) {
      return {
        stream: response.body,
        headers: { "Content-Type": "text/event-stream", "X-Provider-Format": "openai-sse" }
      };
    }
    const isAnthropicSSE = contentType.includes("text/event-stream") || providerFormat === "anthropic-sse" || contentType.includes("text/plain");
    if (isAnthropicSSE && response.body) {
      return {
        stream: this.createTransformedStream(response.body),
        headers: { "Content-Type": "text/event-stream", "X-Provider-Format": "anthropic-sse-transformed" }
      };
    }
    if (contentType.includes("application/json") || providerFormat === "anthropic-json") {
      return await this.transformNonStreamingResponse(response);
    }
    try {
      return await this.transformNonStreamingResponse(response);
    } catch (_) {
      if (response.body) {
        return { stream: this.createTransformedStream(response.body), headers: { "Content-Type": "text/event-stream" } };
      }
      const empty = new ReadableStream({
        start(controller) {
          controller.enqueue(new TextEncoder().encode("data: [DONE]\n\n"));
          controller.close();
        }
      });
      return { stream: empty, headers: { "Content-Type": "text/event-stream" } };
    }
  }
  /**
   * Transform non-streaming JSON response to SSE format for consistent handling
   */
  async transformNonStreamingResponse(response) {
    const responseData = await response.json();
    const stream = new ReadableStream({
      start(controller) {
        const messageId = responseData.id || `chatcmpl-${Date.now()}`;
        const model = responseData.model || "anthropic-model";
        const created = Math.floor(Date.now() / 1e3);
        if (responseData.content && responseData.content.length > 0) {
          for (const block of responseData.content) {
            if (block.type === "text") {
              const textChunk = {
                id: messageId,
                object: "chat.completion.chunk",
                created,
                model,
                choices: [{
                  index: 0,
                  delta: { content: block.text },
                  finish_reason: null
                }]
              };
              controller.enqueue(
                new TextEncoder().encode(`data: ${JSON.stringify(textChunk)}

`)
              );
            } else if (block.type === "tool_use") {
              const toolChunk = {
                id: messageId,
                object: "chat.completion.chunk",
                created,
                model,
                choices: [{
                  index: 0,
                  delta: {
                    tool_calls: [{
                      index: 0,
                      id: block.id,
                      type: "function",
                      function: {
                        name: block.name,
                        arguments: JSON.stringify(block.input || {})
                      }
                    }]
                  },
                  finish_reason: null
                }]
              };
              controller.enqueue(
                new TextEncoder().encode(`data: ${JSON.stringify(toolChunk)}

`)
              );
            }
          }
          let finishReason = "stop";
          if (responseData.stop_reason === "tool_use") {
            finishReason = "tool_calls";
          } else if (responseData.stop_reason === "max_tokens") {
            finishReason = "length";
          }
          const doneChunk = {
            id: messageId,
            object: "chat.completion.chunk",
            created,
            model,
            choices: [{
              index: 0,
              delta: {},
              finish_reason: finishReason
            }]
          };
          controller.enqueue(
            new TextEncoder().encode(`data: ${JSON.stringify(doneChunk)}

`)
          );
        }
        controller.enqueue(new TextEncoder().encode("data: [DONE]\n\n"));
        controller.close();
      }
    });
    return {
      stream,
      headers: {
        "Content-Type": "text/event-stream"
      }
    };
  }
  /**
   * This method is kept for potential future use when Obsidian supports streaming.
   * Currently not used as requestUrl doesn't support streaming.
   */
  createTransformedStream(originalBody) {
    return new ReadableStream({
      async start(controller) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
        const reader = originalBody.getReader();
        const decoder = new TextDecoder();
        let buffer = "";
        let messageId = "";
        let modelName = "";
        let currentToolCallId = "";
        let currentToolName = "";
        let accumulatedToolInput = "";
        let isInToolUse = false;
        let isInThinking = false;
        let accumulatedThinkingText = "";
        try {
          while (true) {
            const { done, value } = await reader.read();
            if (done) break;
            buffer += decoder.decode(value, { stream: true });
            const lines = buffer.split("\n");
            buffer = lines.pop() || "";
            for (const line of lines) {
              if (line.trim() === "") continue;
              if (line.startsWith("event: ")) {
                continue;
              } else if (line.startsWith("data: ")) {
                const data = line.substring(6).trim();
                if (!data || data === "[DONE]") continue;
                try {
                  const parsed = JSON.parse(data);
                  if (parsed.choices && ((_a = parsed.choices[0]) == null ? void 0 : _a.delta)) {
                    controller.enqueue(
                      new TextEncoder().encode(`${line}

`)
                    );
                    continue;
                  }
                  switch (parsed.type) {
                    case ANTHROPIC_STREAM_EVENTS.MESSAGE_START:
                      messageId = ((_b = parsed.message) == null ? void 0 : _b.id) || `chatcmpl-${Date.now()}`;
                      modelName = ((_c = parsed.message) == null ? void 0 : _c.model) || "anthropic-model";
                      break;
                    case ANTHROPIC_STREAM_EVENTS.CONTENT_BLOCK_START:
                      if (((_d = parsed.content_block) == null ? void 0 : _d.type) === "tool_use") {
                        isInToolUse = true;
                        currentToolCallId = parsed.content_block.id;
                        currentToolName = parsed.content_block.name;
                        accumulatedToolInput = "";
                        const toolStartChunk = {
                          id: messageId,
                          object: "chat.completion.chunk",
                          created: Math.floor(Date.now() / 1e3),
                          model: modelName,
                          choices: [{
                            index: 0,
                            delta: {
                              tool_calls: [{
                                index: 0,
                                id: currentToolCallId,
                                type: "function",
                                function: {
                                  name: currentToolName,
                                  arguments: ""
                                }
                              }]
                            },
                            finish_reason: null
                          }]
                        };
                        controller.enqueue(
                          new TextEncoder().encode(`data: ${JSON.stringify(toolStartChunk)}

`)
                        );
                      } else if (((_e = parsed.content_block) == null ? void 0 : _e.type) === "thinking") {
                        isInThinking = true;
                        accumulatedThinkingText = "";
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.CONTENT_BLOCK_DELTA:
                      if (isInToolUse && ((_f = parsed.delta) == null ? void 0 : _f.type) === "input_json_delta") {
                        accumulatedToolInput += parsed.delta.partial_json || "";
                        const toolDeltaChunk = {
                          id: messageId,
                          object: "chat.completion.chunk",
                          created: Math.floor(Date.now() / 1e3),
                          model: modelName,
                          choices: [{
                            index: 0,
                            delta: {
                              tool_calls: [{
                                index: 0,
                                function: {
                                  arguments: parsed.delta.partial_json || ""
                                }
                              }]
                            },
                            finish_reason: null
                          }]
                        };
                        controller.enqueue(
                          new TextEncoder().encode(`data: ${JSON.stringify(toolDeltaChunk)}

`)
                        );
                      } else if (isInThinking && ((_g = parsed.delta) == null ? void 0 : _g.type) === "thinking_delta") {
                        const reasoningDelta = parsed.delta.text || "";
                        if (reasoningDelta && reasoningDelta.length > 0) {
                          const reasoningChunk = {
                            id: messageId,
                            object: "chat.completion.chunk",
                            created: Math.floor(Date.now() / 1e3),
                            model: modelName,
                            choices: [{
                              index: 0,
                              delta: {
                                reasoning: reasoningDelta
                              },
                              finish_reason: null
                            }]
                          };
                          controller.enqueue(
                            new TextEncoder().encode(`data: ${JSON.stringify(reasoningChunk)}

`)
                          );
                        }
                      } else if (((_h = parsed.delta) == null ? void 0 : _h.type) === "text_delta") {
                        const chunk = {
                          id: messageId,
                          object: "chat.completion.chunk",
                          created: Math.floor(Date.now() / 1e3),
                          model: modelName,
                          choices: [{
                            index: 0,
                            delta: {
                              content: parsed.delta.text || ""
                            },
                            finish_reason: null
                          }]
                        };
                        controller.enqueue(
                          new TextEncoder().encode(`data: ${JSON.stringify(chunk)}

`)
                        );
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.CONTENT_BLOCK_STOP:
                      if (isInToolUse) {
                        isInToolUse = false;
                        currentToolCallId = "";
                        currentToolName = "";
                        accumulatedToolInput = "";
                      } else if (isInThinking) {
                        isInThinking = false;
                        accumulatedThinkingText = "";
                      }
                      break;
                    case ANTHROPIC_STREAM_EVENTS.MESSAGE_DELTA:
                      break;
                    case ANTHROPIC_STREAM_EVENTS.MESSAGE_STOP:
                      let finishReason = "stop";
                      if (((_i = parsed.message) == null ? void 0 : _i.stop_reason) === "tool_use") {
                        finishReason = "tool_calls";
                      } else if (((_j = parsed.message) == null ? void 0 : _j.stop_reason) === "max_tokens") {
                        finishReason = "length";
                      }
                      const finalChunk = {
                        id: messageId,
                        object: "chat.completion.chunk",
                        created: Math.floor(Date.now() / 1e3),
                        model: modelName,
                        choices: [{
                          index: 0,
                          delta: {},
                          finish_reason: finishReason
                        }]
                      };
                      controller.enqueue(
                        new TextEncoder().encode(`data: ${JSON.stringify(finalChunk)}

`)
                      );
                      break;
                    case "error":
                      const errorChunk = {
                        error: {
                          message: ((_k = parsed.error) == null ? void 0 : _k.message) || "Stream error",
                          type: ((_l = parsed.error) == null ? void 0 : _l.type) || "stream_error"
                        }
                      };
                      controller.enqueue(
                        new TextEncoder().encode(`data: ${JSON.stringify(errorChunk)}

`)
                      );
                      break;
                    case "ping":
                      break;
                    default:
                  }
                } catch (error) {
                  errorLogger.debug(`Failed to parse Anthropic SSE data: ${data}`, {
                    source: "AnthropicAdapter",
                    method: "createTransformedStream",
                    metadata: { line, error: error instanceof Error ? error.message : String(error) }
                  });
                }
              } else if (line.trim() !== "") {
                errorLogger.debug(`Unexpected line format in SSE stream: ${line}`, {
                  source: "AnthropicAdapter",
                  method: "createTransformedStream"
                });
              }
            }
          }
          controller.enqueue(new TextEncoder().encode("data: [DONE]\n\n"));
        } catch (error) {
          errorLogger.error("Error in Anthropic stream transformation", error, {
            source: "AnthropicAdapter",
            method: "createTransformedStream",
            metadata: { messageId, modelName }
          });
          controller.error(error);
        } finally {
          controller.close();
        }
      }
    });
  }
  handleError(error) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n;
    let errorMessage;
    let errorContext = {
      source: "AnthropicAdapter",
      method: "handleError",
      metadata: {
        status: error.status,
        endpoint: this.provider.endpoint,
        errorData: error.data
      }
    };
    if (error.status) {
      switch (error.status) {
        case 401:
          errorMessage = "\u26A0\uFE0F Invalid Anthropic API key. Please check your API key in Settings > Custom Endpoints.";
          errorLogger.error(`Authentication failed: ${error.status}`, error, errorContext);
          return new Error(errorMessage);
        case 400:
          if ((_c = (_b = (_a = error.data) == null ? void 0 : _a.error) == null ? void 0 : _b.message) == null ? void 0 : _c.includes("credit")) {
            errorMessage = "\u{1F4B3} Insufficient credits. Please add credits to your Anthropic account.";
          } else {
            errorMessage = `Invalid request: ${((_e = (_d = error.data) == null ? void 0 : _d.error) == null ? void 0 : _e.message) || "Please check your input and try again."}`;
          }
          errorLogger.error(`Bad request: ${errorMessage}`, error, errorContext);
          return new Error(errorMessage);
        case 429:
          errorMessage = "\u23F1\uFE0F Rate limit exceeded. Please wait a moment and try again.";
          errorLogger.warn(errorMessage, errorContext);
          return new Error(errorMessage);
        case 404:
          errorMessage = "\u274C Model not found. Please check that the model ID is correct.";
          errorLogger.error(`Model not found: ${((_g = (_f = error.data) == null ? void 0 : _f.error) == null ? void 0 : _g.message) || "Unknown model"}`, error, errorContext);
          return new Error(errorMessage);
        case 500:
        case 502:
        case 503:
          errorMessage = "\u{1F527} Anthropic API is temporarily unavailable. Please try again later.";
          errorLogger.error(`Server error ${error.status}: ${((_i = (_h = error.data) == null ? void 0 : _h.error) == null ? void 0 : _i.message) || "Service unavailable"}`, error, errorContext);
          return new Error(errorMessage);
        default:
          errorMessage = ((_k = (_j = error.data) == null ? void 0 : _j.error) == null ? void 0 : _k.message) || `Anthropic API error: ${error.status}`;
          errorLogger.error(`Unexpected API error: ${errorMessage}`, error, errorContext);
          return new Error(errorMessage);
      }
    }
    if ((_l = error.message) == null ? void 0 : _l.includes("Failed to fetch")) {
      errorMessage = "\u{1F310} Network error: Unable to connect to Anthropic. Please check your internet connection.";
      errorLogger.error("Network connection failed", error, errorContext);
      return new Error(errorMessage);
    }
    errorMessage = ((_n = (_m = error.data) == null ? void 0 : _m.error) == null ? void 0 : _n.message) || error.message || `Anthropic API error: ${error.status || "unknown"}`;
    errorLogger.error(`Unhandled error: ${errorMessage}`, error, errorContext);
    return new Error(errorMessage);
  }
  validateTools(mcpTools) {
    return mcpTools.filter((tool) => {
      if (!tool || typeof tool !== "object") return false;
      if (!tool.function || typeof tool.function !== "object") return false;
      if (!tool.function.name || typeof tool.function.name !== "string") return false;
      return true;
    });
  }
};

// src/services/providers/adapters/ProviderAdapterFactory.ts
var ProviderAdapterFactory = class {
  /**
   * Create the appropriate adapter for a given provider
   */
  static createAdapter(provider, plugin) {
    if (isAnthropicEndpoint(provider.endpoint) || isCorrectableAnthropicEndpoint(provider.endpoint)) {
      return new AnthropicAdapter(provider, plugin);
    }
    return new OpenAICompatibleAdapter(provider);
  }
  /**
   * Determine the provider type from the endpoint
   */
  static getProviderType(endpoint) {
    if (isAnthropicEndpoint(endpoint) || isCorrectableAnthropicEndpoint(endpoint)) {
      return "anthropic";
    }
    return "openai-compatible";
  }
};

// src/services/CustomProviderService.ts
var _CustomProviderService = class _CustomProviderService {
  // 30 minutes
  constructor(plugin, app) {
    this.CACHE_DURATION = 30 * 60 * 1e3;
    this.plugin = plugin;
    this.app = app;
    this.logger = console;
  }
  // Add method to clear custom provider cache only
  clearCache() {
    _CustomProviderService.customProviderConnectionCache.clear();
    _CustomProviderService.customProviderTestPromises.clear();
  }
  /**
   * Clear static caches for custom providers only
   * This should be called when the plugin is unloaded
   */
  static clearStaticCaches() {
    _CustomProviderService.customProviderConnectionCache.clear();
    _CustomProviderService.customProviderTestPromises.clear();
  }
  /**
   * Test connection to a provider by attempting to fetch available models
   * For OpenRouter, we also validate the API key by making a minimal completion request
   */
  async testConnection(provider) {
    const cached = _CustomProviderService.customProviderConnectionCache.get(provider.id);
    if (cached && Date.now() - cached.result.timestamp < this.CACHE_DURATION) {
      return cached.result;
    }
    const existingPromise = _CustomProviderService.customProviderTestPromises.get(
      provider.id
    );
    if (existingPromise) {
      return existingPromise;
    }
    const testPromise = this.performConnectionTest(provider);
    _CustomProviderService.customProviderTestPromises.set(provider.id, testPromise);
    try {
      const result = await testPromise;
      if (result.success) {
        _CustomProviderService.customProviderConnectionCache.set(provider.id, {
          result,
          timestamp: Date.now()
        });
      }
      return result;
    } finally {
      _CustomProviderService.customProviderTestPromises.delete(provider.id);
    }
  }
  /**
   * Internal method to actually perform the connection test
   */
  async performConnectionTest(provider) {
    try {
      const adapter = ProviderAdapterFactory.createAdapter(provider, this.plugin);
      const endpoint = provider.endpoint || "";
      const models = await adapter.getModels();
      try {
        const { errorLogger: errorLogger2 } = await Promise.resolve().then(() => (init_errorLogger(), errorLogger_exports));
        errorLogger2.debug("Custom provider connection test", {
          source: "CustomProviderService",
          method: "performConnectionTest",
          metadata: { providerId: provider.id, endpoint, models: models.length }
        });
      } catch (e) {
      }
      if (endpoint.includes("openrouter.ai")) {
        await adapter.validateApiKey();
      }
      if (endpoint.includes("localhost") && models.length === 0) {
        return {
          success: false,
          error: `Cannot reach local provider at ${endpoint}. Is the server running?`,
          timestamp: Date.now()
        };
      }
      return {
        success: true,
        models,
        // Preserve full ProviderModel objects
        timestamp: Date.now()
      };
    } catch (error) {
      try {
        const { errorLogger: errorLogger2 } = await Promise.resolve().then(() => (init_errorLogger(), errorLogger_exports));
        errorLogger2.debug("Custom provider test failed", {
          source: "CustomProviderService",
          method: "performConnectionTest",
          metadata: { providerId: provider.id, endpoint: provider.endpoint }
        });
      } catch (e) {
      }
      return {
        success: false,
        error: this.getErrorMessage(error),
        timestamp: Date.now()
      };
    }
  }
  /**
   * Get a provider adapter for the given custom provider
   */
  getProviderAdapter(provider) {
    return ProviderAdapterFactory.createAdapter(provider, this.plugin);
  }
  /**
   * Get a user-friendly error message from an error object
   */
  getErrorMessage(error) {
    if (error instanceof Error) {
      if (error.name === "AbortError") {
        return "Connection timed out. Please check your internet connection and try again.";
      }
      return error.message;
    }
    return "An unexpected error occurred. Please try again or contact support if the issue persists.";
  }
};
// Isolated static caches by provider type to prevent cross-contamination
_CustomProviderService.customProviderConnectionCache = /* @__PURE__ */ new Map();
_CustomProviderService.customProviderTestPromises = /* @__PURE__ */ new Map();
var CustomProviderService = _CustomProviderService;

// src/main.ts
init_errorHandling();
init_errorLogger();

// src/services/providers/BaseProviderService.ts
var BaseProviderService = class {
  constructor(plugin) {
    this.models = null;
    this.lastFetchTime = 0;
    this.CACHE_DURATION = 30 * 60 * 1e3;
    // 30 minutes
    this.loadingPromise = null;
    this.plugin = plugin;
  }
  /**
   * Clear the provider's cache
   */
  clearCache() {
    this.models = null;
    this.lastFetchTime = 0;
    this.loadingPromise = null;
  }
  /**
   * Check if cache is expired
   */
  isCacheExpired() {
    return Date.now() - this.lastFetchTime >= this.CACHE_DURATION;
  }
  /**
   * Get cached models if available and not expired
   */
  getCachedModels() {
    if (this.models && !this.isCacheExpired()) {
      return this.models;
    }
    return null;
  }
  /**
   * Cache models with timestamp
   */
  cacheModels(models) {
    this.models = models;
    this.lastFetchTime = Date.now();
  }
};

// src/services/providers/SystemSculptProviderService.ts
init_modelUtils();

// src/services/providers/ProviderErrorManager.ts
var ProviderErrorManager = class {
  // 24 hours
  constructor(plugin, app) {
    // Isolated error tracking by provider type
    this.systemSculptErrors = /* @__PURE__ */ new Map();
    this.customProviderErrors = /* @__PURE__ */ new Map();
    this.MAX_ERROR_HISTORY = 10;
    this.ERROR_CLEANUP_INTERVAL = 24 * 60 * 60 * 1e3;
    this.plugin = plugin;
    this.app = app;
  }
  /**
   * Report a SystemSculpt provider error
   */
  reportSystemSculptError(error) {
    const fullError = {
      ...error,
      providerType: "systemsculpt",
      timestamp: Date.now()
    };
    const providerId = error.providerId;
    const errors = this.systemSculptErrors.get(providerId) || [];
    errors.push(fullError);
    if (errors.length > this.MAX_ERROR_HISTORY) {
      errors.shift();
    }
    this.systemSculptErrors.set(providerId, errors);
    this.plugin.emitter.emitWithProvider("providerError", "systemsculpt", fullError);
    if (fullError.licenseRelated) {
      this.handleLicenseError(fullError);
    }
  }
  /**
   * Report a custom provider error
   */
  reportCustomProviderError(error) {
    const fullError = {
      ...error,
      providerType: "custom",
      timestamp: Date.now()
    };
    const providerId = error.providerId;
    const errors = this.customProviderErrors.get(providerId) || [];
    errors.push(fullError);
    if (errors.length > this.MAX_ERROR_HISTORY) {
      errors.shift();
    }
    this.customProviderErrors.set(providerId, errors);
    this.plugin.emitter.emitWithProvider("providerError", "custom", fullError);
    if (fullError.authRelated) {
      this.handleAuthError(fullError);
    }
  }
  /**
   * Get recent errors for a specific SystemSculpt provider
   */
  getSystemSculptErrors(providerId) {
    return this.systemSculptErrors.get(providerId) || [];
  }
  /**
   * Get recent errors for a specific custom provider
   */
  getCustomProviderErrors(providerId) {
    return this.customProviderErrors.get(providerId) || [];
  }
  /**
   * Get error summary for all providers
   */
  getErrorSummary() {
    const systemsculpt = Array.from(this.systemSculptErrors.entries()).map(([providerId, errors]) => ({
      providerId,
      errorCount: errors.length,
      lastError: errors[errors.length - 1]
    }));
    const custom = Array.from(this.customProviderErrors.entries()).map(([providerId, errors]) => ({
      providerId,
      errorCount: errors.length,
      lastError: errors[errors.length - 1]
    }));
    return { systemsculpt, custom };
  }
  /**
   * Handle license-related errors for SystemSculpt
   */
  handleLicenseError(error) {
    const recentLicenseErrors = this.getSystemSculptErrors(error.providerId).filter((e) => e.licenseRelated && Date.now() - e.timestamp < 5 * 60 * 1e3).length;
    if (recentLicenseErrors <= 1) {
      this.showLicenseErrorNotification(error);
    }
  }
  /**
   * Handle authentication-related errors for custom providers
   */
  handleAuthError(error) {
    const recentAuthErrors = this.getCustomProviderErrors(error.providerId).filter((e) => e.authRelated && Date.now() - e.timestamp < 5 * 60 * 1e3).length;
    if (recentAuthErrors <= 1) {
      this.showAuthErrorNotification(error);
    }
  }
  /**
   * Show license error notification
   */
  async showLicenseErrorNotification(error) {
    try {
      const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
      const message = `SystemSculpt license issue: ${error.message}. Please check your license in settings.`;
      showNoticeWhenReady2(this.app, message, {
        type: "error",
        duration: 8e3
      });
    } catch (notificationError) {
    }
  }
  /**
   * Show authentication error notification
   */
  async showAuthErrorNotification(error) {
    try {
      const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
      const message = `Authentication failed for ${error.providerName}: ${error.message}. Please check your API key.`;
      showNoticeWhenReady2(this.app, message, {
        type: "warning",
        duration: 8e3
      });
    } catch (notificationError) {
    }
  }
  /**
   * Clear errors for a specific provider
   */
  clearProviderErrors(providerId, providerType) {
    if (providerType === "systemsculpt") {
      this.systemSculptErrors.delete(providerId);
    } else {
      this.customProviderErrors.delete(providerId);
    }
  }
  /**
   * Clear old errors (cleanup)
   */
  cleanupOldErrors() {
    const cutoffTime = Date.now() - this.ERROR_CLEANUP_INTERVAL;
    for (const [providerId, errors] of this.systemSculptErrors.entries()) {
      const recentErrors = errors.filter((error) => error.timestamp > cutoffTime);
      if (recentErrors.length === 0) {
        this.systemSculptErrors.delete(providerId);
      } else {
        this.systemSculptErrors.set(providerId, recentErrors);
      }
    }
    for (const [providerId, errors] of this.customProviderErrors.entries()) {
      const recentErrors = errors.filter((error) => error.timestamp > cutoffTime);
      if (recentErrors.length === 0) {
        this.customProviderErrors.delete(providerId);
      } else {
        this.customProviderErrors.set(providerId, recentErrors);
      }
    }
  }
  /**
   * Get provider health status based on recent errors
   */
  getProviderHealth(providerId, providerType) {
    if (providerType === "systemsculpt") {
      const errors = this.getSystemSculptErrors(providerId);
      const recentErrors = errors.filter(
        (error) => Date.now() - error.timestamp < 15 * 60 * 1e3
        // 15 minutes
      );
      let status = "healthy";
      if (recentErrors.length >= 3) {
        status = "error";
      } else if (recentErrors.length >= 1) {
        status = "warning";
      }
      return {
        status,
        recentErrorCount: recentErrors.length,
        lastErrorTime: errors.length > 0 ? errors[errors.length - 1].timestamp : void 0
      };
    } else {
      const errors = this.getCustomProviderErrors(providerId);
      const recentErrors = errors.filter(
        (error) => Date.now() - error.timestamp < 15 * 60 * 1e3
        // 15 minutes
      );
      let status = "healthy";
      if (recentErrors.length >= 3) {
        status = "error";
      } else if (recentErrors.length >= 1) {
        status = "warning";
      }
      return {
        status,
        recentErrorCount: recentErrors.length,
        lastErrorTime: errors.length > 0 ? errors[errors.length - 1].timestamp : void 0
      };
    }
  }
  /**
   * Clear all errors
   */
  clearAllErrors() {
    this.systemSculptErrors.clear();
    this.customProviderErrors.clear();
  }
};

// src/services/providers/SystemSculptProviderService.ts
var _SystemSculptProviderService = class _SystemSculptProviderService extends BaseProviderService {
  constructor(plugin) {
    super(plugin);
    this.modelDetailsCache = /* @__PURE__ */ new Map();
    this.errorManager = new ProviderErrorManager(plugin, plugin.app);
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _SystemSculptProviderService(plugin);
    }
    return this.instance;
  }
  static clearInstance() {
    if (this.instance) {
      this.instance.clearCache();
      this.instance.modelDetailsCache.clear();
      this.instance = null;
    }
  }
  getProviderType() {
    return "systemsculpt";
  }
  /**
   * Test connection to SystemSculpt services
   */
  async testConnection() {
    try {
      if (!this.plugin.settings.enableSystemSculptProvider) {
        return false;
      }
      const models = await this.getModels();
      return models.length > 0;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get SystemSculpt models with isolated caching
   */
  async getModels() {
    if (!this.plugin.settings.enableSystemSculptProvider) {
      return [];
    }
    const cachedModels = this.getCachedModels();
    if (cachedModels) {
      return cachedModels;
    }
    if (this.loadingPromise) {
      return this.loadingPromise;
    }
    this.loadingPromise = this.loadSystemSculptModels().then((models) => {
      models.forEach((model) => {
        this.modelDetailsCache.set(model.id, model);
      });
      this.cacheModels(models);
      this.loadingPromise = null;
      this.plugin.emitter.emitWithProvider("modelsUpdated", "systemsculpt", models);
      return models;
    }).catch((error) => {
      this.loadingPromise = null;
      return [];
    });
    return this.loadingPromise;
  }
  /**
   * Load models from SystemSculpt API
   */
  async loadSystemSculptModels() {
    var _a, _b;
    try {
      const systemModels = await this.loadWithRetry(
        () => this.plugin.aiService.getModels(),
        3,
        // max retries
        1e3
        // delay between retries
      );
      return systemModels;
    } catch (error) {
      this.errorManager.reportSystemSculptError({
        providerId: "systemsculpt-api",
        errorCode: "MODEL_LOAD_FAILED",
        message: error instanceof Error ? error.message : "Unknown error loading models",
        licenseRelated: ((_a = error.message) == null ? void 0 : _a.includes("license")) || ((_b = error.message) == null ? void 0 : _b.includes("unauthorized")),
        apiEndpoint: "models",
        context: {
          licenseValid: this.plugin.settings.licenseValid,
          hasLicenseKey: !!this.plugin.settings.licenseKey
        }
      });
      return [];
    }
  }
  /**
   * Load with retry logic
   */
  async loadWithRetry(fn, maxRetries, delay) {
    for (let i = 0; i < maxRetries; i++) {
      try {
        return await Promise.race([
          fn(),
          new Promise(
            (_, reject) => setTimeout(() => reject(new Error("Operation timeout")), 5e3)
          )
        ]);
      } catch (error) {
        if (i === maxRetries - 1) throw error;
        await new Promise((resolve) => setTimeout(resolve, delay));
      }
    }
    throw new Error("Max retries exceeded");
  }
  /**
   * Find the best SystemSculpt alternative model
   */
  findBestAlternativeModel(unavailableModelId) {
    if (!this.models || this.models.length === 0) {
      return void 0;
    }
    try {
      const chatModels = filterChatModels(this.models).filter((m) => m.id !== unavailableModelId);
      if (chatModels.length === 0) {
        return void 0;
      }
      return chatModels[0];
    } catch (error) {
      return void 0;
    }
  }
  /**
   * Get cached model by ID
   */
  getCachedModelById(modelId) {
    return this.modelDetailsCache.get(modelId);
  }
  /**
   * Get provider health status
   */
  getProviderHealth() {
    return this.errorManager.getProviderHealth("systemsculpt-api", "systemsculpt");
  }
  /**
   * Clear all caches
   */
  clearCache() {
    super.clearCache();
    this.modelDetailsCache.clear();
  }
};
_SystemSculptProviderService.instance = null;
var SystemSculptProviderService = _SystemSculptProviderService;

// src/services/providers/CustomProviderModelService.ts
init_modelUtils();
var _CustomProviderModelService = class _CustomProviderModelService extends BaseProviderService {
  constructor(plugin) {
    super(plugin);
    this.providerCaches = /* @__PURE__ */ new Map();
    this.modelDetailsCache = /* @__PURE__ */ new Map();
    this.customProviderService = plugin.customProviderService;
    this.errorManager = new ProviderErrorManager(plugin, plugin.app);
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _CustomProviderModelService(plugin);
    }
    return this.instance;
  }
  static clearInstance() {
    if (this.instance) {
      this.instance.clearCache();
      this.instance.providerCaches.clear();
      this.instance.modelDetailsCache.clear();
      this.instance = null;
    }
  }
  getProviderType() {
    return "custom";
  }
  /**
   * Test connection to custom providers
   */
  async testConnection() {
    try {
      const { customProviders } = this.plugin.settings;
      const enabledProviders = customProviders.filter((p) => p.isEnabled);
      if (enabledProviders.length === 0) {
        return true;
      }
      for (const provider of enabledProviders) {
        try {
          const result = await this.customProviderService.testConnection(provider);
          if (result.success) {
            return true;
          }
        } catch (error) {
        }
      }
      return false;
    } catch (error) {
      return false;
    }
  }
  /**
   * Get all custom provider models with isolated caching
   */
  async getModels() {
    const cachedModels = this.getCachedModels();
    if (cachedModels) {
      return cachedModels;
    }
    if (this.loadingPromise) {
      return this.loadingPromise;
    }
    this.loadingPromise = this.loadCustomProviderModels().then((models) => {
      models.forEach((model) => {
        this.modelDetailsCache.set(model.id, model);
      });
      this.cacheModels(models);
      this.loadingPromise = null;
      this.plugin.emitter.emitWithProvider("modelsUpdated", "custom", models);
      return models;
    }).catch((error) => {
      this.loadingPromise = null;
      return [];
    });
    return this.loadingPromise;
  }
  /**
   * Get models from a specific provider with isolated caching
   */
  async getModelsFromProvider(provider) {
    var _a, _b, _c;
    const cached = this.providerCaches.get(provider.id);
    if (cached && !this.isProviderCacheExpired(cached.timestamp)) {
      return cached.models;
    }
    try {
      const result = await this.customProviderService.testConnection(provider);
      if (result.success && result.models) {
        await this.resetProviderFailureCount(provider.id);
        const models = this.createCustomModels(provider, result.models);
        this.providerCaches.set(provider.id, {
          models,
          timestamp: Date.now()
        });
        return models;
      } else {
        const isAuthRelated = (result.error || "").toLowerCase().includes("401") || (result.error || "").toLowerCase().includes("unauthorized") || (result.error || "").toLowerCase().includes("api key");
        if (isAuthRelated) {
          await this.handleProviderFailure(provider.id, provider.name, result.error);
        } else {
        }
        return [];
      }
    } catch (error) {
      this.errorManager.reportCustomProviderError({
        providerId: provider.id,
        providerName: provider.name,
        errorCode: "MODEL_LOAD_FAILED",
        message: error instanceof Error ? error.message : "Unknown error loading models",
        endpoint: provider.endpoint,
        authRelated: ((_a = error.message) == null ? void 0 : _a.includes("401")) || ((_b = error.message) == null ? void 0 : _b.includes("unauthorized")) || ((_c = error.message) == null ? void 0 : _c.includes("api key")),
        context: {
          hasApiKey: !!provider.apiKey,
          endpoint: provider.endpoint
        }
      });
      const msg = error instanceof Error ? error.message : String(error);
      const isAuthRelated = msg.toLowerCase().includes("401") || msg.toLowerCase().includes("unauthorized") || msg.toLowerCase().includes("api key");
      if (isAuthRelated) {
        await this.handleProviderFailure(provider.id, provider.name, msg);
      } else {
      }
      return [];
    }
  }
  /**
   * Load models from all custom providers
   */
  async loadCustomProviderModels() {
    const { customProviders } = this.plugin.settings;
    const enabledProviders = customProviders.filter((p) => p.isEnabled);
    if (enabledProviders.length === 0) {
      return [];
    }
    const fetches = enabledProviders.map((provider) => this.getModelsFromProvider(provider));
    const results = await Promise.all(fetches);
    return results.flat();
  }
  /**
   * Check if provider-specific cache is expired
   */
  isProviderCacheExpired(timestamp) {
    return Date.now() - timestamp >= this.CACHE_DURATION;
  }
  /**
   * Handle provider connection failure with failure tracking
   */
  async handleProviderFailure(providerId, providerName, errorMessage) {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const provider = settings.customProviders.find((p) => p.id === providerId);
      if (!provider) return;
      if (!provider.failureCount) {
        provider.failureCount = 0;
      }
      provider.failureCount++;
      provider.lastFailureTime = Date.now();
      const FAILURE_THRESHOLD = 3;
      if (provider.failureCount >= FAILURE_THRESHOLD && provider.isEnabled) {
        provider.isEnabled = false;
        const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
        const message = `Custom provider '${providerName}' has been automatically disabled after ${provider.failureCount} consecutive connection failures. You can re-enable it in settings when the server is available.`;
        showNoticeWhenReady2(this.plugin.app, message, { type: "warning", duration: 12e3 });
      } else {
        const { showNoticeWhenReady: showNoticeWhenReady2 } = await Promise.resolve().then(() => (init_notifications(), notifications_exports));
        const remainingAttempts = FAILURE_THRESHOLD - provider.failureCount;
        const message = `Connection to custom provider '${providerName}' failed (attempt ${provider.failureCount} of ${FAILURE_THRESHOLD}). We'll try again when you reload Obsidian. After ${remainingAttempts} more failure${remainingAttempts === 1 ? "" : "s"}, this provider will be automatically disabled.`;
        showNoticeWhenReady2(this.plugin.app, message, { type: "warning", duration: 8e3 });
      }
      await this.plugin.getSettingsManager().saveSettings();
    } catch (error) {
    }
  }
  /**
   * Reset failure count for a provider after successful connection
   */
  async resetProviderFailureCount(providerId) {
    try {
      const settings = this.plugin.getSettingsManager().getSettings();
      const provider = settings.customProviders.find((p) => p.id === providerId);
      if (provider && (provider.failureCount || 0) > 0) {
        provider.failureCount = 0;
        delete provider.lastFailureTime;
        await this.plugin.getSettingsManager().saveSettings();
      }
    } catch (error) {
    }
  }
  /**
   * Creates SystemSculptModel objects for a given custom provider
   */
  createCustomModels(provider, providerModels) {
    const isAnthropic = isAnthropicEndpoint(provider.endpoint);
    return providerModels.map((m) => {
      const modelId = typeof m === "string" ? m : m.id || "";
      const contextWindow = typeof m === "string" ? void 0 : m.contextWindow;
      const displayName = typeof m === "string" ? void 0 : m.name;
      const providerId = provider.name.toLowerCase();
      const canonicalId = createCanonicalId(providerId, modelId);
      if (isAnthropic) {
        const anthropicModel = ANTHROPIC_MODELS.find((mm) => mm.id === modelId);
        if (anthropicModel) {
          return {
            id: canonicalId,
            name: anthropicModel.name,
            provider: providerId,
            isFavorite: false,
            context_length: anthropicModel.contextWindow,
            capabilities: anthropicModel.capabilities,
            pricing: {
              prompt: "0",
              completion: "0",
              image: "0",
              request: "0"
            },
            architecture: {
              modality: anthropicModel.capabilities.includes("vision") ? "text+image->text" : "text->text",
              tokenizer: "claude",
              instruct_type: null
            },
            description: `${anthropicModel.name} - ${anthropicModel.contextWindow.toLocaleString()} token context`,
            identifier: {
              providerId,
              modelId,
              displayName: anthropicModel.name
            },
            // Add supported parameters for proper tool support detection
            supported_parameters: anthropicModel.supportsTools ? ["tools", "max_tokens", "stream"] : ["max_tokens", "stream"]
          };
        }
      }
      return {
        // Use the canonical ID format
        id: canonicalId,
        name: displayName || modelId,
        provider: providerId,
        isFavorite: false,
        context_length: contextWindow != null ? contextWindow : 0,
        capabilities: [],
        pricing: {
          prompt: "0",
          completion: "0",
          image: "0",
          request: "0"
        },
        architecture: {
          modality: "text->text",
          tokenizer: "",
          instruct_type: null
        },
        description: `${provider.name} custom model`,
        identifier: {
          providerId,
          modelId,
          displayName: displayName || modelId
        }
      };
    });
  }
  /**
   * Find the best custom provider alternative model
   */
  findBestAlternativeModel(unavailableModelId) {
    if (!this.models || this.models.length === 0) {
      return void 0;
    }
    try {
      const chatModels = filterChatModels(this.models).filter((m) => m.id !== unavailableModelId);
      if (chatModels.length === 0) {
        return void 0;
      }
      const unavailableModel = this.modelDetailsCache.get(unavailableModelId);
      if (unavailableModel) {
        const sameProviderModels = chatModels.filter(
          (m) => m.provider === unavailableModel.provider
        );
        if (sameProviderModels.length > 0) {
          return sameProviderModels[0];
        }
      }
      return chatModels[0];
    } catch (error) {
      return void 0;
    }
  }
  /**
   * Get cached model by ID
   */
  getCachedModelById(modelId) {
    return this.modelDetailsCache.get(modelId);
  }
  /**
   * Clear all caches including provider-specific caches
   */
  clearCache() {
    super.clearCache();
    this.providerCaches.clear();
    this.modelDetailsCache.clear();
  }
  /**
   * Get provider health status for a specific custom provider
   */
  getProviderHealth(providerId) {
    return this.errorManager.getProviderHealth(providerId, "custom");
  }
  /**
   * Clear cache for a specific provider
   */
  clearProviderCache(providerId) {
    this.providerCaches.delete(providerId);
  }
};
_CustomProviderModelService.instance = null;
var CustomProviderModelService = _CustomProviderModelService;

// src/services/providers/UnifiedModelService.ts
init_FavoritesService();
init_modelUtils();
var _UnifiedModelService = class _UnifiedModelService {
  constructor(plugin) {
    this.plugin = plugin;
    this.isInitialLoadDone = false;
    this.systemSculptService = SystemSculptProviderService.getInstance(plugin);
    this.customProviderService = CustomProviderModelService.getInstance(plugin);
    this.favoritesService = FavoritesService.getInstance(plugin);
  }
  static getInstance(plugin) {
    if (!this.instance) {
      this.instance = new _UnifiedModelService(plugin);
    }
    return this.instance;
  }
  /**
   * Clear the singleton instance to allow proper cleanup
   */
  static clearInstance() {
    if (this.instance) {
      SystemSculptProviderService.clearInstance();
      CustomProviderModelService.clearInstance();
      this.instance = null;
    }
  }
  /**
   * Get models from all providers with isolated loading
   */
  async getModels(forceRefresh = false) {
    try {
      const [systemModels, customModels] = await Promise.allSettled([
        forceRefresh ? (this.systemSculptService.clearCache(), this.systemSculptService.getModels()) : this.systemSculptService.getModels(),
        forceRefresh ? (this.customProviderService.clearCache(), this.customProviderService.getModels()) : this.customProviderService.getModels()
      ]);
      const systemModelList = systemModels.status === "fulfilled" ? systemModels.value : [];
      const customModelList = customModels.status === "fulfilled" ? customModels.value : [];
      if (systemModels.status === "rejected") {
      }
      if (customModels.status === "rejected") {
      }
      const filteredCustomList = customModelList;
      const allModels = [...systemModelList, ...filteredCustomList];
      const canonicalModels = allModels.map((model) => {
        model.id = getCanonicalId(model);
        return model;
      });
      this.favoritesService.processFavorites(canonicalModels);
      if (!this.isInitialLoadDone) {
        await this.validateSelectedModel(canonicalModels);
        this.isInitialLoadDone = true;
      }
      return canonicalModels;
    } catch (error) {
      throw error;
    }
  }
  /**
   * Get a model by its ID from any provider
   */
  async getModelById(modelId) {
    const systemModel = this.systemSculptService.getCachedModelById(modelId);
    if (systemModel) {
      return systemModel;
    }
    const customModel = this.customProviderService.getCachedModelById(modelId);
    if (customModel) {
      return customModel;
    }
    const models = await this.getModels();
    return findModelById(models, modelId);
  }
  /**
   * Find the best alternative model from any provider
   */
  findBestAlternativeModel(unavailableModelId, models) {
    if (!models || models.length === 0) {
      return void 0;
    }
    try {
      const chatModels = filterChatModels(models).filter((m) => m.id !== unavailableModelId);
      if (chatModels.length === 0) {
        return void 0;
      }
      const systemAlternative = this.systemSculptService.findBestAlternativeModel(unavailableModelId);
      if (systemAlternative) {
        return systemAlternative;
      }
      const customAlternative = this.customProviderService.findBestAlternativeModel(unavailableModelId);
      if (customAlternative) {
        return customAlternative;
      }
      return chatModels[0];
    } catch (error) {
      const chatModels = filterChatModels(models);
      return chatModels[0];
    }
  }
  /**
   * Validate saved selectedModelId, fallback if invalid/missing
   */
  async validateSelectedModel(models) {
    const result = {
      wasReplaced: false,
      oldModelId: void 0,
      newModel: void 0,
      forDefault: true
    };
    try {
      const modelList = models || await this.getModels();
      const savedId = this.plugin.settings.selectedModelId;
      const found = modelList == null ? void 0 : modelList.find((m) => m.id === savedId);
      if (!found) {
        const { parseCanonicalId: parseCanonicalId4 } = await Promise.resolve().then(() => (init_modelUtils(), modelUtils_exports));
        const parsed = parseCanonicalId4(savedId);
        if (parsed && parsed.providerId === "systemsculpt" && parsed.modelId.startsWith("groq/")) {
          const tail = parsed.modelId.split("/").pop() || parsed.modelId;
          const candidates = modelList.filter((m) => {
            if (!m.id.includes("@@")) return false;
            const p = parseCanonicalId4(m.id);
            return !!p && p.providerId === "systemsculpt" && p.modelId.startsWith("groq/") && p.modelId.toLowerCase().endsWith("/" + tail.toLowerCase());
          });
          if (candidates.length === 1) {
            const fix = candidates[0];
            result.wasReplaced = true;
            result.oldModelId = savedId;
            result.newModel = fix;
            await this.plugin.getSettingsManager().updateSettings({ selectedModelId: fix.id });
            return result;
          }
        }
        if (modelList && modelList.length > 0) {
          const fallbackModel = this.findBestAlternativeModel(savedId, modelList);
          if (fallbackModel) {
            result.wasReplaced = true;
            result.oldModelId = savedId;
            result.newModel = fallbackModel;
            await this.plugin.getSettingsManager().updateSettings({ selectedModelId: fallbackModel.id });
          }
        } else {
          await this.plugin.getSettingsManager().updateSettings({ selectedModelId: "" });
        }
      }
    } catch (error) {
    }
    return result;
  }
  /**
   * Validate a specific model ID and find an alternative if unavailable
   */
  async validateSpecificModel(modelId, models) {
    try {
      const modelList = models || await this.getModels();
      const found = modelList == null ? void 0 : modelList.find((m) => m.id === modelId);
      if (!found && modelList && modelList.length > 0) {
        const alternativeModel = this.findBestAlternativeModel(modelId, modelList);
        return {
          isAvailable: false,
          alternativeModel
        };
      }
      return {
        isAvailable: !!found
      };
    } catch (error) {
      return { isAvailable: false };
    }
  }
  /**
   * Toggle favorite status for a model
   */
  async toggleFavorite(model) {
    await this.favoritesService.toggleFavorite(model);
  }
  /**
   * Refresh models from all providers
   */
  async refreshModels() {
    return this.getModels(true);
  }
  /**
   * Check if a model supports MCP tools
   */
  async checkToolCompatibility(modelId) {
    try {
      const model = await this.getModelById(modelId);
      if (!model) {
        return {
          isCompatible: false,
          reason: "Model not found",
          confidence: "high"
        };
      }
      return getToolCompatibilityInfo(model);
    } catch (error) {
      return {
        isCompatible: false,
        reason: "Error checking compatibility",
        confidence: "low"
      };
    }
  }
  /**
   * Get all tool-compatible models from all providers
   */
  async getToolCompatibleModels() {
    try {
      const models = await this.getModels();
      return models.filter((model) => supportsTools(model));
    } catch (error) {
      return [];
    }
  }
  /**
   * Test connections to all providers independently
   */
  async testAllConnections() {
    const [systemResult, customResult] = await Promise.allSettled([
      this.systemSculptService.testConnection(),
      this.customProviderService.testConnection()
    ]);
    return {
      systemSculpt: systemResult.status === "fulfilled" ? systemResult.value : false,
      customProviders: customResult.status === "fulfilled" ? customResult.value : false
    };
  }
  /**
   * Get cached models without triggering a load (for quick access)
   */
  getCachedModels() {
    return [];
  }
  /**
   * Clear all caches
   */
  clearAllCaches() {
    this.systemSculptService.clearCache();
    this.customProviderService.clearCache();
  }
};
_UnifiedModelService.instance = null;
var UnifiedModelService = _UnifiedModelService;

// src/templates/TemplateManager.ts
var import_obsidian113 = require("obsidian");
var TemplateSuggestProvider = class extends import_obsidian113.EditorSuggest {
  constructor(app, plugin) {
    super(app);
    this.templateFiles = [];
    this.listeners = [];
    this.plugin = plugin;
    this.limit = 50;
    this.preloadTemplates();
  }
  // Preload templates with multiple attempts
  async preloadTemplates() {
    await this.loadTemplateFiles();
    if (this.templateFiles.length === 0 || this.templateFiles.length === 1 && this.templateFiles[0].path === "no-templates") {
      setTimeout(async () => {
        await this.loadTemplateFiles();
      }, 500);
    }
  }
  // Determine when to trigger the suggestion popup
  onTrigger(cursor, editor) {
    if (!this.plugin.settings.enableTemplateHotkey) return null;
    const line = editor.getLine(cursor.line);
    const textBeforeCursor = line.slice(0, cursor.ch);
    const hotkey = this.plugin.settings.templateHotkey;
    const hotkeyIndex = textBeforeCursor.lastIndexOf(hotkey);
    if (hotkeyIndex >= 0) {
      const textBeforeHotkey = textBeforeCursor.slice(0, hotkeyIndex);
      const hasTextBeforeHotkey = textBeforeHotkey.trim().length > 0;
      if (hasTextBeforeHotkey) {
        return null;
      }
      const textAfterHotkey = textBeforeCursor.slice(hotkeyIndex + hotkey.length);
      const hasClosingChar = /[\]\}\)>]/.test(textAfterHotkey);
      if (hasClosingChar) {
        return null;
      }
      this.loadTemplateFiles();
      const query = textBeforeCursor.slice(hotkeyIndex + hotkey.length);
      return {
        start: {
          line: cursor.line,
          ch: hotkeyIndex
        },
        end: cursor,
        query
      };
    }
    return null;
  }
  // Create a temporary file object to show while loading
  createTemporaryLoadingFile() {
    return {
      basename: "Loading templates...",
      extension: "md",
      path: "loading",
      name: "Loading templates...",
      parent: null,
      vault: this.app.vault,
      stat: null
    };
  }
  // Load template files from the system prompts directory
  async loadTemplateFiles() {
    const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
    if (!systemPromptsDir || systemPromptsDir.trim() === "") {
      this.templateFiles = [this.createNoTemplatesFoundFile()];
      return;
    }
    try {
      if (!this.plugin.directoryManager) {
        this.templateFiles = [this.createNoTemplatesFoundFile()];
        return;
      }
      await this.plugin.directoryManager.ensureDirectoryByKey("systemPromptsDirectory");
      const files = this.app.vault.getMarkdownFiles().filter(
        (file) => file.path.startsWith(systemPromptsDir)
      );
      if (files.length > 0) {
        this.templateFiles = files;
      } else if (this.templateFiles.length === 0 || this.templateFiles.length === 1 && (this.templateFiles[0].path === "loading" || this.templateFiles[0].path === "no-templates")) {
        this.templateFiles = [this.createNoTemplatesFoundFile()];
      }
    } catch (error) {
      this.templateFiles = [this.createNoTemplatesFoundFile()];
    }
  }
  // Create a file object to show when no templates are found
  createNoTemplatesFoundFile() {
    return {
      basename: "No templates found - Click to create one",
      extension: "md",
      path: "no-templates",
      name: "No templates found - Click to create one",
      parent: null,
      vault: this.app.vault,
      stat: null
    };
  }
  // Get suggestions based on the query
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    if (!query) {
      return this.templateFiles;
    }
    const queryParts = query.split(/\s+/).filter((part) => part.length > 0);
    const scoredResults = this.templateFiles.map((file) => {
      const basename = file.basename.toLowerCase();
      const path = file.path.toLowerCase();
      let score = 0;
      if (basename === query) {
        score += 100;
      }
      if (basename.startsWith(query)) {
        score += 80;
      }
      const wordBoundaryMatches = basename.split(/[-_\s]/).filter(
        (word) => word.startsWith(query)
      ).length;
      if (wordBoundaryMatches > 0) {
        score += 60 * wordBoundaryMatches;
      }
      if (path.includes(query)) {
        score += 30;
      }
      const allPartsMatch = queryParts.every((part) => basename.includes(part));
      if (allPartsMatch) {
        score += 40;
      }
      let wordBoundaryPartMatches = 0;
      for (const part of queryParts) {
        const words = basename.split(/[-_\s]/);
        for (const word of words) {
          if (word.startsWith(part)) {
            wordBoundaryPartMatches++;
            break;
          }
        }
      }
      if (wordBoundaryPartMatches > 0) {
        score += 50 * (wordBoundaryPartMatches / queryParts.length);
      }
      let lastIndex = -1;
      let consecutiveMatches = 0;
      for (const char of query) {
        const index = basename.indexOf(char, lastIndex + 1);
        if (index > lastIndex) {
          lastIndex = index;
          consecutiveMatches++;
        }
      }
      if (consecutiveMatches === query.length) {
        score += 20 * (consecutiveMatches / basename.length);
      }
      return { file, score };
    });
    const suggestions = scoredResults.filter((result) => result.score > 0).sort((a, b) => b.score - a.score).map((result) => result.file);
    return suggestions;
  }
  // Render each suggestion item
  renderSuggestion(file, el) {
    var _a, _b;
    const suggestionEl = el.createEl("div", {
      cls: "suggestion-content"
    });
    const iconEl = suggestionEl.createEl("div", {
      cls: "suggestion-icon"
    });
    iconEl.innerHTML = `<svg viewBox="0 0 100 100" class="document" width="17" height="17"><path fill="currentColor" stroke="currentColor" d="M14,4v92h72V29.2l-0.6-0.6l-24-24L60.8,4H14z M18,8h40v24h24v60H18V8z M62,10.9L79.1,28H62V10.9z"></path></svg>`;
    const contentEl = suggestionEl.createEl("div", {
      cls: "suggestion-content-inner"
    });
    const query = ((_b = (_a = this.context) == null ? void 0 : _a.query) == null ? void 0 : _b.toLowerCase()) || "";
    const basename = file.basename;
    const titleEl = contentEl.createEl("div", {
      cls: "suggestion-title"
    });
    if (query) {
      this.renderHighlightedText(titleEl, basename, query);
    } else {
      titleEl.setText(basename);
    }
    this.getTemplatePreview(file).then((preview) => {
      contentEl.createEl("div", {
        text: preview,
        cls: "suggestion-note"
      });
    }).catch((error) => {
      contentEl.createEl("div", {
        text: file.path,
        cls: "suggestion-note"
      });
    });
    suggestionEl.style.display = "flex";
    suggestionEl.style.alignItems = "center";
    suggestionEl.style.gap = "8px";
    const mouseEnterHandler = () => {
      el.addClass("is-selected");
    };
    const mouseLeaveHandler = () => {
      if (!el.hasClass("mod-complex-selected")) {
        el.removeClass("is-selected");
      }
    };
    this.registerListener(el, "mouseenter", mouseEnterHandler);
    this.registerListener(el, "mouseleave", mouseLeaveHandler);
  }
  // Helper method to highlight matching text
  renderHighlightedText(element, text, query) {
    if (!query) {
      element.setText(text);
      return;
    }
    const lowerText = text.toLowerCase();
    const queryParts = query.split(/\s+/).filter((part) => part.length > 0);
    const highlightMap = new Array(text.length).fill(false);
    for (const part of queryParts) {
      let index = lowerText.indexOf(part);
      while (index !== -1) {
        for (let i = 0; i < part.length; i++) {
          highlightMap[index + i] = true;
        }
        index = lowerText.indexOf(part, index + 1);
      }
    }
    if (!highlightMap.some((h) => h) && query.length > 0) {
      let lastIndex = -1;
      for (const char of query.toLowerCase()) {
        const index = lowerText.indexOf(char, lastIndex + 1);
        if (index > lastIndex) {
          highlightMap[index] = true;
          lastIndex = index;
        }
      }
    }
    let currentSpan = null;
    let isHighlighted = false;
    for (let i = 0; i < text.length; i++) {
      if (highlightMap[i] !== isHighlighted || currentSpan === null) {
        isHighlighted = highlightMap[i];
        currentSpan = element.createEl("span");
        if (isHighlighted) {
          currentSpan.addClass("suggestion-highlight");
        }
      }
      currentSpan.textContent += text[i];
    }
  }
  // Helper method to get a preview of the template content
  async getTemplatePreview(file) {
    try {
      if (file.path === "loading") {
        return "Loading your templates, please wait...";
      }
      if (file.path === "no-templates") {
        return `Create templates in ${this.plugin.settings.systemPromptsDirectory}`;
      }
      const content = await this.app.vault.read(file);
      const lines = content.split("\n");
      let preview = "";
      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed) {
          preview = trimmed.substring(0, 50);
          if (trimmed.length > 50) {
            preview += "...";
          }
          break;
        }
      }
      return preview || "Empty template";
    } catch (error) {
      return "Error reading template";
    }
  }
  // Handle selection of a template
  async selectSuggestion(file, evt) {
    try {
      if (file.path === "loading") {
        new import_obsidian113.Notice("Templates are still loading, please try again in a moment.");
        return;
      }
      if (file.path === "no-templates") {
        const systemPromptsDir = this.plugin.settings.systemPromptsDirectory;
        new import_obsidian113.Notice(`Create template files in ${systemPromptsDir} to use this feature.`);
        const folderExists = await this.app.vault.adapter.exists(systemPromptsDir);
        if (!folderExists) {
          if (this.plugin.directoryManager) {
            await this.plugin.directoryManager.ensureDirectoryByPath(systemPromptsDir);
          } else {
            try {
              await this.app.vault.createFolder(systemPromptsDir);
            } catch (error) {
              if (!(error instanceof Error) || !error.message.includes("already exists")) {
                throw error;
              }
            }
          }
        }
        try {
          const folder = this.app.vault.getAbstractFileByPath(systemPromptsDir);
          if (folder) {
            const fileExplorer = this.app.workspace.getLeavesOfType("file-explorer")[0];
            if (fileExplorer) {
              this.app.workspace.revealLeaf(fileExplorer);
              new import_obsidian113.Notice(`Look for the "${systemPromptsDir}" folder in your file explorer.`);
            }
          }
        } catch (e) {
        }
        return;
      }
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian113.MarkdownView);
      if (!activeView) return;
      const editor = activeView.editor;
      const content = await this.app.vault.read(file);
      if (this.context) {
        const commandText = editor.getRange(this.context.start, this.context.end);
        const { showStandardTemplateModal: showStandardTemplateModal2 } = await Promise.resolve().then(() => (init_StandardTemplateModal(), StandardTemplateModal_exports));
        const result = await showStandardTemplateModal2(this.app, file.basename, content, {
          plugin: this.plugin,
          commandText
        });
        if (result) {
          editor.replaceRange(
            result,
            this.context.start,
            this.context.end
          );
        }
      }
    } catch (error) {
      new import_obsidian113.Notice("Failed to process template content.");
    }
  }
  // Add method to register and track event listeners
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  // Add method to clean up all event listeners - making this public so it can be called from TemplateManager
  removeAllListeners() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
};
var TemplateManager = class {
  constructor(plugin, app) {
    this.templateSuggestProvider = null;
    var _a;
    this.plugin = plugin;
    this.app = app;
    try {
      if (!plugin.directoryManager || !plugin.directoryManager.isInitialized()) {
        (_a = plugin.directoryManager) == null ? void 0 : _a.initialize().catch((e) => {
        });
      }
      this.templateSuggestProvider = new TemplateSuggestProvider(app, plugin);
      plugin.registerEditorSuggest(this.templateSuggestProvider);
    } catch (error) {
      this.templateSuggestProvider = null;
    }
  }
  unload() {
    if (this.templateSuggestProvider) {
      this.templateSuggestProvider.removeAllListeners();
    }
  }
};

// src/core/EventEmitter.ts
var EventEmitter = class {
  constructor() {
    this.events = {};
    // Track event listeners by namespace for easier management
    this.namespaceListeners = {};
  }
  /**
   * Register an event listener
   * @param event Event name (supports namespacing like "systemsculpt:modelUpdated")
   * @param listener Function to call when event is emitted
   * @returns Unsubscribe function
   */
  on(event, listener) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(listener);
    this.trackNamespace(event);
    return () => {
      this.events[event] = this.events[event].filter((l) => l !== listener);
      this.cleanupNamespace(event);
    };
  }
  /**
   * Register a one-time event listener
   * @param event Event name
   * @param listener Function to call when event is emitted
   * @returns Unsubscribe function
   */
  once(event, listener) {
    const remove = this.on(event, (...args) => {
      remove();
      listener(...args);
    });
    return remove;
  }
  /**
   * Emit an event
   * @param event Event name
   * @param args Arguments to pass to listeners
   */
  emit(event, ...args) {
    const callbacks = this.events[event];
    if (callbacks) {
      callbacks.forEach((callback) => callback(...args));
    }
  }
  /**
   * Remove all listeners for an event
   * @param event Event name
   */
  off(event) {
    delete this.events[event];
  }
  /**
   * Remove all event listeners
   */
  clear() {
    this.events = {};
    this.namespaceListeners = {};
  }
  /**
   * Track namespace for an event
   */
  trackNamespace(event) {
    const namespace = this.getNamespace(event);
    if (namespace) {
      if (!this.namespaceListeners[namespace]) {
        this.namespaceListeners[namespace] = /* @__PURE__ */ new Set();
      }
      this.namespaceListeners[namespace].add(event);
    }
  }
  /**
   * Clean up namespace tracking when event listeners are removed
   */
  cleanupNamespace(event) {
    const namespace = this.getNamespace(event);
    if (namespace && this.namespaceListeners[namespace]) {
      if (!this.events[event] || this.events[event].length === 0) {
        this.namespaceListeners[namespace].delete(event);
        if (this.namespaceListeners[namespace].size === 0) {
          delete this.namespaceListeners[namespace];
        }
      }
    }
  }
  /**
   * Extract namespace from event name (everything before first colon)
   */
  getNamespace(event) {
    const parts = event.split(":");
    return parts.length > 1 ? parts[0] : null;
  }
  /**
   * Remove all listeners for a specific namespace
   * @param namespace The namespace to clear (e.g., "systemsculpt", "custom")
   */
  clearNamespace(namespace) {
    if (this.namespaceListeners[namespace]) {
      const events = Array.from(this.namespaceListeners[namespace]);
      events.forEach((event) => {
        delete this.events[event];
      });
      delete this.namespaceListeners[namespace];
    }
  }
  /**
   * Get all events in a namespace
   * @param namespace The namespace to query
   * @returns Array of event names in the namespace
   */
  getNamespaceEvents(namespace) {
    return this.namespaceListeners[namespace] ? Array.from(this.namespaceListeners[namespace]) : [];
  }
  /**
   * Emit an event with provider context
   * @param event Event name
   * @param providerType Optional provider type context
   * @param args Arguments to pass to listeners
   */
  emitWithProvider(event, providerType, ...args) {
    this.emit(event, ...args);
    const namespacedEvent = `${providerType}:${event}`;
    this.emit(namespacedEvent, ...args);
  }
  /**
   * Listen to events from a specific provider only
   * @param event Base event name (without namespace)
   * @param providerType Provider type to listen to
   * @param listener Function to call when event is emitted
   * @returns Unsubscribe function
   */
  onProvider(event, providerType, listener) {
    const namespacedEvent = `${providerType}:${event}`;
    return this.on(namespacedEvent, listener);
  }
};

// src/core/DirectoryManager.ts
var import_obsidian114 = require("obsidian");
var DirectoryManager = class {
  constructor(app, plugin) {
    this.directories = /* @__PURE__ */ new Map();
    this.initialized = false;
    this.initializationPromise = null;
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Check if the directory manager has been initialized
   */
  isInitialized() {
    return this.initialized;
  }
  /**
   * Initialize all required directories for the plugin
   * This should be called early in the plugin startup process
   * @param timeoutMs Timeout in milliseconds for the entire initialization (defaults to 12000ms)
   */
  async initialize(timeoutMs = 12e3) {
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    if (this.initialized) {
      return;
    }
    const initPromise = this._initialize();
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Directory initialization timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    });
    this.initializationPromise = Promise.race([initPromise, timeoutPromise]);
    try {
      await this.initializationPromise;
      this.initialized = true;
      this.initializationPromise = null;
    } catch (error) {
      this.initializationPromise = null;
      if (error instanceof Error && error.message.includes("timed out")) {
        this.initialized = true;
      } else {
        throw error;
      }
    }
  }
  /**
   * Internal initialization method - optimized for parallel execution
   */
  async _initialize() {
    try {
      const initStart = performance.now();
      const settings = this.plugin.settings;
      const directories = [
        settings.chatsDirectory,
        settings.savedChatsDirectory,
        settings.recordingsDirectory,
        settings.systemPromptsDirectory,
        settings.attachmentsDirectory,
        settings.extractionsDirectory
      ].filter((dir) => dir && dir.trim() !== "");
      const needsSystemSculptDir = directories.some((dir) => dir.startsWith("SystemSculpt/"));
      if (needsSystemSculptDir) {
        await this.createDirectoryOptimized("SystemSculpt", true);
      }
      const directoryPromises = directories.map(async (dir) => {
        try {
          await this.createDirectoryOptimized(dir);
          return { dir, success: true, error: null };
        } catch (error) {
          return { dir, success: false, error };
        }
      });
      const results = await Promise.allSettled(directoryPromises);
      const successful = results.filter((r) => r.status === "fulfilled" && r.value.success).length;
      const failed = results.length - successful;
      this.notifyDirectoriesReady();
    } catch (error) {
      this.notifyDirectoriesReady();
    }
  }
  /**
   * Notify that directories are ready
   * Components can listen for this event
   */
  notifyDirectoriesReady() {
    if (this.plugin.emitter && typeof this.plugin.emitter.emit === "function") {
      this.plugin.emitter.emit("directory-structure-ready");
    } else {
      const event = new CustomEvent("systemsculpt:directory-structure-ready", {
        detail: { plugin: this.plugin }
      });
      window.dispatchEvent(event);
    }
  }
  /**
   * Get a directory path, ensuring it exists
   * Components should use this instead of accessing settings directly
   */
  getDirectory(key) {
    if (!this.initialized) {
      throw new Error("Directory manager not initialized. Wait for initialization to complete.");
    }
    const path = this.plugin.settings[key];
    if (!path || !this.directories.get(path)) {
      throw new Error(`Directory not available: ${key}`);
    }
    return path;
  }
  /**
   * Create a specific directory by key if not in the original initialization
   * Used when a new directory is needed after initialization
   */
  async ensureDirectoryByKey(key) {
    if (!this.initialized) {
      await this.initialize();
    }
    const path = this.plugin.settings[key];
    if (!path || path.trim() === "") {
      throw new Error(`No path configured for: ${key}`);
    }
    await this.createDirectory(path);
    return path;
  }
  /**
   * Create a specific directory by path
   * Used for direct path creation
   */
  async ensureDirectoryByPath(dirPath) {
    if (!this.initialized) {
      await this.initialize();
    }
    if (!dirPath || dirPath.trim() === "") {
      throw new Error("Cannot create directory: empty path provided");
    }
    await this.createDirectory(dirPath);
  }
  /**
   * Called when directory settings change
   * Ensures the new directories exist
   */
  async handleDirectorySettingChange(key, newPath) {
    if (!this.initialized) {
      await this.initialize();
    }
    if (newPath && newPath.trim() !== "") {
      await this.createDirectory(newPath);
    }
  }
  /**
   * Optimized directory creation method with reduced file system operations
   * @param dirPath Directory path to create
   * @param createMarker Whether to create a marker file
   */
  async createDirectoryOptimized(dirPath, createMarker = false) {
    if (!dirPath || dirPath.trim() === "") {
      throw new Error("Cannot create directory: empty or invalid path");
    }
    const normalizedPath = this.normalizePath(dirPath);
    if (this.directories.get(normalizedPath)) {
      return;
    }
    try {
      const exists = await this.app.vault.adapter.exists(normalizedPath);
      if (!exists) {
        await this.app.vault.createFolder(normalizedPath);
      }
      if (createMarker) {
        const markerPath = `${normalizedPath}/.folder`;
        const markerExists = await this.app.vault.adapter.exists(markerPath);
        if (!markerExists) {
          await this.app.vault.adapter.write(
            markerPath,
            "This file helps Obsidian recognize the directory."
          );
        }
      }
      this.directories.set(normalizedPath, true);
    } catch (error) {
      if (error instanceof Error && error.message.includes("already exists")) {
        this.directories.set(normalizedPath, true);
        return;
      }
      throw error;
    }
  }
  /**
   * Legacy method for backward compatibility - now uses optimized version
   * @param dirPath Directory path to create
   * @param createMarker Whether to create a marker file
   * @param timeoutMs Timeout in milliseconds (ignored, kept for compatibility)
   * @param retryCount Number of retries attempted (ignored, kept for compatibility)
   */
  async createDirectory(dirPath, createMarker = false, timeoutMs = 3e3, retryCount = 0) {
    return this.createDirectoryOptimized(dirPath, createMarker);
  }
  /**
   * Original method with timeout and retry logic (kept for fallback)
   * @param dirPath Directory path to create
   * @param createMarker Whether to create a marker file
   * @param timeoutMs Timeout in milliseconds (defaults to 3000ms)
   * @param retryCount Number of retries attempted (for internal use)
   */
  async createDirectoryWithRetry(dirPath, createMarker = false, timeoutMs = 3e3, retryCount = 0) {
    if (!dirPath || dirPath.trim() === "") {
      throw new Error("Cannot create directory: empty or invalid path");
    }
    const normalizedPath = this.normalizePath(dirPath);
    const directoryPromise = (async () => {
      try {
        const pathParts = normalizedPath.split("/");
        if (pathParts.length > 1) {
          const parentPath = pathParts.slice(0, -1).join("/");
          await this.createDirectory(parentPath);
        }
        const exists = await this.app.vault.adapter.exists(normalizedPath);
        const folderExists = this.app.vault.getAbstractFileByPath(normalizedPath) instanceof import_obsidian114.TFolder;
        if (!exists || !folderExists) {
          await this.app.vault.createFolder(normalizedPath);
        } else {
        }
        if (createMarker) {
          const markerPath = `${normalizedPath}/.folder`;
          const markerExists = await this.app.vault.adapter.exists(markerPath);
          if (!markerExists) {
            await this.app.vault.adapter.write(
              markerPath,
              "This file helps Obsidian recognize the directory."
            );
          }
        }
        this.directories.set(normalizedPath, true);
      } catch (error) {
        if (!(error instanceof Error) || !error.message.includes("already exists")) {
          throw error;
        } else {
          this.directories.set(normalizedPath, true);
        }
      }
    })();
    const timeoutPromise = new Promise((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Directory operation timed out after ${timeoutMs}ms: ${normalizedPath}`));
      }, timeoutMs);
    });
    try {
      await Promise.race([directoryPromise, timeoutPromise]);
    } catch (error) {
      const isTimeout = error instanceof Error && error.message.includes("timed out");
      if (isTimeout && retryCount < 2) {
        const backoffMs = 1e3 * Math.pow(2, retryCount);
        await new Promise((resolve) => setTimeout(resolve, backoffMs));
        return this.createDirectory(dirPath, createMarker, timeoutMs * 1.5, retryCount + 1);
      }
      if (isTimeout) {
        try {
          const exists = await this.app.vault.adapter.exists(normalizedPath);
          if (exists) {
            this.directories.set(normalizedPath, true);
            return;
          }
        } catch (checkError) {
        }
      }
      this.directories.set(normalizedPath, false);
      if (!dirPath.includes("System Prompts")) {
        throw error;
      } else {
      }
    }
  }
  /**
   * Normalize a directory path to handle edge cases
   * @param dirPath The directory path to normalize
   * @returns Normalized path
   */
  normalizePath(dirPath) {
    let path = dirPath.trim();
    path = path.replace(/^\/+|\/+$/g, "");
    path = path.replace(/\/+/g, "/");
    if (path === "") {
      return "/";
    }
    return path;
  }
  /**
   * Verify all directories are accessible
   * Used for diagnostics and repair
   */
  async verifyDirectories() {
    const issues = [];
    try {
      const settings = this.plugin.settings;
      const directories = [
        settings.chatsDirectory,
        settings.savedChatsDirectory,
        settings.recordingsDirectory,
        settings.systemPromptsDirectory,
        settings.attachmentsDirectory,
        settings.extractionsDirectory
      ];
      const needsSystemSculptDir = directories.some(
        (dir) => dir && dir.trim() !== "" && dir.startsWith("SystemSculpt/")
      );
      if (needsSystemSculptDir) {
        const mainPath = "SystemSculpt";
        const mainExists = await this.app.vault.adapter.exists(mainPath);
        const mainFolder = this.app.vault.getAbstractFileByPath(mainPath) instanceof import_obsidian114.TFolder;
        if (!mainExists || !mainFolder) {
          issues.push(`Main directory "${mainPath}" does not exist`);
        }
      }
      for (const dir of directories) {
        if (!dir || dir.trim() === "") continue;
        const exists = await this.app.vault.adapter.exists(dir);
        const folder = this.app.vault.getAbstractFileByPath(dir) instanceof import_obsidian114.TFolder;
        if (!exists || !folder) {
          issues.push(`Directory "${dir}" does not exist or is not accessible`);
        }
      }
    } catch (error) {
      issues.push(`Error verifying directories: ${error.message}`);
    }
    return {
      valid: issues.length === 0,
      issues
    };
  }
  /**
   * Repair the directory structure
   * Used when issues are detected
   */
  async repair() {
    try {
      this.initialized = false;
      this.initializationPromise = null;
      this.directories.clear();
      const settings = this.plugin.settings;
      const directories = [
        settings.chatsDirectory,
        settings.savedChatsDirectory,
        settings.recordingsDirectory,
        settings.systemPromptsDirectory,
        settings.attachmentsDirectory,
        settings.extractionsDirectory
      ];
      const needsSystemSculptDir = directories.some(
        (dir) => dir && dir.trim() !== "" && dir.startsWith("SystemSculpt/")
      );
      if (needsSystemSculptDir) {
        await this.createDirectory("SystemSculpt", true);
      }
      await this.initialize();
      return true;
    } catch (error) {
      return false;
    }
  }
};

// src/services/VersionCheckerService.ts
var import_obsidian116 = require("obsidian");
init_api();
init_api();
var _VersionCheckerService = class _VersionCheckerService {
  constructor(currentVersion, app, plugin) {
    this.githubRepo = "systemsculpt/obsidian-systemsculpt-ai";
    this.pluginId = "systemsculpt-ai";
    this.cachedVersionInfo = null;
    this.lastChecked = 0;
    this.cacheTimeMs = 1e3 * 60 * 10;
    this.updateDrawerEl = null;
    this.periodicCheckIntervalMs = 1e3 * 60 * 10;
    // 10 minutes
    this.periodicCheckTimeout = null;
    // Development mode state to track update flow
    this.devModeUpdateState = "show-update";
    this.currentVersion = currentVersion;
    this.app = app;
    this.plugin = plugin;
    if (DEVELOPMENT_MODE === "DEVELOPMENT") {
      const savedState = localStorage.getItem("systemsculpt-dev-update-state");
      if (savedState === "show-post-update" || savedState === "show-update") {
        this.devModeUpdateState = savedState;
      }
    }
  }
  /**
   * Simulates an update in development mode
   */
  simulateUpdate() {
    if (DEVELOPMENT_MODE === "DEVELOPMENT") {
      this.devModeUpdateState = "show-post-update";
      localStorage.setItem("systemsculpt-dev-update-state", "show-post-update");
    }
  }
  /**
   * Resets the development mode update flow
   */
  resetDevUpdateFlow() {
    if (DEVELOPMENT_MODE === "DEVELOPMENT") {
      this.devModeUpdateState = "show-update";
      localStorage.setItem("systemsculpt-dev-update-state", "show-update");
    }
  }
  static getInstance(currentVersion, app, plugin) {
    if (!_VersionCheckerService.instance) {
      if (!app || !plugin) {
        throw new Error("App and plugin must be provided when initializing VersionCheckerService");
      }
      _VersionCheckerService.instance = new _VersionCheckerService(currentVersion, app, plugin);
    }
    return _VersionCheckerService.instance;
  }
  /**
   * Starts the periodic update checker
   */
  startPeriodicUpdateCheck() {
    if (DEVELOPMENT_MODE !== "DEVELOPMENT" && !this.plugin.settings.showUpdateNotifications) {
      return;
    }
    this.stopPeriodicUpdateCheck();
    this.periodicCheckTimeout = setInterval(() => {
      this.checkForUpdatesQuietly();
    }, this.periodicCheckIntervalMs);
  }
  /**
   * Stops the periodic update checker
   */
  stopPeriodicUpdateCheck() {
    if (this.periodicCheckTimeout) {
      clearInterval(this.periodicCheckTimeout);
      this.periodicCheckTimeout = null;
    }
  }
  /**
   * Checks for updates in background without showing notification
   * if already on the latest version
   */
  async checkForUpdatesQuietly() {
    if (DEVELOPMENT_MODE !== "DEVELOPMENT" && !this.plugin.settings.showUpdateNotifications) {
      return;
    }
    try {
      let versionInfo = await this.checkVersion(true);
      if (DEVELOPMENT_MODE === "DEVELOPMENT" && this.devModeUpdateState === "show-update") {
        versionInfo = {
          currentVersion: this.currentVersion,
          latestVersion: "99.99.99",
          isLatest: false,
          releaseUrl: versionInfo.releaseUrl,
          updateUrl: versionInfo.updateUrl
        };
      }
      if (!versionInfo.isLatest) {
        this.showUpdateDrawer(versionInfo);
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("403")) {
      } else {
      }
    }
  }
  /**
   * Checks if the current version is the latest available version
   * @param forceRefresh Force refresh the cache
   * @returns Version information
   */
  async checkVersion(forceRefresh = false) {
    const now = Date.now();
    if (!forceRefresh && this.cachedVersionInfo && now - this.lastChecked < this.cacheTimeMs) {
      return this.cachedVersionInfo;
    }
    try {
      const latestVersion = await this.fetchLatestVersion();
      let isLatest = this.compareVersions(this.currentVersion, latestVersion) >= 0;
      this.cachedVersionInfo = {
        currentVersion: this.currentVersion,
        latestVersion,
        isLatest,
        releaseUrl: `https://github.com/${this.githubRepo}/releases/latest`,
        updateUrl: `obsidian://show-plugin?id=${this.pluginId}`
      };
      this.lastChecked = now;
      return this.cachedVersionInfo;
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      if (errorMessage.includes("403")) {
      } else {
      }
      return {
        currentVersion: this.currentVersion,
        latestVersion: "unknown",
        isLatest: true,
        // Assume we're on latest if we can't check
        releaseUrl: `https://github.com/${this.githubRepo}/releases/latest`,
        updateUrl: `obsidian://show-plugin?id=${this.pluginId}`
      };
    }
  }
  /**
   * Checks for plugin updates on startup and shows a notice if an update is available
   * @param delayMs Time to wait before checking (default: 3000ms)
   */
  async checkForUpdatesOnStartup(delayMs = 3e3) {
    await new Promise((resolve) => setTimeout(resolve, delayMs));
    if (DEVELOPMENT_MODE === "DEVELOPMENT") {
      if (this.devModeUpdateState === "show-post-update") {
        this.showPostUpdateDrawer();
        this.devModeUpdateState = "show-update";
        localStorage.setItem("systemsculpt-dev-update-state", "show-update");
      } else {
        const fakeVersionInfo = {
          currentVersion: this.currentVersion,
          latestVersion: "99.99.99",
          isLatest: false,
          releaseUrl: `https://github.com/${this.githubRepo}/releases/latest`,
          updateUrl: `obsidian://show-plugin?id=${this.pluginId}`
        };
        this.showUpdateDrawer(fakeVersionInfo);
      }
      this.startPeriodicUpdateCheck();
      return;
    }
    const lastKnownVersion = this.plugin.settings.lastKnownVersion;
    const hasJustUpdated = lastKnownVersion && lastKnownVersion !== this.currentVersion && this.compareVersions(this.currentVersion, lastKnownVersion) > 0;
    if (lastKnownVersion !== this.currentVersion) {
      await this.plugin.getSettingsManager().updateSettings({ lastKnownVersion: this.currentVersion });
    }
    if (hasJustUpdated) {
      this.showPostUpdateDrawer();
    }
    if (!this.plugin.settings.showUpdateNotifications) {
      return;
    }
    try {
      const versionInfo = await this.checkVersion();
      if (!versionInfo.isLatest) {
        this.showUpdateDrawer(versionInfo);
      }
    } catch (error) {
      const message = error instanceof Error ? error.message : String(error);
      if (message.includes("403")) {
      } else {
      }
    } finally {
      this.startPeriodicUpdateCheck();
    }
  }
  /**
   * Shows a post-update notification drawer
   */
  showPostUpdateDrawer() {
    this.removeUpdateDrawer();
    this.updateDrawerEl = document.createElement("div");
    this.updateDrawerEl.classList.add("systemsculpt-update-drawer");
    this.updateDrawerEl.setAttribute("role", "dialog");
    this.updateDrawerEl.setAttribute("aria-labelledby", "update-drawer-title");
    this.updateDrawerEl.setAttribute("aria-describedby", "update-drawer-message");
    this.updateDrawerEl.innerHTML = `
      <div class="systemsculpt-update-drawer-header">
        <div id="update-drawer-title" class="systemsculpt-update-drawer-title">SystemSculpt AI Updated</div>
        <button class="systemsculpt-update-drawer-close" aria-label="Close" type="button"></button>
      </div>
      <div class="systemsculpt-update-drawer-content">
        <div id="update-drawer-message" class="systemsculpt-update-drawer-message">
          Update completed successfully!
        </div>
        <div class="systemsculpt-update-drawer-versions" aria-label="Current version">
          <span class="systemsculpt-update-drawer-latest">v${this.currentVersion}</span>
        </div>
        <button class="systemsculpt-update-drawer-button" type="button">View Changelog</button>
      </div>
    `;
    document.body.appendChild(this.updateDrawerEl);
    const closeButton = this.updateDrawerEl.querySelector(".systemsculpt-update-drawer-close");
    if (closeButton) {
      closeButton.addEventListener("click", () => {
        this.removeUpdateDrawer();
      });
      closeButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.removeUpdateDrawer();
        }
      });
    }
    const changelogButton = this.updateDrawerEl.querySelector(".systemsculpt-update-drawer-button");
    if (changelogButton) {
      changelogButton.addEventListener("click", () => {
        this.openChangelogTab();
        this.removeUpdateDrawer();
      });
      changelogButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.openChangelogTab();
          this.removeUpdateDrawer();
        }
      });
    }
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        this.removeUpdateDrawer();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
    setTimeout(() => {
      if (this.updateDrawerEl) {
        this.updateDrawerEl.classList.add("visible");
      }
    }, 100);
    setTimeout(() => {
      this.removeUpdateDrawer();
    }, 2e4);
  }
  /**
   * Opens the SystemSculpt settings to the changelog tab
   */
  openChangelogTab() {
    Promise.resolve().then(() => (init_ChangeLogModal(), ChangeLogModal_exports)).then(({ ChangeLogModal: ChangeLogModal2 }) => {
      const modal = new ChangeLogModal2(this.app);
      modal.open();
    }).catch(() => {
      new import_obsidian116.Notice("Unable to open changelog modal.", 4e3);
    });
  }
  /**
   * Shows a custom update drawer in the bottom right corner
   * @param versionInfo Version information to display
   */
  showUpdateDrawer(versionInfo) {
    this.removeUpdateDrawer();
    this.updateDrawerEl = document.createElement("div");
    this.updateDrawerEl.classList.add("systemsculpt-update-drawer");
    this.updateDrawerEl.setAttribute("role", "dialog");
    this.updateDrawerEl.setAttribute("aria-labelledby", "update-drawer-title");
    this.updateDrawerEl.setAttribute("aria-describedby", "update-drawer-message");
    this.updateDrawerEl.innerHTML = `
      <div class="systemsculpt-update-drawer-header">
        <div id="update-drawer-title" class="systemsculpt-update-drawer-title">SystemSculpt AI Update</div>
        <button class="systemsculpt-update-drawer-close" aria-label="Close" type="button"></button>
      </div>
      <div class="systemsculpt-update-drawer-content">
        <div id="update-drawer-message" class="systemsculpt-update-drawer-message">
          Version ${versionInfo.latestVersion} is available.
        </div>
        <div class="systemsculpt-update-drawer-versions" aria-label="Version information">
          <span class="systemsculpt-update-drawer-current">v${versionInfo.currentVersion}</span>
          <span class="systemsculpt-update-drawer-arrow">\u2192</span>
          <span class="systemsculpt-update-drawer-latest">v${versionInfo.latestVersion}</span>
        </div>
        <button class="systemsculpt-update-drawer-button" type="button">Update</button>
      </div>
    `;
    document.body.appendChild(this.updateDrawerEl);
    const closeButton = this.updateDrawerEl.querySelector(".systemsculpt-update-drawer-close");
    if (closeButton) {
      closeButton.addEventListener("click", () => {
        this.removeUpdateDrawer();
      });
      closeButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.removeUpdateDrawer();
        }
      });
    }
    const updateButton = this.updateDrawerEl.querySelector(".systemsculpt-update-drawer-button");
    if (updateButton) {
      updateButton.addEventListener("click", () => {
        this.handleUpdateButtonClick(versionInfo);
      });
      updateButton.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          this.handleUpdateButtonClick(versionInfo);
        }
      });
    }
    const handleEscape = (e) => {
      if (e.key === "Escape") {
        this.removeUpdateDrawer();
        document.removeEventListener("keydown", handleEscape);
      }
    };
    document.addEventListener("keydown", handleEscape);
    setTimeout(() => {
      if (this.updateDrawerEl) {
        this.updateDrawerEl.classList.add("visible");
      }
    }, 100);
    setTimeout(() => {
      this.removeUpdateDrawer();
    }, 2e4);
  }
  /**
   * Handles the update button click functionality
   * @param versionInfo Version information for the update
   */
  handleUpdateButtonClick(versionInfo) {
    if (DEVELOPMENT_MODE === "DEVELOPMENT") {
      this.simulateUpdate();
      new import_obsidian116.Notice(
        "Development Mode: Simulating update...\n\nThe post-update notification will appear on next reload.",
        5e3
      );
      this.removeUpdateDrawer();
      return;
    }
    window.open(versionInfo.updateUrl, "_blank");
    new import_obsidian116.Notice(
      "Opening SystemSculpt AI in Community Plugins...\n\nIf nothing happens, please update manually via Settings \u2192 Community plugins",
      1e4
      // Show for 10 seconds
    );
    this.removeUpdateDrawer();
  }
  /**
   * Removes the update drawer from the DOM
   */
  removeUpdateDrawer() {
    if (this.updateDrawerEl) {
      this.updateDrawerEl.classList.remove("visible");
      setTimeout(() => {
        if (this.updateDrawerEl && this.updateDrawerEl.parentNode) {
          this.updateDrawerEl.parentNode.removeChild(this.updateDrawerEl);
          this.updateDrawerEl = null;
        }
      }, 300);
    }
  }
  /**
   * Fetches the latest version from GitHub releases
   * @returns The latest version string
   */
  async fetchLatestVersion() {
    var _a;
    const apiUrl = `${API_BASE_URL}${SYSTEMSCULPT_API_ENDPOINTS.PLUGINS.LATEST(this.pluginId)}`;
    try {
      const { httpRequest: httpRequest2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
      const response = await httpRequest2({
        url: apiUrl,
        method: "GET",
        headers: { "Accept": "application/json" }
      });
      if (response.status === 403) {
        return this.currentVersion;
      }
      if (!response.status || response.status !== 200) {
        return this.currentVersion;
      }
      const data = response.json || (response.text ? JSON.parse(response.text) : {});
      const version = (_a = data == null ? void 0 : data.data) == null ? void 0 : _a.latestVersion;
      if (typeof version === "string") {
        return version;
      }
      return this.currentVersion;
    } catch (error) {
      return this.currentVersion;
    }
  }
  /**
   * Compares two semantic version strings
   * @param versionA First version (typically current)
   * @param versionB Second version (typically latest)
   * @returns 1 if A > B, 0 if A = B, -1 if A < B
   */
  compareVersions(versionA, versionB) {
    const partsA = versionA.split(".").map((part) => parseInt(part, 10));
    const partsB = versionB.split(".").map((part) => parseInt(part, 10));
    for (let i = 0; i < Math.max(partsA.length, partsB.length); i++) {
      const partA = i < partsA.length ? partsA[i] : 0;
      const partB = i < partsB.length ? partsB[i] : 0;
      if (partA > partB) return 1;
      if (partA < partB) return -1;
    }
    return 0;
  }
  /**
   * Restarts update checking when notifications are re-enabled
   */
  onUpdateNotificationsEnabled() {
    if (this.plugin.settings.showUpdateNotifications) {
      this.startPeriodicUpdateCheck();
      this.checkForUpdatesOnStartup(1e3);
    }
  }
  /**
   * Stops update checking when notifications are disabled
   */
  onUpdateNotificationsDisabled() {
    this.stopPeriodicUpdateCheck();
    this.removeUpdateDrawer();
  }
  /**
   * Clean up resources when the plugin is unloaded
   */
  unload() {
    this.stopPeriodicUpdateCheck();
    this.removeUpdateDrawer();
  }
  /**
   * Clear the singleton instance to allow proper cleanup
   */
  static clearInstance() {
    if (_VersionCheckerService.instance) {
      _VersionCheckerService.instance.unload();
      _VersionCheckerService.instance = null;
    }
  }
};
_VersionCheckerService.instance = null;
var VersionCheckerService = _VersionCheckerService;

// src/main.ts
init_FavoritesService();

// src/core/storage/StorageManager.ts
var import_obsidian117 = require("obsidian");
var StorageManager = class {
  /**
   * Create a new StorageManager
   */
  constructor(app, plugin) {
    // Base path for hidden storage in the vault
    this.hiddenBasePath = ".systemsculpt";
    // Track initialization state
    this.initialized = false;
    this.initializationPromise = null;
    // Track created directories to avoid redundant checks
    this.createdDirectories = /* @__PURE__ */ new Set();
    this.app = app;
    this.plugin = plugin;
  }
  /**
   * Initialize the storage system
   * Creates necessary directories and ensures everything is ready
   */
  async initialize() {
    if (this.initialized) {
      return;
    }
    if (this.initializationPromise) {
      return this.initializationPromise;
    }
    this.initializationPromise = this._initialize();
    try {
      await this.initializationPromise;
      this.initialized = true;
    } catch (error) {
      throw error;
    } finally {
      this.initializationPromise = null;
    }
  }
  /**
   * Internal initialization method
   */
  async _initialize() {
    try {
      await this.ensureDirectory(this.hiddenBasePath);
      await Promise.all([
        this.ensureDirectory(this.getPath("settings")),
        this.ensureDirectory(this.getPath("settings", "backups")),
        this.ensureDirectory(this.getPath("settings", "emergency")),
        this.ensureDirectory(this.getPath("embeddings")),
        this.ensureDirectory(this.getPath("cache")),
        this.ensureDirectory(this.getPath("temp")),
        this.ensureDirectory(this.getPath("logs"))
      ]);
    } catch (error) {
      throw error;
    }
  }
  /**
   * Check if the storage system is initialized
   */
  isInitialized() {
    return this.initialized;
  }
  /**
   * Get the path to a storage location in the vault's .systemsculpt directory
   * @param type The type of storage location
   * @param subPath Optional sub-path components
   * @returns The full path to the storage location
   */
  getPath(type, ...subPath) {
    const basePath = `${this.hiddenBasePath}/${type}`;
    return subPath.length > 0 ? `${basePath}/${subPath.join("/")}` : basePath;
  }
  /**
   * Ensure a directory exists
   * @param path The path to ensure exists
   * @param createMarker Whether to create a marker file
   * @returns Promise resolving when directory is created
   */
  async ensureDirectory(path, createMarker = false) {
    const normalizedPath = path.replace(/\\/g, "/");
    if (this.createdDirectories.has(normalizedPath)) {
      return;
    }
    try {
      const pathParts = normalizedPath.split("/");
      if (pathParts.length > 1) {
        const parentPath = pathParts.slice(0, -1).join("/");
        if (parentPath) {
          await this.ensureDirectory(parentPath);
        }
      }
      const exists = await this.app.vault.adapter.exists(normalizedPath);
      const folderExists = this.app.vault.getAbstractFileByPath(normalizedPath) instanceof import_obsidian117.TFolder;
      if (!exists || !folderExists) {
        await this.app.vault.createFolder(normalizedPath);
      }
      if (createMarker) {
        const markerPath = `${normalizedPath}/.folder`;
        const markerExists = await this.app.vault.adapter.exists(markerPath);
        if (!markerExists) {
          await this.app.vault.adapter.write(
            markerPath,
            "This file helps Obsidian recognize the directory."
          );
        }
      }
      this.createdDirectories.add(normalizedPath);
    } catch (error) {
      if (!(error instanceof Error) || !error.message.includes("already exists")) {
        throw error;
      } else {
        this.createdDirectories.add(normalizedPath);
      }
    }
  }
  /**
   * Write data to a file
   * @param type Storage location type
   * @param fileName File name within the location
   * @param data Data to write (string or object)
   * @returns Promise resolving to operation result
   */
  async writeFile(type, fileName, data) {
    try {
      await this.initialize();
      const path = this.getPath(type, fileName);
      const content = typeof data === "string" ? data : JSON.stringify(data, null, 2);
      await this.app.vault.adapter.write(path, content);
      return { success: true, path };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: errorMessage };
    }
  }
  /**
   * Append a line of data to a file, creating it when missing.
   * Writes are serialized through the adapter to avoid race issues.
   */
  async appendToFile(type, fileName, data) {
    try {
      await this.initialize();
      const path = this.getPath(type, fileName);
      const payload = data.endsWith("\n") ? data : `${data}
`;
      const adapter = this.app.vault.adapter;
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        await this.app.vault.adapter.write(path, payload);
      } else if (typeof adapter.append === "function") {
        await adapter.append(path, payload);
      } else {
        const existing = await this.app.vault.adapter.read(path);
        await this.app.vault.adapter.write(path, `${existing}${payload}`);
      }
      return { success: true, path };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: errorMessage };
    }
  }
  /**
   * Read data from a file
   * @param type Storage location type
   * @param fileName File name within the location
   * @param parseJson Whether to parse the file as JSON
   * @returns Promise resolving to file content or parsed object
   */
  async readFile(type, fileName, parseJson = false) {
    try {
      const path = this.getPath(type, fileName);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        return null;
      }
      const content = await this.app.vault.adapter.read(path);
      if (parseJson) {
        return JSON.parse(content);
      }
      return content;
    } catch (error) {
      return null;
    }
  }
  /**
   * Delete a file
   * @param type Storage location type
   * @param fileName File name within the location
   * @returns Promise resolving to operation result
   */
  async deleteFile(type, fileName) {
    try {
      const path = this.getPath(type, fileName);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        return { success: true, path };
      }
      await this.app.vault.adapter.remove(path);
      return { success: true, path };
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      return { success: false, error: errorMessage };
    }
  }
  /**
   * List files in a storage location
   * @param type Storage location type
   * @param subPath Optional sub-path within the location
   * @returns Promise resolving to array of file names
   */
  async listFiles(type, subPath = "") {
    try {
      const path = subPath ? this.getPath(type, subPath) : this.getPath(type);
      const exists = await this.app.vault.adapter.exists(path);
      if (!exists) {
        return [];
      }
      const files = await this.app.vault.adapter.list(path);
      return files.files.map((f) => f.split("/").pop() || "");
    } catch (error) {
      return [];
    }
  }
};

// src/views/chatview/ResumeChatService.ts
var import_obsidian118 = require("obsidian");
var ResumeChatService = class {
  constructor(plugin) {
    this.listeners = [];
    // Track inserted resume buttons per leaf to avoid broad DOM scans
    this.resumeButtonByLeaf = /* @__PURE__ */ new WeakMap();
    this.plugin = plugin;
    this.app = plugin.app;
    this.settings = plugin.settings;
    this.registerWorkspaceEvents();
  }
  registerWorkspaceEvents() {
    this.plugin.registerEvent(
      this.app.workspace.on("active-leaf-change", (leaf) => {
        if (leaf) {
          this.handleLeafChange(leaf);
        }
      })
    );
    this.plugin.registerEvent(
      this.app.workspace.on("layout-change", this.debouncedRefreshAllLeaves())
    );
    this.plugin.registerEvent(
      this.app.metadataCache.on("changed", (file) => {
        if (this.isChatHistoryFile(file)) {
          this.app.workspace.iterateAllLeaves((leaf) => {
            var _a;
            if (leaf.view instanceof import_obsidian118.MarkdownView && ((_a = leaf.view.file) == null ? void 0 : _a.path) === file.path) {
              this.handleLeafChange(leaf);
            }
          });
        }
      })
    );
  }
  debouncedRefreshAllLeaves() {
    let scheduled = false;
    return () => {
      if (scheduled) return;
      scheduled = true;
      setTimeout(() => {
        try {
          this.app.workspace.iterateAllLeaves((leaf) => {
            this.handleLeafChange(leaf);
          });
        } finally {
          scheduled = false;
        }
      }, 50);
    };
  }
  async handleLeafChange(leaf) {
    var _a, _b, _c, _d;
    try {
      (_b = (_a = window.FreezeMonitor) == null ? void 0 : _a.mark) == null ? void 0 : _b.call(_a, "resume-chat:handleLeafChange:start");
    } catch (e) {
    }
    const view = leaf.view;
    if (!(view instanceof import_obsidian118.MarkdownView)) return;
    const file = view.file;
    const existingButton = this.resumeButtonByLeaf.get(leaf);
    if (existingButton && existingButton.isConnected) {
      existingButton.remove();
    }
    this.resumeButtonByLeaf.delete(leaf);
    if (!file || !this.isChatHistoryFile(file)) return;
    const editorContainer = view.contentEl.querySelector(".cm-editor");
    const contentContainer = view.getMode() === "source" ? editorContainer : view.contentEl;
    if (!contentContainer) return;
    const chatId = this.extractChatId(file);
    if (!chatId) return;
    const buttonContainer = this.createResumeChatButton(chatId, file);
    contentContainer.insertBefore(buttonContainer, contentContainer.firstChild);
    this.resumeButtonByLeaf.set(leaf, buttonContainer);
    try {
      (_d = (_c = window.FreezeMonitor) == null ? void 0 : _c.mark) == null ? void 0 : _d.call(_c, "resume-chat:handleLeafChange:end");
    } catch (e) {
    }
  }
  isChatHistoryFile(file) {
    const chatsDirectory = this.settings.chatsDirectory || "SystemSculpt/Chats";
    if (!file.path.startsWith(chatsDirectory)) return false;
    if (!file.path.endsWith(".md")) return false;
    const cache = this.app.metadataCache.getCache(file.path);
    if (!(cache == null ? void 0 : cache.frontmatter)) return false;
    const metadata = cache.frontmatter;
    return !!(metadata.id && metadata.model && (metadata.created || metadata.lastModified));
  }
  extractChatId(file) {
    var _a;
    const cache = this.app.metadataCache.getCache(file.path);
    if ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.id) {
      return cache.frontmatter.id;
    }
    const filename = file.basename;
    return filename || null;
  }
  getModelFromFile(file) {
    var _a;
    const cache = this.app.metadataCache.getCache(file.path);
    return ((_a = cache == null ? void 0 : cache.frontmatter) == null ? void 0 : _a.model) || this.plugin.settings.selectedModelId;
  }
  createResumeChatButton(chatId, file) {
    const buttonContainer = document.createElement("div");
    buttonContainer.className = "systemsculpt-resume-chat-button";
    const button = document.createElement("button");
    button.className = "systemsculpt-resume-chat-btn";
    button.textContent = "Resume this chat";
    const selectedModelId = this.getModelFromFile(file);
    const clickHandler = async () => {
      await this.openChat(chatId, selectedModelId);
    };
    this.registerListener(button, "click", clickHandler);
    buttonContainer.appendChild(button);
    return buttonContainer;
  }
  async openChat(chatId, selectedModelId) {
    try {
      const { workspace } = this.app;
      const leaf = workspace.getLeaf("tab");
      await leaf.setViewState({
        type: CHAT_VIEW_TYPE,
        state: {
          chatId,
          selectedModelId
        }
      });
      workspace.setActiveLeaf(leaf, { focus: true });
    } catch (e) {
      new import_obsidian118.Notice("Error opening chat. Please try again.");
    }
  }
  registerListener(element, type, listener) {
    element.addEventListener(type, listener);
    this.listeners.push({ element, type, listener });
  }
  cleanup() {
    this.listeners.forEach(({ element, type, listener }) => {
      element.removeEventListener(type, listener);
    });
    this.listeners = [];
  }
};

// src/main.ts
init_inline_diff();

// src/services/embeddings/EmbeddingsManager.ts
var import_obsidian119 = require("obsidian");

// src/services/embeddings/storage/EmbeddingsStorage.ts
var DB_NAME = "SystemSculptEmbeddings";
var DB_VERSION = 8;
var STORE_NAME = "embeddings";
var EmbeddingsStorage = class {
  constructor() {
    this.db = null;
    this.cache = /* @__PURE__ */ new Map();
    this.initialized = false;
    // Cached array view of vectors to avoid re-allocating on every search
    this.vectorsArrayCache = null;
    // Track distinct file paths for accurate stats
    this.pathsSet = /* @__PURE__ */ new Set();
  }
  /**
   * Initialize the database
   */
  async initialize() {
    if (this.initialized) return;
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(DB_NAME, DB_VERSION);
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        this.initialized = true;
        resolve();
      };
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        const oldVersion = event.oldVersion;
        if (!db.objectStoreNames.contains(STORE_NAME)) {
          const store = db.createObjectStore(STORE_NAME, { keyPath: "id" });
          store.createIndex("by_path", "path", { unique: false });
          store.createIndex("by_namespace", "metadata.namespace", { unique: false });
          store.createIndex("by_mtime", "metadata.mtime", { unique: false });
          store.createIndex("by_contentHash", "metadata.contentHash", { unique: false });
        } else {
          const transaction = event.target.transaction;
          const oldStore = transaction.objectStore(STORE_NAME);
          const wasPathKey = oldStore.keyPath === "path";
          if (wasPathKey) {
            const tempName = `${STORE_NAME}_temp_v8`;
            const tempStore = db.createObjectStore(tempName, { keyPath: "id" });
            tempStore.createIndex("by_path", "path", { unique: false });
            tempStore.createIndex("by_namespace", "metadata.namespace", { unique: false });
            tempStore.createIndex("by_mtime", "metadata.mtime", { unique: false });
            tempStore.createIndex("by_contentHash", "metadata.contentHash", { unique: false });
            const getAllReq = oldStore.getAll();
            getAllReq.onsuccess = () => {
              var _a, _b, _c, _d;
              const oldItems = getAllReq.result || [];
              for (const item of oldItems) {
                const id = `${item.path}#0`;
                const migrated = {
                  id,
                  path: item.path,
                  chunkId: 0,
                  vector: item.vector,
                  metadata: {
                    title: ((_a = item.metadata) == null ? void 0 : _a.title) || "",
                    excerpt: void 0,
                    mtime: ((_b = item.metadata) == null ? void 0 : _b.mtime) || Date.now(),
                    contentHash: ((_c = item.metadata) == null ? void 0 : _c.hash) || "legacy",
                    isEmpty: ((_d = item.metadata) == null ? void 0 : _d.isEmpty) || false,
                    provider: "unknown",
                    model: "unknown",
                    dimension: Array.isArray(item.vector) ? item.vector.length : 0,
                    createdAt: Date.now(),
                    namespace: `unknown:unknown:${Array.isArray(item.vector) ? item.vector.length : 0}`
                  }
                };
                tempStore.put(migrated);
              }
              db.deleteObjectStore(STORE_NAME);
              const newStore = db.createObjectStore(STORE_NAME, { keyPath: "id" });
              newStore.createIndex("by_path", "path", { unique: false });
              newStore.createIndex("by_namespace", "metadata.namespace", { unique: false });
              newStore.createIndex("by_mtime", "metadata.mtime", { unique: false });
              newStore.createIndex("by_contentHash", "metadata.contentHash", { unique: false });
              const tempGetAll = tempStore.getAll();
              tempGetAll.onsuccess = () => {
                const tempItems = tempGetAll.result || [];
                for (const v of tempItems) newStore.put(v);
                db.deleteObjectStore(tempName);
              };
            };
          } else {
            if (!oldStore.indexNames.contains("by_path")) oldStore.createIndex("by_path", "path", { unique: false });
            if (!oldStore.indexNames.contains("by_namespace")) oldStore.createIndex("by_namespace", "metadata.namespace", { unique: false });
            if (!oldStore.indexNames.contains("by_mtime")) oldStore.createIndex("by_mtime", "metadata.mtime", { unique: false });
            if (!oldStore.indexNames.contains("by_contentHash")) oldStore.createIndex("by_contentHash", "metadata.contentHash", { unique: false });
          }
        }
      };
    });
  }
  /**
   * Load all embeddings into cache
   */
  async loadEmbeddings() {
    if (!this.db) throw new Error("Database not initialized");
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.getAll();
      request.onsuccess = () => {
        this.cache.clear();
        this.pathsSet.clear();
        for (const vector of request.result) {
          this.cache.set(vector.id, vector);
          if (vector.path) this.pathsSet.add(vector.path);
        }
        this.vectorsArrayCache = Array.from(this.cache.values());
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  /**
   * Store embeddings in batch
   */
  async storeVectors(vectors) {
    if (!this.db || vectors.length === 0) return;
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      let completed = 0;
      const total = vectors.length;
      for (const vector of vectors) {
        const request = store.put(vector);
        request.onsuccess = () => {
          this.cache.set(vector.id, vector);
          if (vector.path) this.pathsSet.add(vector.path);
          completed++;
          if (completed === total) resolve();
        };
        request.onerror = () => reject(request.error);
      }
      transaction.onerror = () => reject(transaction.error);
      transaction.oncomplete = () => {
        this.vectorsArrayCache = null;
      };
    });
  }
  /**
   * Get all vectors for a specific file path using the by_path index
   */
  async getVectorsByPath(path) {
    if (!this.db) return [];
    return new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction([STORE_NAME], "readonly");
        const store = tx.objectStore(STORE_NAME);
        const index = store.index("by_path");
        const req = index.getAll(IDBKeyRange.only(path));
        req.onsuccess = () => {
          const items = req.result || [];
          for (const v of items) this.cache.set(v.id, v);
          resolve(items);
        };
        req.onerror = () => reject(req.error);
      } catch (e) {
        resolve([]);
      }
    });
  }
  /**
   * Upsert vectors with optional predicate that skips writes for vectors deemed up-to-date.
   * This is used to avoid rewriting unchanged chunk embeddings during incremental updates.
   */
  async upsertVectorsIf(vectors, shouldWrite) {
    if (!this.db || vectors.length === 0) return;
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      let completed = 0;
      const total = vectors.length;
      for (const vector of vectors) {
        const getReq = store.get(vector.id);
        getReq.onsuccess = () => {
          const existing = getReq.result;
          if (shouldWrite(existing, vector)) {
            const putReq = store.put(vector);
            putReq.onsuccess = () => {
              this.cache.set(vector.id, vector);
              if (vector.path) this.pathsSet.add(vector.path);
              completed++;
              if (completed === total) resolve();
            };
            putReq.onerror = () => reject(putReq.error);
          } else {
            completed++;
            if (completed === total) resolve();
          }
        };
        getReq.onerror = () => reject(getReq.error);
      }
      transaction.onerror = () => reject(transaction.error);
      transaction.oncomplete = () => {
        this.vectorsArrayCache = null;
      };
    });
  }
  /**
   * Move a vector to a new id (e.g., when a chunk's index changes but content is identical).
   * If a vector already exists at the destination id, it will be replaced.
   */
  async moveVectorId(oldId, newId, newChunkId) {
    if (!this.db) return;
    if (oldId === newId) return;
    await new Promise((resolve, reject) => {
      const tx = this.db.transaction([STORE_NAME], "readwrite");
      const store = tx.objectStore(STORE_NAME);
      const getOld = store.get(oldId);
      getOld.onsuccess = () => {
        const existing = getOld.result;
        if (!existing) return resolve();
        const updated = {
          ...existing,
          id: newId,
          chunkId: typeof newChunkId === "number" ? newChunkId : existing.chunkId
        };
        const putReq = store.put(updated);
        putReq.onsuccess = () => {
          const delReq = store.delete(oldId);
          delReq.onsuccess = () => {
            this.cache.delete(oldId);
            this.cache.set(newId, updated);
            resolve();
          };
          delReq.onerror = () => reject(delReq.error);
        };
        putReq.onerror = () => reject(putReq.error);
      };
      getOld.onerror = () => reject(getOld.error);
      tx.oncomplete = () => {
        this.vectorsArrayCache = null;
      };
    });
  }
  /**
   * Get a specific vector
   */
  async getVector(pathOrId) {
    if (this.cache.has(pathOrId)) {
      return this.cache.get(pathOrId);
    }
    if (!this.db) return null;
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([STORE_NAME], "readonly");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.get(pathOrId);
      request.onsuccess = () => {
        const vector = request.result;
        if (vector) {
          this.cache.set(pathOrId, vector);
          resolve(vector || null);
        } else {
          try {
            const index = store.index("by_path");
            const req2 = index.getAll(IDBKeyRange.only(pathOrId));
            req2.onsuccess = () => {
              const results = req2.result;
              if (results && results.length > 0) {
                for (const v of results) this.cache.set(v.id, v);
                resolve(results[0]);
              } else {
                resolve(null);
              }
            };
            req2.onerror = () => resolve(null);
          } catch (e) {
            resolve(null);
          }
        }
      };
      request.onerror = () => reject(request.error);
    });
  }
  /**
   * Get vector synchronously from cache
   */
  getVectorSync(id) {
    return this.cache.get(id) || null;
  }
  /**
   * Get all vectors
   */
  async getAllVectors() {
    if (this.cache.size > 0) {
      if (!this.vectorsArrayCache) {
        this.vectorsArrayCache = Array.from(this.cache.values());
      }
      return this.vectorsArrayCache;
    }
    await this.loadEmbeddings();
    if (!this.vectorsArrayCache) {
      this.vectorsArrayCache = Array.from(this.cache.values());
    }
    return this.vectorsArrayCache;
  }
  /**
   * Remove a vector
   */
  async removeVector(pathOrId) {
    if (!this.db) return;
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.delete(pathOrId);
      request.onsuccess = () => {
        this.cache.delete(pathOrId);
        this.vectorsArrayCache = null;
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  /**
   * Clear all embeddings
   */
  async clear() {
    if (!this.db) return;
    return new Promise((resolve, reject) => {
      const transaction = this.db.transaction([STORE_NAME], "readwrite");
      const store = transaction.objectStore(STORE_NAME);
      const request = store.clear();
      request.onsuccess = () => {
        this.cache.clear();
        this.pathsSet.clear();
        this.vectorsArrayCache = null;
        resolve();
      };
      request.onerror = () => reject(request.error);
    });
  }
  /**
   * Reset the database
   */
  async reset() {
    if (this.db) {
      this.db.close();
      this.db = null;
    }
    return new Promise((resolve, reject) => {
      const deleteRequest = indexedDB.deleteDatabase(DB_NAME);
      deleteRequest.onsuccess = () => {
        this.cache.clear();
        this.initialized = false;
        this.vectorsArrayCache = null;
        this.pathsSet.clear();
        resolve();
      };
      deleteRequest.onerror = () => reject(deleteRequest.error);
      deleteRequest.onblocked = () => {
        setTimeout(() => resolve(), 1e3);
      };
    });
  }
  /**
   * Get storage size
   */
  size() {
    return this.cache.size;
  }
  /**
   * Check if path exists
   */
  has(id) {
    return this.cache.has(id);
  }
  /** Check if any vector exists for a given file path */
  hasPath(path) {
    return this.pathsSet.has(path);
  }
  /**
   * Get count of distinct file paths represented in the store (sync)
   */
  distinctPathCount() {
    return this.pathsSet.size;
  }
  /**
   * Get a snapshot of all distinct file paths represented in the store
   */
  getDistinctPaths() {
    return Array.from(this.pathsSet);
  }
  /**
   * Remove all vectors associated with a given file path
   */
  async removeByPath(path) {
    if (!this.db) return;
    await new Promise((resolve, reject) => {
      const tx = this.db.transaction([STORE_NAME], "readwrite");
      const store = tx.objectStore(STORE_NAME);
      try {
        const index = store.index("by_path");
        const req = index.getAllKeys(IDBKeyRange.only(path));
        req.onsuccess = () => {
          const keys = req.result || [];
          if (keys.length === 0) return resolve();
          const delTx = this.db.transaction([STORE_NAME], "readwrite");
          const delStore = delTx.objectStore(STORE_NAME);
          let completed = 0;
          for (const key of keys) {
            const delReq = delStore.delete(key);
            delReq.onsuccess = () => {
              this.cache.delete(key);
              completed++;
              if (completed === keys.length) resolve();
            };
            delReq.onerror = () => reject(delReq.error);
          }
          delTx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.clear();
            for (const v of this.cache.values()) this.pathsSet.add(v.path);
          };
        };
        req.onerror = () => reject(req.error);
      } catch (e) {
        resolve();
      }
    });
  }
  /**
   * Remove only vectors for a path whose contentHash differs from allowed set.
   * Keeps unchanged chunks intact.
   */
  async removeByPathExceptHashes(path, keepChunkHashes) {
    if (!this.db) return;
    await new Promise((resolve, reject) => {
      const tx = this.db.transaction([STORE_NAME], "readwrite");
      const store = tx.objectStore(STORE_NAME);
      try {
        const index = store.index("by_path");
        const req = index.getAll(IDBKeyRange.only(path));
        req.onsuccess = () => {
          const items = req.result || [];
          if (items.length === 0) return resolve();
          const delTx = this.db.transaction([STORE_NAME], "readwrite");
          const delStore = delTx.objectStore(STORE_NAME);
          let completed = 0;
          const toDelete = items.filter((v) => !(v.metadata && keepChunkHashes.has(v.metadata.contentHash)));
          if (toDelete.length === 0) {
            delTx.oncomplete = () => {
              this.vectorsArrayCache = null;
              this.pathsSet.clear();
              for (const v of this.cache.values()) this.pathsSet.add(v.path);
            };
            return resolve();
          }
          for (const v of toDelete) {
            const delReq = delStore.delete(v.id);
            delReq.onsuccess = () => {
              this.cache.delete(v.id);
              completed++;
              if (completed === toDelete.length) resolve();
            };
            delReq.onerror = () => reject(delReq.error);
          }
          delTx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.clear();
            for (const v of this.cache.values()) this.pathsSet.add(v.path);
          };
        };
        req.onerror = () => reject(req.error);
      } catch (e) {
        resolve();
      }
    });
  }
  /**
   * Remove all vectors for a path except those with ids in keepIds.
   * This prevents duplicate chunks when indices shift.
   */
  async removeByPathExceptIds(path, keepIds) {
    if (!this.db) return;
    await new Promise((resolve, reject) => {
      const tx = this.db.transaction([STORE_NAME], "readwrite");
      const store = tx.objectStore(STORE_NAME);
      try {
        const index = store.index("by_path");
        const req = index.getAllKeys(IDBKeyRange.only(path));
        req.onsuccess = () => {
          const keys = req.result || [];
          const toDelete = keys.filter((id) => !keepIds.has(id));
          if (toDelete.length === 0) {
            tx.oncomplete = () => {
              this.vectorsArrayCache = null;
              this.pathsSet.clear();
              for (const v of this.cache.values()) this.pathsSet.add(v.path);
            };
            return resolve();
          }
          let completed = 0;
          for (const id of toDelete) {
            const delReq = store.delete(id);
            delReq.onsuccess = () => {
              this.cache.delete(id);
              completed++;
              if (completed === toDelete.length) resolve();
            };
            delReq.onerror = () => reject(delReq.error);
          }
          tx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.clear();
            for (const v of this.cache.values()) this.pathsSet.add(v.path);
          };
        };
        req.onerror = () => reject(req.error);
      } catch (e) {
        resolve();
      }
    });
  }
  async renameByPath(oldPath, newPath, newTitle) {
    if (!this.db) return;
    if (!oldPath || !newPath || oldPath === newPath) return;
    await new Promise((resolve, reject) => {
      const tx = this.db.transaction([STORE_NAME], "readwrite");
      const store = tx.objectStore(STORE_NAME);
      try {
        const index = store.index("by_path");
        const req = index.getAll(IDBKeyRange.only(oldPath));
        req.onsuccess = () => {
          const items = req.result || [];
          if (items.length === 0) return resolve();
          const writeTx = this.db.transaction([STORE_NAME], "readwrite");
          const writeStore = writeTx.objectStore(STORE_NAME);
          let completed = 0;
          for (const v of items) {
            const chunkId = typeof v.chunkId === "number" ? v.chunkId : parseInt(v.id.split("#")[1] || "0", 10) || 0;
            const newId = `${newPath}#${chunkId}`;
            const updated = {
              ...v,
              id: newId,
              path: newPath,
              chunkId,
              metadata: newTitle ? { ...v.metadata, title: newTitle } : v.metadata
            };
            const delReq = writeStore.delete(v.id);
            delReq.onsuccess = () => {
              const putReq = writeStore.put(updated);
              putReq.onsuccess = () => {
                this.cache.delete(v.id);
                this.cache.set(newId, updated);
                completed++;
                if (completed === items.length) resolve();
              };
              putReq.onerror = () => reject(putReq.error);
            };
            delReq.onerror = () => reject(delReq.error);
          }
          writeTx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.delete(oldPath);
            this.pathsSet.add(newPath);
          };
        };
        req.onerror = () => reject(req.error);
      } catch (e) {
        resolve();
      }
    });
  }
  /**
   * Rename all vectors under a directory prefix without re-embedding.
   */
  async renameByDirectory(oldDir, newDir) {
    if (!this.db) return;
    if (!oldDir || !newDir || oldDir === newDir) return;
    const oldPrefix = oldDir.endsWith("/") ? oldDir : `${oldDir}`;
    const newPrefix = newDir.endsWith("/") ? newDir : `${newDir}`;
    await new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction([STORE_NAME], "readonly");
        const store = tx.objectStore(STORE_NAME);
        const getAll = store.getAll();
        getAll.onsuccess = () => {
          const all = getAll.result || [];
          const toUpdate = all.filter((v) => v.path && v.path.startsWith(oldPrefix));
          if (toUpdate.length === 0) return resolve();
          const writeTx = this.db.transaction([STORE_NAME], "readwrite");
          const writeStore = writeTx.objectStore(STORE_NAME);
          let completed = 0;
          for (const v of toUpdate) {
            const chunkId = typeof v.chunkId === "number" ? v.chunkId : parseInt(v.id.split("#")[1] || "0", 10) || 0;
            const relative = v.path.substring(oldPrefix.length);
            const newPath = `${newPrefix}${relative}`;
            const newId = `${newPath}#${chunkId}`;
            const updated = { ...v, id: newId, path: newPath, chunkId };
            const delReq = writeStore.delete(v.id);
            delReq.onsuccess = () => {
              const putReq = writeStore.put(updated);
              putReq.onsuccess = () => {
                this.cache.delete(v.id);
                this.cache.set(newId, updated);
                completed++;
                if (completed === toUpdate.length) resolve();
              };
              putReq.onerror = () => reject(putReq.error);
            };
            delReq.onerror = () => reject(delReq.error);
          }
          writeTx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.clear();
            for (const vec of this.cache.values()) this.pathsSet.add(vec.path);
          };
        };
        getAll.onerror = () => reject(getAll.error);
      } catch (e) {
        resolve();
      }
    });
  }
  /**
   * Remove all vectors under a directory prefix (e.g., when folder is deleted).
   */
  async removeByDirectory(dir) {
    if (!this.db) return;
    const prefix = dir.endsWith("/") ? dir : `${dir}`;
    await new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction([STORE_NAME], "readonly");
        const store = tx.objectStore(STORE_NAME);
        const getAllKeys = store.getAllKeys();
        getAllKeys.onsuccess = () => {
          const keys = getAllKeys.result || [];
          const toDelete = keys.filter((id) => id.startsWith(prefix));
          if (toDelete.length === 0) return resolve();
          const delTx = this.db.transaction([STORE_NAME], "readwrite");
          const delStore = delTx.objectStore(STORE_NAME);
          let completed = 0;
          for (const key of toDelete) {
            const delReq = delStore.delete(key);
            delReq.onsuccess = () => {
              this.cache.delete(key);
              completed++;
              if (completed === toDelete.length) resolve();
            };
            delReq.onerror = () => reject(delReq.error);
          }
          delTx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.clear();
            for (const vec of this.cache.values()) this.pathsSet.add(vec.path);
          };
        };
        getAllKeys.onerror = () => reject(getAllKeys.error);
      } catch (e) {
        resolve();
      }
    });
  }
  /**
   * Remove all vectors whose namespace starts with a given prefix.
   * Used for forcing a refresh/migration for the current provider+model+schema.
   */
  async removeByNamespacePrefix(prefix) {
    if (!this.db) return;
    await new Promise((resolve, reject) => {
      try {
        const tx = this.db.transaction([STORE_NAME], "readonly");
        const store = tx.objectStore(STORE_NAME);
        const getAll = store.getAll();
        getAll.onsuccess = () => {
          const all = getAll.result || [];
          const toDelete = all.filter((v) => {
            var _a;
            return typeof ((_a = v == null ? void 0 : v.metadata) == null ? void 0 : _a.namespace) === "string" && v.metadata.namespace.startsWith(prefix);
          });
          if (toDelete.length === 0) return resolve();
          const delTx = this.db.transaction([STORE_NAME], "readwrite");
          const delStore = delTx.objectStore(STORE_NAME);
          let completed = 0;
          for (const v of toDelete) {
            const delReq = delStore.delete(v.id);
            delReq.onsuccess = () => {
              this.cache.delete(v.id);
              completed++;
              if (completed === toDelete.length) resolve();
            };
            delReq.onerror = () => reject(delReq.error);
          }
          delTx.oncomplete = () => {
            this.vectorsArrayCache = null;
            this.pathsSet.clear();
            for (const vec of this.cache.values()) this.pathsSet.add(vec.path);
          };
        };
        getAll.onerror = () => reject(getAll.error);
      } catch (e) {
        resolve();
      }
    });
  }
};

// src/services/embeddings/providers/SystemSculptProvider.ts
init_httpClient();
init_api();
init_urlHelpers();

// src/utils/TokenCounter.ts
init_tokenCounting();
var EstimatorTokenCounter = class {
  estimateTokens(text) {
    return estimateTokens(text);
  }
  calculateOptimalBatchSize(texts) {
    return calculateOptimalBatchSize(texts);
  }
  createOptimizedBatches(items) {
    return createOptimizedBatches(items);
  }
  truncateToTokenLimit(text, maxTokens) {
    return truncateToTokenLimit(text, maxTokens);
  }
  getBatchStatistics(texts) {
    return getBatchStatistics(texts);
  }
};
var currentTokenCounter = new EstimatorTokenCounter();
var tokenCounter = {
  estimateTokens(text) {
    return currentTokenCounter.estimateTokens(text);
  },
  calculateOptimalBatchSize(texts) {
    return currentTokenCounter.calculateOptimalBatchSize(texts);
  },
  createOptimizedBatches(items) {
    return currentTokenCounter.createOptimizedBatches(items);
  },
  truncateToTokenLimit(text, maxTokens) {
    return currentTokenCounter.truncateToTokenLimit(text, maxTokens);
  },
  getBatchStatistics(texts) {
    return currentTokenCounter.getBatchStatistics(texts);
  }
};

// src/services/embeddings/providers/SystemSculptProvider.ts
init_errorLogger();
var SystemSculptProvider = class {
  constructor(licenseKey, baseUrl = API_BASE_URL, model) {
    this.licenseKey = licenseKey;
    this.model = model;
    this.id = "systemsculpt";
    this.name = "SystemSculpt";
    this.supportsModels = false;
    this.defaultModel = "text-embedding-004-multilingual";
    this.maxRetries = 3;
    this.retryDelay = 1e3;
    this.requestTimeoutMs = 9e4;
    // Add explicit timeout to avoid silent hangs
    this.lastModelChanged = false;
    this.baseUrl = resolveSystemSculptApiBaseUrl(baseUrl);
    this.model = "text-embedding-004-multilingual";
  }
  async generateEmbeddings(texts, options) {
    if (!this.licenseKey) {
      throw new Error("License key is required for SystemSculpt embeddings");
    }
    if (texts.length === 0) {
      return [];
    }
    const validTexts = texts.filter((text) => text && typeof text === "string" && text.trim().length > 0).map((text) => {
      const truncated = tokenCounter.truncateToTokenLimit(text, 5e3);
      if (truncated !== text) {
      }
      return truncated;
    });
    if (validTexts.length === 0) {
      return [];
    }
    const textStats = validTexts.map((text, idx) => ({
      index: idx,
      length: text.length,
      estimatedTokens: tokenCounter.estimateTokens(text),
      preview: text.substring(0, 100) + (text.length > 100 ? "..." : "")
    }));
    const oversizedTexts = textStats.filter((stat) => stat.estimatedTokens > 8e3);
    if (oversizedTexts.length > 0) {
    }
    const url = `${this.baseUrl}${SYSTEMSCULPT_API_ENDPOINTS.EMBEDDINGS.GENERATE}`;
    const hostStatusFn = typeof isHostTemporarilyDisabled === "function" ? isHostTemporarilyDisabled : () => ({ disabled: false, retryInMs: 0 });
    const hostStatus = hostStatusFn(url);
    if (hostStatus.disabled) {
      throw new Error(`Embeddings host temporarily unavailable. Retry in ${hostStatus.retryInMs}ms`);
    }
    let lastError = null;
    for (let attempt = 1; attempt <= this.maxRetries; attempt++) {
      try {
        const requestHeaders = SYSTEMSCULPT_API_HEADERS.WITH_LICENSE(this.licenseKey);
        const idempotencyKey = this.buildIdempotencyKey(validTexts, this.model || this.defaultModel, (options == null ? void 0 : options.inputType) || "document");
        const requestBody = {
          texts: validTexts,
          model: this.model || this.defaultModel,
          inputType: (options == null ? void 0 : options.inputType) || "document",
          // Provide currentModel to allow server to flag migrations
          currentModel: this.model || this.defaultModel
        };
        const response = await httpRequest({
          url,
          method: "POST",
          headers: { ...requestHeaders, "Idempotency-Key": idempotencyKey },
          body: JSON.stringify(requestBody),
          timeoutMs: this.requestTimeoutMs
        });
        if (!response.status || response.status !== 200) {
          const errorMessage = this.parseErrorResponse(response);
          throw new Error(`API error ${response.status}: ${errorMessage}`);
        }
        const raw = typeof response.text === "string" ? response.text : "";
        let data = void 0;
        try {
          data = raw ? JSON.parse(raw) : void 0;
        } catch (e) {
        }
        if (!data || !data.embeddings && !data.embedding) {
          throw new Error("Invalid response format: missing embeddings array");
        }
        if (typeof data.model === "string" && data.model.length > 0) {
          this.model = data.model;
        }
        this.lastModelChanged = !!data.modelChanged;
        if (Array.isArray(data.embeddings)) return data.embeddings;
        if (Array.isArray(data.embedding)) return [data.embedding];
        return [];
      } catch (error) {
        lastError = this.normalizeError(error);
        const status = typeof (lastError == null ? void 0 : lastError.status) === "number" ? lastError.status : void 0;
        if (status && (status === 502 || status === 503 || status === 504)) {
          try {
            errorLogger.warn("SystemSculpt embeddings API gateway error", {
              source: "SystemSculptProvider",
              method: "generateEmbeddings",
              providerId: this.id,
              metadata: {
                status,
                attempt,
                maxRetries: this.maxRetries,
                texts: validTexts.length,
                baseUrl: this.baseUrl
              }
            });
          } catch (e) {
          }
        }
        const message = String((lastError == null ? void 0 : lastError.message) || "");
        const isCircuit = message.includes("circuit open");
        const refused = message.includes("net::ERR") || message.includes("ECONN") || message.includes("REFUSED");
        if (isCircuit) break;
        if (attempt < this.maxRetries && !isCircuit) {
          if (refused && attempt >= 2) break;
          await this.delay(this.retryDelay * attempt);
        }
      }
    }
    throw lastError || new Error("Failed to generate embeddings after retries");
  }
  buildIdempotencyKey(texts, model, inputType) {
    let hash = 2166136261;
    const add = (s) => {
      for (let i = 0; i < s.length; i++) {
        hash ^= s.charCodeAt(i);
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
      }
    };
    add(model + "|" + inputType + "|");
    for (const t of texts) add(t);
    return (hash >>> 0).toString(36);
  }
  async validateConfiguration() {
    try {
      await this.generateEmbeddings(["test"]);
      return true;
    } catch (error) {
      return false;
    }
  }
  async getModels() {
    return ["text-embedding-004-multilingual"];
  }
  parseErrorResponse(response) {
    const status = typeof (response == null ? void 0 : response.status) === "number" ? response.status : void 0;
    const text = typeof (response == null ? void 0 : response.text) === "string" ? response.text : "";
    const trimmed = text.trim();
    const contentType = this.getHeaderValue(response == null ? void 0 : response.headers, "content-type");
    const lowerTrimmed = trimmed.toLowerCase();
    const isHtml = contentType && contentType.toLowerCase().includes("text/html") || lowerTrimmed.startsWith("<!doctype html") || lowerTrimmed.startsWith("<html") || trimmed.startsWith("<");
    if (status && (status === 502 || status === 503 || status === 504)) {
      if (isHtml) {
        return `SystemSculpt API is temporarily unavailable (HTTP ${status}). The upstream service returned a gateway error page instead of JSON.`;
      }
      return `SystemSculpt API is temporarily unavailable (HTTP ${status}). Retry shortly.`;
    }
    if (isHtml) {
      return "Received HTML instead of JSON. Verify the server URL points to api.systemsculpt.com.";
    }
    const structured = typeof (response == null ? void 0 : response.json) === "object" && (response == null ? void 0 : response.json) !== null ? response.json : void 0;
    if (structured && typeof structured === "object") {
      const errorMessage = structured.error || structured.message;
      if (typeof errorMessage === "string" && errorMessage.trim().length > 0) {
        return errorMessage;
      }
    }
    if (trimmed.length === 0) {
      return status ? `HTTP ${status}` : "Unknown error";
    }
    try {
      const errorData = text ? JSON.parse(text) : void 0;
      if (errorData && typeof errorData === "object") {
        return errorData.error || errorData.message || text;
      }
      return text || "Unknown error";
    } catch (e) {
      return text || "Unknown error";
    }
  }
  getHeaderValue(headers, name) {
    if (!headers || typeof headers !== "object") {
      return void 0;
    }
    const entries = Array.isArray(headers) ? headers : Object.entries(headers);
    const lowerName = name.toLowerCase();
    for (const entry of entries) {
      const [key, value] = entry;
      if (typeof key === "string" && key.toLowerCase() === lowerName) {
        if (Array.isArray(value)) {
          return typeof value[0] === "string" ? value[0] : void 0;
        }
        if (typeof value === "string") {
          return value;
        }
      }
    }
    return void 0;
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  normalizeError(error) {
    if (error instanceof Error) {
      return error;
    }
    const status = typeof (error == null ? void 0 : error.status) === "number" ? error.status : void 0;
    const parsed = this.parseErrorResponse(error);
    const statusText = status ? `SystemSculpt API request failed with status ${status}` : "SystemSculpt API request failed";
    const message = parsed ? `${statusText}: ${parsed}` : statusText;
    const normalized = new Error(message);
    if (status !== void 0) {
      normalized.status = status;
    }
    return normalized;
  }
};

// src/services/embeddings/providers/CustomProvider.ts
init_httpClient();
var CustomProvider = class {
  constructor(config) {
    this.config = config;
    this.id = "custom";
    this.name = "Custom Provider";
    this.supportsModels = true;
    this.maxBatchSize = config.maxBatchSize || 100;
    this.headers = {
      "Content-Type": "application/json",
      ...config.headers
    };
    if (config.apiKey) {
      this.headers["Authorization"] = `Bearer ${config.apiKey}`;
    }
    this.model = config.model;
    const endpoint = (config.endpoint || "").toLowerCase();
    this.isOllamaStyle = endpoint.includes("/api/embeddings");
  }
  async generateEmbeddings(texts, options) {
    var _a, _b, _c;
    if (!this.config.endpoint) {
      throw new Error("Custom endpoint URL is required");
    }
    if (texts.length === 0) {
      return [];
    }
    if (texts.length > this.maxBatchSize) {
      return this.generateEmbeddingsInBatches(texts);
    }
    try {
      if (this.isOllamaStyle) {
        const results = [];
        for (const text of texts) {
          const response = await httpRequest({
            url: this.config.endpoint,
            method: "POST",
            headers: this.headers,
            body: JSON.stringify({
              model: this.config.model,
              prompt: text,
              task_type: (options == null ? void 0 : options.inputType) === "query" ? "retrieval_query" : "retrieval_document"
            })
          });
          if (!response.status || response.status !== 200) {
            const errorMessage = await this.parseErrorResponse(response);
            throw new Error(`Custom API error ${response.status}: ${errorMessage}`);
          }
          const data = (_a = response.json) != null ? _a : JSON.parse(response.text || "{}");
          if (Array.isArray(data == null ? void 0 : data.embedding)) {
            results.push(data.embedding);
          } else if (Array.isArray(data == null ? void 0 : data.data) && Array.isArray((_b = data.data[0]) == null ? void 0 : _b.embedding)) {
            results.push(data.data[0].embedding);
          } else {
            throw new Error("Unsupported response format from Ollama endpoint");
          }
        }
        return results;
      } else {
        const response = await httpRequest({
          url: this.config.endpoint,
          method: "POST",
          headers: this.headers,
          body: JSON.stringify({
            input: texts,
            model: this.config.model,
            encoding_format: "float",
            input_type: (options == null ? void 0 : options.inputType) === "query" ? "query" : "document"
          })
        });
        if (!response.status || response.status !== 200) {
          const errorMessage = await this.parseErrorResponse(response);
          throw new Error(`Custom API error ${response.status}: ${errorMessage}`);
        }
        const data = (_c = response.json) != null ? _c : JSON.parse(response.text || "{}");
        if (data.data && Array.isArray(data.data)) {
          const embeddings = data.data.sort((a, b) => a.index - b.index).map((item) => item.embedding);
          return embeddings;
        }
        if (Array.isArray(data) && data.length > 0 && Array.isArray(data[0])) {
          return data;
        }
        throw new Error("Unsupported response format from custom endpoint");
      }
    } catch (error) {
      throw error;
    }
  }
  async validateConfiguration() {
    try {
      const url = new URL(this.config.endpoint);
      if (!url.protocol.startsWith("http")) {
        throw new Error("Endpoint must use HTTP or HTTPS protocol");
      }
      await this.generateEmbeddings(["test"]);
      return true;
    } catch (error) {
      return false;
    }
  }
  async getModels() {
    const commonModels = [
      "text-embedding-004",
      "text-embedding-004-multilingual",
      "all-MiniLM-L6-v2",
      "all-mpnet-base-v2"
    ];
    if (this.config.model && !commonModels.includes(this.config.model)) {
      return [this.config.model, ...commonModels];
    }
    return commonModels;
  }
  async generateEmbeddingsInBatches(texts) {
    const results = [];
    for (let i = 0; i < texts.length; i += this.maxBatchSize) {
      const batch = texts.slice(i, i + this.maxBatchSize);
      const batchEmbeddings = await this.generateEmbeddings(batch);
      results.push(...batchEmbeddings);
    }
    return results;
  }
  async parseErrorResponse(response) {
    var _a;
    try {
      const errorData = JSON.parse(response.text);
      if ((_a = errorData.error) == null ? void 0 : _a.message) return errorData.error.message;
      if (errorData.message) return errorData.message;
      if (errorData.detail) return errorData.detail;
      return response.text;
    } catch (e) {
      return response.text || "Unknown error";
    }
  }
};

// src/services/embeddings/utils/namespace.ts
init_embeddings();
function buildNamespace(providerId, model, dimension) {
  const safeProvider = String(providerId || "unknown");
  const safeModel = String(model || "unknown");
  const dim = typeof dimension === "number" && dimension > 0 ? dimension : 0;
  return `${safeProvider}:${safeModel}:v${EMBEDDING_SCHEMA_VERSION}:${dim}`;
}
function buildNamespacePrefix(providerId, model) {
  const safeProvider = String(providerId || "unknown");
  const safeModel = String(model || "unknown");
  return `${safeProvider}:${safeModel}:v${EMBEDDING_SCHEMA_VERSION}:`;
}
function namespaceMatchesCurrentVersion(namespace, providerId, model) {
  if (!namespace || typeof namespace !== "string") return false;
  const prefix = buildNamespacePrefix(providerId, model);
  return namespace.startsWith(prefix);
}

// src/services/embeddings/processing/EmbeddingsProcessor.ts
var EmbeddingsProcessor = class {
  constructor(provider, storage, preprocessor, config) {
    this.provider = provider;
    this.storage = storage;
    this.preprocessor = preprocessor;
    this.config = config;
    this.processingQueue = [];
    this.activeRequests = 0;
    this.cancelled = false;
    this.processedCount = 0;
    this.requestTimestamps = [];
  }
  /**
   * Process files with progress tracking
   */
  async processFiles(files, app, onProgress) {
    var _a, _b;
    this.cancelled = false;
    this.processedCount = 0;
    const totalFiles = files.length;
    const filesToProcess = [];
    for (const file of files) {
      try {
        const content = await app.vault.read(file);
        const processed = this.preprocessor.process(content, file);
        if (processed) {
          const chunks = this.preprocessor.chunkContentWithHashes(processed.content);
          if (chunks.length === 0) {
            const dimension = 768;
            const id = `${file.path}#0`;
            const modelId = this.provider.model || "unknown";
            const sentinel = {
              id,
              path: file.path,
              chunkId: 0,
              vector: new Array(dimension).fill(0),
              metadata: {
                title: file.basename,
                excerpt: "",
                mtime: ((_a = file.stat) == null ? void 0 : _a.mtime) || Date.now(),
                contentHash: "empty",
                isEmpty: true,
                provider: this.provider.id,
                model: modelId,
                dimension,
                createdAt: Date.now(),
                namespace: buildNamespace(this.provider.id, modelId, dimension)
              }
            };
            await this.storage.storeVectors([sentinel]);
            this.processedCount++;
          } else {
            const keepHashes = new Set(chunks.map((c) => c.hash));
            await this.storage.removeByPathExceptHashes(file.path, keepHashes);
            chunks.forEach((chunk, idx) => {
              var _a2, _b2, _c, _d;
              const existing = this.storage.getVectorSync(`${file.path}#${idx}`);
              const sameHash = !!existing && ((_a2 = existing.metadata) == null ? void 0 : _a2.contentHash) === chunk.hash;
              const sameProvider = !!existing && ((_b2 = existing.metadata) == null ? void 0 : _b2.provider) === this.provider.id;
              const currentModel = this.provider.model || "unknown";
              const sameModel = !!existing && ((_c = existing.metadata) == null ? void 0 : _c.model) === currentModel;
              const sameSchema = !!existing && namespaceMatchesCurrentVersion((_d = existing.metadata) == null ? void 0 : _d.namespace, this.provider.id, currentModel);
              const isUpToDate = sameHash && sameProvider && sameModel && sameSchema;
              if (!isUpToDate) {
                filesToProcess.push({
                  file,
                  content: chunk.text,
                  hash: chunk.hash,
                  chunkId: idx
                });
              }
            });
          }
        } else {
          const dimension = 768;
          const id = `${file.path}#0`;
          const modelId = this.provider.model || "unknown";
          const emptyVector = {
            id,
            path: file.path,
            chunkId: 0,
            vector: new Array(dimension).fill(0),
            metadata: {
              title: file.basename,
              excerpt: "",
              mtime: ((_b = file.stat) == null ? void 0 : _b.mtime) || Date.now(),
              contentHash: "empty",
              isEmpty: true,
              provider: this.provider.id,
              model: modelId,
              dimension,
              createdAt: Date.now(),
              namespace: buildNamespace(this.provider.id, modelId, dimension)
            }
          };
          await this.storage.storeVectors([emptyVector]);
          this.processedCount++;
        }
      } catch (error) {
      }
    }
    if (filesToProcess.length === 0) {
      return;
    }
    const batches = tokenCounter.createOptimizedBatches(filesToProcess);
    const totalBatches = batches.length;
    const stats = tokenCounter.getBatchStatistics(filesToProcess.map((f) => f.content));
    let completedBatches = 0;
    const batchPromises = [];
    for (let i = 0; i < batches.length; i++) {
      if (this.cancelled) break;
      while (this.activeRequests >= this.config.maxConcurrency) {
        await this.delay(50);
      }
      const batchPromise = this.processBatch(batches[i], i).then(() => {
        completedBatches++;
        if (onProgress) {
          onProgress({
            current: this.processedCount,
            total: totalFiles,
            batchProgress: {
              completed: completedBatches,
              total: totalBatches
            }
          });
        }
      });
      batchPromises.push(batchPromise);
    }
    await Promise.all(batchPromises);
  }
  /**
   * Cancel processing
   */
  cancel() {
    this.cancelled = true;
  }
  /**
   * Set provider dynamically
   */
  setProvider(provider) {
    this.provider = provider;
  }
  /**
   * Cleanup resources
   */
  cleanup() {
    this.cancel();
    this.processingQueue = [];
  }
  // Private methods
  async processBatch(batch, batchIndex) {
    if (this.cancelled) return;
    this.activeRequests++;
    try {
      const texts = batch.map((item) => {
        const truncated = tokenCounter.truncateToTokenLimit(item.content);
        if (truncated !== item.content) {
        }
        return truncated;
      });
      const batchStats = tokenCounter.getBatchStatistics(texts);
      await this.enforceRateLimit();
      const embeddings = await this.provider.generateEmbeddings(texts, { inputType: "document" });
      this.recordCall();
      if (embeddings.length !== texts.length) {
        throw new Error(`Embedding count mismatch: expected ${texts.length}, got ${embeddings.length}`);
      }
      const vectors = batch.map((item, index) => {
        var _a;
        const vector = embeddings[index];
        const dimension = Array.isArray(vector) ? vector.length : 0;
        const id = `${item.file.path}#${item.chunkId}`;
        const excerpt = item.content.substring(0, 240);
        return {
          id,
          path: item.file.path,
          chunkId: item.chunkId,
          vector,
          metadata: {
            title: item.file.basename,
            excerpt,
            mtime: ((_a = item.file.stat) == null ? void 0 : _a.mtime) || Date.now(),
            contentHash: item.hash,
            provider: this.provider.id,
            model: this.provider.model || "unknown",
            dimension,
            createdAt: Date.now(),
            namespace: buildNamespace(this.provider.id, this.provider.model || "unknown", dimension)
          }
        };
      });
      await this.storage.storeVectors(vectors);
      this.processedCount += batch.length;
    } catch (error) {
      throw error;
    } finally {
      this.activeRequests--;
    }
  }
  delay(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
  recordCall() {
    const now = Date.now();
    this.requestTimestamps.push(now);
    const cutoff = now - 6e4;
    this.requestTimestamps = this.requestTimestamps.filter((t) => t >= cutoff);
  }
  async enforceRateLimit() {
    const limit = this.config.rateLimitPerMinute;
    if (!limit || limit <= 0) return;
    const now = Date.now();
    const windowStart = now - 6e4;
    this.requestTimestamps = this.requestTimestamps.filter((t) => t >= windowStart);
    if (this.requestTimestamps.length >= limit) {
      const earliest = this.requestTimestamps[0];
      const waitMs = Math.max(0, 6e4 - (now - earliest));
      if (waitMs > 0) {
        await this.delay(waitMs);
      }
    }
  }
};

// src/services/embeddings/processing/ContentPreprocessor.ts
var ContentPreprocessor = class {
  constructor() {
    this.MIN_CONTENT_LENGTH = 50;
    this.MAX_CONTENT_LENGTH = 1e5;
    this.CHUNK_SIZE = 8e3;
  }
  // Target characters per chunk before embedding
  /**
   * Process file content for embedding
   */
  process(content, file) {
    const cleaned = this.cleanContent(content);
    if (cleaned.length < this.MIN_CONTENT_LENGTH) {
      return null;
    }
    const processed = cleaned.length > this.MAX_CONTENT_LENGTH ? this.smartTruncate(cleaned, this.MAX_CONTENT_LENGTH) : cleaned;
    const hash = this.generateHash(processed);
    return {
      content: processed,
      hash,
      length: processed.length,
      excerpt: processed.substring(0, 240)
    };
  }
  /**
   * Clean content for embedding
   */
  cleanContent(content) {
    return content.replace(/!\[\[.*?\]\]/g, "").replace(/!\[.*?\]\(.*?\)/g, "").replace(/\[\[([^\|\]]+)\|([^\]]+)\]\]/g, "$2").replace(/\[\[([^\]]+)\]\]/g, "$1").replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").replace(/^#+\s*/gm, "").replace(/^-{3,}$/gm, "").replace(/^_{3,}$/gm, "").replace(/^\*{3,}$/gm, "").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/```[^\n]*\n([\s\S]*?)```/g, "$1").replace(/`([^`]+)`/g, "$1").replace(/[\u0000-\u0008\u000B\u000C\u000E-\u001F\u007F-\u009F]/g, "").replace(/[\u200B-\u200D\uFEFF]/g, "").replace(/\n{3,}/g, "\n\n").replace(/\s+/g, " ").normalize("NFC").trim();
  }
  /**
   * Smart truncation that respects sentence boundaries
   */
  smartTruncate(text, maxLength) {
    if (text.length <= maxLength) return text;
    const truncated = text.substring(0, maxLength);
    const lastPeriod = truncated.lastIndexOf(".");
    const lastQuestion = truncated.lastIndexOf("?");
    const lastExclamation = truncated.lastIndexOf("!");
    const lastSentence = Math.max(lastPeriod, lastQuestion, lastExclamation);
    if (lastSentence > maxLength * 0.8) {
      return truncated.substring(0, lastSentence + 1).trim();
    }
    const lastSpace = truncated.lastIndexOf(" ");
    if (lastSpace > maxLength * 0.8) {
      return truncated.substring(0, lastSpace).trim();
    }
    return truncated.trim();
  }
  /**
   * Generate content hash
   */
  generateHash(content) {
    let hash = 2166136261;
    for (let i = 0; i < content.length; i++) {
      hash ^= content.charCodeAt(i);
      hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    }
    return (hash >>> 0).toString(36);
  }
  /**
   * Split content into chunks for large files
   */
  chunkContent(content) {
    if (content.length <= this.CHUNK_SIZE) {
      return [content];
    }
    const chunks = [];
    const sentences = content.match(/[^.!?]+[.!?]+/g) || [content];
    let currentChunk = "";
    for (const sentence of sentences) {
      if (currentChunk.length + sentence.length > this.CHUNK_SIZE && currentChunk.length > 0) {
        chunks.push(currentChunk.trim());
        currentChunk = sentence;
      } else {
        currentChunk += " " + sentence;
      }
    }
    if (currentChunk.trim()) {
      chunks.push(currentChunk.trim());
    }
    return chunks;
  }
  /**
   * Split content into chunks and include stable content hashes per chunk.
   * This enables incremental embedding updates by reusing unchanged chunk vectors.
   */
  chunkContentWithHashes(content) {
    const chunks = this.chunkContent(content);
    return chunks.map((text) => ({ text, hash: this.generateHash(text) }));
  }
};

// src/services/embeddings/search/VectorSearch.ts
var VectorSearch = class {
  constructor() {
    this.defaultMinSimilarity = 0.1;
    this.defaultChunkSize = 250;
    this.defaultYieldMs = 0;
    this.defaultExcerptLength = 200;
    this.minSimilarity = this.defaultMinSimilarity;
    this.excerptLength = this.defaultExcerptLength;
  }
  /**
   * Find similar vectors using cosine similarity
   */
  findSimilar(queryVector, vectors, limit = 20) {
    if (vectors.length === 0) return [];
    const similarities = this.calculateSimilarities(queryVector, vectors);
    const topResults = this.getTopK(similarities, limit);
    return topResults;
  }
  /**
   * Non-blocking version of findSimilar that yields to the UI thread between chunks.
   * This prevents long freezes when searching large vector sets on the main thread.
   */
  async findSimilarAsync(queryVector, vectors, limit = 20, options) {
    var _a;
    if (vectors.length === 0) return [];
    const similarities = [];
    const total = vectors.length;
    const chunkSize = (options == null ? void 0 : options.chunkSize) && options.chunkSize > 0 ? options.chunkSize : this.defaultChunkSize;
    const yieldMs = (_a = options == null ? void 0 : options.yieldMs) != null ? _a : this.defaultYieldMs;
    const queryNorm = this.calculateNorm(queryVector);
    for (let start = 0; start < total; start += chunkSize) {
      const end = Math.min(start + chunkSize, total);
      for (let i = start; i < end; i++) {
        const v = vectors[i];
        if (v.metadata.isEmpty) continue;
        const score = this.cosineSimilarity(queryVector, v.vector, queryNorm);
        if (score > this.minSimilarity) {
          similarities.push({ vector: v, score });
        }
      }
      if (options == null ? void 0 : options.onProgress) options.onProgress(end, total);
      if (end < total) {
        await new Promise((resolve) => setTimeout(resolve, yieldMs));
      }
    }
    const topResults = this.getTopK(similarities, limit);
    return topResults;
  }
  /**
   * Batch search for multiple queries
   */
  batchSearch(queryVectors, vectors, limit = 20) {
    return queryVectors.map((query) => this.findSimilar(query, vectors, limit));
  }
  /**
   * Calculate similarities efficiently
   */
  calculateSimilarities(queryVector, vectors) {
    const results = [];
    const queryNorm = this.calculateNorm(queryVector);
    for (const vector of vectors) {
      if (vector.metadata.isEmpty) {
        continue;
      }
      const score = this.cosineSimilarity(queryVector, vector.vector, queryNorm);
      if (score > this.minSimilarity) {
        results.push({ vector, score });
      }
    }
    return results;
  }
  /**
   * Optimized cosine similarity calculation
   */
  cosineSimilarity(a, b, precomputedNormA) {
    if (!Array.isArray(a) || !Array.isArray(b) || a.length === 0 || b.length === 0) {
      return 0;
    }
    if (a.length !== b.length) {
      return 0;
    }
    let dotProduct = 0;
    let normB = 0;
    for (let i = 0; i < a.length; i++) {
      dotProduct += a[i] * b[i];
      normB += b[i] * b[i];
    }
    const normA = precomputedNormA || this.calculateNorm(a);
    normB = Math.sqrt(normB);
    if (normA === 0 || normB === 0) return 0;
    return dotProduct / (normA * normB);
  }
  /**
   * Calculate vector norm
   */
  calculateNorm(vector) {
    let sum = 0;
    for (const val of vector) {
      sum += val * val;
    }
    return Math.sqrt(sum);
  }
  /**
   * Efficient top-k selection using partial sort
   */
  getTopK(similarities, k) {
    if (similarities.length <= k * 2) {
      return similarities.sort((a, b) => b.score - a.score).slice(0, k).map((item) => this.toSearchResult(item));
    }
    const topK = this.partialSort(similarities, k);
    return topK.map((item) => this.toSearchResult(item));
  }
  /**
   * Partial sort for efficiency with large datasets
   */
  partialSort(items, k) {
    const result = items.slice(0, k).sort((a, b) => b.score - a.score);
    for (let i = k; i < items.length; i++) {
      if (items[i].score > result[k - 1].score) {
        let insertPos = k - 1;
        while (insertPos > 0 && items[i].score > result[insertPos - 1].score) {
          insertPos--;
        }
        result.splice(insertPos, 0, items[i]);
        result.pop();
      }
    }
    return result;
  }
  /**
   * Convert to search result format
   */
  toSearchResult(item) {
    const rawExcerpt = item.vector.metadata.excerpt || "";
    const excerpt = rawExcerpt.substring(0, this.excerptLength);
    const needsEllipsis = rawExcerpt.length > this.excerptLength;
    return {
      path: item.vector.path,
      score: item.score,
      metadata: {
        title: item.vector.metadata.title,
        excerpt: needsEllipsis ? `${excerpt}...` : excerpt,
        lastModified: item.vector.metadata.mtime || Date.now()
      }
    };
  }
};

// src/services/embeddings/EmbeddingsManager.ts
init_SystemSculptEnvironment();
var EmbeddingsManager = class {
  constructor(app, plugin, config) {
    this.app = app;
    this.plugin = plugin;
    this.fileWatchers = [];
    this.isProcessing = false;
    this.processingSuspended = false;
    this.initializationPromise = null;
    this.initialized = false;
    this.perPathTimers = /* @__PURE__ */ new Map();
    this.inFlightPaths = /* @__PURE__ */ new Set();
    this.modelMigrationCooldownUntil = 0;
    this.reindexScheduledFromSearch = false;
    this.queryCache = /* @__PURE__ */ new Map();
    this.QUERY_CACHE_TTL_MS = 60 * 1e3;
    // 60 seconds
    this.QUERY_CACHE_MAX = 64;
    this.config = this.buildConfig(config);
    this.storage = new EmbeddingsStorage();
    this.preprocessor = new ContentPreprocessor();
    this.search = new VectorSearch();
    this.provider = this.createProvider();
    this.processor = new EmbeddingsProcessor(
      this.provider,
      this.storage,
      this.preprocessor,
      {
        batchSize: this.config.batchSize,
        maxConcurrency: this.config.maxConcurrency,
        rateLimitPerMinute: this.plugin.settings.embeddingsRateLimitPerMinute
      }
    );
  }
  /**
   * Initialize the embeddings system
   */
  async initialize() {
    if (this.initializationPromise) return this.initializationPromise;
    this.initializationPromise = (async () => {
      try {
        await this.storage.initialize();
        await this.storage.loadEmbeddings();
        if (this.plugin.settings.embeddingsEnabled && this.config.autoProcess) {
          this.scheduleAutoProcessing();
        }
        this.setupFileWatchers();
        this.initialized = true;
      } catch (error) {
        throw error;
      }
    })();
    return this.initializationPromise;
  }
  /**
   * Process entire vault
   */
  async processVault(onProgress) {
    var _a, _b;
    await this.awaitReady();
    if (this.processingSuspended) {
      return;
    }
    if (this.isProcessing) {
      throw new Error("Processing already in progress");
    }
    this.isProcessing = true;
    try {
      if (this.config.provider.providerId === "custom") {
        const endpoint = (this.config.provider.customEndpoint || "").trim();
        const model = (this.config.provider.customModel || this.config.provider.model || "").trim();
        if (!endpoint || !model) {
          throw new Error("Custom embeddings provider is not configured. Set API Endpoint and Model before processing.");
        }
      }
      const files = this.app.vault.getMarkdownFiles();
      const filesToProcess = files.filter((file) => this.shouldProcessFile(file));
      if (filesToProcess.length === 0) {
        return;
      }
      try {
        (_a = this.plugin.emitter) == null ? void 0 : _a.emit("embeddings:processing-start", {
          scope: "vault",
          total: filesToProcess.length,
          reason: "manual"
        });
      } catch (e) {
      }
      const forwardProgress = (progress) => {
        var _a2;
        try {
          (_a2 = this.plugin.emitter) == null ? void 0 : _a2.emit("embeddings:processing-progress", {
            scope: "vault",
            total: filesToProcess.length,
            processedUnits: progress.current,
            batch: progress.batchProgress
          });
        } catch (e) {
        }
        if (onProgress) onProgress(progress);
      };
      await this.processor.processFiles(filesToProcess, this.app, forwardProgress);
      if (this.provider.lastModelChanged === true) {
        try {
          const now = Date.now();
          if (now >= this.modelMigrationCooldownUntil) {
            this.modelMigrationCooldownUntil = now + 6 * 60 * 60 * 1e3;
            this.provider.lastModelChanged = false;
            this.queryCache.clear();
            setTimeout(async () => {
              try {
                const refreshedFiles = this.app.vault.getMarkdownFiles().filter((f) => this.shouldProcessFile(f));
                if (refreshedFiles.length > 0 && !this.isProcessing && !this.processingSuspended) {
                  await this.processor.processFiles(refreshedFiles, this.app);
                }
              } catch (e) {
              }
            }, 5e3);
          } else {
            this.provider.lastModelChanged = false;
          }
        } catch (e) {
        }
      }
    } finally {
      this.isProcessing = false;
      try {
        (_b = this.plugin.emitter) == null ? void 0 : _b.emit("embeddings:processing-complete", {
          scope: "vault",
          total: void 0
        });
      } catch (e) {
      }
    }
  }
  /**
   * Search for similar content
   */
  async searchSimilar(query, limit = 20) {
    const all = await this.storage.getAllVectors();
    const currentModel = this.provider.model || "unknown";
    const nsPrefix = buildNamespacePrefix(this.provider.id, currentModel);
    const candidates = all.filter((v) => {
      var _a;
      return !v.metadata.isEmpty && typeof ((_a = v.metadata) == null ? void 0 : _a.namespace) === "string" && v.metadata.namespace.startsWith(nsPrefix);
    });
    if (candidates.length === 0) {
      if (this.storage.size() > 0 && this.plugin.settings.embeddingsEnabled) {
        try {
          if (!this.reindexScheduledFromSearch && Date.now() >= this.modelMigrationCooldownUntil) {
            this.reindexScheduledFromSearch = true;
            setTimeout(() => {
              this.processVault().catch(() => {
              }).finally(() => {
                this.reindexScheduledFromSearch = false;
              });
            }, 2e3);
          }
        } catch (e) {
        }
      }
      return [];
    }
    const cacheKey = this.buildQueryCacheKey(query, this.provider.id, currentModel);
    const now = Date.now();
    const cached = this.queryCache.get(cacheKey);
    let queryVec;
    if (cached && cached.expiresAt > now) {
      queryVec = cached.vector;
    } else {
      const queryEmbedding = await this.provider.generateEmbeddings([query], { inputType: "query" });
      queryVec = queryEmbedding[0] || [];
      this.insertQueryCache(cacheKey, queryVec, now + this.QUERY_CACHE_TTL_MS);
    }
    const targetNamespace = buildNamespace(this.provider.id, currentModel, queryVec.length);
    const finalCandidates = candidates.filter((v) => {
      var _a;
      return ((_a = v.metadata) == null ? void 0 : _a.namespace) === targetNamespace;
    });
    return await this.search.findSimilarAsync(queryVec, finalCandidates, limit);
  }
  /**
   * Find similar notes to a specific file
   */
  async findSimilar(filePath, limit = 15) {
    const vector = await this.storage.getVector(`${filePath}#0`);
    if (!vector) {
      return [];
    }
    return this.findSimilarToVector(vector, limit);
  }
  /**
   * Get processing statistics
   */
  getStats() {
    var _a, _b;
    let totalFiles = 0;
    const cached = this.plugin.vaultFileCache ? this.plugin.vaultFileCache.getMarkdownFiles() : this.app.vault.getMarkdownFiles();
    if (Array.isArray(cached)) {
      totalFiles = cached.reduce((acc, f) => acc + (this.isFileExcluded(f) ? 0 : 1), 0);
    }
    const currentModel = this.provider.model || "unknown";
    const nsPrefix = buildNamespacePrefix(this.provider.id, currentModel);
    let processed = 0;
    try {
      const allVectors = this.storage.cache ? Array.from(this.storage.cache.values()) : [];
      const pathsWithMatch = /* @__PURE__ */ new Set();
      for (const v of allVectors) {
        if (!v || !v.path) continue;
        const ns = ((_a = v.metadata) == null ? void 0 : _a.namespace) || "";
        if (typeof ns === "string" && ns.startsWith(nsPrefix)) {
          const f = ((_b = this.plugin.vaultFileCache) == null ? void 0 : _b.getMarkdownFile(v.path)) || this.app.vault.getAbstractFileByPath(v.path);
          if (f && f instanceof import_obsidian119.TFile && !this.isFileExcluded(f)) {
            pathsWithMatch.add(v.path);
          }
        }
      }
      processed = pathsWithMatch.size;
    } catch (e) {
      processed = 0;
    }
    const needsProcessing = Math.max(0, totalFiles - processed);
    return {
      total: totalFiles,
      processed,
      needsProcessing
    };
  }
  /**
   * Check if currently processing
   */
  isCurrentlyProcessing() {
    return this.isProcessing;
  }
  /**
   * Fast check: do we have any embeddings stored at all?
   */
  hasAnyEmbeddings() {
    try {
      return this.storage.distinctPathCount() > 0;
    } catch (e) {
      return false;
    }
  }
  /**
   * Await manager readiness (storage initialized and embeddings loaded)
   */
  async awaitReady() {
    if (this.initialized) return;
    if (this.initializationPromise) {
      await this.initializationPromise;
      return;
    }
    await this.initialize();
  }
  /**
   * Report initialization state
   */
  isReady() {
    return this.initialized;
  }
  /**
   * Temporarily pause all embeddings processing and cancel any in-flight batches.
   * File watchers remain registered but will no-op while suspended.
   */
  suspendProcessing() {
    this.processingSuspended = true;
    try {
      this.processor.cancel();
    } catch (e) {
    }
    this.isProcessing = false;
  }
  /**
   * Resume processing after a prior suspension.
   */
  resumeProcessing() {
    this.processingSuspended = false;
  }
  /**
   * Report current suspension state.
   */
  isSuspended() {
    return this.processingSuspended;
  }
  /**
   * Fast check: does a vector already exist for this path?
   */
  hasVector(path) {
    return this.storage.hasPath(path);
  }
  /**
   * Clear all embeddings
   */
  async clearAll() {
    await this.storage.clear();
  }
  /**
   * Switch provider
   */
  async switchProvider(config, options) {
    this.config.provider = config;
    this.provider = this.createProvider();
    this.processor.setProvider(this.provider);
    this.queryCache.clear();
    if (this.plugin.settings.embeddingsEnabled && this.config.autoProcess) {
      this.scheduleAutoProcessing();
    }
  }
  /**
   * Reset database
   */
  async resetDatabase() {
    await this.storage.reset();
    await this.storage.initialize();
  }
  /**
   * Cleanup resources
   */
  cleanup() {
    this.unregisterWatchers();
    this.processor.cleanup();
  }
  /** Public: Describe the active namespace components */
  getCurrentNamespaceDescriptor() {
    const model = this.provider.model || "unknown";
    try {
      const { EMBEDDING_SCHEMA_VERSION: EMBEDDING_SCHEMA_VERSION2 } = (init_embeddings(), __toCommonJS(embeddings_exports));
      return { provider: this.provider.id, model, schema: EMBEDDING_SCHEMA_VERSION2 };
    } catch (e) {
      return { provider: this.provider.id, model, schema: 1 };
    }
  }
  /** Public: List available namespaces with counts */
  async getNamespaceStats() {
    var _a;
    await this.awaitReady();
    const vectors = await this.storage.getAllVectors();
    const map = /* @__PURE__ */ new Map();
    for (const v of vectors) {
      const ns = String(((_a = v.metadata) == null ? void 0 : _a.namespace) || "");
      if (!ns) continue;
      if (!map.has(ns)) map.set(ns, { vectors: 0, files: /* @__PURE__ */ new Set() });
      const entry = map.get(ns);
      entry.vectors += 1;
      if (v.path) entry.files.add(v.path);
    }
    const results = [];
    for (const [ns, data] of map.entries()) {
      const m = /^([^:]+):([^:]+):v(\d+):(\d+)$/.exec(ns);
      if (!m) continue;
      const provider = m[1];
      const model = m[2];
      const schema = parseInt(m[3], 10) || 0;
      const dimension = parseInt(m[4], 10) || 0;
      results.push({ namespace: ns, provider, model, schema, dimension, vectors: data.vectors, files: data.files.size });
    }
    results.sort((a, b) => a.provider.localeCompare(b.provider) || a.model.localeCompare(b.model) || a.schema - b.schema || a.dimension - b.dimension);
    return results;
  }
  /**
   * Force refresh embeddings for the current provider/model/schema by
   * removing all vectors in the current namespace and reprocessing the vault.
   */
  async forceRefreshCurrentNamespace() {
    await this.awaitReady();
    const currentModel = this.provider.model || "unknown";
    const nsPrefix = buildNamespacePrefix(this.provider.id, currentModel);
    this.suspendProcessing();
    try {
      await this.storage.removeByNamespacePrefix(nsPrefix);
    } finally {
      this.resumeProcessing();
    }
    await this.processVault();
  }
  // Private methods
  buildConfig(partial) {
    const settings = this.plugin.settings;
    return {
      provider: {
        providerId: settings.embeddingsProvider || "systemsculpt",
        customEndpoint: settings.embeddingsCustomEndpoint,
        customApiKey: settings.embeddingsCustomApiKey,
        customModel: settings.embeddingsCustomModel,
        // Force multilingual for SystemSculpt; allow configured model only for custom provider
        model: (settings.embeddingsProvider || "systemsculpt") === "systemsculpt" ? "text-embedding-004-multilingual" : settings.embeddingsCustomModel || settings.embeddingsModel || "text-embedding-004"
      },
      batchSize: settings.embeddingsBatchSize || 20,
      maxConcurrency: 3,
      cacheEnabled: true,
      autoProcess: settings.embeddingsAutoProcess !== false,
      exclusions: settings.embeddingsExclusions || {
        folders: [],
        patterns: [],
        ignoreChatHistory: true,
        respectObsidianExclusions: true
      },
      ...partial
    };
  }
  createProvider() {
    const { provider } = this.config;
    if (provider.providerId === "custom") {
      const endpoint = (provider.customEndpoint || "").trim();
      const model = (provider.customModel || provider.model || "").trim();
      if (!endpoint || !model) {
        throw new Error("Custom embeddings provider is not configured. Please set API Endpoint and Model.");
      }
      return new CustomProvider({
        endpoint,
        apiKey: provider.customApiKey || "",
        model
      });
    }
    if (provider.providerId === "systemsculpt") {
      const baseUrl = SystemSculptEnvironment.resolveBaseUrl(this.plugin.settings);
      return new SystemSculptProvider(
        this.plugin.settings.licenseKey,
        baseUrl,
        "text-embedding-004-multilingual"
      );
    }
    throw new Error(`Unknown embeddings provider: ${provider.providerId}`);
  }
  scheduleAutoProcessing() {
    setTimeout(async () => {
      try {
        await this.awaitReady();
        if (this.processingSuspended) {
          this.scheduleAutoProcessing();
          return;
        }
        try {
          const { API_BASE_URL: API_BASE_URL2, SYSTEMSCULPT_API_ENDPOINTS: SYSTEMSCULPT_API_ENDPOINTS2 } = await Promise.resolve().then(() => (init_api(), api_exports));
          const { isHostTemporarilyDisabled: isHostTemporarilyDisabled2 } = await Promise.resolve().then(() => (init_httpClient(), httpClient_exports));
          const url = `${API_BASE_URL2}${SYSTEMSCULPT_API_ENDPOINTS2.EMBEDDINGS.GENERATE}`;
          const status = isHostTemporarilyDisabled2(url);
          if (status.disabled) {
            this.scheduleAutoProcessing();
            return;
          }
        } catch (e) {
        }
        if (this.config.provider.providerId === "custom") {
          const endpoint = (this.config.provider.customEndpoint || "").trim();
          const model = (this.config.provider.customModel || this.config.provider.model || "").trim();
          if (!endpoint || !model) {
            return;
          }
        }
        const stats = this.getStats();
        if (stats.needsProcessing > 0 && !this.isProcessing) {
          await this.processVault();
        }
      } catch (error) {
      }
    }, 3e3);
  }
  setupFileWatchers() {
    this.unregisterWatchers();
    const refs = [];
    refs.push(this.app.vault.on("modify", (file) => {
      if (file instanceof import_obsidian119.TFile && file.extension === "md") {
        this.processFileIfNeeded(file, "modify");
      }
    }));
    refs.push(this.app.vault.on("create", (file) => {
      if (file instanceof import_obsidian119.TFile && file.extension === "md") {
        this.processFileIfNeeded(file, "create");
      }
    }));
    refs.push(this.app.vault.on("rename", (file, oldPath) => {
      if (file instanceof import_obsidian119.TFile && file.extension === "md") {
        try {
          this.storage.renameByPath(oldPath, file.path, file.basename);
        } catch (e) {
        }
        const oldTimer = this.perPathTimers.get(oldPath);
        if (oldTimer) {
          try {
            clearTimeout(oldTimer);
          } catch (e) {
          }
          this.perPathTimers.delete(oldPath);
        }
        const newTimer = this.perPathTimers.get(file.path);
        if (newTimer) {
          try {
            clearTimeout(newTimer);
          } catch (e) {
          }
          this.perPathTimers.delete(file.path);
        }
      }
    }));
    refs.push(this.app.vault.on("delete", (file) => {
      if (file instanceof import_obsidian119.TFile && file.extension === "md") {
        this.storage.removeByPath(file.path);
      }
    }));
    refs.push(this.app.vault.on("rename", (file, oldPath) => {
      if (!(file instanceof import_obsidian119.TFile)) {
        const newPath = (file == null ? void 0 : file.path) || "";
        if (typeof oldPath === "string" && typeof newPath === "string") {
          try {
            this.storage.renameByDirectory(oldPath.endsWith("/") ? oldPath : oldPath + "/", newPath.endsWith("/") ? newPath : newPath + "/");
          } catch (e) {
          }
        }
      }
    }));
    refs.push(this.app.vault.on("delete", (file) => {
      if (!(file instanceof import_obsidian119.TFile)) {
        const path = (file == null ? void 0 : file.path) || "";
        if (typeof path === "string") {
          try {
            this.storage.removeByDirectory(path.endsWith("/") ? path : path + "/");
          } catch (e) {
          }
        }
      }
    }));
    this.fileWatchers = refs;
  }
  unregisterWatchers() {
    if (this.fileWatchers && this.fileWatchers.length > 0) {
      for (const ref of this.fileWatchers) {
        try {
          this.app.vault.offref(ref);
        } catch (e) {
        }
      }
      this.fileWatchers = [];
    }
  }
  async processFileIfNeeded(file, reason = "manual") {
    var _a;
    if (this.processingSuspended) return;
    if (!this.isProviderReady()) return;
    const path = file.path;
    const delaySetting = (_a = this.plugin.settings.embeddingsQuietPeriodMs) != null ? _a : 1200;
    const delay = reason === "modify" ? delaySetting : 300;
    const existing = this.perPathTimers.get(path);
    if (existing) {
      try {
        clearTimeout(existing);
      } catch (e) {
      }
    }
    const timer = setTimeout(async () => {
      this.perPathTimers.delete(path);
      if (this.processingSuspended) return;
      if (this.inFlightPaths.has(path)) return;
      if (!this.shouldProcessFile(file)) return;
      this.inFlightPaths.add(path);
      try {
        await this.processFile(file, reason);
      } catch (error) {
      } finally {
        this.inFlightPaths.delete(path);
      }
    }, delay);
    this.perPathTimers.set(path, timer);
  }
  isProviderReady() {
    const p = this.config.provider;
    if (p.providerId === "custom") {
      const endpoint = (p.customEndpoint || "").trim();
      const model = (p.customModel || p.model || "").trim();
      return !!endpoint && !!model;
    }
    return !!this.plugin.settings.licenseKey;
  }
  async processFile(file, reason = "manual") {
    var _a, _b, _c, _d, _e;
    try {
      this.isProcessing = true;
      (_a = this.plugin.emitter) == null ? void 0 : _a.emit("embeddings:processing-start", {
        scope: "file",
        path: file.path,
        reason
      });
    } catch (e) {
    }
    const content = await this.app.vault.read(file);
    const processed = this.preprocessor.process(content, file);
    if (!processed) {
      const dimension = 768;
      const id = `${file.path}#0`;
      const emptyVector = {
        id,
        path: file.path,
        chunkId: 0,
        vector: new Array(dimension).fill(0),
        metadata: {
          title: file.basename,
          excerpt: "",
          mtime: ((_b = file.stat) == null ? void 0 : _b.mtime) || Date.now(),
          contentHash: "empty",
          isEmpty: true,
          provider: this.provider.id,
          model: this.provider.model || "unknown",
          dimension,
          createdAt: Date.now(),
          namespace: buildNamespace(this.provider.id, this.provider.model || "unknown", dimension)
        }
      };
      await this.storage.storeVectors([emptyVector]);
      try {
        (_c = this.plugin.emitter) == null ? void 0 : _c.emit("embeddings:processing-complete", {
          scope: "file",
          path: file.path
        });
      } catch (e) {
      }
      this.isProcessing = false;
      return;
    }
    const chunkItems = this.preprocessor.chunkContentWithHashes(processed.content);
    const providerModel = this.provider.model || "unknown";
    const nsPrefix = buildNamespacePrefix(this.provider.id, providerModel);
    const existingVectors = await this.storage.getVectorsByPath(file.path);
    const byHash = /* @__PURE__ */ new Map();
    for (const v of existingVectors) {
      const h = ((_d = v.metadata) == null ? void 0 : _d.contentHash) || "";
      if (!byHash.has(h)) byHash.set(h, []);
      byHash.get(h).push(v);
    }
    const keepIds = /* @__PURE__ */ new Set();
    const keptIndex = /* @__PURE__ */ new Set();
    for (let idx = 0; idx < chunkItems.length; idx++) {
      const { hash } = chunkItems[idx];
      const candidates = byHash.get(hash) || [];
      let chosen = candidates.find((v) => {
        var _a2;
        return typeof ((_a2 = v.metadata) == null ? void 0 : _a2.namespace) === "string" && v.metadata.namespace.startsWith(nsPrefix);
      });
      if (!chosen) continue;
      const targetId = `${file.path}#${idx}`;
      if (chosen.id !== targetId) {
        await this.storage.moveVectorId(chosen.id, targetId, idx);
      }
      keepIds.add(targetId);
      keptIndex.add(idx);
      byHash.set(hash, candidates.filter((v) => v.id !== chosen.id));
    }
    const textsToEmbed = [];
    const chunkIndexMap = [];
    for (let idx = 0; idx < chunkItems.length; idx++) {
      if (keptIndex.has(idx)) continue;
      textsToEmbed.push(chunkItems[idx].text);
      chunkIndexMap.push(idx);
    }
    let vectors = [];
    if (textsToEmbed.length > 0) {
      let embeddings = [];
      try {
        embeddings = await this.provider.generateEmbeddings(textsToEmbed, { inputType: "document" });
      } catch (e) {
        try {
          const message = String((e == null ? void 0 : e.message) || "");
          const transient = message.includes("circuit open") || message.includes("net::ERR") || message.includes("ECONN") || message.includes("REFUSED");
          if (transient) {
            this.suspendProcessing();
            setTimeout(() => this.resumeProcessing(), 5 * 60 * 1e3);
          }
        } catch (e2) {
        }
        throw e;
      }
      vectors = embeddings.map((v, mapIdx) => {
        var _a2;
        const idx = chunkIndexMap[mapIdx];
        const text = chunkItems[idx].text;
        const hash = chunkItems[idx].hash;
        const dimension = Array.isArray(v) ? v.length : 0;
        const id = `${file.path}#${idx}`;
        keepIds.add(id);
        return {
          id,
          path: file.path,
          chunkId: idx,
          vector: v,
          metadata: {
            title: file.basename,
            excerpt: text.substring(0, 240),
            mtime: ((_a2 = file.stat) == null ? void 0 : _a2.mtime) || Date.now(),
            contentHash: hash,
            provider: this.provider.id,
            model: providerModel,
            dimension,
            createdAt: Date.now(),
            namespace: buildNamespace(this.provider.id, providerModel, dimension)
          }
        };
      });
      await this.storage.upsertVectorsIf(vectors, (existing, incoming) => {
        var _a2, _b2, _c2, _d2;
        if (!existing) return true;
        const sameHash = ((_a2 = existing.metadata) == null ? void 0 : _a2.contentHash) === ((_b2 = incoming.metadata) == null ? void 0 : _b2.contentHash);
        const sameNamespace = ((_c2 = existing.metadata) == null ? void 0 : _c2.namespace) === ((_d2 = incoming.metadata) == null ? void 0 : _d2.namespace);
        return !(sameHash && sameNamespace);
      });
    }
    const finalKeepIds = /* @__PURE__ */ new Set();
    for (let idx = 0; idx < chunkItems.length; idx++) finalKeepIds.add(`${file.path}#${idx}`);
    await this.storage.removeByPathExceptIds(file.path, finalKeepIds);
    try {
      (_e = this.plugin.emitter) == null ? void 0 : _e.emit("embeddings:processing-complete", {
        scope: "file",
        path: file.path
      });
    } catch (e) {
    }
    this.isProcessing = false;
  }
  shouldProcessFile(file) {
    var _a, _b;
    if (this.isFileExcluded(file)) return false;
    if (!file.stat || typeof file.stat.mtime !== "number") {
      return true;
    }
    const existing = this.storage.getVectorSync(`${file.path}#0`);
    if (!existing) return true;
    const currentModel = this.provider.model || "unknown";
    const nsOk = namespaceMatchesCurrentVersion((_a = existing.metadata) == null ? void 0 : _a.namespace, this.provider.id, currentModel);
    if (!nsOk) return true;
    if (((_b = existing.metadata) == null ? void 0 : _b.mtime) && existing.metadata.mtime >= file.stat.mtime) return false;
    return true;
  }
  isFileExcluded(file) {
    var _a, _b;
    const { exclusions } = this.config;
    for (const folder of exclusions.folders) {
      if (file.path.startsWith(folder)) return true;
    }
    for (const pattern of exclusions.patterns) {
      if (file.path.includes(pattern)) return true;
    }
    if (exclusions.ignoreChatHistory && file.path.includes("SystemSculpt Chat History")) {
      return true;
    }
    if (exclusions.respectObsidianExclusions !== false) {
      try {
        const userIgnoreFilters = (_b = (_a = this.app.vault) == null ? void 0 : _a.getConfig) == null ? void 0 : _b.call(_a, "userIgnoreFilters");
        if (Array.isArray(userIgnoreFilters) && userIgnoreFilters.length > 0) {
          for (const filter of userIgnoreFilters) {
            if (!filter || typeof filter !== "string") continue;
            if (file.path.includes(filter)) return true;
          }
        }
      } catch (e) {
      }
    }
    return false;
  }
  async findSimilarToVector(vector, limit) {
    const allVectors = await this.storage.getAllVectors();
    const candidates = allVectors.filter((v) => {
      var _a, _b;
      return v.path !== vector.path && !v.metadata.isEmpty && ((_a = v.metadata) == null ? void 0 : _a.namespace) === ((_b = vector.metadata) == null ? void 0 : _b.namespace);
    });
    return await this.search.findSimilarAsync(
      vector.vector,
      candidates,
      limit
    );
  }
  buildQueryCacheKey(query, providerId, model) {
    let hash = 2166136261;
    const add = (s) => {
      for (let i = 0; i < s.length; i++) {
        hash ^= s.charCodeAt(i);
        hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
      }
    };
    add(providerId + "|" + model + "|");
    add(query);
    return (hash >>> 0).toString(36);
  }
  insertQueryCache(key, vector, expiresAt) {
    if (this.queryCache.size >= this.QUERY_CACHE_MAX) {
      let oldestKey = null;
      let oldest = Infinity;
      for (const [k, v] of this.queryCache.entries()) {
        if (v.expiresAt < oldest) {
          oldest = v.expiresAt;
          oldestKey = k;
        }
      }
      if (oldestKey) this.queryCache.delete(oldestKey);
    }
    this.queryCache.set(key, { vector, expiresAt });
  }
  // confirmProviderSwitch removed: switching providers no longer deletes embeddings
};

// src/utils/VaultFileCache.ts
var import_obsidian120 = require("obsidian");
var VaultFileCache = class {
  // 5 seconds after initialization
  constructor(app) {
    this.markdownFiles = null;
    this.allFiles = null;
    this.fileStats = null;
    this.eventRefs = [];
    this.lastCacheUpdate = 0;
    this.isInitialized = false;
    // Cache invalidation settings
    this.MAX_CACHE_AGE = 3e5;
    // 5 minutes max cache age
    this.STATS_CACHE_AGE = 6e4;
    // 1 minute for stats
    // Performance tracking
    this.cacheHits = 0;
    this.cacheMisses = 0;
    // Cleanup tracking
    this.warmCacheTimeout = null;
    // Startup grace period to ignore file events during initial vault scanning
    this.startupTime = 0;
    this.STARTUP_GRACE_PERIOD = 5e3;
    this.app = app;
    this.vault = app.vault;
  }
  /**
   * Initialize the cache system with event listeners
   * Optimized to defer expensive operations until first use
   */
  async initialize() {
    const initStart = performance.now();
    if (this.isInitialized) {
      return;
    }
    this.startupTime = Date.now();
    this.setupEventListeners();
    this.isInitialized = true;
    this.warmCacheTimeout = window.setTimeout(() => {
      this.warmCache().then(() => {
      }).catch((error) => {
      });
    }, 2e3);
  }
  /**
   * Get all markdown files (cached)
   */
  getMarkdownFiles() {
    if (this.isCacheValid() && this.markdownFiles) {
      this.cacheHits++;
      return [...this.markdownFiles];
    }
    this.cacheMisses++;
    this.refreshMarkdownCache();
    return [...this.markdownFiles || []];
  }
  /**
   * Get all files (cached)
   */
  getAllFiles() {
    if (this.isCacheValid() && this.allFiles) {
      this.cacheHits++;
      return [...this.allFiles];
    }
    this.cacheMisses++;
    this.refreshAllFilesCache();
    return [...this.allFiles || []];
  }
  /**
   * Get file count (lightweight, cached)
   */
  getMarkdownFileCount() {
    var _a;
    if (this.isStatsCacheValid() && this.fileStats) {
      this.cacheHits++;
      return this.fileStats.count;
    }
    this.cacheMisses++;
    this.refreshFileStats();
    return ((_a = this.fileStats) == null ? void 0 : _a.count) || 0;
  }
  /**
   * Get total vault size (cached)
   */
  getTotalVaultSize() {
    var _a;
    if (this.isStatsCacheValid() && this.fileStats) {
      this.cacheHits++;
      return this.fileStats.totalSize;
    }
    this.cacheMisses++;
    this.refreshFileStats();
    return ((_a = this.fileStats) == null ? void 0 : _a.totalSize) || 0;
  }
  /**
   * Force refresh of all caches
   */
  invalidateCache() {
    this.markdownFiles = null;
    this.allFiles = null;
    this.fileStats = null;
    this.lastCacheUpdate = 0;
  }
  /**
   * Get cache performance statistics
   */
  getCacheStats() {
    const total = this.cacheHits + this.cacheMisses;
    const hitRatio = total > 0 ? (this.cacheHits / total * 100).toFixed(1) : "0.0";
    return {
      hits: this.cacheHits,
      misses: this.cacheMisses,
      hitRatio: `${hitRatio}%`
    };
  }
  /**
   * Check if a file exists in the markdown cache (fast lookup)
   */
  hasMarkdownFile(path) {
    var _a;
    if (!this.markdownFiles) {
      this.getMarkdownFiles();
    }
    return ((_a = this.markdownFiles) == null ? void 0 : _a.some((file) => file.path === path)) || false;
  }
  /**
   * Get a specific markdown file from cache (fast lookup)
   */
  getMarkdownFile(path) {
    var _a;
    if (!this.markdownFiles) {
      this.getMarkdownFiles();
    }
    return ((_a = this.markdownFiles) == null ? void 0 : _a.find((file) => file.path === path)) || null;
  }
  /**
   * Cleanup resources
   */
  destroy() {
    if (this.warmCacheTimeout) {
      window.clearTimeout(this.warmCacheTimeout);
      this.warmCacheTimeout = null;
    }
    for (const ref of this.eventRefs) {
      this.vault.offref(ref);
    }
    this.eventRefs = [];
    this.invalidateCache();
    this.isInitialized = false;
    const stats = this.getCacheStats();
  }
  // Private methods
  isCacheValid() {
    return this.lastCacheUpdate > 0 && Date.now() - this.lastCacheUpdate < this.MAX_CACHE_AGE;
  }
  isStatsCacheValid() {
    return this.fileStats !== null && Date.now() - this.fileStats.lastUpdate < this.STATS_CACHE_AGE;
  }
  refreshMarkdownCache() {
    const refreshStart = performance.now();
    try {
      this.markdownFiles = this.vault.getMarkdownFiles();
      this.lastCacheUpdate = Date.now();
    } catch (error) {
      this.markdownFiles = [];
    }
  }
  refreshAllFilesCache() {
    try {
      this.allFiles = this.vault.getFiles();
      this.lastCacheUpdate = Date.now();
    } catch (error) {
      this.allFiles = [];
    }
  }
  refreshFileStats() {
    try {
      if (!this.markdownFiles) {
        this.refreshMarkdownCache();
      }
      const files = this.markdownFiles || [];
      const totalSize = files.reduce((sum, file) => {
        var _a;
        return sum + (((_a = file.stat) == null ? void 0 : _a.size) || 0);
      }, 0);
      this.fileStats = {
        count: files.length,
        totalSize,
        lastUpdate: Date.now()
      };
    } catch (error) {
      this.fileStats = { count: 0, totalSize: 0, lastUpdate: Date.now() };
    }
  }
  async warmCache() {
    const warmStart = performance.now();
    try {
      this.refreshMarkdownCache();
      this.refreshFileStats();
    } catch (error) {
    }
  }
  setupEventListeners() {
    this.eventRefs.push(
      this.vault.on("create", (file) => {
        const timeSinceStartup = Date.now() - this.startupTime;
        const isInGracePeriod = timeSinceStartup < this.STARTUP_GRACE_PERIOD;
        if (isInGracePeriod) {
          return;
        }
        if (file instanceof import_obsidian120.TFile && this.isUserContentFile(file)) {
          this.handleFileChange("create");
        }
      })
    );
    this.eventRefs.push(
      this.vault.on("modify", (file) => {
        if (file instanceof import_obsidian120.TFile && this.isUserContentFile(file)) {
          this.fileStats = null;
        }
      })
    );
    this.eventRefs.push(
      this.vault.on("delete", (file) => {
        if (file instanceof import_obsidian120.TFile && this.isUserContentFile(file)) {
          this.handleFileChange("delete");
        }
      })
    );
    this.eventRefs.push(
      this.vault.on("rename", (file) => {
        if (file instanceof import_obsidian120.TFile && this.isUserContentFile(file)) {
          this.handleFileChange("rename");
        }
      })
    );
  }
  /**
   * Check if a file is user content (not system files)
   */
  isUserContentFile(file) {
    const path = file.path;
    if (path.startsWith(".obsidian/")) {
      return false;
    }
    if (path.startsWith(".trash/") || path.startsWith("node_modules/") || path.startsWith(".git/") || path.startsWith("dist/") || path.startsWith("build/")) {
      return false;
    }
    return true;
  }
  handleFileChange(type) {
    this.markdownFiles = null;
    this.allFiles = null;
    this.fileStats = null;
    this.lastCacheUpdate = 0;
  }
};

// src/modals/WelcomeModal.ts
var import_obsidian121 = require("obsidian");

// src/constants/welcome.ts
var WELCOME_CONFIG = {
  // CSS class names
  CLASSES: {
    MODAL: "systemsculpt-welcome-modal",
    HERO: "welcome-hero",
    ICON_WRAPPER: "welcome-icon-wrapper",
    ICON: "welcome-icon",
    TAGLINE: "welcome-tagline",
    FEATURES_GRID: "welcome-features-grid",
    FEATURE_CARD: "welcome-feature-card",
    FEATURE_ICON: "welcome-feature-icon",
    FEATURE_CONTENT: "welcome-feature-content",
    FEATURE_TITLE: "welcome-feature-title",
    FEATURE_DESC: "welcome-feature-desc",
    CTA_SECTION: "welcome-cta-section",
    CTA_TEXT: "welcome-cta-text",
    BUTTONS: "welcome-buttons",
    FOOTER: "welcome-footer",
    SKIP_LINK: "welcome-skip-link"
  },
  // Text content
  TEXT: {
    TITLE: "SystemSculpt AI",
    TAGLINE: "Your AI-powered thinking partner",
    CTA_TEXT: "Ready to enhance your thinking?",
    START_BUTTON: "Get Started",
    SKIP_BUTTON: "Jump In",
    SKIP_LINK: "Don't show this again"
  },
  // Feature definitions
  FEATURES: [
    { icon: "message-circle", title: "Natural Conversations", desc: "Chat naturally with AI" },
    { icon: "sparkles", title: "Smart Context", desc: "Understands your notes" },
    { icon: "zap", title: "Quick Commands", desc: "Powerful shortcuts" },
    { icon: "user", title: "Personalized", desc: "Learns your style" }
  ]
};

// src/modals/WelcomeModal.ts
var WelcomeModal = class extends import_obsidian121.Modal {
  constructor(app, plugin) {
    super(app);
    this.modalClickHandler = null;
    this.skipLinkClickHandler = null;
    this.plugin = plugin;
    this.modalEl.addClass(WELCOME_CONFIG.CLASSES.MODAL);
  }
  onOpen() {
    const { contentEl, titleEl } = this;
    contentEl.empty();
    titleEl.setText(WELCOME_CONFIG.TEXT.TITLE);
    try {
      this.renderContent();
    } catch (error) {
      contentEl.createEl("p", {
        text: "Welcome to SystemSculpt! Something went wrong, but you can still start using the plugin.",
        cls: "systemsculpt-error-message"
      });
    }
    this.scope.register([], "Escape", () => {
      this.close();
      return false;
    });
    this.modalClickHandler = (e) => {
      if (e.target === this.modalEl) {
        e.preventDefault();
        e.stopPropagation();
        this.close();
      }
    };
    this.modalEl.addEventListener("click", this.modalClickHandler);
  }
  renderContent() {
    const { contentEl } = this;
    const heroSection = contentEl.createDiv(WELCOME_CONFIG.CLASSES.HERO);
    const iconWrapper = heroSection.createDiv(WELCOME_CONFIG.CLASSES.ICON_WRAPPER);
    const iconEl = iconWrapper.createDiv(WELCOME_CONFIG.CLASSES.ICON);
    (0, import_obsidian121.setIcon)(iconEl, "brain-circuit");
    heroSection.createEl("p", {
      text: WELCOME_CONFIG.TEXT.TAGLINE,
      cls: WELCOME_CONFIG.CLASSES.TAGLINE
    });
    const featuresGrid = contentEl.createDiv(WELCOME_CONFIG.CLASSES.FEATURES_GRID);
    WELCOME_CONFIG.FEATURES.forEach((feature) => {
      const featureCard = featuresGrid.createDiv(WELCOME_CONFIG.CLASSES.FEATURE_CARD);
      const featureIcon = featureCard.createDiv(WELCOME_CONFIG.CLASSES.FEATURE_ICON);
      (0, import_obsidian121.setIcon)(featureIcon, feature.icon);
      const featureContent = featureCard.createDiv(WELCOME_CONFIG.CLASSES.FEATURE_CONTENT);
      featureContent.createEl("div", {
        text: feature.title,
        cls: WELCOME_CONFIG.CLASSES.FEATURE_TITLE
      });
      featureContent.createEl("div", {
        text: feature.desc,
        cls: WELCOME_CONFIG.CLASSES.FEATURE_DESC
      });
    });
    const ctaSection = contentEl.createDiv(WELCOME_CONFIG.CLASSES.CTA_SECTION);
    ctaSection.createEl("p", {
      text: WELCOME_CONFIG.TEXT.CTA_TEXT,
      cls: WELCOME_CONFIG.CLASSES.CTA_TEXT
    });
    const buttonsWrapper = ctaSection.createDiv(WELCOME_CONFIG.CLASSES.BUTTONS);
    const primaryButton = new import_obsidian121.ButtonComponent(buttonsWrapper);
    primaryButton.setButtonText(WELCOME_CONFIG.TEXT.START_BUTTON).setCta().onClick(() => this.close());
    const secondaryButton = new import_obsidian121.ButtonComponent(buttonsWrapper);
    secondaryButton.setButtonText(WELCOME_CONFIG.TEXT.SKIP_BUTTON).onClick(() => this.close());
    const footer = contentEl.createDiv(WELCOME_CONFIG.CLASSES.FOOTER);
    const skipLink = footer.createEl("a", {
      text: WELCOME_CONFIG.TEXT.SKIP_LINK,
      cls: WELCOME_CONFIG.CLASSES.SKIP_LINK
    });
    this.skipLinkClickHandler = async (e) => {
      e.preventDefault();
      try {
        this.plugin.settings.showWelcomeOnStartup = false;
        await this.plugin.saveSettings();
        this.close();
      } catch (error) {
        this.close();
      }
    };
    skipLink.addEventListener("click", this.skipLinkClickHandler);
  }
  onClose() {
    const { contentEl } = this;
    if (this.modalClickHandler) {
      this.modalEl.removeEventListener("click", this.modalClickHandler);
      this.modalClickHandler = null;
    }
    const skipLink = contentEl.querySelector(`.${WELCOME_CONFIG.CLASSES.SKIP_LINK}`);
    if (skipLink && this.skipLinkClickHandler) {
      skipLink.removeEventListener("click", this.skipLinkClickHandler);
      this.skipLinkClickHandler = null;
    }
    contentEl.empty();
  }
};

// src/services/FreezeMonitor.ts
var FreezeMonitor = class {
  // avoid flooding
  static start(options) {
    if (typeof window === "undefined") return;
    if (this.intervalId) return;
    if (options == null ? void 0 : options.thresholdMs) this.thresholdMs = options.thresholdMs;
    if (options == null ? void 0 : options.maxBreadcrumbs) this.maxBreadcrumbs = options.maxBreadcrumbs;
    if (options == null ? void 0 : options.minReportIntervalMs) this.minReportIntervalMs = options.minReportIntervalMs;
    if ((options == null ? void 0 : options.enabled) === false) this.enabled = false;
    this.lastTick = performance.now();
    this.intervalId = window.setInterval(() => {
      if (!this.enabled) return;
      const now = performance.now();
      const delta = now - this.lastTick;
      this.lastTick = now;
      if (delta > 50 + this.thresholdMs) {
        this.reportLag(delta);
      }
    }, 50);
  }
  static stop() {
    if (this.intervalId) {
      window.clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }
  static mark(label, data) {
    if (!this.enabled) return;
    const entry = { t: performance.now(), label, data };
    this.breadcrumbs.push(entry);
    if (this.breadcrumbs.length > this.maxBreadcrumbs) {
      this.breadcrumbs.shift();
    }
  }
  static reportLag(deltaMs) {
    const now = performance.now();
    if (now - this.lastReportTime < this.minReportIntervalMs) return;
    this.lastReportTime = now;
    const tail = this.breadcrumbs.slice(-15);
    const snapshot = tail.map((b, i) => {
      var _a, _b;
      const prev = i > 0 ? tail[i - 1].t : (_b = (_a = tail[0]) == null ? void 0 : _a.t) != null ? _b : b.t;
      const dt = Math.max(0, b.t - prev).toFixed(1);
      const json = b.data ? ` ${safeJson(b.data)}` : "";
      return `${dt}ms ${b.label}${json}`;
    });
    try {
      const event = new CustomEvent("systemsculpt:freeze-detected", {
        detail: {
          deltaMs: Number(deltaMs.toFixed(1)),
          events: snapshot
        }
      });
      window.dispatchEvent(event);
    } catch (e) {
    }
  }
};
FreezeMonitor.breadcrumbs = [];
FreezeMonitor.maxBreadcrumbs = 100;
// keep last 100 marks
FreezeMonitor.intervalId = null;
FreezeMonitor.lastTick = performance.now();
FreezeMonitor.thresholdMs = 200;
// lag threshold in ms
FreezeMonitor.enabled = true;
FreezeMonitor.lastReportTime = 0;
FreezeMonitor.minReportIntervalMs = 3e3;
function safeJson(obj) {
  try {
    return JSON.stringify(obj);
  } catch (_) {
    return "[unserializable]";
  }
}

// src/utils/PluginLogger.ts
init_errorLogger();
var LOG_FILE_PREFIX = "systemsculpt-plugin";
var PluginLogger = class {
  constructor(plugin) {
    this.plugin = plugin;
    const now = /* @__PURE__ */ new Date();
    this.currentDateKey = this.getDateKey(now);
    this.logFileName = this.buildLogFileName(now);
  }
  info(message, context) {
    void this.log("info", message, context);
  }
  warn(message, context) {
    void this.log("warn", message, context);
  }
  error(message, error, context) {
    void this.log("error", message, context, error);
  }
  debug(message, context) {
    void this.log("debug", message, context);
  }
  async log(level, message, context, error) {
    const now = /* @__PURE__ */ new Date();
    this.rotateIfNeeded(now);
    const entry = {
      timestamp: now.toISOString(),
      level,
      message,
      context
    };
    this.logToConsole(level, message, context, error);
    await this.writeToFile(entry);
  }
  logToConsole(level, message, context, error) {
    var _a;
    const errorObject = error instanceof Error ? error : void 0;
    const loggerContext = {
      source: (_a = context == null ? void 0 : context.source) != null ? _a : "Plugin",
      method: context == null ? void 0 : context.method,
      metadata: context == null ? void 0 : context.metadata
    };
    switch (level) {
      case "error":
        errorLogger.error(message, errorObject, loggerContext);
        break;
      case "warn":
        errorLogger.warn(message, loggerContext);
        break;
      case "info":
        errorLogger.info(message, loggerContext);
        break;
      case "debug":
        errorLogger.debug(message, loggerContext);
        break;
    }
  }
  async writeToFile(entry) {
    if (!this.plugin.storage) {
      return;
    }
    try {
      const payload = JSON.stringify(entry);
      const result = await this.plugin.storage.appendToFile("logs", this.logFileName, payload);
      if (!result.success) {
        console.warn(
          "[SystemSculpt][PluginLogger] Failed to append log entry",
          result.error
        );
      }
    } catch (writeError) {
      console.warn("[SystemSculpt][PluginLogger] Error writing log entry", writeError);
    }
  }
  rotateIfNeeded(now) {
    const dateKey = this.getDateKey(now);
    if (dateKey === this.currentDateKey) {
      return;
    }
    this.currentDateKey = dateKey;
    this.logFileName = this.buildLogFileName(now);
  }
  buildLogFileName(date) {
    return `${LOG_FILE_PREFIX}-${this.getDateKey(date)}.log`;
  }
  getDateKey(date) {
    return date.toISOString().split("T")[0];
  }
};

// src/core/diagnostics/InitializationTracer.ts
var phaseCounter = 0;
var DEFAULT_SLOW_THRESHOLD_MS = 750;
var DEFAULT_TIMEOUT_MS = 15e3;
var InitializationTracer = class {
  constructor(loggerFactory, config) {
    this.activePhases = /* @__PURE__ */ new Map();
    var _a, _b;
    this.getLogger = loggerFactory;
    this.defaultSlowThresholdMs = (_a = config == null ? void 0 : config.defaultSlowThresholdMs) != null ? _a : DEFAULT_SLOW_THRESHOLD_MS;
    this.defaultTimeoutMs = (_b = config == null ? void 0 : config.defaultTimeoutMs) != null ? _b : DEFAULT_TIMEOUT_MS;
  }
  startPhase(name, options) {
    var _a, _b, _c;
    const handle = new InitializationPhaseHandle(
      ++phaseCounter,
      name,
      this.getLogger,
      {
        slowThresholdMs: (_a = options == null ? void 0 : options.slowThresholdMs) != null ? _a : this.defaultSlowThresholdMs,
        timeoutMs: (_b = options == null ? void 0 : options.timeoutMs) != null ? _b : this.defaultTimeoutMs,
        metadata: options == null ? void 0 : options.metadata,
        successLevel: (_c = options == null ? void 0 : options.successLevel) != null ? _c : "info"
      },
      (id) => {
        this.activePhases.delete(id);
      }
    );
    this.activePhases.set(handle.id, handle);
    return handle;
  }
  async trackPromise(name, task, options) {
    const phase = this.startPhase(name, options);
    try {
      const result = await task();
      phase.complete();
      return result;
    } catch (error) {
      phase.fail(error);
      throw error;
    }
  }
  markMilestone(name, metadata) {
    const logger = this.getLogger();
    const context = {
      source: "InitializationTracer",
      metadata: {
        milestone: name,
        ...metadata != null ? metadata : {}
      }
    };
    logger.info("init:milestone", context);
  }
  flushOpenPhases(reason) {
    const logger = this.getLogger();
    for (const phase of this.activePhases.values()) {
      logger.warn("init:open", {
        source: "InitializationTracer",
        metadata: {
          phase: phase.name,
          id: phase.id,
          elapsedMs: phase.getElapsedMs(),
          reason
        }
      });
    }
  }
};
var InitializationPhaseHandle = class {
  constructor(id, name, loggerFactory, options, cleanup) {
    this.startedAt = performance.now();
    this.hasCompleted = false;
    this.timedOut = false;
    this.id = id;
    this.name = name;
    this.getLogger = loggerFactory;
    this.options = options;
    this.cleanup = cleanup;
    this.logStart();
    if (this.options.slowThresholdMs > 0) {
      this.slowTimer = setTimeout(() => {
        if (!this.hasCompleted) {
          this.emit("warn", "init:slow", {
            elapsedMs: this.getElapsedMs(),
            slowMs: this.options.slowThresholdMs
          });
        }
      }, this.options.slowThresholdMs);
    }
    if (this.options.timeoutMs > 0) {
      this.timeoutTimer = setTimeout(() => {
        if (!this.hasCompleted) {
          this.timedOut = true;
          this.emit("error", "init:timeout", {
            elapsedMs: this.getElapsedMs(),
            timeoutMs: this.options.timeoutMs
          });
        }
      }, this.options.timeoutMs);
    }
  }
  complete(additional) {
    if (this.hasCompleted) {
      return;
    }
    this.hasCompleted = true;
    this.clearTimers();
    this.cleanup(this.id);
    const duration = this.getElapsedMs();
    const metadata = this.mergeMetadata({
      durMs: duration,
      ...additional != null ? additional : {}
    });
    if (this.timedOut) {
      this.emit("error", "init:late", metadata);
      return;
    }
    if (this.options.slowThresholdMs > 0 && duration > this.options.slowThresholdMs) {
      this.emit("warn", "init:slow-done", {
        ...metadata,
        slowMs: this.options.slowThresholdMs
      });
      return;
    }
    const level = this.options.successLevel === "debug" ? "debug" : "info";
    this.emit(level, "init:done", metadata);
  }
  fail(error, additional) {
    if (this.hasCompleted) {
      return;
    }
    this.hasCompleted = true;
    this.clearTimers();
    this.cleanup(this.id);
    const metadata = this.mergeMetadata({
      durMs: this.getElapsedMs(),
      ...additional != null ? additional : {}
    });
    this.emit("error", "init:fail", metadata, error);
  }
  getElapsedMs() {
    return performance.now() - this.startedAt;
  }
  logStart() {
    const logger = this.getLogger();
    this.emit("info", "init:start", {
      slowMs: this.options.slowThresholdMs,
      timeoutMs: this.options.timeoutMs
    });
  }
  clearTimers() {
    if (this.slowTimer) {
      clearTimeout(this.slowTimer);
    }
    if (this.timeoutTimer) {
      clearTimeout(this.timeoutTimer);
    }
  }
  mergeMetadata(metadata) {
    var _a;
    return {
      ...(_a = this.options.metadata) != null ? _a : {},
      ...metadata
    };
  }
  buildContext(metadata) {
    return {
      source: "InitializationTracer",
      metadata: {
        phase: this.name,
        id: this.id,
        ...metadata
      }
    };
  }
  emit(level, message, metadata, error) {
    const logger = this.getLogger();
    const context = this.buildContext(metadata);
    switch (level) {
      case "debug":
        logger.debug(message, context);
        break;
      case "warn":
        logger.warn(message, context);
        break;
      case "error":
        logger.error(message, error, context);
        break;
      default:
        logger.info(message, context);
        break;
    }
  }
};

// src/utils/yieldToEventLoop.ts
async function yieldToEventLoop(delayMs = 0) {
  await new Promise((resolve) => {
    setTimeout(resolve, delayMs);
  });
}

// src/main.ts
init_PlatformContext();
ErrorCollectorService.initializeEarlyLogsCapture();
var SystemSculptPlugin = class extends import_obsidian123.Plugin {
  constructor() {
    super(...arguments);
    this.recorderService = null;
    this.fileContextMenuService = null;
    this.isUnloading = false;
    this.isPreloadingDone = false;
    this.failures = [];
    this.statusBarEl = null;
    this.statusIconEl = null;
    this.statusTextEl = null;
    this.progressEl = null;
    this._lastActiveFile = null;
    this.pluginLogger = null;
    this.initializationTracer = null;
    this.hasPromptedForDefaultModel = false;
    this.embeddingsManager = null;
    // Removed complex settings callback system - embeddings are now completely on-demand
    // Simple initialization tracking
    this.embeddingsInitialized = false;
    this.criticalInitializationPromise = null;
    this.deferredInitializationPromise = null;
    this.lastFileCountUpdate = 0;
    this.fileCountCacheInterval = 6e4;
  }
  // Keep the getter for general readonly access
  get settings() {
    return this._internal_settings_systemsculpt_plugin;
  }
  // Lazy service getters to avoid blocking startup
  get aiService() {
    if (!this._aiService) {
      if (!this.customProviderService) {
        this.customProviderService = new CustomProviderService(this, this.app);
      }
      this._aiService = SystemSculptService.getInstance(this);
    }
    return this._aiService;
  }
  get modelService() {
    if (!this._modelService) {
      this._modelService = UnifiedModelService.getInstance(this);
    }
    return this._modelService;
  }
  /**
   * Get or create embeddings manager - simple and reliable
   */
  getOrCreateEmbeddingsManager() {
    if (!this.embeddingsManager) {
      const provider = this.settings.embeddingsProvider || "systemsculpt";
      if (provider === "systemsculpt") {
        if (!this.settings.licenseKey || !this.settings.serverUrl) {
          throw new Error("Embeddings not available. Please check your license key and server URL.");
        }
      } else if (provider === "custom") {
        const endpoint = (this.settings.embeddingsCustomEndpoint || "").trim();
        const model = (this.settings.embeddingsCustomModel || this.settings.embeddingsModel || "").trim();
        if (!endpoint || !model) {
          throw new Error("Custom embeddings provider is not configured. Set API Endpoint and Model in settings.");
        }
      }
      this.embeddingsManager = new EmbeddingsManager(this.app, this);
      if (!this.embeddingsInitialized) {
        this.embeddingsInitialized = true;
        this.embeddingsManager.initialize().catch((error) => {
          const logger = this.getLogger();
          logger.error("Embeddings manager background initialization failed", error, {
            source: "SystemSculptPlugin",
            metadata: {
              provider
            }
          });
        });
      }
    }
    return this.embeddingsManager;
  }
  getPluginLogger() {
    return this.pluginLogger;
  }
  getInitializationTracer() {
    if (!this.initializationTracer) {
      this.initializationTracer = new InitializationTracer(() => this.getLogger());
    }
    return this.initializationTracer;
  }
  async waitForCriticalInitialization() {
    if (!this.criticalInitializationPromise) {
      return;
    }
    await this.criticalInitializationPromise;
  }
  // Update cache every 60 seconds
  async onload() {
    const loadStart = performance.now();
    const tracer = this.getInitializationTracer();
    const onloadPhase = tracer.startPhase("plugin.onload", {
      slowThresholdMs: 1500,
      timeoutMs: 2e4,
      metadata: {
        version: this.manifest.version
      }
    });
    const logger = this.getLogger();
    logger.info("SystemSculpt plugin onload starting", {
      source: "SystemSculptPlugin",
      metadata: {
        version: this.manifest.version
      }
    });
    try {
      this._internal_settings_systemsculpt_plugin = { ...DEFAULT_SETTINGS };
      tracer.markMilestone("defaults-applied", {
        settingsKeys: Object.keys(DEFAULT_SETTINGS).length
      });
      PlatformContext.initialize();
      this.registerEditorExtension(inlineDiffExtension);
      logger.debug("Registered inline diff editor extension", {
        source: "SystemSculptPlugin",
        metadata: {
          extension: "inlineDiff"
        }
      });
      this.ensureSettingsManagerInstance();
      const freezePhase = tracer.startPhase("monitor.freeze.start", {
        slowThresholdMs: 200,
        timeoutMs: 2e3,
        metadata: {
          thresholdMs: 150,
          minReportIntervalMs: 2e3
        }
      });
      FreezeMonitor.start({ thresholdMs: 150, minReportIntervalMs: 2e3 });
      freezePhase.complete();
      const notificationsPhase = tracer.startPhase("ui.notifications.initialize", {
        slowThresholdMs: 400,
        timeoutMs: 3e3
      });
      try {
        initializeNotificationQueue(this.app);
        notificationsPhase.complete();
      } catch (error) {
        notificationsPhase.fail(error);
        this.failures.push("notification queue");
      }
      const errorCollectorPhase = tracer.startPhase("services.errorCollector.initialize", {
        slowThresholdMs: 200,
        timeoutMs: 3e3,
        metadata: {
          bufferSize: 500
        }
      });
      this.errorCollectorService = new ErrorCollectorService(500);
      errorCollectorPhase.complete();
      const versionPhase = tracer.startPhase("services.versionChecker.initialize", {
        slowThresholdMs: 200,
        timeoutMs: 3e3,
        metadata: {
          version: this.manifest.version
        }
      });
      const version = this.manifest.version;
      this.versionCheckerService = VersionCheckerService.getInstance(version, this.app, this);
      versionPhase.complete();
      const storageConstructPhase = tracer.startPhase("storage.manager.construct", {
        slowThresholdMs: 200,
        timeoutMs: 3e3
      });
      this.storage = new StorageManager(this.app, this);
      storageConstructPhase.complete();
      const loggerPhase = tracer.startPhase("logging.pluginLogger.ready", {
        slowThresholdMs: 100,
        timeoutMs: 2e3
      });
      this.pluginLogger = this.getLogger();
      this.pluginLogger.info("Plugin logger ready", {
        source: "SystemSculptPlugin",
        metadata: {
          version: this.manifest.version
        }
      });
      loggerPhase.complete();
      const storageBootstrapPhase = tracer.startPhase("storage.manager.initialize", {
        slowThresholdMs: 750,
        timeoutMs: 8e3
      });
      setTimeout(() => {
        this.storage.initialize().then(() => {
          storageBootstrapPhase.complete();
          tracer.markMilestone("storage-initialized");
        }).catch((error) => {
          this.failures.push("storage");
          storageBootstrapPhase.fail(error);
        });
      }, 0);
      const criticalSchedulePhase = tracer.startPhase("init.critical.schedule", {
        slowThresholdMs: 50,
        timeoutMs: 1e3,
        successLevel: "debug"
      });
      const criticalScheduledAt = performance.now();
      this.criticalInitializationPromise = (async () => {
        try {
          await yieldToEventLoop();
          const now = performance.now();
          criticalSchedulePhase.complete({
            scheduledDelayMs: Number((now - criticalScheduledAt).toFixed(1)),
            sinceLoadMs: Number((now - loadStart).toFixed(1))
          });
          await this.runCriticalInitialization();
        } catch (error) {
          const failureError = error instanceof Error ? error : new Error(String(error != null ? error : "critical initialization failed"));
          this.failures.push("critical initialization");
          tracer.flushOpenPhases("critical-initialization-error");
          logger.error("Critical initialization failed", failureError, {
            source: "SystemSculptPlugin",
            method: "runCriticalInitialization"
          });
          throw failureError;
        }
      })();
      this.criticalInitializationPromise.catch(() => {
      });
      this.deferredInitializationPromise = (async () => {
        const awaitCriticalPhase = tracer.startPhase("init.deferred.awaitCritical", {
          slowThresholdMs: 250,
          timeoutMs: 5e3,
          successLevel: "debug"
        });
        try {
          await this.waitForCriticalInitialization();
          awaitCriticalPhase.complete({
            sinceLoadMs: Number((performance.now() - loadStart).toFixed(1))
          });
        } catch (error) {
          const failureError = error instanceof Error ? error : new Error(String(error != null ? error : "critical initialization failed"));
          awaitCriticalPhase.fail(failureError, {
            skipped: true,
            reason: "critical-initialization-failed"
          });
          throw failureError;
        }
        const deferredSchedulePhase = tracer.startPhase("init.deferred.schedule", {
          slowThresholdMs: 150,
          timeoutMs: 1500,
          successLevel: "debug"
        });
        const deferredScheduledAt = performance.now();
        await yieldToEventLoop();
        const now = performance.now();
        deferredSchedulePhase.complete({
          scheduledDelayMs: Number((now - deferredScheduledAt).toFixed(1)),
          sinceLoadMs: Number((now - loadStart).toFixed(1))
        });
        try {
          await this.runDeferredInitialization();
        } catch (error) {
          const failureError = error instanceof Error ? error : new Error(String(error != null ? error : "deferred initialization failed"));
          this.failures.push("deferred initialization");
          tracer.flushOpenPhases("deferred-initialization-error");
          logger.error("Deferred initialization failed", failureError, {
            source: "SystemSculptPlugin",
            method: "runDeferredInitialization"
          });
          throw failureError;
        }
      })();
      this.deferredInitializationPromise.catch(() => {
      });
      await yieldToEventLoop();
      this.waitForCriticalInitialization().then(() => {
        try {
          logger.debug("Starting file context menu service after critical initialization", {
            source: "SystemSculptPlugin"
          });
          this.setupFileContextMenuService();
          tracer.markMilestone("file-context-menu-ready");
        } catch (error) {
          this.failures.push("file context menu service");
          logger.error("Failed to set up file context menu service after critical initialization", error, {
            source: "SystemSculptPlugin"
          });
        }
      }).catch((error) => {
        const failureError = error instanceof Error ? error : new Error(String(error != null ? error : "critical initialization failed"));
        logger.warn("File context menu service initialization skipped", {
          source: "SystemSculptPlugin",
          metadata: {
            reason: "critical initialization failed",
            error: failureError.message
          }
        });
      });
      this.registerEvent(
        this.app.workspace.on("active-leaf-change", (leaf) => {
          const filePath = leaf && leaf.view instanceof import_obsidian123.MarkdownView && leaf.view.file ? leaf.view.file.path : null;
          FreezeMonitor.mark("workspace:active-leaf-change:start", { hasLeaf: !!leaf });
          if (filePath) {
            this._lastActiveFile = {
              path: filePath,
              content: "",
              timestamp: Date.now()
            };
            FreezeMonitor.mark("workspace:active-leaf-change:markdown", { path: filePath });
          }
          FreezeMonitor.mark("workspace:active-leaf-change:end");
          logger.debug("Active leaf change handled", {
            source: "SystemSculptPlugin",
            metadata: {
              filePath,
              hasLeaf: !!leaf
            }
          });
        })
      );
      await yieldToEventLoop();
      const commandPhase = tracer.startPhase("commands.register", {
        slowThresholdMs: 300,
        timeoutMs: 3e3
      });
      try {
        this.registerCommands();
        commandPhase.complete();
      } catch (error) {
        this.failures.push("command registration");
        commandPhase.fail(error);
      }
      await yieldToEventLoop();
      if (this.versionCheckerService) {
        this.app.workspace.onLayoutReady(() => {
          const scheduleDelayMs = 1e4;
          const schedulePhase = tracer.startPhase("updates.check.schedule", {
            slowThresholdMs: 0,
            timeoutMs: 0,
            successLevel: "debug",
            metadata: {
              intent: "version-check"
            }
          });
          schedulePhase.complete({
            scheduledDelayMs: scheduleDelayMs
          });
          window.setTimeout(() => {
            const executePhase = tracer.startPhase("updates.check.execute", {
              slowThresholdMs: 6e3,
              timeoutMs: 3e4,
              successLevel: "debug"
            });
            const service = this.versionCheckerService;
            if (!service) {
              executePhase.complete({
                skipped: true,
                reason: "service-unavailable"
              });
              return;
            }
            try {
              const result = service.checkForUpdatesOnStartup();
              if (result && typeof result.then === "function") {
                result.then(() => {
                  executePhase.complete();
                }).catch((error) => {
                  executePhase.fail(error);
                });
              } else {
                executePhase.complete({
                  synchronous: true
                });
              }
            } catch (error) {
              executePhase.fail(error);
            }
          }, scheduleDelayMs);
        });
      }
      onloadPhase.complete({
        totalMs: Number((performance.now() - loadStart).toFixed(1)),
        failureCount: this.failures.length
      });
    } catch (error) {
      this.failures.push("core initialization");
      onloadPhase.fail(error, {
        failureCount: this.failures.length
      });
      tracer.flushOpenPhases("plugin.onload-error");
      if (this.errorCollectorService) {
        this.errorCollectorService.captureError("Plugin load", error);
      } else {
        logger.error("Plugin load failed before error collector ready", error, {
          source: "SystemSculptPlugin"
        });
      }
    }
    this.app.workspace.onLayoutReady(() => {
      const layoutPhase = tracer.startPhase("workspace.layoutReady", {
        slowThresholdMs: 300,
        timeoutMs: 5e3,
        metadata: {
          registeredAtMs: Number((performance.now() - loadStart).toFixed(1))
        }
      });
      if (this.settings.showWelcomeOnStartup) {
        setTimeout(() => {
          const welcomeModal = new WelcomeModal(this.app, this);
          welcomeModal.open();
          logger.info("Welcome modal opened after layout", {
            source: "SystemSculptPlugin"
          });
        }, 1e3);
      }
      if (this.settings.embeddingsEnabled && this.settings.embeddingsAutoProcess) {
        setTimeout(() => {
          const embeddingsPhase = tracer.startPhase("embeddings.autostart", {
            slowThresholdMs: 2e3,
            timeoutMs: 2e4
          });
          try {
            this.getOrCreateEmbeddingsManager();
            embeddingsPhase.complete();
          } catch (error) {
            embeddingsPhase.fail(error);
          }
        }, 1e4);
      }
      layoutPhase.complete({
        elapsedSinceLoadMs: Number((performance.now() - loadStart).toFixed(1))
      });
    });
    if (this.failures.length > 0) {
      logger.warn("Initialization reported recoverable issues", {
        source: "SystemSculptPlugin",
        metadata: {
          failures: [...this.failures]
        }
      });
      this.showErrorNotice(
        `SystemSculpt had issues with: ${this.failures.join(", ")}. Some features may be unavailable.`,
        this.collectErrorDetails()
      );
    }
  }
  showUserNotice(message) {
    new import_obsidian123.Notice(message, 8e3);
  }
  /**
   * Show an error notice with copy functionality
   * @param message The error message to display
   * @param details Additional error details to include when copied
   */
  showErrorNotice(message, details) {
    const notice = new import_obsidian123.Notice(
      message + "\n\nClick this notice to copy ALL SystemSculpt logs for reporting.",
      15e3
    );
    if (notice.noticeEl) {
      notice.noticeEl.addEventListener("click", async () => {
        const success = await this.copyAllLogsToClipboard();
        if (success) {
          new import_obsidian123.Notice("All SystemSculpt logs copied! Please share with the developer.", 3e3);
        } else {
          new import_obsidian123.Notice("Failed to copy logs. Try using the 'Copy Logs for Support' button in settings.", 3e3);
        }
      });
      notice.noticeEl.style.cursor = "pointer";
    }
  }
  /**
   * Collect detailed error information for reporting
   */
  collectErrorDetails() {
    var _a;
    const details = [];
    details.push(`SystemSculpt Version: ${this.manifest.version}`);
    details.push(`Obsidian Version: ${this.app.vault.configDir.split("/").pop() || "Unknown"}`);
    details.push(`
Failures: ${this.failures.join(", ")}`);
    details.push(`
Initialization State:`);
    details.push(`- Directory Manager Initialized: ${((_a = this.directoryManager) == null ? void 0 : _a.isInitialized()) || false}`);
    details.push(`- Settings Loaded: ${!!this.settings}`);
    details.push(`- Template Manager: ${!!this.templateManager}`);
    if (this.directoryManager) {
      this.directoryManager.verifyDirectories().then(({ valid, issues }) => {
        if (!valid) {
          details.push(`
Directory Issues:`);
          issues.forEach((issue) => details.push(`- ${issue}`));
        }
      }).catch((e) => {
        details.push(`
Error verifying directories: ${e.message}`);
      });
    }
    details.push(`
Recent Error Logs:`);
    const recentErrors = this.getRecentSystemSculptErrors();
    recentErrors.forEach((error) => details.push(error));
    return details.join("\n");
  }
  /**
   * Get recent SystemSculpt-related console errors
   */
  getRecentSystemSculptErrors() {
    if (this.errorCollectorService) {
      return this.errorCollectorService.getErrorLogs();
    }
    const errors = [];
    const now = /* @__PURE__ */ new Date();
    this.failures.forEach((failure) => {
      errors.push(`[${now.toISOString()}] Error with: ${failure}`);
    });
    return errors;
  }
  /**
   * Get all SystemSculpt-related console logs
   */
  getAllSystemSculptLogs() {
    if (this.errorCollectorService) {
      return this.errorCollectorService.getAllLogs();
    }
    return this.getRecentSystemSculptErrors();
  }
  /**
   * Copy all SystemSculpt logs to clipboard
   * @returns true if copied successfully, false otherwise
   */
  async copyAllLogsToClipboard() {
    try {
      if (this.errorCollectorService) {
        this.errorCollectorService.enableCaptureAllLogs();
      }
      const logs = this.getAllSystemSculptLogs();
      const logsText = logs.join("\n");
      const headerInfo = [
        `SystemSculpt Version: ${this.manifest.version}`,
        `Date: ${(/* @__PURE__ */ new Date()).toISOString()}`,
        `Platform: ${navigator.platform || "Unknown"}`,
        `User Agent: ${navigator.userAgent || "Unknown"}`,
        `Logs Captured: ${logs.length}`,
        `Error Collector Status: ${this.errorCollectorService ? "Active" : "Inactive"}`,
        `
--- LOGS ---
`
      ].join("\n");
      const fullText = headerInfo + logsText;
      await navigator.clipboard.writeText(fullText);
      return true;
    } catch (error) {
      return false;
    }
  }
  async runCriticalInitialization() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("init.critical", {
      slowThresholdMs: 4e3,
      timeoutMs: 25e3
    });
    const logger = this.getLogger();
    try {
      this.emitter = new EventEmitter();
      logger.debug("Event emitter ready for critical initialization", {
        source: "SystemSculptPlugin"
      });
      await this.initializeSettings();
      const parallelTasks = [
        this.initializeDirectories(),
        this.initializeVaultFileCache(),
        this.initializeBasicServices()
      ];
      const results = await Promise.allSettled(parallelTasks);
      tracer.markMilestone("critical-parallel-tasks", {
        statuses: results.map((result) => result.status)
      });
      await this.initializeBasicUI();
      phase.complete();
    } catch (error) {
      phase.fail(error);
      logger.error("Critical initialization aborted", error, {
        source: "SystemSculptPlugin"
      });
      throw error;
    }
  }
  async initializeDirectories() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("directories.initialize", {
      slowThresholdMs: 800,
      timeoutMs: 8e3
    });
    const logger = this.getLogger();
    try {
      this.directoryManager = new DirectoryManager(this.app, this);
      await this.directoryManager.initialize();
      logger.info("Directory manager initialized", {
        source: "SystemSculptPlugin"
      });
      phase.complete();
    } catch (error) {
      this.failures.push("directories");
      phase.fail(error);
      logger.error("Directory manager failed to initialize", error, {
        source: "SystemSculptPlugin"
      });
    }
  }
  async initializeVaultFileCache() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("cache.vaultFile.initialize", {
      slowThresholdMs: 600,
      timeoutMs: 6e3
    });
    const logger = this.getLogger();
    try {
      this.vaultFileCache = new VaultFileCache(this.app);
      await this.vaultFileCache.initialize();
      logger.info("Vault file cache primed", {
        source: "SystemSculptPlugin"
      });
      phase.complete();
    } catch (error) {
      phase.fail(error);
      logger.warn("Vault file cache unavailable", {
        source: "SystemSculptPlugin",
        metadata: {
          error: error instanceof Error ? error.message : String(error)
        }
      });
    }
  }
  async runDeferredInitialization() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("init.deferred", {
      slowThresholdMs: 5e3,
      timeoutMs: 3e4
    });
    const logger = this.getLogger();
    if (this.isUnloading) {
      phase.complete({ skipped: true });
      return;
    }
    try {
      await this.initializeRemainingServices();
      await this.initializeManagers();
      void this.initializeLicense();
      await this.preloadDataInBackground();
      if (this.viewManager) {
        const restorePhase = tracer.startPhase("views.restore", {
          slowThresholdMs: 1200,
          timeoutMs: 6e3,
          successLevel: "debug"
        });
        try {
          await this.viewManager.restoreChatViews();
          restorePhase.complete();
        } catch (error) {
          restorePhase.fail(error);
          logger.warn("Failed to restore chat views", {
            source: "SystemSculptPlugin",
            metadata: {
              error: error instanceof Error ? error.message : String(error)
            }
          });
        }
      }
      phase.complete();
    } catch (error) {
      phase.fail(error);
      logger.error("Deferred initialization aborted", error, {
        source: "SystemSculptPlugin"
      });
      throw error;
    }
  }
  /**
   * Initialize embeddings for user - fully automatic
   */
  async initializeEmbeddingsForUser() {
    try {
      const manager = this.getOrCreateEmbeddingsManager();
    } catch (error) {
      throw error;
    }
  }
  /**
   * Initialize embeddings - simple system doesn't need file monitoring
   */
  async initializeEmbeddingsForFileEvents() {
  }
  /**
   * Set up file watchers for embeddings system
   */
  setupEmbeddingsFileWatchers() {
  }
  /**
   * Auto-start embeddings processing - simplified
   */
  async autoStartEmbeddingsProcessing() {
  }
  ensureSettingsManagerInstance() {
    if (!this.settingsManager) {
      this.settingsManager = new SettingsManager(this);
    }
    return this.settingsManager;
  }
  /**
   * Initialize settings using Obsidian's native data API
   * Implements robust error handling to prevent settings loss
   */
  async initializeSettings() {
    var _a, _b, _c, _d;
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("settings.load", {
      slowThresholdMs: 600,
      timeoutMs: 8e3
    });
    const logger = this.getLogger();
    try {
      const settingsManager = this.ensureSettingsManagerInstance();
      await settingsManager.loadSettings();
      this._internal_settings_systemsculpt_plugin = settingsManager.getSettings();
      try {
        const { StandardModelSelectionModal: StandardModelSelectionModal2 } = await Promise.resolve().then(() => (init_StandardModelSelectionModal(), StandardModelSelectionModal_exports));
        StandardModelSelectionModal2.cleanupProviderPreferences(this);
      } catch (cleanupError) {
        logger.debug("No standard model preference cleanup needed", {
          source: "SystemSculptPlugin",
          metadata: {
            message: cleanupError instanceof Error ? cleanupError.message : String(cleanupError)
          }
        });
      }
      const debugMode = (_a = this.settings.debugMode) != null ? _a : false;
      const logLevel = debugMode ? 3 /* DEBUG */ : (_b = this.settings.logLevel) != null ? _b : 1 /* WARNING */;
      setLogLevel(logLevel);
      errorLogger.setDebugMode(debugMode);
      logger.info("Settings initialized", {
        source: "SystemSculptPlugin",
        metadata: {
          logLevel,
          debugMode
        }
      });
      phase.complete({
        logLevel,
        debugMode
      });
    } catch (error) {
      const fallbackManager = this.ensureSettingsManagerInstance();
      if (!this._internal_settings_systemsculpt_plugin) {
        this._internal_settings_systemsculpt_plugin = fallbackManager.getSettings();
      }
      const fallbackSettings = this._internal_settings_systemsculpt_plugin;
      const debugMode = (_c = fallbackSettings == null ? void 0 : fallbackSettings.debugMode) != null ? _c : false;
      const logLevel = debugMode ? 3 /* DEBUG */ : (_d = fallbackSettings == null ? void 0 : fallbackSettings.logLevel) != null ? _d : 1 /* WARNING */;
      setLogLevel(logLevel);
      errorLogger.setDebugMode(debugMode);
      this.failures.push("settings");
      phase.fail(error, {
        fallback: true
      });
      logger.error("Failed to load settings, using defaults", error, {
        source: "SystemSculptPlugin",
        metadata: {
          logLevel,
          debugMode
        }
      });
    }
  }
  async initializeBasicServices() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("services.basic.initialize", {
      slowThresholdMs: 800,
      timeoutMs: 8e3
    });
    const logger = this.getLogger();
    try {
      this.customProviderService = new CustomProviderService(this, this.app);
      this._aiService = SystemSculptService.getInstance(this);
      this.favoritesService = FavoritesService.getInstance(this);
      this._modelService = UnifiedModelService.getInstance(this);
      const metadata = {
        services: [
          "CustomProviderService",
          "SystemSculptService",
          "FavoritesService",
          "UnifiedModelService"
        ]
      };
      logger.info("Core AI services initialized", {
        source: "SystemSculptPlugin",
        metadata
      });
      phase.complete(metadata);
    } catch (error) {
      this.failures.push("basic services");
      phase.fail(error, {
        services: [
          "CustomProviderService",
          "SystemSculptService",
          "FavoritesService",
          "UnifiedModelService"
        ]
      });
      logger.error("Failed to initialize core AI services", error, {
        source: "SystemSculptPlugin"
      });
    }
  }
  async initializeBasicUI() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("ui.basic.initialize", {
      slowThresholdMs: 1e3,
      timeoutMs: 9e3
    });
    const logger = this.getLogger();
    try {
      this.settingsTab = new SystemSculptSettingTab(this.app, this);
      this.addSettingTab(this.settingsTab);
      if (!this.directoryManager) {
        await this.initializeDirectories();
      } else if (!this.directoryManager.isInitialized()) {
        await this.directoryManager.initialize();
      }
      this.templateManager = new TemplateManager(this, this.app);
      logger.info("Primary UI components ready", {
        source: "SystemSculptPlugin"
      });
      phase.complete();
    } catch (error) {
      this.failures.push("UI components");
      phase.fail(error);
      logger.error("Failed to prepare primary UI", error, {
        source: "SystemSculptPlugin"
      });
    }
  }
  // DIRECTORY MANAGEMENT METHODS
  /**
   * Create a directory using the DirectoryManager
   * This is provided for backward compatibility with components
   * that haven't been updated to use the DirectoryManager directly
   */
  async createDirectory(dirPath) {
    if (!this.directoryManager) {
      this.directoryManager = new DirectoryManager(this.app, this);
      await this.directoryManager.initialize();
    }
    await this.directoryManager.ensureDirectoryByPath(dirPath);
  }
  /**
   * For backward compatibility with existing components
   * Delegates to the createDirectory method
   */
  async createDirectoryOnce(dirPath) {
    await this.createDirectory(dirPath);
  }
  /**
   * Repair the directory structure
   * For user-initiated repairs from settings or command palette
   */
  async repairDirectoryStructure() {
    if (!this.directoryManager) {
      this.directoryManager = new DirectoryManager(this.app, this);
    }
    const result = await this.directoryManager.repair();
    if (result) {
      this.showUserNotice("Directory structure has been repaired successfully.");
    } else {
      this.showUserNotice("Failed to repair directory structure. Check console for details.");
    }
    return result;
  }
  /**
   * Check the health of the directory structure
   * For diagnostics from settings
   */
  async checkDirectoryHealth() {
    if (!this.directoryManager) {
      this.directoryManager = new DirectoryManager(this.app, this);
    }
    return await this.directoryManager.verifyDirectories();
  }
  async initializeRemainingServices() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("services.remaining.initialize", {
      slowThresholdMs: 1500,
      timeoutMs: 12e3
    });
    const logger = this.getLogger();
    const failures = [];
    try {
      if (this.criticalInitializationPromise) {
        logger.debug("Awaiting critical initialization before remaining services", {
          source: "SystemSculptPlugin"
        });
      }
      await this.waitForCriticalInitialization();
    } catch (error) {
      const failureError = error instanceof Error ? error : new Error(String(error != null ? error : "critical initialization failed"));
      phase.fail(failureError, {
        skipped: true,
        reason: "critical-initialization-failed"
      });
      logger.warn("Remaining services skipped because critical initialization failed", {
        source: "SystemSculptPlugin",
        metadata: {
          error: failureError.message
        }
      });
      throw failureError;
    }
    const wrap = (key, displayName, action) => {
      const subPhase = tracer.startPhase(`services.${key}`, {
        slowThresholdMs: 600,
        timeoutMs: 5e3,
        successLevel: "debug"
      });
      try {
        const result = action();
        if (result instanceof Promise) {
          return result.then(() => {
            subPhase.complete({ service: displayName });
          }).catch((error) => {
            subPhase.fail(error, { service: displayName });
            failures.push(displayName);
            logger.error(`Failed to initialize ${displayName}`, error, {
              source: "SystemSculptPlugin"
            });
          });
        }
        subPhase.complete({ service: displayName });
        return Promise.resolve();
      } catch (error) {
        subPhase.fail(error, { service: displayName });
        failures.push(displayName);
        logger.error(`Failed to initialize ${displayName}`, error, {
          source: "SystemSculptPlugin"
        });
        return Promise.resolve();
      }
    };
    await Promise.all([
      wrap("transcription", "transcription service", () => {
        this.transcriptionService = TranscriptionService.getInstance(this);
      }),
      wrap("recorder", "recorder service", () => {
        this.ensureRecorderService();
      }),
      wrap("fileContextMenu", "file context menu service", () => {
        this.setupFileContextMenuService();
      })
    ]);
    if (failures.length > 0) {
      this.failures.push(...failures);
    }
    phase.complete({
      failures: failures.length
    });
  }
  setupFileContextMenuService(forceRestart = false) {
    var _a;
    if (this.fileContextMenuService && !forceRestart) {
      this.fileContextMenuService.start();
      return;
    }
    this.fileContextMenuService = new FileContextMenuService({
      app: this.app,
      plugin: this,
      pluginLogger: this.pluginLogger
    });
    (_a = this.pluginLogger) == null ? void 0 : _a.info("File context menu integration ready", {
      source: "SystemSculptPlugin"
    });
  }
  async initializeManagers() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("managers.initialize", {
      slowThresholdMs: 1500,
      timeoutMs: 12e3
    });
    const logger = this.getLogger();
    try {
      this.licenseManager = new LicenseManager(this, this.app);
      this.resumeChatService = new ResumeChatService(this);
      this.viewManager = new ViewManager(this, this.app);
      this.viewManager.initialize();
      this.commandManager = new CommandManager(this, this.app);
      this.commandManager.registerCommands();
      const metadata = {
        managers: [
          "LicenseManager",
          "ResumeChatService",
          "ViewManager",
          "CommandManager"
        ]
      };
      logger.info("Managers initialized", {
        source: "SystemSculptPlugin",
        metadata
      });
      phase.complete(metadata);
    } catch (error) {
      this.failures.push("managers");
      phase.fail(error);
      logger.error("Manager initialization failed", error, {
        source: "SystemSculptPlugin"
      });
    }
  }
  async initializeLicense() {
    if (!this.licenseManager) {
      return;
    }
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("license.initialize", {
      slowThresholdMs: 1200,
      timeoutMs: 12e3
    });
    const logger = this.getLogger();
    try {
      await this.licenseManager.initializeLicense();
      phase.complete();
      logger.info("License validation completed", {
        source: "SystemSculptPlugin"
      });
    } catch (error) {
      this.failures.push("license validation");
      phase.fail(error);
      logger.warn("License validation failed", {
        source: "SystemSculptPlugin",
        metadata: {
          error: error instanceof Error ? error.message : String(error)
        }
      });
    }
  }
  async onunload() {
    this.isUnloading = true;
    const tracer = this.getInitializationTracer();
    tracer.flushOpenPhases("plugin-unload");
    const phase = tracer.startPhase("plugin.onunload", {
      slowThresholdMs: 1e3,
      timeoutMs: 1e4
    });
    const logger = this.getLogger();
    try {
      if (this.versionCheckerService) {
        VersionCheckerService.clearInstance();
      }
      if (this.errorCollectorService) {
        this.errorCollectorService.unload();
      }
      if (this.settingsManager) {
        this.settingsManager.destroy();
      }
      if (this.embeddingsManager) {
        this.embeddingsManager.cleanup();
        this.embeddingsManager = null;
      }
      if (this.settingsTab) {
      }
      if (this.commandManager) {
        const commands = [
          "toggle-audio-recorder",
          "open-systemsculpt-chat",
          "open-chat-history",
          "open-systemsculpt-janitor",
          "reload-obsidian",
          "open-systemsculpt-settings",
          "change-chat-model",
          "chat-with-file",
          "suggest-edits",
          "clear-suggested-edits"
        ];
        commands.forEach((id) => {
          this.app.commands.removeCommand(`${this.manifest.id}:${id}`);
        });
      }
      if (this.viewManager) {
        this.viewManager.unloadViews();
      }
      if (this.templateManager) {
        this.templateManager.unload();
      }
      if (this.fileContextMenuService) {
        this.fileContextMenuService.stop();
        this.fileContextMenuService = null;
      }
      if (this.recorderService) {
        this.recorderService.unload();
        this.recorderService = null;
      }
      if (this.transcriptionService) {
        this.transcriptionService.unload();
      }
      if (this.resumeChatService) {
        this.resumeChatService.cleanup();
      }
      if (this.embeddingsManager) {
        this.embeddingsManager = null;
      }
      if (this.vaultFileCache) {
        this.vaultFileCache.destroy();
      }
      UnifiedModelService.clearInstance();
      FavoritesService.clearInstance();
      SystemSculptService.clearInstance();
      CustomProviderService.clearStaticCaches();
      this._modelService = void 0;
      this._aiService = void 0;
      this.customProviderService = void 0;
      try {
        PreviewService.hideAllPreviews();
        PreviewService.cleanup();
      } catch (error) {
      }
      try {
        if (this.statusBarEl) {
          this.statusBarEl.remove();
          this.statusBarEl = null;
          this.statusIconEl = null;
          this.statusTextEl = null;
          this.progressEl = null;
        }
      } catch (error) {
      }
      this.pluginLogger = null;
      phase.complete();
      logger.info("SystemSculpt plugin unloaded", {
        source: "SystemSculptPlugin"
      });
    } catch (error) {
      phase.fail(error);
      logger.error("Plugin unload encountered errors", error, {
        source: "SystemSculptPlugin"
      });
    }
  }
  get isReady() {
    return this.isPreloadingDone;
  }
  async loadData() {
    return super.loadData();
  }
  async saveData(data) {
    return super.saveData(data);
  }
  async saveSettings() {
    await this.settingsManager.saveSettings();
  }
  getLogger() {
    if (!this.pluginLogger) {
      this.pluginLogger = new PluginLogger(this);
    }
    return this.pluginLogger;
  }
  hasRecorderService() {
    return this.recorderService !== null;
  }
  ensureRecorderService() {
    if (!this.recorderService) {
      const logger = this.getLogger();
      try {
        const instance = RecorderService.getInstance(this.app, this);
        if (!instance) {
          throw new Error("RecorderService instance unavailable");
        }
        this.recorderService = instance;
        logger.debug("RecorderService instantiated", {
          source: "RecorderService",
          metadata: { initializedDuringEnsure: true }
        });
      } catch (error) {
        logger.error("RecorderService initialization failed", error, {
          source: "RecorderService",
          method: "ensureRecorderService"
        });
        throw error;
      }
    }
    return this.recorderService;
  }
  getRecorderService() {
    return this.ensureRecorderService();
  }
  getTranscriptionService() {
    return this.transcriptionService;
  }
  getLicenseManager() {
    return this.licenseManager;
  }
  getSettingsManager() {
    return this.settingsManager;
  }
  /**
   * Get fresh models from the model service
   */
  getInitialModels() {
    return this.modelService.getModels();
  }
  async preloadDataInBackground() {
    const tracer = this.getInitializationTracer();
    const phase = tracer.startPhase("preload.background", {
      slowThresholdMs: 400,
      timeoutMs: 4e3,
      successLevel: "debug"
    });
    const logger = this.getLogger();
    if (this.isUnloading) {
      phase.complete({ skipped: true });
      return;
    }
    this.isPreloadingDone = true;
    logger.debug("Background preload completed", {
      source: "SystemSculptPlugin"
    });
    phase.complete();
  }
  // Add getter for version checker service
  getVersionCheckerService() {
    return this.versionCheckerService;
  }
  async updateLastSaveAsNoteFolder(folder) {
    await this.settingsManager.updateSettings({ lastSaveAsNoteFolder: folder });
  }
  // Embeddings methods removed
  // --- Status bar methods removed ---
  // Embedding status polling methods removed
  /**
   * Public getter for the ViewManager instance.
   */
  getViewManager() {
    if (!this.viewManager) {
    }
    return this.viewManager;
  }
  // --- Command Registration ---
  registerCommands() {
    this.addCommand({
      id: "audio-chunking-analysis",
      name: "Run Audio Chunking Analysis",
      callback: () => {
        Promise.resolve().then(() => (init_RunAudioAnalysis(), RunAudioAnalysis_exports)).then((module2) => {
          module2.runAudioAnalysis(this);
        }).catch((error) => {
          new import_obsidian123.Notice(`Error running analysis: ${error instanceof Error ? error.message : String(error)}`);
        });
      }
    });
    this.addCommand({
      id: "find-similar-current-note",
      name: "Find Similar Notes (Current Note)",
      editorCallback: async (editor, view) => {
        if (!view.file) {
          new import_obsidian123.Notice("No active file selected.");
          return;
        }
        const currentFilePath = view.file.path;
        const fileContent = editor.getValue();
        if (!fileContent.trim()) {
          new import_obsidian123.Notice("Current note is empty.");
          return;
        }
        try {
          if (!this.settings.embeddingsEnabled) {
            new import_obsidian123.Notice("Enable embeddings in Settings > SystemSculpt AI > Embeddings to find similar notes.");
            return;
          }
          await this.viewManager.activateEmbeddingsView();
        } catch (error) {
          new import_obsidian123.Notice(`Error finding similar notes: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "process-embeddings",
      name: "Process Embeddings",
      callback: async () => {
        try {
          if (!this.settings.embeddingsEnabled) {
            new import_obsidian123.Notice("Embeddings are disabled. Enable them in Settings > SystemSculpt AI > Embeddings.");
            return;
          }
          new import_obsidian123.Notice("Embeddings processing is automatic. Files are processed in the background as needed.");
        } catch (error) {
          new import_obsidian123.Notice(`Failed to process embeddings: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "rebuild-embeddings",
      name: "Rebuild Embeddings",
      callback: async () => {
        try {
          if (!this.settings.embeddingsEnabled) {
            new import_obsidian123.Notice("Embeddings are disabled. Enable them in Settings > SystemSculpt AI > Embeddings.");
            return;
          }
          const manager = this.getOrCreateEmbeddingsManager();
          new import_obsidian123.Notice("Clearing embeddings data...");
          await manager.clearAll();
          new import_obsidian123.Notice("Embeddings cleared. Files will be automatically re-processed in the background.");
        } catch (error) {
          new import_obsidian123.Notice(`Failed to rebuild embeddings: ${error.message}`);
        }
      }
    });
    this.addCommand({
      id: "toggle-mobile-emulation",
      name: "Toggle Mobile Emulation Mode",
      callback: () => {
        const appAny = this.app;
        if (typeof appAny.emulateMobile !== "function") {
          new import_obsidian123.Notice("Mobile emulation is not available in this Obsidian build.", 4e3);
          return;
        }
        const nextState = !appAny.isMobile;
        try {
          appAny.emulateMobile(nextState);
          PlatformContext.get().getDetection().resetCache();
          const status = nextState ? "enabled" : "disabled";
          new import_obsidian123.Notice(`Mobile emulation ${status}.`, 2500);
        } catch (error) {
          new import_obsidian123.Notice(`Failed to toggle mobile emulation: ${error instanceof Error ? error.message : String(error)}`);
        }
      }
    });
  }
  // Removed complex settings callback system - no longer needed for simplified embeddings
};

/* nosourcemap */