/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AnkiIntegration
});
module.exports = __toCommonJS(main_exports);
var import_obsidian8 = require("obsidian");

// src/AnkiIntegrationSettingTab.ts
var import_obsidian2 = require("obsidian");

// src/AnkiConnect.ts
var import_obsidian = require("obsidian");
var ANKI_PORT = 8765;
function Invoke(action, params = {}) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.addEventListener("error", () => reject("failed to issue request"));
    xhr.addEventListener("load", () => {
      try {
        const response = JSON.parse(xhr.responseText);
        if (Object.getOwnPropertyNames(response).length != 2) {
          throw "response has an unexpected number of fields";
        }
        if (!response.hasOwnProperty("error")) {
          throw "response is missing required error field";
        }
        if (!response.hasOwnProperty("result")) {
          throw "response is missing required result field";
        }
        if (response.error) {
          throw response.error;
        }
        resolve(response.result);
      } catch (e) {
        reject(e);
      }
    });
    xhr.open("POST", "http://127.0.0.1:" + ANKI_PORT.toString());
    xhr.send(JSON.stringify({ action, version: 6, params }));
  });
}
async function RequestPermission() {
  try {
    const result = await Invoke("requestPermission", {});
    if (!result || result.permission != "granted") {
      new import_obsidian.Notice(
        "Permission to access Anki was denied.\nCheck the documentation for more information."
      );
      return null;
    }
    new import_obsidian.Notice("Permission to access Anki was granted.");
    return result;
  } catch (error) {
    new import_obsidian.Notice(
      "Failed to request the permission.\nPlease make sure that Anki is running."
    );
    return null;
  }
}
async function SynchronizeData(plugin) {
  let decksData;
  decksData = await GetDecksData();
  if (decksData !== null) plugin.settings.ankiData["decksData"] = decksData;
  let modelsData;
  modelsData = await GetModelsData();
  if (modelsData !== null) plugin.settings.ankiData["modelsData"] = modelsData;
  await plugin.saveSetting();
}
async function GetDecksData() {
  try {
    let result = {};
    const decksNamesAndIds = await Invoke("deckNamesAndIds", {});
    if (!decksNamesAndIds) {
      new import_obsidian.Notice(
        "No decks were found.\nCreate a deck to synchronize deck data."
      );
      return null;
    }
    for (let i = 0; i < Object.values(decksNamesAndIds).length; i++) {
      result["deck" + i] = {
        "name": Object.keys(decksNamesAndIds)[i],
        "id": Object.values(decksNamesAndIds)[i]
      };
    }
    new import_obsidian.Notice("Decks have been synchronized.");
    return result;
  } catch (error) {
    new import_obsidian.Notice(
      "Failed to synchronize decks.\n" + error + "\nPlease make sure that Anki is running."
    );
    return null;
  }
}
async function GetModelsData() {
  try {
    let result = {};
    const modelNamesAndIds = await Invoke("modelNamesAndIds", {});
    if (!modelNamesAndIds) {
      new import_obsidian.Notice(
        "No models were found.\nCreate a model to synchronize model data."
      );
      return null;
    }
    for (let i = 0; i < Object.values(modelNamesAndIds).length; i++) {
      let model = {
        "name": Object.keys(modelNamesAndIds)[i],
        "id": Object.values(modelNamesAndIds)[i]
      };
      model["fields"] = await Invoke("modelFieldNames", {
        "modelName": Object.keys(modelNamesAndIds)[i]
      });
      result["model" + i] = model;
    }
    new import_obsidian.Notice("Models have been synchronized.");
    return result;
  } catch (error) {
    new import_obsidian.Notice(
      "Failed to synchronize models.\n" + error + "\nPlease make sure that Anki is running."
    );
    return null;
  }
}
async function CreateDeck(deckName) {
  if (deckName === "") {
    new import_obsidian.Notice("Please enter a name for your deck.");
    return false;
  }
  try {
    await Invoke("createDeck", { "deck": deckName });
    new import_obsidian.Notice("Deck " + deckName + " has been created.");
    return true;
  } catch (error) {
    new import_obsidian.Notice(
      'Failed to create the deck "${deckName}".\n' + error + "\nMake sure Anki is running."
    );
    return false;
  }
}
async function ProcessCreateDeck(inputEl, modal) {
  const deckName = inputEl.value;
  const result = await CreateDeck(deckName);
  if (result === false) {
    return;
  } else {
    modal.close();
  }
}
async function AddNote(deckName, modelName, fields, tags = []) {
  try {
    await Invoke("addNote", {
      "note": {
        "deckName": deckName,
        "modelName": modelName,
        "fields": fields,
        "tags": tags
      }
    });
    new import_obsidian.Notice("Note has been added.");
    return true;
  } catch (error) {
    new import_obsidian.Notice(
      "Failed to add note.\n" + error + "\nMake sure that Anki is running."
    );
  }
}
async function ProcessAddNote(deckSelector, modelSelector, inputContainer, tags = [], modal) {
  const deckName = deckSelector.getValue();
  if (deckName === "default") {
    new import_obsidian.Notice("Please select a deck.");
    return;
  }
  const modelName = modelSelector.getValue();
  if (modelName === "default") {
    new import_obsidian.Notice("Please select a model.");
    return;
  }
  const modelFields = {};
  const inputs = inputContainer.querySelectorAll("input");
  if (inputs[0].value === "" || inputs[1].value === "") {
    new import_obsidian.Notice("Please fill at least the two first fields of your note.");
    return;
  }
  for (let i = 0; i < inputs.length; i++) {
    modelFields[inputs[i].placeholder] = inputs[i].value;
  }
  const result = await AddNote(
    deckName,
    modelName,
    modelFields,
    tags
  );
  if (result === false) {
    return;
  } else {
    modal.close();
  }
}

// src/AnkiIntegrationSettingTab.ts
var DEFAULT_SETTINGS = {
  ankiData: {},
  invisibleCodeblock: true
};
var AnkiIntegrationSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian2.Setting(containerEl).setName("Connect Obsidian to Anki").setDesc("Click this button to connect Obsidian to Anki. Make sure that your Anki App is running before attempting to connect.").addButton((button) => button.setButtonText("Connect").setCta().onClick(async () => {
      await RequestPermission();
    }));
    new import_obsidian2.Setting(containerEl).setName("Synchronize data between Obsidian and Anki").setDesc("Click this button to synchronize data between Obsidian and Anki. Make sure that your Anki App is running before attempting to synchronize.").addButton((button) => button.setButtonText("Synchronize").setCta().onClick(async () => {
      await SynchronizeData(this.plugin);
    }));
    new import_obsidian2.Setting(containerEl).setName("Enable invisible codeblock").setDesc("Toggle by default, define if Anki Integration codeblock should be hidden or not.").addToggle((toggle) => toggle.setValue(this.plugin.settings.invisibleCodeblock).onChange(async (value) => {
      this.plugin.settings.invisibleCodeblock = value;
      await this.plugin.saveSetting();
    }));
  }
};

// src/modals/CreateDeckModal.ts
var import_obsidian4 = require("obsidian");

// src/utils.ts
var import_obsidian3 = require("obsidian");
function FetchModelByName(plugin, name) {
  const modelsData = plugin.settings.ankiData["modelsData"];
  for (const [key, model] of Object.entries(modelsData)) {
    if (model.name === name) {
      return model;
    }
  }
}
function AddContainer(parent, classes = []) {
  classes.push();
  let createdEl;
  createdEl = parent.createEl("div", {
    cls: [
      classes.join(" ")
    ]
  });
  return createdEl;
}
function AddTitle(parent, title, classes = []) {
  classes.push(
    "ankiIntegrationModal__h1--margin",
    "ankiIntegrationModal__h1--text-align"
  );
  let createdEl;
  createdEl = parent.createEl("h1", {
    text: title,
    cls: [
      classes.join(" ")
    ]
  });
  return createdEl;
}
function AddSubtitle(parent, subtitle, classes = []) {
  classes.push(
    "ankiIntegrationModal__h2--fit-content"
  );
  let createdEl;
  createdEl = parent.createEl("h2", {
    text: subtitle,
    cls: [
      classes.join(" ")
    ]
  });
  return createdEl;
}
function AddParagraph(parent, text, classes = []) {
  classes.push(
    "ankiIntegrationModal__paragraph--text-align"
  );
  let createdEl;
  createdEl = parent.createEl("p", {
    text,
    cls: [
      classes.join(" ")
    ]
  });
  return createdEl;
}
function AddDropdown(parent, defaultString, classes = []) {
  classes.push(
    "ankiIntegrationModal__dropdown--default-width"
  );
  let createdEl;
  createdEl = new import_obsidian3.DropdownComponent(parent);
  createdEl.selectEl.addClass(classes.join(" "));
  createdEl.addOption("default", defaultString);
  return createdEl;
}
function AddOptionsToDropdownFromDataset(parent, keys, valueKey, placeholderKey, where) {
  for (const key of keys) {
    const optionValue = where[key][valueKey];
    const optionPlaceholder = where[key][placeholderKey];
    parent.addOption(optionValue, optionPlaceholder);
  }
}
function AddLabel(parent, text, classes = []) {
  classes.push();
  let createdEl;
  createdEl = parent.createEl("label", {
    text,
    cls: [
      classes.join(" ")
    ]
  });
  return createdEl;
}
function AddInput(parent, type, placeholder = "", value = "", classes = []) {
  classes.push(
    "ankiIntegrationModal__input--default-width"
  );
  let createdEl;
  createdEl = parent.createEl("input", {
    type,
    placeholder,
    value,
    cls: [
      classes.join(" ")
    ]
  });
  return createdEl;
}
function AddFieldGroups(parent, inputData) {
  for (let i = 0; i < inputData.length; i++) {
    AddLabel(parent, inputData[i]["fieldName"]);
    AddInput(parent, "text", inputData[i]["fieldName"], inputData[i]["fieldValue"]);
  }
}
function AddButton(parent, text = null, icon = null, classes = []) {
  classes.push(
    "ankiIntegrationModal__button--default-width",
    "ankiIntegrationModal__button--default-margin",
    "ankiIntegrationModal__button--default-padding"
  );
  let createdEl = new import_obsidian3.ButtonComponent(parent);
  createdEl.setCta();
  if (text) {
    createdEl.setButtonText(text);
  }
  if (icon) {
    createdEl.setIcon(icon);
  }
  classes.forEach((cssClass) => {
    createdEl.setClass(cssClass);
  });
  return createdEl;
}
function CreateFieldsGroupData(fieldsGroupData, keys, values = {}) {
  for (let i = 0; i < keys.length; i++) {
    const fieldName = keys[i];
    let fieldValue = null;
    if (values["fields"]) {
      fieldValue = ExtractValueFromCodeBlock(fieldValue, values, fieldName);
    } else {
      fieldValue = ExtractValueFromMetadata(fieldValue, values, fieldName);
    }
    fieldsGroupData[i] = {
      fieldName,
      fieldValue
    };
  }
}
function ExtractValueFromMetadata(fieldValue, values, fieldName) {
  if (values.hasOwnProperty(fieldName.toLowerCase())) {
    fieldValue = values[fieldName.toLowerCase()];
    return fieldValue;
  }
}
function ExtractValueFromCodeBlock(fieldValue, values, fieldName) {
  if (values["fields"].hasOwnProperty(fieldName.toLowerCase())) {
    fieldValue = values["fields"][fieldName.toLowerCase()];
    return fieldValue;
  }
}
async function ReadFileContent(modal, fileData) {
  return await modal.app.vault.read(fileData);
}
function AutoAssignDeck(deckSelector, noteParameters) {
  let deckSelectorHasNoteParametersDeck = Array.from(deckSelector.selectEl.options).some((option) => option.value === noteParameters["deck"]);
  if (deckSelectorHasNoteParametersDeck) {
    deckSelector.setValue(noteParameters["deck"]);
  }
}
function AutoAssignModel(modelSelector, noteParameters) {
  let modelSelectorHasNoteParametersModel = Array.from(modelSelector.selectEl.options).some((option) => option.value === noteParameters["model"]);
  if (modelSelectorHasNoteParametersModel) {
    modelSelector.setValue(noteParameters["model"]);
  }
}
function AutoGenerateFields(modal, modelSelector, inputContainer, noteParameters) {
  let modelSelectorHasNoteParametersModel = Array.from(modelSelector.selectEl.options).some((option) => option.value === noteParameters["model"]);
  if (!modelSelectorHasNoteParametersModel) {
    AddParagraph(inputContainer, "Select a model to see its fields.");
  } else {
    modal.AddFieldsGroupsToModal(inputContainer, modelSelector.getValue(), noteParameters);
  }
}
function BuildTagsArray() {
  const tagInputs = document.querySelectorAll("#tagInput");
  let tags = [];
  tagInputs.forEach((tagInput) => {
    tags.push(tagInput.value);
  });
  return tags;
}
function AddTagInputGroup(parent, tagValue = null) {
  const tagInputGroup = AddContainer(parent);
  tagInputGroup.addClasses([
    "ankiIntegrationModal__container--width-fit-content",
    "ankiIntegrationModal__container--flex-row"
  ]);
  const tagInput = AddInput(tagInputGroup, "text", "My tag::Super", tagValue, [
    "ankiIntegrationModal__input--field-sizing-content",
    "ankiIntegrationModal__tagInput--border",
    "ankiIntegrationModal__tagInput--focus"
  ]);
  tagInput.removeClasses([
    "ankiIntegrationModal__input--default-width"
  ]);
  tagInput.id = "tagInput";
  const deleteTagInputButton = AddButton(tagInputGroup, "", "x", [
    "ankiIntegrationModal__deleteInputButton--border",
    "ankiIntegrationModal__icon--color-red"
  ]);
  deleteTagInputButton.removeCta();
  deleteTagInputButton.buttonEl.removeClasses([
    "ankiIntegrationModal__button--default-width",
    "ankiIntegrationModal__button--default-margin",
    "ankiIntegrationModal__button--default-padding"
  ]);
  deleteTagInputButton.onClick(async () => {
    tagInputGroup.remove();
  });
  tagInput.focus();
  return tagInputGroup;
}

// src/modals/CreateDeckModal.ts
var CreateDeckModal = class extends import_obsidian4.Modal {
  /**
   * Creates a new CreateDeckModal instance.
   * Initializes the modal with the provided app instance.
   * @param {App} app - The Obsidian app instance.
   */
  constructor(app) {
    super(app);
  }
  /**
   * Handles the opening of the modal for creating a new deck.
   * Sets up the modal UI with a title, input field for the deck name, and a submit button.
   * An event listener is attached to the submit button to handle the deck creation process.
   */
  onOpen() {
    const { contentEl } = this;
    this.contentEl.focus();
    AddTitle(contentEl, "Create a new deck");
    const inputEl = AddInput(contentEl, "text", "Enter the name of your new deck.");
    const submitButtonEl = AddButton(contentEl, "Create a new deck");
    submitButtonEl.onClick(async () => {
      await ProcessCreateDeck(inputEl, this);
    });
    this.contentEl.addEventListener("keydown", async (event) => {
      if (event.shiftKey && event.key === "Enter") {
        await ProcessCreateDeck(inputEl, this);
      }
    });
  }
  /**
   * Handles the closing of the modal by clearing the content container.
   * Removes all elements within the modal's content area.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/AddNoteModal.ts
var import_obsidian5 = require("obsidian");
var AddNoteModal = class extends import_obsidian5.Modal {
  /**
   * Creates a new AddNoteModal instance.
   * Initializes the modal with the provided app and plugin.
   * @param {App} app - The Obsidian app instance.
   * @param {AnkiIntegration} plugin - The AnkiIntegration plugin instance.
   */
  constructor(app, plugin) {
    super(app);
    /**
     * @type {AnkiIntegration}
     * The plugin instance associated with the modal.
     */
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  /**
   * Handles the opening of the modal for creating a new Anki note.
   * Initializes the UI elements, populates dropdowns with Anki data, and sets up event listeners.
   */
  onOpen() {
    const ankiData = this.plugin.settings.ankiData;
    const { contentEl } = this;
    this.contentEl.focus();
    AddTitle(contentEl, "Add a new note");
    AddSubtitle(contentEl, "Deck & Model");
    const dropdownContainer = AddContainer(contentEl, [
      "ankiIntegrationModal__dropdownContainer--flex"
    ]);
    const deckSelector = AddDropdown(dropdownContainer, "Choose a deck");
    const deckKeys = Object.keys(ankiData["decksData"]);
    AddOptionsToDropdownFromDataset(deckSelector, deckKeys, "name", "name", ankiData["decksData"]);
    const modelSelector = AddDropdown(dropdownContainer, "Choose a model");
    const modelKeys = Object.keys(ankiData["modelsData"]);
    AddOptionsToDropdownFromDataset(modelSelector, modelKeys, "name", "name", ankiData["modelsData"]);
    const tagsHeader = AddContainer(contentEl, [
      "ankiIntegrationModal__container--flex-row",
      "ankiIntegrationModal__container--flex-align-center",
      "ankiIntegrationModal__container--flex-justify-space-between"
    ]);
    AddSubtitle(tagsHeader, "Tags");
    let addTagFieldButton = AddButton(tagsHeader, "", "circle-plus");
    addTagFieldButton.buttonEl.removeClasses([
      "ankiIntegrationModal__button--default-width",
      "ankiIntegrationModal__button--default-margin",
      "ankiIntegrationModal__button--default-padding"
    ]);
    const tagsBody = AddContainer(contentEl);
    tagsBody.addClasses([
      "ankiIntegrationModal__container--flex-row",
      "ankiIntegrationModal__container--flex-wrap",
      "ankiIntegrationModal__container--gap-16px"
    ]);
    addTagFieldButton.onClick(async () => {
      const tagInputGroup = AddContainer(tagsBody);
      tagInputGroup.addClasses([
        "ankiIntegrationModal__container--width-fit-content",
        "ankiIntegrationModal__container--flex-row"
      ]);
      const tagInput = AddInput(tagInputGroup, "text", "My tag::Super", null, [
        "ankiIntegrationModal__input--field-sizing-content",
        "ankiIntegrationModal__tagInput--border",
        "ankiIntegrationModal__tagInput--focus"
      ]);
      tagInput.removeClasses([
        "ankiIntegrationModal__input--default-width"
      ]);
      tagInput.id = "tagInput";
      const deleteTagInputButton = AddButton(tagInputGroup, "", "x", [
        "ankiIntegrationModal__deleteInputButton--border",
        "ankiIntegrationModal__icon--color-red"
      ]);
      deleteTagInputButton.removeCta();
      deleteTagInputButton.buttonEl.removeClasses([
        "ankiIntegrationModal__button--default-width",
        "ankiIntegrationModal__button--default-margin",
        "ankiIntegrationModal__button--default-padding"
      ]);
      deleteTagInputButton.onClick(async () => {
        tagInputGroup.remove();
      });
      tagInput.focus();
    });
    AddSubtitle(contentEl, "Fields");
    const inputContainer = AddContainer(contentEl, [
      "ankiIntegrationModal__inputContainer--flex"
    ]);
    AddParagraph(inputContainer, "Select a model to see its fields.");
    modelSelector.onChange(async (value) => {
      const selectedModel = FetchModelByName(this.plugin, value);
      const fieldsGroupData = [];
      inputContainer.empty();
      if (value === "default") {
        AddParagraph(inputContainer, "Select a model to see its fields.");
        return;
      } else {
        CreateFieldsGroupData(fieldsGroupData, selectedModel["fields"], {});
        AddFieldGroups(inputContainer, fieldsGroupData);
      }
    });
    const submitButtonEl = AddButton(contentEl, "Create note");
    submitButtonEl.onClick(async () => {
      const tags = BuildTagsArray();
      await ProcessAddNote(deckSelector, modelSelector, inputContainer, tags, this);
    });
    this.contentEl.addEventListener("keydown", async (event) => {
      if (event.shiftKey && event.key === "Enter") {
        const tags = BuildTagsArray();
        await ProcessAddNote(deckSelector, modelSelector, inputContainer, tags, this);
      }
    });
  }
  /**
   * Handles the closing of the modal by clearing the content container.
   * Removes all elements within the modal's content area.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/modals/AddNoteFromMetadataModal.ts
var import_obsidian6 = require("obsidian");
var AddNoteFromMetadataModal = class extends import_obsidian6.Modal {
  /**
   * Creates a new AddNoteFromMetadataModal instance.
   * Initializes the modal with the provided app and plugin.
   * @param {App} app - The Obsidian app instance.
   * @param {AnkiIntegration} plugin - The AnkiIntegration plugin instance.
   * @constructor
   */
  constructor(app, plugin) {
    super(app);
    /**
     * @type {AnkiIntegration}
     * @description The plugin instance associated with the modal.
     */
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  onOpen() {
    const ankiData = this.plugin.settings.ankiData;
    const { contentEl } = this;
    this.contentEl.focus();
    const activeFileData = this.app.workspace.getActiveFile();
    let yaml = null;
    if (activeFileData) {
      yaml = this.app.metadataCache.getFileCache(activeFileData).frontmatter;
    }
    AddTitle(contentEl, "Add a new note using metadata");
    AddSubtitle(contentEl, "Deck & Model");
    const dropdownContainer = AddContainer(contentEl, [
      "ankiIntegrationModal__dropdownContainer--flex"
    ]);
    const deckSelector = AddDropdown(dropdownContainer, "Choose a deck");
    const deckKeys = Object.keys(ankiData["decksData"]);
    AddOptionsToDropdownFromDataset(deckSelector, deckKeys, "name", "name", ankiData["decksData"]);
    const modelSelector = AddDropdown(dropdownContainer, "Choose a model");
    const modelKeys = Object.keys(ankiData["modelsData"]);
    AddOptionsToDropdownFromDataset(modelSelector, modelKeys, "name", "name", ankiData["modelsData"]);
    const tagsHeader = AddContainer(contentEl, [
      "ankiIntegrationModal__container--flex-row",
      "ankiIntegrationModal__container--flex-align-center",
      "ankiIntegrationModal__container--flex-justify-space-between"
    ]);
    AddSubtitle(tagsHeader, "Tags");
    let addTagFieldButton = AddButton(tagsHeader, "", "circle-plus");
    addTagFieldButton.buttonEl.removeClasses([
      "ankiIntegrationModal__button--default-width",
      "ankiIntegrationModal__button--default-margin",
      "ankiIntegrationModal__button--default-padding"
    ]);
    const tagsBody = AddContainer(contentEl);
    tagsBody.addClasses([
      "ankiIntegrationModal__container--flex-row",
      "ankiIntegrationModal__container--flex-wrap",
      "ankiIntegrationModal__container--gap-16px"
    ]);
    if (yaml["cardTags"] != null) {
      for (let i = 0; i < yaml["cardTags"].length; i++) {
        AddTagInputGroup(tagsBody, yaml["cardTags"][i]);
      }
    }
    addTagFieldButton.onClick(async () => {
      const tagInputGroup = AddTagInputGroup(tagsBody);
    });
    AddSubtitle(contentEl, "Fields");
    const inputContainer = AddContainer(contentEl, [
      "ankiIntegrationModal__inputContainer--flex"
    ]);
    modelSelector.onChange(async (value) => {
      this.AddFieldsGroupsToModal(inputContainer, value, yaml);
    });
    if (yaml != null) {
      AutoAssignDeck(deckSelector, yaml);
      AutoAssignModel(modelSelector, yaml);
      AutoGenerateFields(this, modelSelector, inputContainer, yaml);
    } else {
      AddParagraph(inputContainer, "Select a model to see its fields.");
    }
    const submitButtonEl = AddButton(contentEl, "Create Note");
    submitButtonEl.onClick(async () => {
      const tags = BuildTagsArray();
      await ProcessAddNote(deckSelector, modelSelector, inputContainer, tags, this);
    });
    this.contentEl.addEventListener("keydown", async (event) => {
      if (event.shiftKey && event.key === "Enter") {
        const tags = BuildTagsArray();
        await ProcessAddNote(deckSelector, modelSelector, inputContainer, tags, this);
      }
    });
  }
  /**
   * Handles the closing of the modal by clearing the content container.
   * Removes all elements within the modal's content area.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Adds as many fields groups as the currently selected model has fields to the modal.
   * @param {HTMLDivElement} inputContainer - DIV containing all the generated inputs.
   * @param {any} selectedValue - Currently selected model select value of the modelSelector (DropdownComponent).
   * @param {FrontMatterCache} inputValues - The YAML metadata of the currently active note.
   */
  AddFieldsGroupsToModal(inputContainer, selectedValue, inputValues) {
    inputContainer.empty();
    const selectedModel = FetchModelByName(this.plugin, selectedValue);
    const fieldsGroupData = [];
    if (selectedValue === "default") {
      AddParagraph(inputContainer, "Select a model to see its fields.");
      return;
    } else {
      if (inputValues) {
        CreateFieldsGroupData(fieldsGroupData, selectedModel["fields"], inputValues);
        AddFieldGroups(inputContainer, fieldsGroupData);
      } else {
        CreateFieldsGroupData(fieldsGroupData, selectedModel["fields"]);
        AddFieldGroups(inputContainer, fieldsGroupData);
      }
    }
  }
};

// src/modals/AddNoteFromCodeBlockModal.ts
var import_obsidian7 = require("obsidian");
var AddNoteFromCodeBlockModal = class extends import_obsidian7.Modal {
  /**
   * Creates a new AddNoteFromCodeBlockModal instance.
   * Initializes the modal with provided app and plugin.
   * @param {App} app - The Obsidian app instance.
   * @param {AnkiIntegration} plugin - The AnkiIntegration plugin instance.
   * @constructor
   */
  constructor(app, plugin) {
    super(app);
    /**
     * @type {AnkiIntegration}
     * @description The plugin instance associated with the modal.
     */
    __publicField(this, "plugin");
    this.plugin = plugin;
  }
  onOpen() {
    const ankiData = this.plugin.settings.ankiData;
    const { contentEl } = this;
    this.contentEl.focus();
    AddTitle(contentEl, "Add a new note using code block");
    AddSubtitle(contentEl, "Deck & Model");
    const dropdownContainer = AddContainer(contentEl, [
      "ankiIntegrationModal__dropdownContainer--flex"
    ]);
    const deckSelector = AddDropdown(dropdownContainer, "Choose a deck");
    const deckKeys = Object.keys(ankiData["decksData"]);
    AddOptionsToDropdownFromDataset(deckSelector, deckKeys, "name", "name", ankiData["decksData"]);
    const modelSelector = AddDropdown(dropdownContainer, "Choose a model");
    const modelKeys = Object.keys(ankiData["modelsData"]);
    AddOptionsToDropdownFromDataset(modelSelector, modelKeys, "name", "name", ankiData["modelsData"]);
    const tagsHeader = AddContainer(contentEl, [
      "ankiIntegrationModal__container--flex-row",
      "ankiIntegrationModal__container--flex-align-center",
      "ankiIntegrationModal__container--flex-justify-space-between"
    ]);
    AddSubtitle(tagsHeader, "Tags");
    let addTagFieldButton = AddButton(tagsHeader, "", "circle-plus");
    addTagFieldButton.buttonEl.removeClasses([
      "ankiIntegrationModal__button--default-width",
      "ankiIntegrationModal__button--default-margin",
      "ankiIntegrationModal__button--default-padding"
    ]);
    const tagsBody = AddContainer(contentEl);
    tagsBody.addClasses([
      "ankiIntegrationModal__container--flex-row",
      "ankiIntegrationModal__container--flex-wrap",
      "ankiIntegrationModal__container--gap-16px"
    ]);
    addTagFieldButton.onClick(async () => {
      const tagInputGroup = AddTagInputGroup(tagsBody);
    });
    AddSubtitle(contentEl, "Fields");
    const inputContainer = AddContainer(contentEl, [
      "ankiIntegrationModal__inputContainer--flex"
    ]);
    modelSelector.onChange(async (value) => {
      const codeBlockParameters = await this.GetCodeBlockParameters();
      this.AddFieldsGroupsToModal(inputContainer, value, codeBlockParameters);
    });
    this.onOpenAsync(deckSelector, modelSelector, tagsBody, inputContainer);
    const submitButtonEl = AddButton(contentEl, "Create Note");
    submitButtonEl.onClick(async () => {
      const tags = BuildTagsArray();
      await ProcessAddNote(deckSelector, modelSelector, inputContainer, tags, this);
    });
    this.contentEl.addEventListener("keydown", async (event) => {
      if (event.shiftKey && event.key === "Enter") {
        const tags = BuildTagsArray();
        await ProcessAddNote(deckSelector, modelSelector, inputContainer, tags, this);
      }
    });
  }
  /**
   * Handles the closing of the modal by clearing the content container.
   * Removes all elements within the modal's content area.
   */
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
  /**
   * Adds as many fields groups as the currently selected model has fields to the modal.
   * @param {HTMLDivElement} inputContainer - DIV containing all the generated inputs.
   * @param {any} selectedValue - Currently selected model select value of the modelSelector (DropdownComponent).
   * @param {any} inputValues - The ??? of the currently active note.
   */
  AddFieldsGroupsToModal(inputContainer, selectedValue, inputValues) {
    const selectedModel = FetchModelByName(this.plugin, selectedValue);
    const fieldsGroupData = [];
    inputContainer.empty();
    if (selectedValue === "default") {
      AddParagraph(inputContainer, "Select a model to see its fields.");
      return;
    } else {
      if (inputValues) {
        CreateFieldsGroupData(fieldsGroupData, selectedModel["fields"], inputValues);
        console.log(inputValues);
        AddFieldGroups(inputContainer, fieldsGroupData);
      } else {
        CreateFieldsGroupData(fieldsGroupData, selectedModel["fields"]);
        AddFieldGroups(inputContainer, fieldsGroupData);
      }
    }
  }
  /**
   * onOpen() async equivalent allowing asynchronous operations.
   * @param {DropdownComponent} deckSelector - Dropdown component that allows the user to select a deck.
   * @param {DropdownComponent} modelSelector - Dropdown component that allows the user to select a model.
   * @param {HTMLDivElement} tagsBody - Speaking for itself.
   * @param {HTMLDivElement} inputContainer - Speaking for itself.
   */
  async onOpenAsync(deckSelector, modelSelector, tagsBody, inputContainer) {
    const codeBlockParameters = await this.GetCodeBlockParameters();
    if (!codeBlockParameters) {
      this.AddFieldsGroupsToModal(inputContainer, modelSelector.getValue(), null);
    } else {
      AutoAssignDeck(deckSelector, codeBlockParameters);
      AutoAssignModel(modelSelector, codeBlockParameters);
      if (codeBlockParameters["tags"] != null) {
        for (let i = 0; i < codeBlockParameters["tags"].length; i++) {
          AddTagInputGroup(tagsBody, codeBlockParameters["tags"][i]);
        }
      }
      AutoGenerateFields(this, modelSelector, inputContainer, codeBlockParameters);
    }
  }
  /**
   * Return the note's parameters defined in the code block.
   * @description Method that :
   * - retrieve the first code block using "AnkiIntegration" as its language in the open and currently active file in the instance of Obsidian.
   * - extract each lines following a "key: value;" or "key: "value";" and push it an object that is returned by the function.
   * @return {Object} codeBlockParameters
   */
  async GetCodeBlockParameters() {
    const activeFileData = this.app.workspace.getActiveFile();
    if (!activeFileData) {
      return;
    }
    const activeFileContent = await ReadFileContent(this, activeFileData);
    const codeBlock = activeFileContent.match(/(```AnkiIntegration[\s\S]*?```)/)[1];
    const regex = /^\s*(\w+):\s*(?:"([^"]+)"|([^;]+));/gm;
    const tagsRegex = /"([^"]+)"/g;
    const codeBlockParameters = {
      "fields": {},
      "tags": {}
    };
    let match = [];
    while ((match = regex.exec(codeBlock)) !== null) {
      const codeBlockChildFields = ["deck", "model", "tags"];
      const key = match[1];
      const value = match[2] || match[3];
      if (codeBlockChildFields.includes(key)) {
        if (key == "tags") {
          codeBlockParameters[key] = [];
          while ((match = tagsRegex.exec(value)) !== null) {
            const tag = match[1];
            codeBlockParameters[key].push(tag);
          }
        } else {
          codeBlockParameters[key] = value;
        }
      } else {
        codeBlockParameters["fields"][key.toLowerCase()] = value;
      }
    }
    return codeBlockParameters;
  }
};

// src/main.ts
var AnkiIntegration = class extends import_obsidian8.Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "settings");
  }
  async onload() {
    await this.loadSetting();
    await RequestPermission();
    await SynchronizeData(this);
    this.addSettingTab(new AnkiIntegrationSettingTab(this.app, this));
    this.addCommand({
      id: "synchronize-data",
      name: "Synchronize data",
      callback: () => {
        SynchronizeData(this);
      }
    });
    this.addCommand({
      id: "create-a-new-deck",
      name: "Create a new deck",
      callback: () => {
        new CreateDeckModal(this.app).open();
      }
    });
    this.addCommand({
      id: "add-a-new-note",
      name: "Add a new note",
      callback: () => {
        new AddNoteModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "add-a-new-note-from-metadata",
      name: "Add a new note from metadata",
      callback: () => {
        new AddNoteFromMetadataModal(this.app, this).open();
      }
    });
    this.addCommand({
      id: "add-a-new-note-to-code-block",
      name: "Add a new note from code block",
      callback: () => {
        new AddNoteFromCodeBlockModal(this.app, this).open();
      }
    });
    this.registerMarkdownCodeBlockProcessor("AnkiIntegration", (source, element, context) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian8.MarkdownView);
      if (this.settings.invisibleCodeblock === true && activeView.getMode() === "preview") {
        return;
      } else {
        let pre = element.createEl("pre");
        pre.removeClass("language-none");
        let code = pre.createEl("code", { text: source });
        code.removeClass("language-none");
      }
    });
  }
  async onunload() {
    await this.saveSetting();
  }
  /**
   * @description
   * Create an empty object where we inject the values that "DEFAULT_SETTINGS" stores, then, we inject the values loaded by "this.loadData()".
   * If a key already exists in this new empty object thanks to "DEFAULT_SETTINGS", it gets overwritten by the one loaded by "this.loadData()".
   * "loadData()" returns the value stored in the "data.json" file located in the root of the folder.
   */
  async loadSetting() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  /**
   * Save the settings of the plugin stored in the "settings" variable into the "data.json" file.
   */
  async saveSetting() {
    await this.saveData(this.settings);
  }
};


/* nosourcemap */