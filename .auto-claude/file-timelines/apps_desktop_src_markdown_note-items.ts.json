{
  "file_path": "apps/desktop/src/markdown/note-items.ts",
  "main_branch_history": [],
  "task_views": {
    "002-i-need-these-to-be-analyzed-and-i-need-the-pages-t": {
      "task_id": "002-i-need-these-to-be-analyzed-and-i-need-the-pages-t",
      "branch_point": {
        "commit_hash": "223b6906c6e567162b9c4367984c6ffbc6ed28e6",
        "content": "export type NoteItemKind = 'task' | 'habit'\n\nexport type NoteItemMeta = {\n  kind: NoteItemKind\n  tokenId: string\n  title: string\n  estimateMinutes?: number | null\n  dueAt?: number | null\n  rawText: string\n}\n\nconst TOKEN_META_RE = /\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g\nconst NOTE_ITEM_TOKEN_RE = /\\{(task|habit):([^\\s}]+)([^}]*)\\}/\nconst ESTIMATE_RE = /\\best\\s*:\\s*(\\d+)\\s*m\\b/i\nconst VALUE_RE = /\\bvalue\\s*:\\s*(\\d+)\\s*m\\b/i\nconst DUE_RE = /\\bdue\\s*:\\s*([0-9]{4}-[0-9]{2}-[0-9]{2})\\b/i\nconst CHECKLIST_RE = /^\\s*[-*+]\\s*\\[[ xX]\\]\\s+/\nconst TASK_HINT_RE = /(^|\\s)#task\\b/i\nconst HABIT_HINT_RE = /(^|\\s)#habit\\b/i\n\nfunction parseEstimateMinutes(meta: string) {\n  const estRaw = meta.match(ESTIMATE_RE)?.[1] ?? meta.match(VALUE_RE)?.[1] ?? null\n  if (!estRaw) return null\n  const value = Number(estRaw)\n  return Number.isFinite(value) ? value : null\n}\n\nfunction parseDueAt(meta: string) {\n  const dueRaw = meta.match(DUE_RE)?.[1] ?? null\n  if (!dueRaw) return null\n  return new Date(`${dueRaw}T09:00:00`).getTime()\n}\n\nfunction stripInlineTokens(raw: string) {\n  return raw.replace(/[#@!*^$~][^\\s{]+\\{[^}]+\\}/g, '')\n}\n\nfunction slugify(raw: string) {\n  const slug = raw\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n  return slug || 'item'\n}\n\nfunction hashString(raw: string) {\n  let hash = 0\n  for (let i = 0; i < raw.length; i += 1) {\n    hash = (hash * 31 + raw.charCodeAt(i)) >>> 0\n  }\n  return hash.toString(36)\n}\n\nfunction cleanTaskTitle(raw: string) {\n  return raw\n    .replace(/^[-*+]\\s*\\[[ xX]\\]\\s*/i, '')\n    .replace(/^[-*+]\\s+/, '')\n    .replace(/\\s+#(?:task|habit)\\b/gi, '')\n    .trim()\n}\n\nexport function parseNoteItemMeta(raw: string): NoteItemMeta | null {\n  const tokenMatch = raw.match(NOTE_ITEM_TOKEN_RE)\n  const cleaned = stripInlineTokens(raw.replace(TOKEN_META_RE, '')).replace(/\\s+/g, ' ').trim()\n  const title = cleanTaskTitle(cleaned)\n  if (tokenMatch?.[1] && tokenMatch[2]) {\n    const kind = tokenMatch[1] as NoteItemKind\n    const tokenId = tokenMatch[2]\n    const meta = tokenMatch[3] ?? ''\n    const estimateMinutes = parseEstimateMinutes(meta)\n    const dueAt = kind === 'task' ? parseDueAt(meta) : null\n    return { kind, tokenId, title, estimateMinutes, dueAt, rawText: raw }\n  }\n\n  const isChecklist = CHECKLIST_RE.test(raw)\n  const hasTaskHint = TASK_HINT_RE.test(raw)\n  const hasHabitHint = HABIT_HINT_RE.test(raw)\n  if (!isChecklist && !hasTaskHint && !hasHabitHint) return null\n\n  const kind: NoteItemKind = hasHabitHint ? 'habit' : 'task'\n  const tokenId = `${kind}_${slugify(title || 'task')}_${hashString(raw)}`\n  return { kind, tokenId, title, estimateMinutes: null, dueAt: null, rawText: raw }\n}\n",
        "timestamp": "2026-01-13T11:38:54.774343"
      },
      "worktree_state": {
        "content": "export type NoteItemKind = 'task' | 'habit'\n\nexport type FrontMatter = {\n  title?: string\n  date?: string\n  tags?: string[]\n  source?: string\n  author?: string\n  [key: string]: string | string[] | number | boolean | null | undefined\n}\n\nexport type FrontMatterResult = {\n  frontMatter: FrontMatter | null\n  content: string\n}\n\nconst FRONT_MATTER_RE = /^---\\r?\\n([\\s\\S]*?)\\r?\\n---(?:\\r?\\n|$)/\n\nfunction parseYamlValue(raw: string): string | string[] | number | boolean | null {\n  const trimmed = raw.trim()\n  if (trimmed === '' || trimmed === 'null' || trimmed === '~') return null\n  if (trimmed === 'true') return true\n  if (trimmed === 'false') return false\n  if (/^-?\\d+$/.test(trimmed)) return parseInt(trimmed, 10)\n  if (/^-?\\d+\\.\\d+$/.test(trimmed)) return parseFloat(trimmed)\n  if (trimmed.startsWith('[') && trimmed.endsWith(']')) {\n    const inner = trimmed.slice(1, -1)\n    return inner.split(',').map((s) => s.trim().replace(/^[\"']|[\"']$/g, '')).filter(Boolean)\n  }\n  return trimmed.replace(/^[\"']|[\"']$/g, '')\n}\n\nfunction parseYamlArray(lines: string[], startIndex: number): { value: string[]; endIndex: number } {\n  const items: string[] = []\n  let i = startIndex\n  while (i < lines.length) {\n    const line = lines[i]\n    const arrayItemMatch = line.match(/^\\s*-\\s+(.*)$/)\n    if (!arrayItemMatch) break\n    const val = arrayItemMatch[1]?.trim().replace(/^[\"']|[\"']$/g, '') ?? ''\n    if (val) items.push(val)\n    i += 1\n  }\n  return { value: items, endIndex: i - 1 }\n}\n\nexport function parseFrontMatter(text: string | null | undefined): FrontMatterResult {\n  const content = (text ?? '').trim()\n  if (!content) return { frontMatter: null, content: '' }\n\n  const match = content.match(FRONT_MATTER_RE)\n  if (!match?.[1]) return { frontMatter: null, content }\n\n  try {\n    const yamlBlock = match[1]\n    const remainingContent = content.slice(match[0].length).trim()\n    const lines = yamlBlock.split(/\\r?\\n/)\n    const frontMatter: FrontMatter = {}\n\n    for (let i = 0; i < lines.length; i += 1) {\n      const line = lines[i] ?? ''\n      if (!line.trim()) continue\n\n      const keyValueMatch = line.match(/^([a-zA-Z_][a-zA-Z0-9_-]*)\\s*:\\s*(.*)$/)\n      if (!keyValueMatch?.[1]) continue\n\n      const key = keyValueMatch[1]\n      const valueRaw = keyValueMatch[2] ?? ''\n\n      if (!valueRaw.trim() && i + 1 < lines.length) {\n        const nextLine = lines[i + 1] ?? ''\n        if (/^\\s+-\\s+/.test(nextLine)) {\n          const { value, endIndex } = parseYamlArray(lines, i + 1)\n          frontMatter[key] = value\n          i = endIndex\n          continue\n        }\n      }\n\n      frontMatter[key] = parseYamlValue(valueRaw)\n    }\n\n    return { frontMatter, content: remainingContent }\n  } catch {\n    // Graceful fallback for invalid YAML front matter\n    return { frontMatter: null, content }\n  }\n}\n\nexport function hasFrontMatter(text: string | null | undefined): boolean {\n  const content = (text ?? '').trim()\n  return FRONT_MATTER_RE.test(content)\n}\n\nexport function stripFrontMatter(text: string | null | undefined): string {\n  const { content } = parseFrontMatter(text)\n  return content\n}\n\nexport type HeadingLevel = 1 | 2 | 3 | 4 | 5 | 6\n\nexport type HeadingMeta = {\n  level: HeadingLevel\n  text: string\n  line: number\n}\n\nexport type NoteItemMeta = {\n  kind: NoteItemKind\n  tokenId: string\n  title: string\n  estimateMinutes?: number | null\n  dueAt?: number | null\n  rawText: string\n}\n\nconst TOKEN_META_RE = /\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g\nconst NOTE_ITEM_TOKEN_RE = /\\{(task|habit):([^\\s}]+)([^}]*)\\}/\nconst ESTIMATE_RE = /\\best\\s*:\\s*(\\d+)\\s*m\\b/i\nconst VALUE_RE = /\\bvalue\\s*:\\s*(\\d+)\\s*m\\b/i\nconst DUE_RE = /\\bdue\\s*:\\s*([0-9]{4}-[0-9]{2}-[0-9]{2})\\b/i\nconst CHECKLIST_RE = /^\\s*[-*+]\\s*\\[[ xX]\\]\\s+/\nconst TASK_HINT_RE = /(^|\\s)#task\\b/i\nconst HABIT_HINT_RE = /(^|\\s)#habit\\b/i\nconst HEADING_RE = /^(#{1,6})\\s+(.+)$/\n\nfunction parseEstimateMinutes(meta: string) {\n  const estRaw = meta.match(ESTIMATE_RE)?.[1] ?? meta.match(VALUE_RE)?.[1] ?? null\n  if (!estRaw) return null\n  const value = Number(estRaw)\n  return Number.isFinite(value) ? value : null\n}\n\nfunction parseDueAt(meta: string) {\n  const dueRaw = meta.match(DUE_RE)?.[1] ?? null\n  if (!dueRaw) return null\n  return new Date(`${dueRaw}T09:00:00`).getTime()\n}\n\nfunction stripInlineTokens(raw: string) {\n  return raw.replace(/[#@!*^$~][^\\s{]+\\{[^}]+\\}/g, '')\n}\n\nfunction slugify(raw: string) {\n  const slug = raw\n    .toLowerCase()\n    .replace(/[^a-z0-9]+/g, '-')\n    .replace(/^-+|-+$/g, '')\n  return slug || 'item'\n}\n\nfunction hashString(raw: string) {\n  let hash = 0\n  for (let i = 0; i < raw.length; i += 1) {\n    hash = (hash * 31 + raw.charCodeAt(i)) >>> 0\n  }\n  return hash.toString(36)\n}\n\nfunction cleanTaskTitle(raw: string) {\n  return raw\n    .replace(/^[-*+]\\s*\\[[ xX]\\]\\s*/i, '')\n    .replace(/^[-*+]\\s+/, '')\n    .replace(/\\s+#(?:task|habit)\\b/gi, '')\n    .trim()\n}\n\nexport function parseNoteItemMeta(raw: string): NoteItemMeta | null {\n  const tokenMatch = raw.match(NOTE_ITEM_TOKEN_RE)\n  const cleaned = stripInlineTokens(raw.replace(TOKEN_META_RE, '')).replace(/\\s+/g, ' ').trim()\n  const title = cleanTaskTitle(cleaned)\n  if (tokenMatch?.[1] && tokenMatch[2]) {\n    const kind = tokenMatch[1] as NoteItemKind\n    const tokenId = tokenMatch[2]\n    const meta = tokenMatch[3] ?? ''\n    const estimateMinutes = parseEstimateMinutes(meta)\n    const dueAt = kind === 'task' ? parseDueAt(meta) : null\n    return { kind, tokenId, title, estimateMinutes, dueAt, rawText: raw }\n  }\n\n  const isChecklist = CHECKLIST_RE.test(raw)\n  const hasTaskHint = TASK_HINT_RE.test(raw)\n  const hasHabitHint = HABIT_HINT_RE.test(raw)\n  if (!isChecklist && !hasTaskHint && !hasHabitHint) return null\n\n  const kind: NoteItemKind = hasHabitHint ? 'habit' : 'task'\n  const tokenId = `${kind}_${slugify(title || 'task')}_${hashString(raw)}`\n  return { kind, tokenId, title, estimateMinutes: null, dueAt: null, rawText: raw }\n}\n\nexport function extractHeadings(text: string): HeadingMeta[] {\n  const headings: HeadingMeta[] = []\n  const lines = text.split(/\\r?\\n/)\n  for (let i = 0; i < lines.length; i += 1) {\n    const line = lines[i]\n    const match = line.match(HEADING_RE)\n    if (match?.[1] && match[2]) {\n      const level = match[1].length as HeadingLevel\n      const headingText = match[2].trim()\n      if (headingText) {\n        headings.push({ level, text: headingText, line: i + 1 })\n      }\n    }\n  }\n  return headings\n}\n",
        "last_modified": "2026-01-13T13:07:29.911382"
      },
      "task_intent": {
        "title": "002-i-need-these-to-be-analyzed-and-i-need-the-pages-t",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 3,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T11:38:54.990213",
  "last_updated": "2026-01-13T11:38:55.036587"
}