{
  "file_path": "apps/desktop/src/App.tsx",
  "main_branch_history": [],
  "task_views": {
    "004-need-you-to-reframe-the-notes-explorer-page-becaus": {
      "task_id": "004-need-you-to-reframe-the-notes-explorer-page-becaus",
      "branch_point": {
        "commit_hash": "223b6906c6e567162b9c4367984c6ffbc6ed28e6",
        "content": "import './App.css'\nimport { useEffect, useMemo, useState, useRef, type DragEvent, useCallback, type SetStateAction } from 'react'\nimport { AnimatePresence, motion } from 'framer-motion'\nimport type { Session } from '@supabase/supabase-js'\nimport { Toaster, toast } from 'sonner'\n\nimport { addInboxCapture, listInboxCaptures, updateCaptureEntityIds, updateCaptureText, type InboxCapture } from './storage/inbox'\nimport { createTask, deleteTask, listTasks, startTask, upsertTask, type Task, type TaskStatus } from './storage/tasks'\nimport { createEvent, deleteEvent, findActiveByTrackerKey, findActiveEpisode, findBestActiveEventAt, listEvents, upsertEvent, type CalendarEvent } from './storage/calendar'\nimport { ensureEntity } from './storage/entities'\nimport { estimateCalories, parseWorkoutFromText, saveWorkout } from './storage/workouts'\nimport { estimateFoodNutrition, parseMealFromText, saveMeal } from './storage/nutrition'\nimport { emptySharedMeta, loadTrackerDefs, saveTrackerDefs, upsertTrackerDef, type TrackerDef } from './storage/ecosystem'\nimport { parseCaptureNatural, type ParsedEvent } from './nlp/natural'\nimport { parseCaptureWithBlocksLlm, type LlmParsedEvent } from './nlp/llm-parse'\nimport { estimateNutritionWithLlm } from './nlp/nutrition-estimate'\nimport { loadSettings } from './assistant/storage'\nimport { makeFoodItemId, type ExtendedMacros, type FoodItem } from './db/insight-db'\nimport { getSupabaseClient } from './supabase/client'\nimport { migrateLocalDataToSupabase, pullSupabaseToLocal } from './supabase/sync'\n\nimport { Icon, type IconName } from './ui/icons'\nimport { EVENT_COLOR_PRESETS, eventAccent } from './ui/event-visual'\nimport { DISPLAY_SETTINGS_CHANGED_EVENT, loadDisplaySettings, type EventTitleDetail } from './ui/display-settings'\nimport { applyTheme, loadThemePreference, resolveTheme, saveThemePreference, THEME_CHANGED_EVENT, type ThemePreference } from './ui/theme'\nimport { parseChecklistMarkdown, toggleChecklistLine } from './ui/checklist'\nimport { MarkdownEditor } from './ui/markdown-editor'\nimport { CaptureModal } from './ui/CaptureModal'\nimport { ActiveSessionBanner } from './ui/ActiveSessionBanner'\nimport { Pane, type WorkspaceTab, type WorkspaceViewKey } from './workspace/pane'\nimport { TickTickTasksView } from './workspace/views/ticktick-tasks'\nimport { AssistantView } from './workspace/views/assistant'\nimport { DashboardView } from './workspace/views/dashboard'\nimport { HealthDashboard } from './workspace/views/health'\nimport { PlaceholderView } from './workspace/views/placeholder'\nimport { TimelineView } from './workspace/views/timeline'\nimport { PlannerView } from './workspace/views/planner'\nimport { NotesView } from './workspace/views/notes'\nimport { SettingsView } from './workspace/views/settings'\nimport { RewardsView } from './workspace/views/rewards'\nimport { GoalsView } from './workspace/views/goals'\nimport { EcosystemView } from './workspace/views/ecosystem'\nimport { ProjectsView } from './workspace/views/projects'\nimport { TrackersView } from './workspace/views/trackers'\nimport { HabitsView } from './workspace/views/habits'\nimport { basePoints, multiplierFor, pointsForMinutes } from './scoring/points'\nimport { loadCustomTaxonomy, saveCustomTaxonomy } from './taxonomy/custom'\nimport { categoriesFromStarter, subcategoriesFromStarter } from './taxonomy/starter'\nimport { loadTaxonomyRules, TAXONOMY_RULES_CHANGED_EVENT, type TaxonomyRule } from './taxonomy/rules'\nimport { collectMarkdownTokens, extractInlineTokens, toTokenCollections } from './markdown/schema'\nimport { parseNoteItemMeta, type NoteItemKind } from './markdown/note-items'\n\ntype PaneState = {\n  tabs: WorkspaceTab[]\n  activeTabId: string\n}\n\ntype CreateEventSeed = {\n  startAt: number\n  endAt: number\n  kind?: CalendarEvent['kind']\n  taskId?: string | null\n}\n\ntype EventComposerDraft = {\n  title: string\n  startAt: number\n  endAt: number\n  kind: CalendarEvent['kind']\n  allDay: boolean\n  active: boolean\n  icon: string | null\n  color: string | null\n  tagsRaw: string\n  location: string\n  peopleRaw: string\n  skillsRaw: string\n  character: string[]\n  category: string\n  subcategory: string\n  importance: number | null\n  difficulty: number | null\n  estimateMinutesRaw: string\n  notes: string\n  taskId: string | null\n  trackerKey: string\n}\n\ntype HabitDef = {\n  id: string\n  name: string\n  category: string | null\n  subcategory: string | null\n  difficulty: number\n  importance: number\n  character: Array<'STR' | 'INT' | 'CON' | 'PER'>\n  skills: string[]\n  tags: string[]\n  contexts: string[]\n  people: string[]\n  location?: string | null\n  goal?: string | null\n  project?: string | null\n  estimateMinutes?: number | null\n  polarity?: 'positive' | 'negative' | 'both'\n  schedule?: string | null\n  targetPerWeek?: number | null\n  color?: string | null\n  icon?: string | null\n  isTimed?: boolean\n}\n\ntype Selection =\n  | { kind: 'none' }\n  | { kind: 'task'; id: string }\n  | { kind: 'event'; id: string }\n  | { kind: 'capture'; id: string }\n\nconst HABITS_UPDATED_EVENT = 'insight5.habits.updated'\nconst DND_HABIT = 'application/insight5-habit'\nconst DND_TRACKER = 'application/insight5-tracker'\nconst REPORTS_HABIT_ID_KEY = 'insight5.reports.habitId'\n\nfunction makeTabId(view: WorkspaceViewKey) {\n  return `tab_${view}_${Date.now()}_${Math.random().toString(16).slice(2)}`\n}\n\nfunction defaultTabTitle(view: WorkspaceViewKey) {\n  switch (view) {\n    case 'notes':\n      return 'Notes'\n    case 'reflections':\n      return 'Thoughts'\n    case 'tasks':\n      return 'Tasks'\n    case 'calendar':\n      return 'Day'\n    case 'dashboard':\n      return 'Life Tracker'\n    case 'assistant':\n      return 'Chat'\n    case 'habits':\n      return 'Habits'\n    case 'goals':\n      return 'Goals'\n    case 'goal-detail':\n      return 'Goal'\n    case 'ecosystem':\n      return 'Ecosystem'\n    case 'projects':\n      return 'Projects'\n    case 'trackers':\n      return 'Trackers'\n    case 'rewards':\n      return 'Rewards'\n    case 'reports':\n      return 'Reports'\n    case 'health':\n      return 'Health'\n    case 'people':\n      return 'People'\n    case 'places':\n      return 'Places'\n    case 'tags':\n      return 'Tags'\n    case 'timeline':\n      return 'Timeline'\n    case 'settings':\n      return 'Settings'\n    default:\n      return view\n  }\n}\n\nfunction clamp01(n: number) {\n  return Math.max(0, Math.min(1, n))\n}\n\nfunction numberOrNull(v: string) {\n  const n = Number(v)\n  return Number.isFinite(n) ? n : null\n}\n\nfunction toLocalDateTimeInput(ms: number | null | undefined) {\n  if (!ms) return ''\n  const d = new Date(ms)\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  const hh = String(d.getHours()).padStart(2, '0')\n  const mi = String(d.getMinutes()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}T${hh}:${mi}`\n}\n\nfunction fromLocalDateTimeInput(v: string) {\n  const ms = new Date(v).getTime()\n  return Number.isFinite(ms) ? ms : null\n}\n\nfunction estimateMinutesFromRange(startAt: number, endAt: number) {\n  const minutes = Math.round(Math.max(5 * 60 * 1000, endAt - startAt) / (60 * 1000))\n  return Number.isFinite(minutes) ? String(minutes) : ''\n}\n\nconst EVENT_ICON_OPTIONS: Array<{ value: IconName; label: string }> = [\n  { value: 'calendar', label: 'Calendar' },\n  { value: 'check', label: 'Task' },\n  { value: 'phone', label: 'Call' },\n  { value: 'food', label: 'Food' },\n  { value: 'cart', label: 'Shopping' },\n  { value: 'dumbbell', label: 'Workout' },\n  { value: 'tooth', label: 'Teeth' },\n  { value: 'briefcase', label: 'Work' },\n  { value: 'stethoscope', label: 'Clinic' },\n  { value: 'book', label: 'Study' },\n  { value: 'moonStar', label: 'Sleep' },\n  { value: 'pin', label: 'Location' },\n  { value: 'users', label: 'People' },\n]\n\nfunction toTitleCase(input: string) {\n  return input\n    .trim()\n    .split(/\\s+/)\n    .map((w) => (w ? w[0]!.toUpperCase() + w.slice(1).toLowerCase() : ''))\n    .join(' ')\n}\n\nfunction inferCategorySubcategoryLoose(title: string, tags: string[]) {\n  const t = title.toLowerCase()\n  const tagSet = new Set(tags.map((x) => x.replace(/^#/, '').toLowerCase()))\n  let category: string | null = null\n  let subcategory: string | null = null\n\n  for (const rawTag of tags) {\n    const cleaned = rawTag.replace(/^#/, '').trim()\n    if (!cleaned || !cleaned.includes('/')) continue\n    const [cat, sub] = cleaned.split('/', 2)\n    if (cat) category = toTitleCase(cat)\n    if (sub) subcategory = toTitleCase(sub)\n    break\n  }\n\n  if (!category && (tagSet.has('work') || /\\b(work|shift)\\b/.test(t))) category = 'Work'\n  if (tagSet.has('clinic') || /\\b(clinic|patients|rounds|inpatient)\\b/.test(t)) {\n    category = category ?? 'Work'\n    subcategory = subcategory ?? 'Clinic'\n  }\n  if (tagSet.has('meeting') || /\\b(meeting|conference|rounds)\\b/.test(t)) {\n    category = category ?? 'Work'\n    subcategory = subcategory ?? 'Meeting'\n  }\n  if (tagSet.has('study') || /\\b(study|lecture|reading)\\b/.test(t)) {\n    category = category ?? 'Learning'\n    subcategory = subcategory ?? (/\\b(read|reading)\\b/.test(t) ? 'Reading' : 'Practice')\n  }\n  if (tagSet.has('workout') || /\\b(workout|gym|lift|lifting|run|cardio|yoga|training)\\b/.test(t)) {\n    category = category ?? 'Health'\n    subcategory = subcategory ?? 'Workout'\n  }\n  if (tagSet.has('sleep') || /\\b(sleep|nap)\\b/.test(t)) {\n    category = category ?? 'Health'\n    subcategory = subcategory ?? 'Sleep'\n  }\n  if (tagSet.has('shopping') || /\\b(grocery|shopping|store|errand)\\b/.test(t)) {\n    category = category ?? 'Personal'\n    subcategory = subcategory ?? (/\\b(grocery|groceries)\\b/.test(t) ? 'Groceries' : 'Errands')\n  }\n  if (tagSet.has('morning') || /\\b(get ready|morning routine|prep|ready for work)\\b/.test(t)) {\n    category = category ?? 'Personal'\n    subcategory = subcategory ?? 'Morning Routine'\n  }\n  if (tagSet.has('food') || /\\b(dinner|lunch|breakfast|meal|restaurant|food)\\b/.test(t)) {\n    category = category ?? 'Food'\n    subcategory = subcategory ?? (/\\b(restaurant|dinner out|lunch out|eat out)\\b/.test(t) ? 'Restaurant' : 'Meal')\n  }\n  if (tagSet.has('walk') || /\\b(walk|stroll)\\b/.test(t)) {\n    category = category ?? 'Personal'\n    subcategory = subcategory ?? 'Health'\n  }\n  if (tagSet.has('transport') || /\\b(transport|drive|driving|commute|flight|fly|uber|lyft|train|bus|parking)\\b/.test(t)) {\n    category = category ?? 'Transport'\n    if (/\\b(flight|fly|airport)\\b/.test(t)) subcategory = subcategory ?? 'Flight'\n    else if (/\\b(train|bus|transit|subway)\\b/.test(t)) subcategory = subcategory ?? 'Transit'\n    else if (/\\b(parking)\\b/.test(t)) subcategory = subcategory ?? 'Parking'\n    else subcategory = subcategory ?? 'Driving'\n  }\n  if (tagSet.has('finance') || /\\b(bank|finance|mortgage|loan|bill|budget|expense)\\b/.test(t)) {\n    category = category ?? 'Finance'\n    subcategory = subcategory ?? (/\\b(bank)\\b/.test(t) ? 'Banking' : /\\b(bill|bills)\\b/.test(t) ? 'Bills' : 'Budget')\n  }\n\n  if (category) {\n    const canonical = categoriesFromStarter().find((c) => c.toLowerCase() === category!.toLowerCase())\n    if (canonical) category = canonical\n  }\n  if (category && subcategory) {\n    const subs = subcategoriesFromStarter(category)\n    const canonicalSub = subs.find((s) => s.toLowerCase() === subcategory!.toLowerCase())\n    if (canonicalSub) subcategory = canonicalSub\n  }\n\n  return { category, subcategory }\n}\n\nfunction normalizeHashTag(raw: string) {\n  const t = raw.trim()\n  if (!t) return ''\n  return t.startsWith('#') ? t : `#${t}`\n}\n\nfunction recordTaxonomyEntry(category: string | null, subcategory: string | null) {\n  if (!category) return\n  const next = loadCustomTaxonomy()\n  const idx = next.findIndex((c) => c.category.toLowerCase() === category.toLowerCase())\n  if (idx >= 0) {\n    const current = next[idx]!\n    const subs = new Set(current.subcategories.map((s) => s.trim()).filter(Boolean))\n    if (subcategory) subs.add(subcategory)\n    next[idx] = { category: current.category, subcategories: Array.from(subs) }\n  } else {\n    next.push({ category, subcategories: subcategory ? [subcategory] : [] })\n  }\n  saveCustomTaxonomy(next)\n}\n\nfunction loadHabitDefsFromStorage(): HabitDef[] {\n  try {\n    const raw = localStorage.getItem('insight5.habits.defs.v1')\n    if (!raw) return []\n    const parsed = JSON.parse(raw) as HabitDef[]\n    if (!Array.isArray(parsed)) return []\n    return parsed\n      .filter((h) => h && typeof h.id === 'string' && typeof h.name === 'string')\n      .map((h) => ({\n        ...h,\n        tags: (h.tags ?? []).map((t) => normalizeHashTag(String(t))).filter(Boolean),\n        contexts: Array.isArray(h.contexts) ? h.contexts.map((c) => String(c).trim()).filter(Boolean) : [],\n        people: Array.isArray(h.people) ? h.people.map((p) => String(p).trim()).filter(Boolean) : [],\n        location: typeof h.location === 'string' ? h.location : null,\n        goal: typeof h.goal === 'string' ? h.goal : null,\n        project: typeof h.project === 'string' ? h.project : null,\n        estimateMinutes: typeof h.estimateMinutes === 'number' ? h.estimateMinutes : null,\n        polarity: h.polarity ?? 'both',\n        color: h.color ?? null,\n        icon: h.icon ?? null,\n        isTimed: h.isTimed ?? false,\n      }))\n  } catch {\n    return []\n  }\n}\n\n/*\nfunction trackerTitleFor(def: TrackerDef) {\n  if (def.defaultValue == null || !Number.isFinite(def.defaultValue)) return def.label\n  return `${def.key}: ${Math.round(def.defaultValue)}/10`\n}\n*/\n\nfunction extractContextTokens(rawText: string) {\n  const out = new Set<string>()\n  for (const m of rawText.matchAll(/(^|[\\s(])\\+([a-zA-Z][\\w/-]*)/g)) {\n    const name = (m[2] ?? '').trim()\n    if (name) out.add(name)\n  }\n  return [...out].slice(0, 16)\n}\n\nfunction extractDurationToken(rawText: string) {\n  const t = rawText.toLowerCase()\n  const hm = t.match(/~\\s*(\\d{1,2})\\s*h(?:ours?)?\\s*(\\d{1,2})\\s*m(?:in(?:ute)?s?)?\\b/)\n  if (hm?.[1]) {\n    const h = Number(hm[1])\n    const m = Number(hm[2] ?? 0)\n    if (Number.isFinite(h) && Number.isFinite(m)) return h * 60 + m\n  }\n  const h = t.match(/~\\s*(\\d{1,2})(?:\\.(\\d))?\\s*h(?:ours?)?\\b/)\n  if (h?.[1]) {\n    const whole = Number(h[1])\n    const tenth = h[2] ? Number(h[2]) / 10 : 0\n    if (Number.isFinite(whole)) return Math.max(1, Math.round((whole + tenth) * 60))\n  }\n  const m = t.match(/~\\s*(\\d{1,3})\\s*(m|min|mins|minute|minutes)\\b/)\n  if (m?.[1]) {\n    const mins = Number(m[1])\n    if (Number.isFinite(mins)) return Math.max(1, Math.min(24 * 60, mins))\n  }\n  return null\n}\n\nfunction extractImportanceToken(rawText: string) {\n  const m = rawText.match(/!(\\d{1,2})\\b/)\n  const v = m?.[1] ? Number(m[1]) : null\n  const kv = rawText.match(/\\bimportance[:=]\\s*(\\d{1,2})\\b/i)?.[1]\n  const vv = kv ? Number(kv) : null\n  const val = Number.isFinite(v ?? NaN) ? v : Number.isFinite(vv ?? NaN) ? vv : null\n  return val != null ? Math.max(1, Math.min(10, val)) : null\n}\n\nfunction extractDifficultyToken(rawText: string) {\n  const m = rawText.match(/\\^(\\d{1,2})\\b/)\n  const v = m?.[1] ? Number(m[1]) : null\n  const kv = rawText.match(/\\b(?:difficulty|energy)[:=]\\s*(\\d{1,2})\\b/i)?.[1]\n  const ratio = rawText.match(/\\b(\\d{1,2})\\s*\\/\\s*10\\b/)?.[1]\n  const vv = kv ? Number(kv) : ratio ? Number(ratio) : null\n  const val = Number.isFinite(v ?? NaN) ? v : Number.isFinite(vv ?? NaN) ? vv : null\n  return val != null ? Math.max(1, Math.min(10, val)) : null\n}\n\nfunction hasExplicitTimeRange(rawText: string) {\n  const t = rawText.toLowerCase()\n  if (/\\b(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm)?\\s*(?:-|\u2013|\u2014|\\s+to\\s+)\\s*\\d{1,2}(?::\\d{2})?\\s*(?:am|pm)?)\\b/.test(t)) return true\n  if (/\\b(at|@)\\s*\\d{1,2}(?::\\d{2})?\\s*(?:am|pm)?\\b/.test(t)) return true\n  return false\n}\n\nfunction parseInlineList(raw: string) {\n  return raw\n    .replace(/^\\[/, '')\n    .replace(/\\]$/, '')\n    .split(',')\n    .map((x) => x.trim().replace(/^['\"]|['\"]$/g, ''))\n    .filter(Boolean)\n}\n\nfunction parseSimpleFrontmatter(lines: string[]) {\n  const out: Record<string, any> = {}\n  let activeKey: string | null = null\n  let listBuffer: string[] = []\n\n  const flushList = () => {\n    if (activeKey) out[activeKey] = [...listBuffer]\n    activeKey = null\n    listBuffer = []\n  }\n\n  for (const rawLine of lines) {\n    const line = rawLine.replace(/\\t/g, '  ')\n    if (!line.trim() || /^\\s*#/.test(line)) continue\n    const listMatch = line.match(/^\\s*-\\s+(.+)$/)\n    if (listMatch && activeKey) {\n      listBuffer.push(listMatch[1].trim().replace(/^['\"]|['\"]$/g, ''))\n      continue\n    }\n    if (activeKey) flushList()\n    const m = line.match(/^\\s*([A-Za-z][\\w-]*)\\s*:\\s*(.*)$/)\n    if (!m?.[1]) continue\n    const key = m[1]\n    const value = (m[2] ?? '').trim()\n    if (!value) {\n      activeKey = key\n      listBuffer = []\n      continue\n    }\n    if (value.startsWith('[') && value.endsWith(']')) {\n      out[key] = parseInlineList(value)\n      continue\n    }\n    const unquoted = value.replace(/^['\"]|['\"]$/g, '')\n    if (/^(true|false)$/i.test(unquoted)) {\n      out[key] = unquoted.toLowerCase() === 'true'\n      continue\n    }\n    const num = Number(unquoted)\n    out[key] = Number.isFinite(num) && unquoted !== '' ? num : unquoted\n  }\n  if (activeKey) flushList()\n  return out\n}\n\nfunction extractFrontmatter(rawText: string) {\n  const lines = rawText.split(/\\r?\\n/)\n  if ((lines[0] ?? '').trim() !== '---') return { frontmatter: null, body: rawText }\n  const endIdx = lines.slice(1).findIndex((l) => l.trim() === '---')\n  if (endIdx === -1) return { frontmatter: null, body: rawText }\n  const fmLines = lines.slice(1, endIdx + 1)\n  const body = lines.slice(endIdx + 2).join('\\n').trim()\n  const frontmatter = parseSimpleFrontmatter(fmLines)\n  return { frontmatter, body }\n}\n\nfunction toStringList(value: unknown) {\n  if (Array.isArray(value)) return value.map((x) => String(x)).filter(Boolean)\n  if (typeof value === 'string') return value.split(/[,;]+/).map((x) => x.trim()).filter(Boolean)\n  return []\n}\n\nconst NUMBER_WORDS: Record<string, number> = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  three: 3,\n  four: 4,\n  five: 5,\n  six: 6,\n  seven: 7,\n  eight: 8,\n  nine: 9,\n  ten: 10,\n}\n\nconst NUMBER_WORD_PATTERN = Object.keys(NUMBER_WORDS).join('|')\n\nfunction parseNumberToken(raw: string) {\n  const cleaned = raw.trim().toLowerCase()\n  if (!cleaned) return null\n  if (NUMBER_WORDS[cleaned] != null) return NUMBER_WORDS[cleaned]\n  const num = Number(cleaned)\n  return Number.isFinite(num) ? num : null\n}\n\nfunction parseRatingRange(first: string, second?: string | null) {\n  const a = parseNumberToken(first)\n  if (a == null) return null\n  const b = second ? parseNumberToken(second) : null\n  const value = b != null ? (a + b) / 2 : a\n  return Math.max(0, Math.min(10, value))\n}\n\nfunction parseRatingNearText(text: string, keyword: string) {\n  const tokenPattern = String.raw`(?:\\d{1,2}|${NUMBER_WORD_PATTERN})`\n  const re = new RegExp(\n    String.raw`\\b${keyword}\\b(?:\\s*(?:is|was|were|like|around|about|at|score|rating|of|=|:)?\\s*)(${tokenPattern})(?:\\s*(?:-|to)\\s*(${tokenPattern}))?(?:\\s*\\/\\s*10)?`,\n    'i',\n  )\n  const m = text.match(re)\n  if (!m?.[1]) return null\n  return parseRatingRange(m[1], m[2])\n}\n\nfunction inferMoodFromAdjectives(text: string) {\n  const moodSignal = /\\b(feel(?:ing)?|mood|looking forward|cant wait|can't wait|excited|love (?:doing|this|it))\\b/i.test(text)\n  if (!moodSignal) return null\n  const moodAdjectives: Array<{ re: RegExp; value: number }> = [\n    { re: /\\b(amazing|awesome|fantastic|incredible)\\b/i, value: 9 },\n    { re: /\\b(great)\\b/i, value: 8 },\n    { re: /\\b(very good|really good|pretty good|good)\\b/i, value: 7 },\n    { re: /\\b(looking forward)\\b/i, value: 7 },\n    { re: /\\b(cant wait|can't wait|excited)\\b/i, value: 8 },\n    { re: /\\b(love (?:doing|this|it))\\b/i, value: 8 },\n    { re: /\\b(okay|ok|fine|neutral)\\b/i, value: 5 },\n    { re: /\\b(meh)\\b/i, value: 4 },\n    { re: /\\b(not good|bad|down)\\b/i, value: 3 },\n    { re: /\\b(sad|depressed)\\b/i, value: 2 },\n    { re: /\\b(awful|terrible|miserable)\\b/i, value: 1 },\n    { re: /\\b(happy|joyful|excited)\\b/i, value: 8 },\n    { re: /\\b(anxious|stressed|angry)\\b/i, value: 4 },\n  ]\n  for (const entry of moodAdjectives) {\n    if (entry.re.test(text)) return entry.value\n  }\n  return null\n}\n\nfunction inferEnergyFromAdjectives(text: string) {\n  const energySignal =\n    /\\benergy\\b/i.test(text) ||\n    /\\b(energized|wired|pumped|tired|exhausted|drained|fatigued|sleepy|sluggish)\\b/i.test(text)\n  if (!energySignal) return null\n  const energyAdjectives: Array<{ re: RegExp; value: number }> = [\n    { re: /\\b(energized|wired|pumped|high energy|very high energy)\\b/i, value: 8 },\n    { re: /\\b(great energy|good energy|solid energy)\\b/i, value: 7 },\n    { re: /\\b(okay energy|fine|average|medium)\\b/i, value: 5 },\n    { re: /\\b(low energy|tired|fatigued|sluggish)\\b/i, value: 3 },\n    { re: /\\b(exhausted|drained|wiped|spent)\\b/i, value: 2 },\n  ]\n  for (const entry of energyAdjectives) {\n    if (entry.re.test(text)) return entry.value\n  }\n  return null\n}\n\nfunction inferStressFromAdjectives(text: string) {\n  if (!/\\b(stress|stressed|overwhelmed|anxious|calm|relaxed)\\b/i.test(text)) return null\n  if (/\\b(calm|relaxed)\\b/i.test(text)) return 2\n  if (/\\b(overwhelmed|very stressed|extremely stressed)\\b/i.test(text)) return 8\n  if (/\\b(stressed|anxious)\\b/i.test(text)) return 7\n  return null\n}\n\nfunction extractTrackerTokens(text: string) {\n  const out: Array<{ name: string; value: number }> = []\n  for (const m of text.matchAll(/#([a-zA-Z][\\w/-]*)\\(([-+]?\\d*\\.?\\d+)\\)/g)) {\n    const name = m[1].toLowerCase()\n    if (name === 'sleep') continue\n    out.push({ name: m[1], value: Number(m[2]) })\n  }\n  for (const m of text.matchAll(/#([a-zA-Z][\\w/-]*):([-+]?\\d*\\.?\\d+)/g)) {\n    const name = m[1].toLowerCase()\n    if (name === 'sleep') continue\n    out.push({ name: m[1], value: Number(m[2]) })\n  }\n  const lower = text.toLowerCase()\n  const keys = ['mood', 'energy', 'stress', 'pain', 'anxiety', 'focus', 'motivation', 'productivity'] as const\n  for (const key of keys) {\n    if (out.some((t) => t.name.toLowerCase() === key)) continue\n    const value = parseRatingNearText(lower, key)\n    if (value != null) {\n      out.push({ name: key, value })\n    }\n  }\n  if (!out.some((t) => t.name.toLowerCase() === 'mood')) {\n    const moodValue = inferMoodFromAdjectives(lower)\n    if (moodValue != null) out.push({ name: 'mood', value: moodValue })\n  }\n  if (!out.some((t) => t.name.toLowerCase() === 'energy')) {\n    const energyValue = inferEnergyFromAdjectives(lower)\n    if (energyValue != null) out.push({ name: 'energy', value: energyValue })\n  }\n  if (!out.some((t) => t.name.toLowerCase() === 'stress')) {\n    const stressValue = inferStressFromAdjectives(lower)\n    if (stressValue != null) out.push({ name: 'stress', value: stressValue })\n  }\n  return out\n}\n\nfunction extractMoodMentions(text: string) {\n  const out: Array<{ value: number; hint: 'start' | 'now' | 'unknown' }> = []\n  const tokenPattern = String.raw`(?:\\d{1,2}|${NUMBER_WORD_PATTERN})`\n  const re = new RegExp(\n    String.raw`\\b(?:mood|feel(?:ing)?)\\b(?:\\s*(?:is|was|were|like|around|about|at|:)?\\s*)(${tokenPattern})(?:\\s*(?:-|to)\\s*(${tokenPattern}))?(?:\\s*\\/\\s*10)?`,\n    'gi',\n  )\n  for (const m of text.matchAll(re)) {\n    const value = parseRatingRange(m[1], m[2])\n    if (value == null) continue\n    const idx = m.index ?? 0\n    const window = text.slice(Math.max(0, idx - 16), Math.min(text.length, idx + m[0].length + 16)).toLowerCase()\n    const hint = /\\b(now|right now|currently|at the moment|after|later|end(?:ed)?|finished)\\b/.test(window)\n      ? 'now'\n      : /\\b(before|earlier|previously|start(?:ed|ing)?|begin(?:ning)?|at first)\\b/.test(window)\n        ? 'start'\n        : 'unknown'\n    out.push({ value: Math.max(0, Math.min(10, Math.round(value))), hint })\n  }\n  return out\n}\n\nfunction extractTaskLines(markdown: string) {\n  const titles: string[] = []\n  for (const line of markdown.split(/\\r?\\n/)) {\n    const checklist = line.match(/^\\s*[-*+]\\s*\\[( |x|X)\\]\\s*(.+)$/)\n    if (checklist?.[2]) {\n      titles.push(checklist[2].trim())\n      continue\n    }\n    if (!/(?:\\{task:[^}]+\\}|#task\\b)/i.test(line)) continue\n    const cleaned = line\n      .replace(/^\\s*[-*+]\\s+/, '')\n      .replace(/\\{task:[^}]+\\}/gi, '')\n      .replace(/\\s+#task\\b/gi, '')\n      .trim()\n    if (cleaned) titles.push(cleaned)\n  }\n  return titles.slice(0, 50)\n}\n\nasync function createTrackerLogsFromText(opts: {\n  text: string\n  atMs: number\n  sourceNoteId?: string\n  parentEventId?: string | null\n  events: CalendarEvent[]\n  ensureTrackerDefinition: (opts: { key: string; label?: string; icon?: IconName | null; color?: string | null; defaultValue?: number | null }) => TrackerDef | null\n  defaultTrackerUnit: (key: string) => TrackerDef['unit']\n  findBestActiveEventAt: (atMs: number) => Promise<CalendarEvent | null>\n  createEvent: typeof createEvent\n  setEvents: (value: SetStateAction<CalendarEvent[]>) => void\n}) {\n  const tokens = extractTrackerTokens(opts.text)\n  if (!tokens.length) return { created: 0, skipped: 0 }\n  const parentId =\n    typeof opts.parentEventId !== 'undefined'\n      ? opts.parentEventId\n      : (await opts.findBestActiveEventAt(opts.atMs))?.id ?? null\n  const createdKeys = new Set<string>()\n  let created = 0\n  let skipped = 0\n  for (const tok of tokens) {\n    const key = tok.name.trim().toLowerCase()\n    if (!key) continue\n    if (key === 'sleep') continue\n    const dedupeKey = `${key}|${opts.sourceNoteId ?? ''}`\n    if (createdKeys.has(dedupeKey)) continue\n    const already = opts.events.find((e) => e.kind === 'log' && e.trackerKey === key && e.sourceNoteId === opts.sourceNoteId)\n    if (already) {\n      skipped += 1\n      continue\n    }\n    const def = opts.ensureTrackerDefinition({ key })\n    const unit = def?.unit ?? opts.defaultTrackerUnit(key)\n    let value = typeof tok.value === 'number' && Number.isFinite(tok.value) ? tok.value : null\n    if (value != null) {\n      if (unit.step && unit.step > 0) value = Math.round(value / unit.step) * unit.step\n      if (unit.min != null) value = Math.max(unit.min, value)\n      if (unit.max != null) value = Math.min(unit.max, value)\n    }\n    if (value == null) continue\n    const label = def?.label ?? key\n    const unitSuffix = unit.label && unit.label !== 'value' && unit.label !== 'score' ? ` ${unit.label}` : ''\n    const title = `${label}: ${value}${unitSuffix}`\n    const log = await opts.createEvent({\n      title,\n      startAt: opts.atMs,\n      endAt: opts.atMs + 5 * 60 * 1000,\n      kind: 'log',\n      parentEventId: parentId,\n      tags: [`#${key}`],\n      sourceNoteId: opts.sourceNoteId ?? null,\n      trackerKey: key,\n      icon: def?.icon ?? null,\n      color: def?.color ?? null,\n      category: null,\n      subcategory: null,\n    })\n    opts.setEvents((prev) => [log, ...prev])\n    createdKeys.add(dedupeKey)\n    created += 1\n  }\n  return { created, skipped }\n}\n\nfunction parseCommaList(raw: string) {\n  return raw\n    .split(/[,\\n]+/)\n    .map((x) => x.trim())\n    .filter(Boolean)\n    .slice(0, 20)\n}\n\nfunction formatCommaList(values: string[] | null | undefined) {\n  return (values ?? []).join(', ')\n}\n\nconst CHARACTER_KEYS = ['STR', 'INT', 'CON', 'PER'] as const\n\nfunction normalizeCharacterKey(raw: string) {\n  const t = raw.trim().toLowerCase()\n  if (!t) return null\n  if (t === 'str' || t === 'strength') return 'STR'\n  if (t === 'int' || t === 'intelligence') return 'INT'\n  if (t === 'con' || t === 'constitution') return 'CON'\n  if (t === 'per' || t === 'perception') return 'PER'\n  return null\n}\n\nfunction normalizeCharacterSelection(values: string[] | null | undefined) {\n  const out: string[] = []\n  const seen = new Set<string>()\n  for (const v of values ?? []) {\n    const k = normalizeCharacterKey(v)\n    if (!k) continue\n    if (seen.has(k)) continue\n    seen.add(k)\n    out.push(k)\n  }\n  return out\n}\n\nfunction toggleCharacterSelection(values: string[] | null | undefined, key: (typeof CHARACTER_KEYS)[number]) {\n  const current = new Set(normalizeCharacterSelection(values))\n  if (current.has(key)) current.delete(key)\n  else current.add(key)\n  return [...current]\n}\n\nfunction extractTagTokens(rawText: string) {\n  const out = new Set<string>()\n  for (const m of rawText.matchAll(/#([a-zA-Z][\\w/-]*)(?!\\s*(\\(|:\\s*[-+]?\\d))/g)) out.add(m[1].toLowerCase())\n  return [...out].slice(0, 24)\n}\n\nfunction extractAtMentions(rawText: string) {\n  const out: Array<{ raw: string; before: string }> = []\n  for (const m of rawText.matchAll(/(^|[\\s(])@(?:\"([^\"]+)\"|'([^']+)'|([A-Za-z][\\w'\u2019-]*(?:\\s+[A-Za-z][\\w'\u2019-]*){0,3}))/g)) {\n    const before = (m[1] ?? '').toLowerCase()\n    const raw = (m[2] ?? m[3] ?? m[4] ?? '').trim()\n    if (!raw) continue\n    out.push({ raw, before })\n  }\n  return out.slice(0, 16)\n}\n\nfunction uniqStrings(values: string[]) {\n  const out: string[] = []\n  const seen = new Set<string>()\n  for (const v of values) {\n    const s = v.trim()\n    if (!s) continue\n    const k = s.toLowerCase()\n    if (seen.has(k)) continue\n    seen.add(k)\n    out.push(s)\n  }\n  return out\n}\n\nfunction formatMinutesSpan(totalMinutes: number) {\n  const mins = Math.max(0, Math.round(totalMinutes))\n  const h = Math.floor(mins / 60)\n  const m = mins % 60\n  if (h > 0) return `${h}h ${m}m`\n  return `${m}m`\n}\n\nconst PINNED_GROUP_ORDER_KEY = 'insight5.explorer.pinnedGroupOrder.v1'\nconst DEFAULT_PINNED_GROUP_ORDER = ['tasks', 'habits', 'trackers', 'shortcuts'] as const\n\nfunction loadPinnedGroupOrder() {\n  try {\n    const raw = localStorage.getItem(PINNED_GROUP_ORDER_KEY)\n    if (!raw) return [...DEFAULT_PINNED_GROUP_ORDER]\n    const parsed = JSON.parse(raw) as string[]\n    if (!Array.isArray(parsed)) return [...DEFAULT_PINNED_GROUP_ORDER]\n    const allowed = new Set(DEFAULT_PINNED_GROUP_ORDER)\n    const next = parsed.filter((k) => allowed.has(k as any))\n    for (const k of DEFAULT_PINNED_GROUP_ORDER) if (!next.includes(k)) next.push(k)\n    return next\n  } catch {\n    return [...DEFAULT_PINNED_GROUP_ORDER]\n  }\n}\n\nfunction savePinnedGroupOrder(order: string[]) {\n  try {\n    localStorage.setItem(PINNED_GROUP_ORDER_KEY, JSON.stringify(order))\n  } catch {\n    // ignore\n  }\n}\n\nfunction nextThemePref(current: ThemePreference): ThemePreference {\n  if (current === 'light') return 'dark'\n  if (current === 'dark') return 'system'\n  return 'light'\n}\n\nfunction extractImplicitPeople(rawText: string) {\n  const out: string[] = []\n  for (const m of rawText.matchAll(/\\bwith\\s+(?:(?:dr|doctor|mr|ms|mrs|prof|professor)\\.?\\s+)?([A-Z][\\w'\u2019.-]*(?:\\s+[A-Z][\\w'\u2019.-]*){0,2})\\b/gim)) {\n    const name = (m[1] ?? '').trim()\n    if (!name) continue\n    out.push(name)\n  }\n  for (const m of rawText.matchAll(/\\b(?:call|text|dm|email)\\s+(mom|dad|mother|father|wife|husband|partner)\\b/gim)) {\n    const raw = (m[1] ?? '').trim()\n    if (!raw) continue\n    out.push(raw[0]!.toUpperCase() + raw.slice(1).toLowerCase())\n  }\n  return uniqStrings(out).slice(0, 8)\n}\n\nfunction normalizePersonName(raw: string) {\n  const cleaned = raw\n    .replace(/^@+/, '')\n    .replace(/^[\\s,;:.!]+/, '')\n    .replace(/[\\s,;:.!]+$/, '')\n    .replace(/\\s+/g, ' ')\n    .trim()\n  if (!cleaned) return null\n  const relationMap: Record<string, string> = {\n    mom: 'Mom',\n    mother: 'Mother',\n    dad: 'Dad',\n    father: 'Father',\n    wife: 'Wife',\n    husband: 'Husband',\n    partner: 'Partner',\n  }\n  const dropWords = new Set([\n    'a',\n    'an',\n    'the',\n    'at',\n    'in',\n    'on',\n    'with',\n    'for',\n    'to',\n    'from',\n    'and',\n    'or',\n    'him',\n    'her',\n    'them',\n    'me',\n    'my',\n    'their',\n    'his',\n    'hers',\n    'i',\n    'im',\n    \"i'm\",\n    'talked',\n    'talking',\n    'met',\n    'see',\n    'saw',\n    'baby',\n  ])\n  const bannedWords = new Set([\n    'patient',\n    'patients',\n    'nurse',\n    'nursing',\n    'clinic',\n    'hospital',\n    'staff',\n    'team',\n    'coworker',\n    'coworkers',\n    'people',\n    'unit',\n    'room',\n    'chart',\n    'charting',\n    'shift',\n    'rounds',\n  ])\n  const titleWords = new Set(['dr', 'doctor', 'mr', 'mrs', 'ms', 'prof', 'professor', 'aunt', 'uncle'])\n  const parts = cleaned.split(' ').filter(Boolean)\n  while (parts.length && titleWords.has(parts[0]!.toLowerCase())) parts.shift()\n  const filtered = parts.filter((p) => !dropWords.has(p.toLowerCase()))\n  if (filtered.length === 0) return null\n  if (filtered.length > 3) return null\n  const joined = filtered.join(' ')\n  const lowerJoined = joined.toLowerCase()\n  if (relationMap[lowerJoined]) return relationMap[lowerJoined]\n  if (!/[A-Z]/.test(joined)) return null\n  if (filtered.some((p) => bannedWords.has(p.toLowerCase()))) return null\n  if (/^(he|she|they|him|her|them|someone|somebody|anyone|anybody|me|my)$/i.test(joined)) return null\n  if (!/[a-z]/i.test(joined)) return null\n  if (joined.length > 40) return null\n  return joined\n}\n\nfunction cleanPeopleList(values: string[]) {\n  const out: string[] = []\n  for (const raw of values) {\n    for (const piece of raw.split(/\\s*(?:,|&|and)\\s*/i)) {\n      const name = normalizePersonName(piece)\n      if (!name) continue\n      out.push(name)\n    }\n  }\n  return uniqStrings(out).slice(0, 12)\n}\n\nfunction escapeRegExp(text: string) {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction normalizeHabitKeyword(raw: string) {\n  const trimmed = raw.trim().replace(/^#/, '')\n  if (!trimmed) return null\n  if (trimmed.length < 3) return null\n  return trimmed.toLowerCase()\n}\n\nfunction buildHabitKeywordList(def: HabitDef) {\n  const keywords = new Set<string>()\n  const name = normalizeHabitKeyword(def.name ?? '')\n  if (name) keywords.add(name)\n  for (const tag of def.tags ?? []) {\n    const cleaned = normalizeHabitKeyword(tag)\n    if (cleaned) keywords.add(cleaned)\n  }\n  const category = normalizeHabitKeyword(def.category ?? '')\n  if (category) keywords.add(category)\n  const subcategory = normalizeHabitKeyword(def.subcategory ?? '')\n  if (subcategory) keywords.add(subcategory)\n\n  const joined = [...keywords].join(' ')\n  const workoutLike = /\\b(workout|exercise|gym)\\b/i.test(joined)\n  if (workoutLike) {\n    ;[\n      'workout',\n      'work out',\n      'exercise',\n      'gym',\n      'run',\n      'running',\n      'ran',\n      'jog',\n      'jogging',\n      'lift',\n      'lifting',\n      'weights',\n      'push up',\n      'pushup',\n      'pull up',\n      'pullup',\n      'squat',\n      'squats',\n      'deadlift',\n      'bench',\n      'cardio',\n    ].forEach((k) => keywords.add(k))\n  }\n\n  return Array.from(keywords)\n}\n\nfunction habitMatchesText(text: string, def: HabitDef) {\n  const lower = text.toLowerCase()\n  for (const keyword of buildHabitKeywordList(def)) {\n    const escaped = escapeRegExp(keyword).replace(/\\s+/g, String.raw`\\\\s+`)\n    const rx = new RegExp(String.raw`\\\\b${escaped}\\\\b`, 'i')\n    if (rx.test(lower)) return true\n  }\n  return false\n}\n\nfunction detectHabitMentions(text: string, defs: HabitDef[]) {\n  return defs.filter((h) => habitMatchesText(text, h))\n}\n\nfunction detectHabitMentionsWithPolarity(text: string, defs: HabitDef[]) {\n  const sentences = text.split(/[\\n.!?;]+/).map((s) => s.trim()).filter(Boolean)\n  const negationRe = /\\b(didn['\u2019]?t|did not|skip(?:ped)?|miss(?:ed)?|couldn['\u2019]?t|could not|wasn['\u2019]?t able|was not able|did not do)\\b/i\n  const states = new Map<string, { habit: HabitDef; pos: boolean; neg: boolean }>()\n\n  for (const sentence of sentences) {\n    const hasNegation = negationRe.test(sentence)\n    for (const habit of defs) {\n      if (!habitMatchesText(sentence, habit)) continue\n      const state = states.get(habit.id) ?? { habit, pos: false, neg: false }\n      if (hasNegation) state.neg = true\n      else state.pos = true\n      states.set(habit.id, state)\n    }\n  }\n\n  return Array.from(states.values()).map((state) => ({\n    habit: state.habit,\n    polarity: state.pos ? 'positive' : 'negative',\n  }))\n}\n\nfunction extractImplicitPlaces(rawText: string) {\n  const out: string[] = []\n  const banned = new Set(['AM', 'PM', 'Today', 'Tomorrow', 'Yesterday', 'I'])\n  for (const m of rawText.matchAll(/\\b(?:at|in|to)\\s+([A-Z][\\w'\u2019.-]*(?:\\s+[A-Z][\\w'\u2019.-]*){0,4})\\b/g)) {\n    const name = (m[1] ?? '').trim()\n    if (!name) continue\n    if (banned.has(name)) continue\n    out.push(name)\n  }\n  const commonPlaceMap: Record<string, string> = {\n    gym: 'Gym',\n    bank: 'Bank',\n    clinic: 'Clinic',\n    hospital: 'Hospital',\n    er: 'ER',\n    home: 'Home',\n    work: 'Work',\n    office: 'Office',\n  }\n  for (const m of rawText.matchAll(/\\b(?:at|in|to)\\s+(?:the\\s+)?(gym|bank|clinic|hospital|er|home|work|office)\\b/gim)) {\n    const key = (m[1] ?? '').trim().toLowerCase()\n    const mapped = commonPlaceMap[key]\n    if (mapped) out.push(mapped)\n  }\n  return uniqStrings(out).slice(0, 8)\n}\n\nfunction extractMoneyUsd(rawText: string) {\n  const t = rawText.toLowerCase()\n  const usd = t.match(/\\$\\s*(\\d+(?:\\.\\d{1,2})?)/)?.[1]\n  if (usd) return Number(usd)\n  const dollars = t.match(/\\b(\\d+(?:\\.\\d{1,2})?)\\s*(?:dollars|bucks)\\b/)?.[1]\n  if (dollars) return Number(dollars)\n  const spend = t.match(/\\bspend\\s*(?:about\\s*)?(\\d+(?:\\.\\d{1,2})?)\\b/)?.[1]\n  if (spend) return Number(spend)\n  return null\n}\n\nfunction extractShoppingItems(rawText: string) {\n  const m = rawText.match(/\\b(?:buy|get|pick up|grab)\\b\\s+([^.;\\n]+)/i)?.[1]\n  if (!m) return []\n  const cut = m.split(/\\b(?:at|in|to|with|for|tomorrow|today|next|on)\\b/i)[0] ?? m\n  return uniqStrings(\n    cut\n      .split(/,|\\band\\b/i)\n      .map((x) => x.trim())\n      .filter(Boolean),\n  ).slice(0, 12)\n}\n\nfunction buildShoppingNotes(items: string[], moneyUsd: number | null) {\n  const lines: string[] = []\n  if (items.length) {\n    lines.push('| Item | Cost |')\n    lines.push('| --- | --- |')\n    lines.push(...items.map((x) => `| ${x} |  |`))\n  }\n  if (moneyUsd != null && Number.isFinite(moneyUsd)) lines.push(`Total budget: $${moneyUsd}`)\n  return lines.join('\\n')\n}\n\ntype TranscriptLine = { time: string; text: string; line: string }\n\nfunction parseTimestampedTranscript(rawText: string | null | undefined) {\n  if (!rawText) return []\n  const out: TranscriptLine[] = []\n  for (const line of rawText.split(/\\r?\\n/)) {\n    const match = line.match(/^\\s*(?:[-*]\\s*)?\\[(\\d{1,2}:\\d{2})\\]\\s*(.+)\\s*$/)\n    if (!match) continue\n    out.push({ time: match[1], text: match[2], line })\n  }\n  return out\n}\n\nfunction isTextInputTarget(target: EventTarget | null) {\n  const el = target as HTMLElement | null\n  if (!el) return false\n  const tag = el.tagName?.toLowerCase()\n  if (tag === 'input' || tag === 'textarea' || tag === 'select') return true\n  return Boolean(el.isContentEditable)\n}\n\nfunction App() {\n  const [captures, setCaptures] = useState<InboxCapture[]>([])\n  const [tasks, setTasks] = useState<Task[]>([])\n  const [events, setEvents] = useState<CalendarEvent[]>([])\n  const eventsRef = useRef<CalendarEvent[]>([])\n  const [authSession, setAuthSession] = useState<Session | null>(null)\n  const [authReady, setAuthReady] = useState(false)\n  const [authEmail, setAuthEmail] = useState('')\n  const [authPassword, setAuthPassword] = useState('')\n  const [authMode, setAuthMode] = useState<'signin' | 'signup'>('signin')\n  const [authError, setAuthError] = useState('')\n  const [authStatus, setAuthStatus] = useState('')\n  const [authWorking, setAuthWorking] = useState(false)\n  const [authDismissed, setAuthDismissed] = useState(false)\n  const supabaseConfigured = Boolean(getSupabaseClient())\n  const taxonomyRulesRef = useRef<TaxonomyRule[]>([])\n  const [trackerDefs, setTrackerDefs] = useState<TrackerDef[]>(() => loadTrackerDefs())\n\n  function defaultTrackerUnit(key: string): TrackerDef['unit'] {\n    const normalized = key.trim().toLowerCase()\n    if (['mood', 'energy', 'stress', 'pain', 'focus'].includes(normalized)) {\n      return { label: 'score', min: 1, max: 10, step: 1, presets: [1, 5, 7, 10] }\n    }\n    if (normalized.includes('water') || normalized.includes('hydration')) {\n      return { label: 'oz', min: 0, max: 200, step: 1, presets: [8, 16, 24, 32, 64] }\n    }\n    return { label: 'value', min: null, max: null, step: null, presets: [] }\n  }\n\n  function buildTrackerDef(opts: { key: string; label?: string; icon?: IconName | null; color?: string | null; defaultValue?: number | null }) {\n    const key = opts.key.trim().toLowerCase()\n    const now = Date.now()\n    const def: TrackerDef = {\n      id: `trk_${key}_${now}`,\n      key,\n      label: (opts.label ?? toTitleCase(key)).trim() || key,\n      createdAt: now,\n      defaultValue: opts.defaultValue ?? null,\n      icon: opts.icon ?? null,\n      color: opts.color ?? null,\n      unit: defaultTrackerUnit(key),\n      meta: emptySharedMeta(),\n    }\n    return def\n  }\n\n  function ensureTrackerDefinition(opts: { key: string; label?: string; icon?: IconName | null; color?: string | null; defaultValue?: number | null }) {\n    const key = opts.key.trim().toLowerCase()\n    if (!key) return null\n    const existing = loadTrackerDefs().find((t) => t.key === key)\n    if (existing) return existing\n    const next = buildTrackerDef(opts)\n    upsertTrackerDef(next)\n    setTrackerDefs(loadTrackerDefs())\n    return next\n  }\n\n  const [captureOpen, setCaptureOpen] = useState(false)\n  const [captureDraft, setCaptureDraft] = useState('')\n  const [captureInterim, setCaptureInterim] = useState('')\n  const [captureAttachEventId, setCaptureAttachEventId] = useState<string | null>(null)\n\t\t  const [captureListening, setCaptureListening] = useState(false)\n\t\t  const [captureSaving, setCaptureSaving] = useState(false)\n\t\t  const [captureAiStatus, setCaptureAiStatus] = useState<string>('')\n\t\t  const [captureError, setCaptureError] = useState<string>('')\n  const [captureProgress, setCaptureProgress] = useState<string[]>([])\n  const [captureAnchorMs, setCaptureAnchorMs] = useState<number>(() => Date.now())\n  const [captureReturnView, setCaptureReturnView] = useState<WorkspaceViewKey | null>(null)\n  const [captureExtendedMode, setCaptureExtendedMode] = useState(false)\n\n  // Refs for voice capture toggle behavior\n  const speechRecognitionRef = useRef<any>(null)\n  const shouldListenRef = useRef(false)\n  const captureTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  const trackerExtractionTimeoutRef = useRef<Record<string, number>>({})\n\n  useEffect(() => {\n    const supabase = getSupabaseClient()\n    if (!supabase) {\n      setAuthReady(true)\n      return\n    }\n    let mounted = true\n\n    async function runInitialSync() {\n      const { data } = await supabase.auth.getSession()\n      if (!mounted) return\n      setAuthSession(data.session ?? null)\n      setAuthReady(true)\n      if (!data.session) return\n      await migrateLocalDataToSupabase()\n      await pullSupabaseToLocal()\n    }\n\n    void runInitialSync()\n\n    const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {\n      if (!mounted) return\n      setAuthSession(session ?? null)\n      if (!session) return\n      void migrateLocalDataToSupabase().then(() => pullSupabaseToLocal())\n    })\n\n    const interval = window.setInterval(() => {\n      supabase.auth.getSession().then(({ data }) => {\n        if (!data.session) return\n        void pullSupabaseToLocal()\n      })\n    }, 120000)\n\n    return () => {\n      mounted = false\n      listener?.subscription?.unsubscribe()\n      window.clearInterval(interval)\n    }\n  }, [])\n\n  useEffect(() => {\n    eventsRef.current = events\n  }, [events])\n\n  useEffect(() => {\n    if (authSession) {\n      setAuthDismissed(false)\n    }\n  }, [authSession])\n\n  const [agendaDate, setAgendaDate] = useState<Date>(() => new Date())\n  const [timelineTagFilters, setTimelineTagFilters] = useState<string[]>([])\n\n  const [selection, setSelection] = useState<Selection>({ kind: 'none' })\n  const selectedEventId = selection.kind === 'event' ? selection.id : null\n  const [selectedGoal, setSelectedGoal] = useState<string | null>(null)\n  const [selectedProject, setSelectedProject] = useState<string | null>(null)\n  const [selectedTrackerKey, setSelectedTrackerKey] = useState<string | null>(null)\n\n  const [leftCollapsed, setLeftCollapsed] = useState(false)\n  const [rightCollapsed, setRightCollapsed] = useState(false)\n  const [railLabelsOpen, setRailLabelsOpen] = useState(false)\n  const [rightMode, setRightMode] = useState<'details' | 'ai'>('details')\n  const rightPanelHideViews = useMemo<Set<WorkspaceViewKey>>(\n    () => new Set(['ecosystem', 'habits', 'goals', 'goal-detail', 'notes']),\n    [],\n  )\n  const [propsCollapsed, setPropsCollapsed] = useState(true)\n  const [docOpen, setDocOpen] = useState(false)\n  const [docTab, setDocTab] = useState<'notes' | 'transcript'>('notes')\n  const [docTranscriptFocus, setDocTranscriptFocus] = useState<string | null>(null)\n  const [themePref, setThemePref] = useState<ThemePreference>(() => loadThemePreference())\n  const [eventTitleDetail, setEventTitleDetail] = useState<EventTitleDetail>(() => loadDisplaySettings().eventTitleDetail)\n\n  const [tagDraft, setTagDraft] = useState('')\n  const [peopleDraft, setPeopleDraft] = useState('')\n  const [locationDraft, setLocationDraft] = useState('')\n  const [contextDraft, setContextDraft] = useState('')\n  const [skillDraft, setSkillDraft] = useState('')\n  const [composerTagDraft, setComposerTagDraft] = useState('')\n  const [composerPeopleDraft, setComposerPeopleDraft] = useState('')\n  const [composerLocationDraft, setComposerLocationDraft] = useState('')\n  const [composerListening, setComposerListening] = useState(false)\n  const [composerInterim, setComposerInterim] = useState('')\n\n  const [eventComposerOpen, setEventComposerOpen] = useState(false)\n  const [eventComposer, setEventComposer] = useState<EventComposerDraft>(() => ({\n    title: '',\n    startAt: Date.now(),\n    endAt: Date.now() + 60 * 60 * 1000,\n    kind: 'event',\n    allDay: false,\n    active: false,\n    icon: null,\n    color: null,\n    tagsRaw: '',\n    location: '',\n    peopleRaw: '',\n    skillsRaw: '',\n    character: [],\n    category: '',\n    subcategory: '',\n    importance: 5,\n    difficulty: 5,\n    estimateMinutesRaw: '60',\n    notes: '',\n    taskId: null,\n    trackerKey: '',\n  }))\n\n  const [explorerPinnedOpen, setExplorerPinnedOpen] = useState(true)\n  const [explorerPinnedTasksOpen, setExplorerPinnedTasksOpen] = useState(true)\n  const [explorerPinnedHabitsOpen, setExplorerPinnedHabitsOpen] = useState(true)\n  const [explorerPinnedTrackersOpen, setExplorerPinnedTrackersOpen] = useState(true)\n  const [explorerPinnedShortcutsOpen, setExplorerPinnedShortcutsOpen] = useState(true)\n  const [pinnedGroupOrder, setPinnedGroupOrder] = useState(() => loadPinnedGroupOrder())\n  const [dragPinnedKey, setDragPinnedKey] = useState<string | null>(null)\n\n  useEffect(() => {\n    savePinnedGroupOrder(pinnedGroupOrder)\n  }, [pinnedGroupOrder])\n  const [explorerRecentOpen, setExplorerRecentOpen] = useState(true)\n  const [explorerPomoOpen, setExplorerPomoOpen] = useState(true)\n  const [explorerTaskQuery, setExplorerTaskQuery] = useState('')\n  const [explorerTaskDraft, setExplorerTaskDraft] = useState('')\n  const [habitDefs, setHabitDefs] = useState<HabitDef[]>(() => loadHabitDefsFromStorage())\n\n  useEffect(() => {\n    const resolved = resolveTheme(themePref)\n    applyTheme(resolved)\n    saveThemePreference(themePref)\n    if (themePref !== 'system') return\n    const media = window.matchMedia?.('(prefers-color-scheme: dark)')\n    if (!media) return\n    const onChange = () => applyTheme(resolveTheme('system'))\n    if (media.addEventListener) media.addEventListener('change', onChange)\n    else media.addListener?.(onChange)\n    return () => {\n      if (media.removeEventListener) media.removeEventListener('change', onChange)\n      else media.removeListener?.(onChange)\n    }\n  }, [themePref])\n\n  useEffect(() => {\n    function onThemeChanged() {\n      setThemePref(loadThemePreference())\n    }\n    window.addEventListener(THEME_CHANGED_EVENT, onThemeChanged)\n    return () => window.removeEventListener(THEME_CHANGED_EVENT, onThemeChanged)\n  }, [])\n\n  useEffect(() => {\n    function onDisplayChanged() {\n      setEventTitleDetail(loadDisplaySettings().eventTitleDetail)\n    }\n    window.addEventListener(DISPLAY_SETTINGS_CHANGED_EVENT, onDisplayChanged)\n    return () => window.removeEventListener(DISPLAY_SETTINGS_CHANGED_EVENT, onDisplayChanged)\n  }, [])\n\n  // Global keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Cmd/Ctrl + K: Open capture modal\n      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {\n        e.preventDefault()\n        setCaptureOpen(true)\n        toast.info('Quick capture opened', { duration: 1500 })\n      }\n\n      // Escape: Close modals\n      if (e.key === 'Escape') {\n        if (captureOpen) {\n          setCaptureOpen(false)\n        }\n        if (eventComposerOpen) {\n          setEventComposerOpen(false)\n        }\n        if (selection.kind !== 'none') {\n          setSelection({ kind: 'none' })\n        }\n      }\n\n      // Cmd/Ctrl + Shift + H: Go to habits\n      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'h') {\n        e.preventDefault()\n        openView('habits')\n        toast.info('Navigated to Habits', { duration: 1500 })\n      }\n\n      // Cmd/Ctrl + Shift + D: Go to dashboard\n      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'd') {\n        e.preventDefault()\n        openView('dashboard')\n        toast.info('Navigated to Dashboard', { duration: 1500 })\n      }\n\n      // Cmd/Ctrl + Shift + R: Go to rewards\n      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'r') {\n        e.preventDefault()\n        openView('rewards')\n        toast.info('Navigated to Rewards', { duration: 1500 })\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [captureOpen, eventComposerOpen, selection])\n\n  useEffect(() => {\n    function refreshHabits() {\n      setHabitDefs(loadHabitDefsFromStorage())\n    }\n    window.addEventListener(HABITS_UPDATED_EVENT, refreshHabits)\n    window.addEventListener('storage', refreshHabits)\n    return () => {\n      window.removeEventListener(HABITS_UPDATED_EVENT, refreshHabits)\n      window.removeEventListener('storage', refreshHabits)\n    }\n  }, [])\n\n  useEffect(() => {\n    const stored = loadTrackerDefs()\n    const byKey = new Map<string, TrackerDef>()\n    for (const def of stored) byKey.set(def.key, def)\n\n    let changed = false\n    for (const e of events) {\n      if (e.kind !== 'log') continue\n      if (e.trackerKey?.startsWith('habit:')) continue\n      const key = (e.trackerKey ?? '').trim().toLowerCase()\n      if (key && !byKey.has(key)) {\n        byKey.set(key, buildTrackerDef({ key }))\n        changed = true\n      }\n      for (const tag of e.tags ?? []) {\n        const clean = tag.replace(/^#/, '').trim().toLowerCase()\n        if (!clean || clean === 'habit') continue\n        if (!byKey.has(clean)) {\n          byKey.set(clean, buildTrackerDef({ key: clean }))\n          changed = true\n        }\n      }\n    }\n\n    const next = Array.from(byKey.values()).slice(0, 24)\n    if (changed) saveTrackerDefs(next)\n    setTrackerDefs(next)\n  }, [events])\n\n  useEffect(() => {\n    setTagDraft('')\n    setPeopleDraft('')\n    setLocationDraft('')\n    setContextDraft('')\n    setSkillDraft('')\n  }, [selection.kind, selection.id])\n\n  useEffect(() => {\n    if (!eventComposerOpen) return\n    setComposerTagDraft('')\n    setComposerPeopleDraft('')\n    setComposerLocationDraft('')\n    setComposerListening(false)\n    setComposerInterim('')\n  }, [eventComposerOpen])\n\n  const [workspace, setWorkspace] = useState<PaneState>(() => {\n    const dashId = makeTabId('dashboard')\n    const notesId = makeTabId('notes')\n    const tasksId = makeTabId('tasks')\n    const calendarId = makeTabId('calendar')\n    return {\n      tabs: [\n        { id: dashId, title: defaultTabTitle('dashboard'), view: 'dashboard' },\n        { id: notesId, title: defaultTabTitle('notes'), view: 'notes' },\n        { id: tasksId, title: defaultTabTitle('tasks'), view: 'tasks' },\n        { id: calendarId, title: defaultTabTitle('calendar'), view: 'calendar' },\n      ],\n      activeTabId: notesId,\n    }\n  })\n\n  useEffect(() => {\n    const view = getActiveTab(workspace)?.view\n    if (view && rightPanelHideViews.has(view)) {\n      setRightCollapsed(true)\n    }\n  }, [rightPanelHideViews, workspace.activeTabId, workspace.tabs])\n\n  async function refreshAll() {\n    const [c, t, e] = await Promise.all([listInboxCaptures(), listTasks(), listEvents()])\n    setCaptures(c)\n    setTasks(t)\n    setEvents(e)\n  }\n\n  useEffect(() => {\n    void refreshAll()\n  }, [])\n\n  useEffect(() => {\n    const { rules } = loadTaxonomyRules()\n    taxonomyRulesRef.current = rules\n    function onRulesChanged() {\n      taxonomyRulesRef.current = loadTaxonomyRules().rules\n    }\n    window.addEventListener(TAXONOMY_RULES_CHANGED_EVENT, onRulesChanged)\n    return () => window.removeEventListener(TAXONOMY_RULES_CHANGED_EVENT, onRulesChanged)\n  }, [])\n\n  function openCapture(opts?: { attachEventId?: string | null }) {\n    const nowMs = Date.now()\n    const attached = opts?.attachEventId ? events.find((e) => e.id === opts.attachEventId) ?? null : null\n    const activeTab = getActiveTab(workspace)\n    let anchorMs = nowMs\n    if (attached?.startAt) {\n      anchorMs = attached.startAt\n    } else if (activeTab?.view === 'calendar') {\n      const base = new Date(agendaDate)\n      const now = new Date(nowMs)\n      base.setHours(now.getHours(), now.getMinutes(), 0, 0)\n      anchorMs = base.getTime()\n    }\n    setCaptureAnchorMs(anchorMs)\n    setCaptureProgress([])\n    setCaptureReturnView(activeTab?.view ?? null)\n    setCaptureAttachEventId(opts?.attachEventId ?? null)\n    setCaptureOpen(true)\n  }\n\n  async function onUpdateCapture(id: string, rawText: string) {\n    await updateCaptureText(id, rawText)\n    setCaptures((prev) => prev.map((c) => (c.id === id ? { ...c, rawText } : c)))\n  }\n\n  function appendTimestampedLine(existing: string | null | undefined, atMs: number, text: string) {\n    const trimmed = text.trim()\n    if (!trimmed) return existing ?? ''\n    const d = new Date(atMs)\n    const hh = String(d.getHours()).padStart(2, '0')\n    const mm = String(d.getMinutes()).padStart(2, '0')\n    const line = `- [${hh}:${mm}] ${trimmed}`\n    const base = (existing ?? '').trimEnd()\n    return base ? `${base}\\n${line}` : line\n  }\n\n  function noteItemTokenId(notes?: string | null) {\n    const match = notes?.match(/\\btoken:([A-Za-z0-9_-]+)\\b/)\n    return match?.[1] ?? null\n  }\n\n  function normalizeTaskTitle(raw: string) {\n    return raw.trim().toLowerCase().replace(/\\s+/g, ' ')\n  }\n\n  function appendTokenToNotes(notes: string | null | undefined, tokenId: string) {\n    const base = notes ?? ''\n    if (!tokenId) return base\n    const tokenRe = new RegExp(String.raw`\\btoken:${escapeRegExp(tokenId)}\\b`)\n    if (tokenRe.test(base)) return base\n    const trimmed = base.trimEnd()\n    return trimmed ? `${trimmed}\\n token:${tokenId}` : `token:${tokenId}`\n  }\n\n  const NOTE_ITEM_INLINE_RE = /\\{(task|habit):([^\\s}]+)[^}]*\\}/i\n\n  function detectInlineItemKind(rawLine: string): NoteItemKind | null {\n    const tokenMatch = rawLine.match(NOTE_ITEM_INLINE_RE)\n    if (tokenMatch?.[1]) return tokenMatch[1] as NoteItemKind\n    if (/#habit\\b/i.test(rawLine)) return 'habit'\n    if (/#task\\b/i.test(rawLine)) return 'task'\n    return null\n  }\n\n  function deriveNoteItemTitle(rawLine: string) {\n    const cleaned = rawLine\n      .replace(/\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g, '')\n      .replace(/[#@!*^$~][^\\s{]+\\{[^}]+\\}/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim()\n    return cleaned.replace(/^[-*+]\\s*(?:\\[[ xX]\\]\\s*)?/, '').replace(/\\s+#(?:task|habit)\\b/gi, '').trim()\n  }\n\n  function makeNoteItemTokenId(kind: NoteItemKind, title: string) {\n    const slug = title\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/^-+|-+$/g, '')\n      .slice(0, 32) || 'item'\n    return `${kind}_${slug}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`\n  }\n\n  function ensureNoteItemTokenInNotes(\n    notes: string | null | undefined,\n    lineIndex: number | null | undefined,\n    kind: NoteItemKind,\n    title: string,\n  ) {\n    const raw = notes ?? ''\n    if (lineIndex == null) return { notes: raw, tokenId: '', line: '' }\n    const lines = raw.split(/\\r?\\n/)\n    const line = lines[lineIndex] ?? ''\n    const match = line.match(NOTE_ITEM_INLINE_RE)\n    if (match?.[2]) return { notes: raw, tokenId: match[2], line }\n    const tokenId = makeNoteItemTokenId(kind, title)\n    const token = `{${kind}:${tokenId}}`\n    lines[lineIndex] = line.trimEnd() ? `${line.trimEnd()} ${token}` : token\n    return { notes: lines.join('\\n'), tokenId, line: lines[lineIndex] ?? line }\n  }\n\n  function formatNoteItemTimestamp(ms: number) {\n    const d = new Date(ms)\n    const yyyy = d.getFullYear()\n    const mm = String(d.getMonth() + 1).padStart(2, '0')\n    const dd = String(d.getDate()).padStart(2, '0')\n    const hh = String(d.getHours()).padStart(2, '0')\n    const min = String(d.getMinutes()).padStart(2, '0')\n    return `${yyyy}-${mm}-${dd}T${hh}:${min}`\n  }\n\n  function upsertNoteItemMeta(line: string, key: string, value: string) {\n    const match = line.match(NOTE_ITEM_INLINE_RE)\n    if (!match) return line\n    const kind = match[1]\n    const tokenId = match[2]\n    const meta = (match[3] ?? '').trim()\n    const keyRe = new RegExp(String.raw`\\b${key}:[^\\s}]+`)\n    const nextMeta = keyRe.test(meta)\n      ? meta.replace(keyRe, `${key}:${value}`)\n      : `${meta} ${key}:${value}`.trim()\n    const replacement = `{${kind}:${tokenId}${nextMeta ? ` ${nextMeta}` : ''}}`\n    return line.replace(match[0], replacement)\n  }\n\n  function removeNoteItemMeta(line: string, key: string) {\n    const match = line.match(NOTE_ITEM_INLINE_RE)\n    if (!match) return line\n    const kind = match[1]\n    const tokenId = match[2]\n    const meta = (match[3] ?? '').trim()\n    const keyRe = new RegExp(String.raw`\\s*\\b${key}:[^\\s}]+`)\n    const nextMeta = meta.replace(keyRe, '').trim()\n    const replacement = `{${kind}:${tokenId}${nextMeta ? ` ${nextMeta}` : ''}}`\n    return line.replace(match[0], replacement)\n  }\n\n  function updateNoteItemLine(\n    notes: string | null | undefined,\n    lineIndex: number | null | undefined,\n    update: (line: string) => string,\n  ) {\n    const raw = notes ?? ''\n    if (lineIndex == null) return { notes: raw, line: '' }\n    const lines = raw.split(/\\r?\\n/)\n    const line = lines[lineIndex] ?? ''\n    const nextLine = update(line)\n    lines[lineIndex] = nextLine\n    return { notes: lines.join('\\n'), line: nextLine }\n  }\n\n  function extractNoteItemLine(notes: string | null | undefined, lineIndex: number) {\n    const lines = (notes ?? '').split(/\\r?\\n/)\n    return lines[lineIndex] ?? ''\n  }\n\n  function extractLineTokenCollections(rawLine: string) {\n    const cleaned = rawLine.replace(/\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g, '')\n    return toTokenCollections(extractInlineTokens(cleaned))\n  }\n\n  function appendMarkdownBlock(existing: string | null | undefined, block: string) {\n    const trimmed = block.trim()\n    if (!trimmed) return (existing ?? '').trimEnd()\n    const base = (existing ?? '').trimEnd()\n    return base ? `${base}\\n\\n---\\n\\n${trimmed}` : trimmed\n  }\n\n  function normalizeTaskChecklistNotes(notes: string | null | undefined) {\n    const raw = notes ?? ''\n    if (!raw.trim()) return raw\n    const lines = raw.split(/\\r?\\n/)\n    let changed = false\n    const next = lines.map((line) => {\n      const trimmed = line.trimStart()\n      if (!/^[-*+]\\s+/.test(trimmed)) return line\n      if (/^[-*+]\\s*\\[[ xX]\\]\\s+/.test(trimmed)) return line\n      if (!/(?:\\{task:[^}]+\\}|\\{habit:[^}]+\\}|#task\\b|#habit\\b)/i.test(line)) return line\n      const indent = line.match(/^\\s*/)?.[0] ?? ''\n      const rest = trimmed.replace(/^[-*+]\\s+/, '')\n      changed = true\n      return `${indent}- [ ] ${rest}`\n    })\n    return changed ? next.join('\\n') : raw\n  }\n\n  function inferDifficultyFromText(text: string) {\n    const t = text.toLowerCase()\n    if (/\\bmarathon|half[-\\s]?marathon\\b/.test(t)) return 10\n    const miles = t.match(/\\b(\\d+(?:\\.\\d+)?)\\s*(mi|mile|miles|km|kilometer|kilometers)\\b/)\n    if (miles?.[1]) {\n      const dist = Number(miles[1])\n      if (Number.isFinite(dist)) {\n        if (dist >= 10) return 9\n        if (dist >= 5) return 8\n        if (dist >= 3) return 7\n      }\n    }\n    const reps = t.match(/\\b(\\d{2,})\\s*(pushups|situps|burpees|squats)\\b/)\n    if (reps?.[1]) {\n      const count = Number(reps[1])\n      if (Number.isFinite(count)) {\n        if (count >= 200) return 9\n        if (count >= 100) return 8\n        if (count >= 50) return 7\n      }\n    }\n    if (/\\b(brutal|exhausting|wrecked|destroyed)\\b/.test(t)) return 9\n    if (/\\b(hard|tough|intense|stressful|rough)\\b/.test(t)) return 8\n    if (/\\b(challenging)\\b/.test(t)) return 7\n    if (/\\b(workout|gym|lift|lifting|run|running|cardio|training)\\b/.test(t)) return 6\n    if (/\\b(normal|okay)\\b/.test(t)) return 5\n    if (/\\b(easy|light|chill)\\b/.test(t)) return 3\n    return null\n  }\n\n  function inferImportanceFromText(text: string) {\n    const t = text.toLowerCase()\n    if (/\\b(critical|urgent|life[-\\s]?changing)\\b/.test(t)) return 10\n    if (/\\b(deadline|exam|interview|surgery|presentation)\\b/.test(t)) return 9\n    if (/\\b(important|major|big|huge|milestone)\\b/.test(t)) return 8\n    if (/\\b(work|clinic|patients|meeting|rounds|inpatient)\\b/.test(t)) return 7\n    if (/\\b(good|productive)\\b/.test(t)) return 6\n    if (/\\b(minor|small|trivial)\\b/.test(t)) return 3\n    return null\n  }\n\n  function inferCharacterFromText(text: string, tags: string[] = []) {\n    const t = `${text} ${tags.join(' ')}`.toLowerCase()\n    const out = new Set<(typeof CHARACTER_KEYS)[number]>()\n    if (/\\b(workout|gym|lift|weights|strength|pushups|squats)\\b/.test(t)) out.add('STR')\n    if (/\\b(run|cardio|walk|stairs|endurance|long)\\b/.test(t)) out.add('CON')\n    if (/\\b(study|read|reading|learn|code|research|write|writing)\\b/.test(t)) out.add('INT')\n    if (/\\b(meet|meeting|call|talk|chat|social|family|friends)\\b/.test(t)) out.add('PER')\n    return [...out]\n  }\n\n  function pointsForEventAt(ev: CalendarEvent, nowMs: number) {\n    const base = basePoints(ev.importance, ev.difficulty)\n    if (base <= 0) return 0\n    const endAt = ev.active ? nowMs : ev.endAt\n    const minutes = Math.max(0, Math.round((endAt - ev.startAt) / (60 * 1000)))\n    const mult = multiplierFor(ev.goal ?? null, ev.project ?? null)\n    return pointsForMinutes(base, minutes, mult)\n  }\n\n  function autoFillEventFromText(ev: CalendarEvent) {\n    const base = `${ev.title ?? ''}\\n${ev.notes ?? ''}`.trim()\n    if (!base) return\n    const detectedTags = extractTagTokens(base).map((t) => normalizeHashTag(t))\n    const mergedTags = uniqStrings([...(ev.tags ?? []), ...detectedTags].map(normalizeHashTag).filter(Boolean))\n    const mentions = extractAtMentions(base).map((m) => m.raw)\n    const nextPeople = uniqStrings([...(ev.people ?? []), ...mentions])\n    const duration = extractDurationToken(base)\n    const nextEstimate = ev.estimateMinutes ?? duration ?? null\n    const inferred = inferCategorySubcategoryLoose(base, mergedTags)\n    const nextImportance = ev.importance ?? inferImportanceFromText(base) ?? 5\n    const nextDifficulty = ev.difficulty ?? inferDifficultyFromText(base) ?? 5\n    commitEvent({\n      ...ev,\n      tags: mergedTags,\n      people: nextPeople,\n      estimateMinutes: nextEstimate,\n      category: ev.category ?? inferred.category ?? null,\n      subcategory: ev.subcategory ?? inferred.subcategory ?? null,\n      importance: nextImportance,\n      difficulty: nextDifficulty,\n    })\n  }\n\n  function autoFillComposerFromText() {\n    const base = `${eventComposer.title ?? ''}\\n${eventComposer.notes ?? ''}`.trim()\n    if (!base) return\n    const detectedTags = extractTagTokens(base).map((t) => normalizeHashTag(t))\n    const mergedTags = uniqStrings([...composerTagList, ...detectedTags].map(normalizeHashTag).filter(Boolean))\n    const mentions = extractAtMentions(base).map((m) => m.raw)\n    const nextPeople = uniqStrings([...composerPeopleList, ...mentions])\n    const duration = extractDurationToken(base)\n    const inferred = inferCategorySubcategoryLoose(base, mergedTags)\n    const nextImportance = eventComposer.importance ?? inferImportanceFromText(base) ?? 5\n    const nextDifficulty = eventComposer.difficulty ?? inferDifficultyFromText(base) ?? 5\n    setEventComposer((prev) => ({\n      ...prev,\n      tagsRaw: mergedTags.join(' '),\n      peopleRaw: nextPeople.join(', '),\n      estimateMinutesRaw: prev.estimateMinutesRaw || (duration ? String(duration) : prev.estimateMinutesRaw),\n      category: prev.category || inferred.category || '',\n      subcategory: prev.subcategory || inferred.subcategory || '',\n      importance: nextImportance,\n      difficulty: nextDifficulty,\n    }))\n  }\n\n\t  function openEventComposer(seed: CreateEventSeed) {\n\t    const startAt = seed.startAt\n\t    const endAt = Math.max(seed.endAt, startAt + 5 * 60 * 1000)\n\t    setEventComposer({\n\t      title: '',\n\t      startAt,\n\t      endAt,\n\t      kind: seed.kind ?? 'event',\n\t      allDay: false,\n\t      active: false,\n\t      icon: null,\n\t      color: null,\n\t      tagsRaw: '',\n\t      location: '',\n\t      peopleRaw: '',\n\t      skillsRaw: '',\n      character: [],\n      category: '',\n      subcategory: '',\n      importance: 5,\n      difficulty: 5,\n      estimateMinutesRaw: estimateMinutesFromRange(startAt, endAt),\n      notes: '',\n      taskId: seed.taskId ?? null,\n\t      trackerKey: '',\n\t    })\n\t    setEventComposerOpen(true)\n\t  }\n\n  function commitTask(next: Task) {\n    setTasks((prev) => prev.map((t) => (t.id === next.id ? next : t)))\n    void upsertTask(next)\n    setEvents((prev) => {\n      let changed = false\n      const updates: CalendarEvent[] = []\n      const nextEvents = prev.map((e) => {\n        if (e.taskId !== next.id) return e\n        const completedAt = next.status === 'done' ? e.completedAt ?? Date.now() : null\n        if (completedAt === e.completedAt) return e\n        const updated = { ...e, completedAt, kind: (e.kind ?? 'task') as any }\n        updates.push(updated)\n        changed = true\n        return updated\n      })\n      for (const ev of updates) void upsertEvent(ev)\n      return changed ? nextEvents : prev\n    })\n  }\n\n  async function stopOtherActiveEvents(excludeId?: string | null, endAtOverride?: number | null) {\n    const now = Date.now()\n    const stopAt = endAtOverride ?? now\n    const activeEvents = events.filter(\n      (e) => e.active && e.id !== excludeId && e.kind !== 'log' && e.kind !== 'episode',\n    )\n    if (!activeEvents.length) return\n    const updates = activeEvents.map((ev) => ({\n      ...ev,\n      active: false,\n      endAt: Math.max(ev.startAt, stopAt),\n    }))\n    for (const next of updates) await upsertEvent(next)\n    setEvents((prev) => prev.map((e) => updates.find((u) => u.id === e.id) ?? e))\n  }\n\n  function resolveTrackerLogAtMs(ev: CalendarEvent) {\n    const now = Date.now()\n    const startAt = Number.isFinite(ev.startAt) ? ev.startAt : now\n    const endAt = Number.isFinite(ev.endAt) ? ev.endAt : startAt\n    if (now < startAt) return startAt\n    if (now > endAt) return endAt\n    return now\n  }\n\n  function scheduleTrackerExtractionFromEventNotes(ev: CalendarEvent) {\n    if (ev.kind === 'log') return\n    const text = (ev.notes ?? '').trim()\n    if (!text) return\n    if (!extractTrackerTokens(text).length) return\n    const existing = trackerExtractionTimeoutRef.current[ev.id]\n    if (existing) window.clearTimeout(existing)\n    trackerExtractionTimeoutRef.current[ev.id] = window.setTimeout(() => {\n      delete trackerExtractionTimeoutRef.current[ev.id]\n      void createTrackerLogsFromText({\n        text,\n        atMs: resolveTrackerLogAtMs(ev),\n        sourceNoteId: ev.id,\n        parentEventId: ev.id,\n        events: eventsRef.current,\n        ensureTrackerDefinition,\n        defaultTrackerUnit,\n        findBestActiveEventAt,\n        createEvent,\n        setEvents,\n      })\n    }, 400)\n  }\n\n  function commitEvent(next: CalendarEvent) {\n    const current = events.find((e) => e.id === next.id)\n    const notesChanged = current?.notes !== next.notes\n    const shouldStopOthers =\n      next.active &&\n      !current?.active &&\n      next.kind !== 'log' &&\n      next.kind !== 'episode'\n    if (shouldStopOthers) void stopOtherActiveEvents(next.id, next.startAt)\n    setEvents((prev) => prev.map((e) => (e.id === next.id ? next : e)))\n    void upsertEvent(next)\n    if (notesChanged) scheduleTrackerExtractionFromEventNotes(next)\n  }\n\n  function onUpdateEvent(eventId: string, patch: Partial<CalendarEvent>) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev) return\n    commitEvent({ ...ev, ...patch })\n  }\n\n  function openView(view: WorkspaceViewKey) {\n    if (view === 'calendar') {\n      setRightCollapsed(false)\n      setRightMode('details')\n    }\n    setWorkspace((p) => {\n      const existing = p.tabs.find((t) => t.view === view)\n      if (existing) return { ...p, activeTabId: existing.id }\n      const id = makeTabId(view)\n      const nextTab: WorkspaceTab = { id, title: defaultTabTitle(view), view }\n      return { tabs: [...p.tabs, nextTab], activeTabId: id }\n    })\n  }\n\n  function openHabitReports(habitId: string) {\n    try {\n      localStorage.setItem(REPORTS_HABIT_ID_KEY, habitId)\n    } catch {\n      // ignore\n    }\n    openView('reports')\n  }\n\n  function openGoalDetail(goalName: string) {\n    setSelectedGoal(goalName)\n    setWorkspace((p) => {\n      const existing = p.tabs.find((t) => t.view === 'goal-detail')\n      const title = goalName || defaultTabTitle('goal-detail')\n      if (existing) {\n        const nextTabs = p.tabs.map((t) => (t.id === existing.id ? { ...t, title } : t))\n        return { tabs: nextTabs, activeTabId: existing.id }\n      }\n      const id = makeTabId('goal-detail')\n      const nextTab: WorkspaceTab = { id, title, view: 'goal-detail' }\n      return { tabs: [...p.tabs, nextTab], activeTabId: id }\n    })\n  }\n\n  function openProjectDetail(projectName: string) {\n    setSelectedProject(projectName)\n    openView('projects')\n  }\n\n  function openTrackerDetail(trackerKey: string) {\n    setSelectedTrackerKey(trackerKey)\n    openView('trackers')\n  }\n\n  function closeTab(id: string) {\n    setWorkspace((p) => {\n      const nextTabs = p.tabs.filter((t) => t.id !== id)\n      const nextActive = p.activeTabId === id ? nextTabs[0]?.id ?? '' : p.activeTabId\n      return { tabs: nextTabs.length ? nextTabs : p.tabs, activeTabId: nextActive }\n    })\n  }\n\n  function onPinnedDragStart(key: string, e: DragEvent) {\n    setDragPinnedKey(key)\n    e.dataTransfer.setData('text/pinned-group', key)\n    e.dataTransfer.effectAllowed = 'move'\n  }\n\n  function onPinnedDrop(targetKey: string, e: DragEvent) {\n    e.preventDefault()\n    const dragged = dragPinnedKey ?? e.dataTransfer.getData('text/pinned-group')\n    if (!dragged || dragged === targetKey) return\n    const from = pinnedGroupOrder.indexOf(dragged)\n    const to = pinnedGroupOrder.indexOf(targetKey)\n    if (from < 0 || to < 0) return\n    const next = [...pinnedGroupOrder]\n    next.splice(from, 1)\n    next.splice(to, 0, dragged)\n    setPinnedGroupOrder(next)\n    setDragPinnedKey(null)\n  }\n\n  function onPinnedDragOver(e: DragEvent) {\n    e.preventDefault()\n  }\n\n  function getActiveTab(pane: PaneState) {\n    return pane.tabs.find((t) => t.id === pane.activeTabId) ?? pane.tabs[0]!\n  }\n\n  function onCreateTaskFromInput(input: { title: string; tags?: string[] }) {\n    void (async () => {\n      const task = await createTask({ title: input.title, tags: input.tags })\n      setTasks((prev) => [task, ...prev])\n      setSelection({ kind: 'task', id: task.id })\n      setRightCollapsed(false)\n      setRightMode('details')\n    })()\n  }\n\n  function onToggleTaskComplete(taskId: string) {\n    const t = tasks.find((x) => x.id === taskId)\n    if (!t) return\n    const nextStatus: TaskStatus = t.status === 'done' ? 'todo' : 'done'\n    commitTask({ ...t, status: nextStatus })\n  }\n\n  function onMoveTaskStatus(taskId: string, status: TaskStatus) {\n    const t = tasks.find((x) => x.id === taskId)\n    if (!t || t.status === status) return\n    commitTask({ ...t, status })\n  }\n\n  function onToggleTaskChecklistItem(taskId: string, lineIndex: number) {\n    const t = tasks.find((x) => x.id === taskId)\n    if (!t) return\n    const nextNotes = toggleChecklistLine(t.notes ?? '', lineIndex)\n    commitTask({ ...t, notes: nextNotes })\n\n    setEvents((prev) => {\n      const changed: CalendarEvent[] = []\n      const next = prev.map((e) => {\n        if (e.taskId !== taskId) return e\n        const updated = { ...e, notes: nextNotes }\n        changed.push(updated)\n        return updated\n      })\n      for (const ev of changed) void upsertEvent(ev)\n      return next\n    })\n  }\n\n  function onCreateEvent(input: {\n    title: string\n    startAt: number\n    endAt: number\n    kind?: CalendarEvent['kind']\n    taskId?: string | null\n    parentEventId?: string | null\n    allDay?: boolean\n    active?: boolean\n    tags?: string[]\n    contexts?: string[]\n    notes?: string | null\n    icon?: string | null\n    color?: string | null\n    estimateMinutes?: number | null\n    location?: string | null\n    people?: string[]\n    skills?: string[]\n    character?: string[]\n    category?: string | null\n    subcategory?: string | null\n    importance?: number | null\n    difficulty?: number | null\n    trackerKey?: string | null\n  }) {\n    void (async () => {\n      const ev = await createEvent({\n        title: input.title,\n        startAt: input.startAt,\n        endAt: input.endAt,\n        kind: input.kind,\n        taskId: input.taskId,\n        parentEventId: input.parentEventId,\n        allDay: input.allDay,\n        active: input.active,\n        tags: input.tags,\n        contexts: input.contexts,\n        notes: input.notes,\n        icon: input.icon,\n        color: input.color,\n        estimateMinutes: input.estimateMinutes,\n        location: input.location,\n\t        people: input.people,\n\t        skills: input.skills,\n\t        character: normalizeCharacterSelection(input.character),\n\t        category: input.category,\n\t        subcategory: input.subcategory,\n\t        importance: input.importance,\n\t        difficulty: input.difficulty,\n\t        trackerKey: input.trackerKey,\n\t      })\n      setEvents((prev) => [ev, ...prev])\n      setSelection({ kind: 'event', id: ev.id })\n      setRightCollapsed(false)\n      setRightMode('details')\n    })()\n  }\n\n  function onMoveEvent(eventId: string, startAt: number, endAt: number) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev) return\n    commitEvent({ ...ev, startAt, endAt })\n  }\n\n  function onToggleEventComplete(eventId: string) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev) return\n    const completing = !ev.completedAt\n    const completedAt = completing ? Date.now() : null\n    commitEvent({ ...ev, completedAt, kind: (ev.kind ?? 'event') as any })\n    if (ev.kind === 'task' && ev.taskId) {\n      const task = tasks.find((t) => t.id === ev.taskId)\n      if (task) commitTask({ ...task, status: completing ? 'done' : 'todo' })\n    }\n  }\n\n  async function stopActiveNoteSessions(parentEventId: string, excludeTokenId?: string | null) {\n    const now = Date.now()\n    const activeChildren = events.filter(\n      (e) => e.parentEventId === parentEventId && e.active && noteItemTokenId(e.notes ?? '') !== excludeTokenId,\n    )\n    if (!activeChildren.length) return\n    const updates: CalendarEvent[] = activeChildren.map((child) => ({\n      ...child,\n      active: false,\n      endAt: Math.max(child.startAt, now),\n    }))\n    for (const next of updates) await upsertEvent(next)\n    setEvents((prev) => prev.map((e) => updates.find((u) => u.id === e.id) ?? e))\n  }\n\n  function findNoteSubEvent(parentEventId: string, tokenId: string) {\n    return events.find((e) => e.parentEventId === parentEventId && noteItemTokenId(e.notes ?? '') === tokenId) ?? null\n  }\n\n  async function ensureNoteSubEvent(opts: {\n    parentEvent: CalendarEvent\n    tokenId: string\n    title: string\n    estimateMinutes?: number | null\n    tags: string[]\n    contexts: string[]\n    people: string[]\n    location: string | null\n    trackerKey?: string | null\n    active: boolean\n    startAt?: number\n  }) {\n    const now = Date.now()\n    const startAt = opts.startAt ?? now\n    const minutes = Math.max(1, Math.round(opts.estimateMinutes ?? 5))\n    const endAt = startAt + minutes * 60 * 1000\n    const existing = events.find(\n      (e) => e.parentEventId === opts.parentEvent.id && noteItemTokenId(e.notes ?? '') === opts.tokenId,\n    )\n    const baseEvent =\n      existing ??\n      (await createEvent({\n        title: opts.title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: opts.parentEvent.id,\n        tags: opts.tags,\n        contexts: opts.contexts,\n        entityIds: opts.parentEvent.entityIds ?? [],\n        active: opts.active,\n        category: opts.parentEvent.category,\n        subcategory: opts.parentEvent.subcategory,\n        goal: opts.parentEvent.goal ?? null,\n        project: opts.parentEvent.project ?? null,\n        importance: opts.parentEvent.importance ?? 5,\n        difficulty: opts.parentEvent.difficulty ?? 5,\n        estimateMinutes: opts.estimateMinutes ?? null,\n        location: opts.location,\n        people: opts.people,\n        trackerKey: opts.trackerKey ?? null,\n        notes: `token:${opts.tokenId}`,\n      }))\n\n    const next = await upsertEvent({\n      ...baseEvent,\n      title: opts.title,\n      startAt,\n      endAt,\n      active: opts.active,\n      tags: opts.tags,\n      contexts: opts.contexts,\n      people: opts.people,\n      location: opts.location,\n      trackerKey: opts.trackerKey ?? baseEvent.trackerKey ?? null,\n      notes: `token:${opts.tokenId}`,\n      parentEventId: opts.parentEvent.id,\n      kind: 'log',\n      category: opts.parentEvent.category,\n      subcategory: opts.parentEvent.subcategory,\n      goal: opts.parentEvent.goal ?? null,\n      project: opts.parentEvent.project ?? null,\n      importance: opts.parentEvent.importance ?? 5,\n      difficulty: opts.parentEvent.difficulty ?? 5,\n      estimateMinutes: opts.estimateMinutes ?? baseEvent.estimateMinutes ?? null,\n    })\n    setEvents((prev) => {\n      const existingIdx = prev.findIndex((e) => e.id === next.id)\n      if (existingIdx === -1) return [next, ...prev]\n      const copy = [...prev]\n      copy[existingIdx] = next\n      return copy\n    })\n    return next\n  }\n\n  async function onStartNoteTask(\n    eventId: string,\n    task: {\n      tokenId: string\n      title: string\n      estimateMinutes?: number | null\n      dueAt?: number | null\n      kind?: NoteItemKind\n      rawText?: string\n      lineIndex?: number | null\n    },\n  ) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev || !task.title) return\n    const kind = task.kind ?? 'task'\n    let workingNotes = ev.notes ?? ''\n    let rawLine = task.rawText ?? task.title\n    let tokenId = task.tokenId?.trim() ?? ''\n\n    if (!NOTE_ITEM_INLINE_RE.test(rawLine)) {\n      const ensured = ensureNoteItemTokenInNotes(workingNotes, task.lineIndex ?? null, kind, task.title)\n      if (ensured.tokenId) {\n        tokenId = ensured.tokenId\n        rawLine = ensured.line || rawLine\n        if (ensured.notes !== workingNotes) {\n          const normalized = normalizeTaskChecklistNotes(ensured.notes)\n          workingNotes = normalized\n          commitEvent({ ...ev, notes: normalized })\n        }\n      }\n    }\n    if (!tokenId) return\n\n    if (task.lineIndex != null) {\n      const startStamp = formatNoteItemTimestamp(Date.now())\n      const stamped = updateNoteItemLine(workingNotes, task.lineIndex, (line) => {\n        if (/\\bstart:[^\\s}]+/.test(line)) return line\n        return upsertNoteItemMeta(line, 'start', startStamp)\n      })\n      if (stamped.notes !== workingNotes) {\n        workingNotes = stamped.notes\n        commitEvent({ ...ev, notes: stamped.notes })\n      }\n      rawLine = stamped.line || rawLine\n    }\n\n    const lineTokens = extractLineTokenCollections(rawLine)\n    const lineTags = lineTokens.tags.map((t) => normalizeHashTag(t))\n    const tags = uniqStrings([...(ev.tags ?? []), ...lineTags, kind === 'habit' ? '#habit' : '#task'])\n    const contexts = uniqStrings([...(ev.contexts ?? []), ...lineTokens.contexts])\n    const people = uniqStrings([...(ev.people ?? []), ...lineTokens.people])\n    const location = ev.location ?? (lineTokens.places.length ? lineTokens.places.join(', ') : null)\n\n    await stopActiveNoteSessions(eventId, tokenId)\n\n    if (kind === 'task') {\n      const existing = tasks.find(\n        (t) => t.parentEventId === eventId && noteItemTokenId(t.notes ?? '') === tokenId,\n      )\n      let target = existing ?? null\n      if (!target) {\n        const titleKey = normalizeTaskTitle(task.title)\n        const byTitle = tasks.find((t) => t.parentEventId === eventId && normalizeTaskTitle(t.title) === titleKey) ?? null\n        if (byTitle) {\n          const updated = await upsertTask({ ...byTitle, notes: appendTokenToNotes(byTitle.notes, tokenId) })\n          setTasks((prev) => prev.map((t) => (t.id === updated.id ? updated : t)))\n          target = updated\n        }\n      }\n      if (!target) {\n        const created = await createTask({\n          title: task.title,\n          status: 'todo',\n          tags,\n          contexts,\n          people,\n          location,\n          skills: ev.skills ?? [],\n          character: ev.character ?? [],\n          entityIds: ev.entityIds ?? [],\n          parentEventId: eventId,\n          category: ev.category ?? null,\n          subcategory: ev.subcategory ?? null,\n          importance: ev.importance ?? 5,\n          difficulty: ev.difficulty ?? 5,\n          estimateMinutes: task.estimateMinutes ?? null,\n          dueAt: task.dueAt ?? null,\n          goal: ev.goal ?? null,\n          project: ev.project ?? null,\n          sourceNoteId: ev.sourceNoteId ?? null,\n        })\n        const withToken = await upsertTask({ ...created, notes: `token:${tokenId}` })\n        setTasks((prev) => [withToken, ...prev])\n        target = withToken\n      }\n      const started = await startTask(target.id)\n      if (started) setTasks((prev) => prev.map((t) => (t.id === started.id ? started : t)))\n    }\n\n    let habitTrackerKey: string | null = null\n    let habitEstimate: number | null | undefined = task.estimateMinutes ?? null\n    if (kind === 'habit') {\n      const habit = detectHabitMentions(task.title, habitDefs)[0] ?? null\n      habitTrackerKey = habit ? `habit:${habit.id}` : null\n      habitEstimate = task.estimateMinutes ?? habit?.estimateMinutes ?? null\n    }\n\n    await ensureNoteSubEvent({\n      parentEvent: ev,\n      tokenId,\n      title: task.title,\n      estimateMinutes: habitEstimate ?? null,\n      tags,\n      contexts,\n      people,\n      location,\n      trackerKey: habitTrackerKey,\n      active: true,\n    })\n  }\n\n  async function onToggleEventNoteChecklist(ev: CalendarEvent, lineIndex: number) {\n    let rawLine = extractNoteItemLine(ev.notes, lineIndex)\n    const baseMeta = parseNoteItemMeta(rawLine)\n    const inferredKind = baseMeta?.kind ?? detectInlineItemKind(rawLine)\n    let workingNotes = ev.notes ?? ''\n    let tokenId = baseMeta?.tokenId ?? ''\n    let meta = baseMeta\n\n    if (inferredKind && (!tokenId || !NOTE_ITEM_INLINE_RE.test(rawLine))) {\n      const ensured = ensureNoteItemTokenInNotes(workingNotes, lineIndex, inferredKind, deriveNoteItemTitle(rawLine))\n      if (ensured.notes !== workingNotes) {\n        workingNotes = ensured.notes\n        rawLine = ensured.line || rawLine\n      }\n      tokenId = ensured.tokenId || tokenId\n      meta = parseNoteItemMeta(rawLine) ?? meta\n    }\n\n    let nextNotes = toggleChecklistLine(workingNotes, lineIndex)\n    let nextLine = extractNoteItemLine(nextNotes, lineIndex)\n    const nextChecked = /^\\s*[-*+]\\s*\\[[xX]\\]\\s+/.test(nextLine)\n    if (tokenId) {\n      if (nextChecked) {\n        const endStamp = formatNoteItemTimestamp(Date.now())\n        const stamped = updateNoteItemLine(nextNotes, lineIndex, (line) => {\n          if (/\\bend:[^\\s}]+/.test(line)) return line\n          return upsertNoteItemMeta(line, 'end', endStamp)\n        })\n        nextNotes = stamped.notes\n        nextLine = stamped.line || nextLine\n      } else {\n        const cleaned = updateNoteItemLine(nextNotes, lineIndex, (line) => removeNoteItemMeta(line, 'end'))\n        nextNotes = cleaned.notes\n        nextLine = cleaned.line || nextLine\n      }\n    }\n\n    commitEvent({ ...ev, notes: nextNotes })\n\n    if (!inferredKind || !tokenId) return\n    const finalMeta =\n      meta ??\n      ({\n        kind: inferredKind,\n        tokenId,\n        title: deriveNoteItemTitle(nextLine),\n        estimateMinutes: null,\n        dueAt: null,\n        rawText: nextLine,\n      } as const)\n\n    const lineTokens = extractLineTokenCollections(nextLine)\n    const lineTags = lineTokens.tags.map((t) => normalizeHashTag(t))\n    const tags = uniqStrings([...(ev.tags ?? []), ...lineTags, finalMeta.kind === 'habit' ? '#habit' : '#task'])\n    const contexts = uniqStrings([...(ev.contexts ?? []), ...lineTokens.contexts])\n    const people = uniqStrings([...(ev.people ?? []), ...lineTokens.people])\n    const location = ev.location ?? (lineTokens.places.length ? lineTokens.places.join(', ') : null)\n\n    const existingSub = findNoteSubEvent(ev.id, tokenId)\n\n    if (finalMeta.kind === 'task') {\n      let target = tasks.find((t) => t.parentEventId === ev.id && noteItemTokenId(t.notes ?? '') === tokenId) ?? null\n      if (!target) {\n        const titleKey = normalizeTaskTitle(finalMeta.title)\n        const byTitle = tasks.find((t) => t.parentEventId === ev.id && normalizeTaskTitle(t.title) === titleKey) ?? null\n        if (byTitle) {\n          const updated = await upsertTask({ ...byTitle, notes: appendTokenToNotes(byTitle.notes, tokenId) })\n          setTasks((prev) => prev.map((t) => (t.id === updated.id ? updated : t)))\n          target = updated\n        }\n      }\n      if (!target && nextChecked) {\n        const created = await createTask({\n          title: finalMeta.title,\n          status: 'done',\n          tags,\n          contexts,\n          people,\n          location,\n          skills: ev.skills ?? [],\n          character: ev.character ?? [],\n          entityIds: ev.entityIds ?? [],\n          parentEventId: ev.id,\n          category: ev.category ?? null,\n          subcategory: ev.subcategory ?? null,\n          importance: ev.importance ?? 5,\n          difficulty: ev.difficulty ?? 5,\n          estimateMinutes: finalMeta.estimateMinutes ?? null,\n          dueAt: finalMeta.dueAt ?? null,\n          goal: ev.goal ?? null,\n          project: ev.project ?? null,\n          sourceNoteId: ev.sourceNoteId ?? null,\n        })\n        target = await upsertTask({ ...created, notes: `token:${tokenId}` })\n        setTasks((prev) => [target!, ...prev])\n      } else if (target) {\n        const updated = await upsertTask({ ...target, status: nextChecked ? 'done' : 'todo' })\n        setTasks((prev) => prev.map((t) => (t.id === updated.id ? updated : t)))\n      }\n    }\n\n    if (finalMeta.kind === 'habit') {\n      const habit = detectHabitMentions(finalMeta.title, habitDefs)[0] ?? null\n      const trackerKey = habit ? `habit:${habit.id}` : null\n\n      if (nextChecked) {\n        if (existingSub?.active) {\n          const stopped = await upsertEvent({ ...existingSub, active: false, endAt: Date.now() })\n          setEvents((prev) => prev.map((e) => (e.id === stopped.id ? stopped : e)))\n          return\n        }\n        await ensureNoteSubEvent({\n          parentEvent: ev,\n          tokenId,\n          title: finalMeta.title,\n          estimateMinutes: finalMeta.estimateMinutes ?? habit?.estimateMinutes ?? null,\n          tags,\n          contexts,\n          people,\n          location,\n          trackerKey,\n          active: false,\n          startAt: Date.now(),\n        })\n      } else if (existingSub) {\n        await deleteEvent(existingSub.id)\n        setEvents((prev) => prev.filter((e) => e.id !== existingSub.id))\n      }\n    } else if (!nextChecked && existingSub) {\n      await deleteEvent(existingSub.id)\n      setEvents((prev) => prev.filter((e) => e.id !== existingSub.id))\n    } else if (nextChecked) {\n      if (existingSub?.active) {\n        const stopped = await upsertEvent({ ...existingSub, active: false, endAt: Date.now() })\n        setEvents((prev) => prev.map((e) => (e.id === stopped.id ? stopped : e)))\n      } else if (!existingSub) {\n        await ensureNoteSubEvent({\n          parentEvent: ev,\n          tokenId,\n          title: finalMeta.title,\n          estimateMinutes: finalMeta.estimateMinutes ?? null,\n          tags,\n          contexts,\n          people,\n          location,\n          active: false,\n          startAt: Date.now(),\n        })\n      }\n    }\n  }\n\n  async function onSaveCapture() {\n    if (captureSaving) return\n    const text = captureDraft.trim()\n    if (!text) return\n    const { frontmatter, body } = extractFrontmatter(text)\n    const captureText = body.trim() ? body.trim() : text\n    const markdownTokens = collectMarkdownTokens(captureText)\n    setCaptureSaving(true)\n    setCaptureAiStatus('')\n    setCaptureError('')\n    setCaptureProgress([])\n\t    try {\n\n    const attachedCaptureEvent = captureAttachEventId ? events.find((e) => e.id === captureAttachEventId) ?? null : null\n    const anchorMs = attachedCaptureEvent?.startAt ?? captureAnchorMs ?? Date.now()\n\n    function normalizeTagName(tag: string) {\n      return tag.replace(/^#/, '').trim().toLowerCase()\n    }\n\n    function slugifyTag(raw: string) {\n      return raw\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '-')\n        .replace(/^-+|-+$/g, '')\n    }\n\n    function toTagTokenFromLabel(raw: string) {\n      const slug = slugifyTag(raw)\n      return slug ? `#${slug}` : ''\n    }\n\n    const tokenSeed = Date.now().toString(36)\n    let tokenCounter = 0\n    function makeTokenId(prefix: string, value: string) {\n      const slug = slugifyTag(value) || value.replace(/\\s+/g, '-').toLowerCase()\n      return `${prefix}_${slug}_${tokenSeed}_${tokenCounter++}`\n    }\n\n    function toInlineToken(prefix: string, type: string, value: string) {\n      const clean = value.trim()\n      if (!clean) return ''\n      const id = makeTokenId(type, clean)\n      return `${prefix}${clean}{${type}:${id}}`\n    }\n\n    function inferTrackerKeyFromText(title: string, tags?: string[] | null) {\n      const tagSet = new Set((tags ?? []).map((t) => normalizeTagName(t)))\n      const text = `${title} ${[...tagSet].join(' ')}`.toLowerCase()\n      const candidates = ['mood', 'energy', 'stress', 'pain', 'workout', 'period', 'bored', 'water']\n      for (const key of candidates) {\n        if (tagSet.has(key)) return key\n      }\n      if (/\\bmood\\b/.test(text)) return 'mood'\n      if (/\\b(happy|sad|angry|anxious|depressed|excited|great|good|okay|ok)\\b/.test(text)) return 'mood'\n      if (/\\benergy\\b/.test(text)) return 'energy'\n      if (/\\b(tired|exhausted|drained|wired|energized)\\b/.test(text)) return 'energy'\n    if (/\\bstress\\b/.test(text)) return 'stress'\n    if (/\\b(stressed|overwhelmed|anxious)\\b/.test(text)) return 'stress'\n    if (/\\bpain\\b/.test(text)) return 'pain'\n    if (/\\bworkout\\b/.test(text)) return 'workout'\n      if (/\\bwater\\b|\\bhydrat(?:e|ion|ing)?\\b/.test(text)) return 'water'\n      if (/\\bperiod\\b/.test(text)) return 'period'\n      if (/\\bbored\\b/.test(text)) return 'bored'\n      return null\n    }\n\n    const LOG_TRACKER_KEYS = new Set(['mood', 'energy', 'stress', 'pain', 'period', 'bored', 'water'])\n\n    function formatSegmentLine(atMs: number | null, label: string) {\n      const cleaned = label.trim()\n      if (!cleaned) return ''\n      if (atMs == null) return `- ${cleaned}`\n      const d = new Date(atMs)\n      const hh = String(d.getHours()).padStart(2, '0')\n      const mm = String(d.getMinutes()).padStart(2, '0')\n      return `- **${hh}:${mm}** - ${cleaned}`\n    }\n\n    function maybeSegmentNotes(notes: string | null | undefined, startAt: number, endAt: number) {\n      const raw = (notes ?? '').trim()\n      if (!raw) return notes ?? ''\n      if (/\\*\\*\\d{2}:\\d{2}\\*\\*|\\-\\s*\\[\\d{2}:\\d{2}\\]/.test(raw)) return raw\n      if (/^\\s*[-*]\\s+/m.test(raw)) return raw\n      const parts = raw\n        .split(/[\\n;]+/)\n        .map((p) => p.trim())\n        .filter(Boolean)\n      if (parts.length < 2) return raw\n      const span = endAt - startAt\n      if (!Number.isFinite(span) || span < 60 * 60 * 1000) return raw\n      const step = Math.max(5 * 60 * 1000, Math.floor(span / (parts.length + 1)))\n      return parts.slice(0, 5).map((p, i) => formatSegmentLine(startAt + step * (i + 1), p)).join('\\n')\n    }\n\n    function parseIsoMs(raw?: string | null) {\n      if (!raw) return null\n      const ms = new Date(raw).getTime()\n      return Number.isFinite(ms) ? ms : null\n    }\n\n    function segmentLabelForEvent(ev: { title?: string; sourceText?: string }) {\n      const title = (ev.title ?? '').trim()\n      const lowerTitle = title.toLowerCase()\n      const preferSource = !title || lowerTitle === 'event' || lowerTitle === 'work' || lowerTitle === 'clinic'\n      const raw = (preferSource ? ev.sourceText ?? '' : title).trim()\n      if (!raw) return 'Segment'\n      return raw\n        .replace(/^(?:i\\s+)?(?:did|was|went|got|started|finished|worked on)\\s+/i, '')\n        .replace(/\\s+/g, ' ')\n        .trim()\n    }\n\n\t    const fm = frontmatter ?? {}\n\t    const llmSettings = loadSettings()\n\t    const llmKey = (llmSettings.openAiKey ?? '').trim()\n\t    const llmParseModel = (llmSettings.parseModel ?? llmSettings.chatModel ?? 'gpt-4.1-mini').trim() || 'gpt-4.1-mini'\n\t    const fmTags = toStringList(fm.tags).map((t) => normalizeTagName(t)).filter(Boolean)\n\t    const fmPeople = toStringList(fm.people)\n\t      .map((p) => p.replace(/^@/, '').trim())\n\t      .filter(Boolean)\n\t    const fmContexts = toStringList(fm.contexts)\n\t      .map((c) => c.replace(/^\\+/, '').trim())\n\t      .filter(Boolean)\n\t    const fmCategory = typeof fm.category === 'string' ? fm.category.trim() : ''\n\t    const fmSubcategory = typeof fm.subcategory === 'string' ? fm.subcategory.trim() : ''\n\t    const fmGoal = typeof fm.goal === 'string' ? fm.goal.trim() : ''\n\t    const fmProject = typeof fm.project === 'string' ? fm.project.trim() : ''\n\t    const fmLocation = typeof fm.location === 'string' ? fm.location.trim() : ''\n\t    const fmImportance = typeof fm.importance === 'number' ? fm.importance : null\n\t    const fmDifficulty = typeof fm.difficulty === 'number' ? fm.difficulty : null\n\t    const fmDuration = typeof fm.durationMinutes === 'number' ? fm.durationMinutes : typeof fm.duration === 'number' ? fm.duration : null\n\t    const fmStartAt = typeof fm.startAt === 'string' ? new Date(fm.startAt).getTime() : null\n\t    const fmEndAt = typeof fm.endAt === 'string' ? new Date(fm.endAt).getTime() : null\n\t    const fmRules = Array.isArray(fm.rules) ? fm.rules : []\n\t    const taxonomyRules = fmRules\n\t      .map((r: any) => ({\n\t        match: typeof r?.match === 'string' ? r.match : '',\n\t        category: typeof r?.category === 'string' ? r.category : undefined,\n\t        subcategory: typeof r?.subcategory === 'string' ? r.subcategory : undefined,\n\t        tags: Array.isArray(r?.tags) ? r.tags.map((t: any) => String(t)).filter(Boolean) : undefined,\n\t      }))\n\t      .filter((r: any) => r.match)\n\t    const activeRules = taxonomyRules.length ? taxonomyRules : taxonomyRulesRef.current\n\n    const durationOverride = fmDuration ?? extractDurationToken(captureText)\n    const importanceOverride = fmImportance ?? extractImportanceToken(captureText)\n    const difficultyOverride = fmDifficulty ?? extractDifficultyToken(captureText)\n    const categoryOverride = fmCategory ? toTitleCase(fmCategory) : null\n    const subcategoryOverride = fmSubcategory ? toTitleCase(fmSubcategory) : null\n    const goalOverride = fmGoal ? fmGoal : null\n    const projectOverride = fmProject ? fmProject : null\n\t    const explicitTimeInCapture = hasExplicitTimeRange(captureText)\n\t    const hasNowSignal = /\\b(currently|right now|at the moment)\\b/i.test(captureText)\n\n    function ruleTagsForText(text: string, rules: TaxonomyRule[]) {\n      const tags: string[] = []\n      for (const rule of rules) {\n        const rx = rule.match?.trim()\n        if (!rx) continue\n        try {\n          const re = new RegExp(rx, 'i')\n          if (!re.test(text)) continue\n        } catch {\n          continue\n        }\n        for (const t of rule.tags ?? []) {\n          const cleaned = normalizeTagName(String(t))\n          if (cleaned) tags.push(cleaned)\n        }\n      }\n      return tags\n    }\n\n    const storedMode = llmSettings.mode ?? 'local'\n    const llmMode = storedMode\n    const shouldTryLlm = llmMode !== 'local' && Boolean(llmKey)\n    const allowLocalFallback = llmMode === 'local' || llmMode === 'hybrid'\n    if (!llmKey && llmMode !== 'local') {\n      setCaptureProgress((p) => [...p, 'AI parsing disabled (no OpenAI key); using local parser'].slice(-10))\n    }\n    const natural = allowLocalFallback ? parseCaptureNatural(captureText, anchorMs) : { tasks: [], events: [] }\n    if (!allowLocalFallback) {\n      setCaptureProgress((p) => [...p, 'Parser mode: LLM (no local fallback)'].slice(-10))\n    }\n    if (allowLocalFallback) {\n      setCaptureProgress((p) => [...p, `Local parse: ${natural.events.length} event(s), ${natural.tasks.length} task(s)`].slice(-10))\n    }\n    const ruleTagNames = ruleTagsForText(captureText, activeRules)\n    const tagNames = new Set<string>(\n      [\n        ...extractTagTokens(captureText),\n        ...fmTags,\n        ...ruleTagNames,\n        ...markdownTokens.tags.map((t) => normalizeTagName(t)),\n      ].filter(Boolean),\n    )\n\t    for (const t of natural.tasks) {\n\t      for (const tag of t.tags ?? []) {\n\t        const name = normalizeTagName(tag)\n\t        if (name) tagNames.add(name)\n\t      }\n\t    }\n\t    for (const e of natural.events) {\n\t      for (const tag of e.tags ?? []) {\n\t        const name = normalizeTagName(tag)\n\t        if (name) tagNames.add(name)\n\t      }\n\t    }\n\n    const explicitTagNames = new Set<string>(\n      [\n        ...extractTagTokens(captureText),\n        ...fmTags,\n        ...ruleTagNames,\n        ...markdownTokens.tags.map((t) => normalizeTagName(t)),\n      ].filter(Boolean),\n    )\n\n    const lowerText = captureText.toLowerCase()\n    const periodStartSignal =\n      /\\b(started|starting|got)\\b.*\\bperiod\\b/.test(lowerText) || /\\bon (my )?period\\b/.test(lowerText) || /\\bmy period\\b.*\\b(started|began)\\b/.test(lowerText)\n    const periodEndSignal =\n      /\\bperiod\\b.*\\b(ended|over|finished)\\b/.test(lowerText) || /\\b(period ended|period is over|period is done)\\b/.test(lowerText)\n\n    const painRatingMatch = lowerText.match(/(\\d{1,2})\\s*\\/\\s*10/)\n    const painSignal = /\\b(pain|hurts|ache|aches|sore)\\b/.test(lowerText) || Boolean(painRatingMatch)\n    const painHealedSignal = /\\b(healed|pain[-\\s]?free|no longer hurts|doesn['\u2019]?t hurt anymore|back to normal)\\b/.test(lowerText)\n    const bodyPartMatch = lowerText.match(/\\bmy\\s+([a-z][a-z-]{1,20})\\s+(hurts|aches|is\\s+(sore|aching))\\b/)\n\n    const workoutStartSignal = /\\b(going to|gonna|start(?:ing)?|begin(?:ning)?|about to)\\b.*\\b(work\\s*out|workout)\\b/.test(lowerText)\n    const workoutEndSignal = /\\b(done|finished|ended|stop(?:ping)?)\\b.*\\b(work\\s*out|workout)\\b/.test(lowerText)\n    const boredSignal = /\\b(bored|boredom|boring)\\b/.test(lowerText)\n    const moodValue =\n      parseRatingNearText(lowerText, 'mood') ??\n      parseRatingNearText(lowerText, 'feeling') ??\n      parseRatingNearText(lowerText, 'feel') ??\n      inferMoodFromAdjectives(lowerText)\n    const energyValue =\n      parseRatingNearText(lowerText, 'energy') ??\n      inferEnergyFromAdjectives(lowerText)\n    const stressValue =\n      parseRatingNearText(lowerText, 'stress') ??\n      inferStressFromAdjectives(lowerText)\n\n    if (periodStartSignal || periodEndSignal) tagNames.add('period')\n    if (painSignal || painHealedSignal) tagNames.add('pain')\n    if (bodyPartMatch?.[1]) tagNames.add(bodyPartMatch[1])\n    if (workoutStartSignal || workoutEndSignal) tagNames.add('workout')\n    if (/\\b(work|shift)\\b/.test(lowerText)) tagNames.add('work')\n    if (/\\b(clinic|patients|inpatient|rounds)\\b/.test(lowerText)) tagNames.add('clinic')\n    if (/\\b(call|phone)\\b/.test(lowerText)) tagNames.add('call')\n    if (/\\b(bank|loan|mortgage|finance)\\b/.test(lowerText)) tagNames.add('finance')\n    if (/\\b(gym)\\b/.test(lowerText)) tagNames.add('gym')\n    if (/\\b(run|running|ran)\\b/.test(lowerText)) tagNames.add('run')\n    if (/\\b(ate|eat|eating|meal|breakfast|lunch|dinner|snack|protein)\\b/.test(lowerText)) tagNames.add('food')\n    if (/\\b(drink|drank|water|hydration|hydrate)\\b/.test(lowerText)) tagNames.add('hydration')\n    if (/\\b(sleep|nap)\\b/.test(lowerText)) tagNames.add('sleep')\n    if (boredSignal) tagNames.add('bored')\n    if (moodValue != null) tagNames.add('mood')\n    if (energyValue != null) tagNames.add('energy')\n    if (stressValue != null) tagNames.add('stress')\n\n    const implicitPeople = extractImplicitPeople(captureText)\n    const implicitPlaces = extractImplicitPlaces(captureText)\n    const implicitMoneyUsd = extractMoneyUsd(captureText)\n    const implicitShoppingItems = extractShoppingItems(captureText)\n    const trackerTokens = extractTrackerTokens(captureText)\n    const moodMentions = extractMoodMentions(captureText)\n    const habitMentions = detectHabitMentionsWithPolarity(captureText, habitDefs)\n    const habitHits = habitMentions.filter((m) => m.polarity === 'positive').map((m) => m.habit)\n    const localWorkout = parseWorkoutFromText(captureText)\n    const localMeal = parseMealFromText(captureText, { nowMs: anchorMs ?? Date.now() })\n    if (implicitMoneyUsd != null && Number.isFinite(implicitMoneyUsd)) tagNames.add('money')\n    if (implicitShoppingItems.length) tagNames.add('shopping')\n\n    const allTagTokens = [...tagNames].map((t) => `#${t}`)\n\n    const contextTokens = extractContextTokens(captureText)\n    const allContexts = uniqStrings([...contextTokens, ...fmContexts, ...markdownTokens.contexts])\n\n    const mentions = extractAtMentions(captureText)\n    const personCandidates: string[] = []\n    const placeMentions: string[] = []\n    const entityIds: string[] = []\n    const entityIdSet = new Set<string>()\n    if (fmLocation) placeMentions.push(fmLocation)\n\n    for (const tag of tagNames) {\n      const ent = await ensureEntity('tag', tag, `#${tag}`)\n      if (!entityIdSet.has(ent.id)) {\n        entityIdSet.add(ent.id)\n        entityIds.push(ent.id)\n      }\n    }\n\n    for (const p of fmPeople) {\n      if (!p) continue\n      personCandidates.push(p)\n    }\n\n    for (const p of markdownTokens.people) {\n      if (!p) continue\n      personCandidates.push(p)\n    }\n\n    for (const pl of markdownTokens.places) {\n      if (!pl) continue\n      placeMentions.push(pl)\n    }\n\n    for (const m of mentions) {\n      const lower = m.raw.toLowerCase()\n      const looksPerson = /\\b(with|call|text|dm|email)\\b/.test(m.before) || ['mom', 'dad', 'doctor', 'dr', 'alex'].includes(lower)\n      if (looksPerson) personCandidates.push(m.raw)\n      else placeMentions.push(m.raw)\n    }\n\n    for (const p of implicitPeople) {\n      if (!p) continue\n      personCandidates.push(p)\n    }\n\n    for (const pl of implicitPlaces) {\n      if (!pl) continue\n      placeMentions.push(pl)\n    }\n\n    function pickLocationForText(text: string) {\n      const hay = text.toLowerCase()\n      for (const pl of placeMentions) {\n        if (!pl) continue\n        if (hay.includes(pl.toLowerCase())) return pl\n      }\n      return null\n    }\n\n    function formatDateOnly(ms: number) {\n      const d = new Date(ms)\n      const yyyy = d.getFullYear()\n      const mm = String(d.getMonth() + 1).padStart(2, '0')\n      const dd = String(d.getDate()).padStart(2, '0')\n      return `${yyyy}-${mm}-${dd}`\n    }\n\n    function formatTimeOnly(ms: number) {\n      const d = new Date(ms)\n      const hh = String(d.getHours()).padStart(2, '0')\n      const mm = String(d.getMinutes()).padStart(2, '0')\n      return `${hh}:${mm}`\n    }\n\n    function summarizeCapture(text: string) {\n      const cleaned = text.replace(/\\s+/g, ' ').trim()\n      if (!cleaned) return 'Capture'\n      const sentence = cleaned.split(/[.!?]/)[0] ?? cleaned\n      const words = sentence.split(/\\s+/).filter(Boolean)\n      return words.slice(0, 10).join(' ')\n    }\n\n    function hasQuestionIntent(text: string) {\n      return /\\?|\\b(what|why|how|when|where|who|which|should|could|do i|do we|need to|how do i|how do we|what do i|what do we)\\b/i.test(text)\n    }\n\n    function stripNoteArtifacts(text: string) {\n      return text\n        .replace(/\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g, '')\n        .replace(/\\[(?:event|task|meal|workout|tracker|habit)\\]/gi, '')\n        .replace(/\\s+/g, ' ')\n        .trim()\n    }\n\n    function splitCaptureDetails(text: string) {\n      const cleaned = stripNoteArtifacts(text)\n      if (!cleaned) return []\n      const parts = cleaned.match(/[^.!?]+[.!?]?/g) ?? [cleaned]\n      const trimmed = parts\n        .map((p) => p.trim())\n        .filter(Boolean)\n        .map((p) => (p.length > 180 ? `${p.slice(0, 177).trimEnd()}...` : p))\n      return uniqStrings(trimmed).slice(0, 8)\n    }\n\n    function splitNotesAndQuestions(text: string) {\n      const sentences = splitCaptureDetails(text)\n      const notes: string[] = []\n      const questions: string[] = []\n      const questionRe = /\\?|\\b(what|why|how|when|where|who|which|should|could|do i|do we|need to|how do i|how do we|what do i|what do we)\\b/i\n      for (const sentence of sentences) {\n        if (questionRe.test(sentence)) questions.push(sentence.replace(/\\?+$/, '?'))\n        else notes.push(sentence)\n      }\n      return { notes, questions }\n    }\n\n    function buildAttachedCaptureMarkdown(\n      nowMs: number,\n      opts?: { tasks?: Array<any>; events?: Array<any> },\n    ) {\n      const d = new Date(nowMs)\n      const hh = String(d.getHours()).padStart(2, '0')\n      const mm = String(d.getMinutes()).padStart(2, '0')\n      const summary = summarizeCapture(captureText)\n      const segmentToken = `{seg:${makeTokenId('seg', `${hh}${mm}`)}}`\n      const noteToken = `{note:${makeTokenId('note', `${hh}${mm}`)}}`\n      const typeTag = (label: string) => toInlineToken('#', 'tag', label)\n\n      const summaryLower = summary.toLowerCase()\n      const headerTags = Array.from(tagNames).filter((t) => {\n        if (explicitTagNames.has(t)) return true\n        if (!t) return false\n        const rx = new RegExp(String.raw`\\b${escapeRegExp(t)}\\b`, 'i')\n        return rx.test(summaryLower)\n      })\n      const tagTokens = headerTags.slice(0, 6).map((t) => toInlineToken('#', 'tag', t))\n      const peopleTokens = uniqStrings(personMentions).slice(0, 4).map((p) => toInlineToken('@', 'person', p))\n      const contextTokens = allContexts.slice(0, 4).map((c) => toInlineToken('*', 'ctx', c))\n      const placeTokens = uniqStrings(placeMentions).slice(0, 3).map((p) => toInlineToken('!', 'loc', p))\n      const goalToken = goalOverride ? [toInlineToken('^', 'goal', goalOverride)] : []\n      const projectToken = projectOverride ? [toInlineToken('$', 'project', projectOverride)] : []\n\n      const headerTokens = [...tagTokens, ...peopleTokens, ...contextTokens, ...placeTokens, ...goalToken, ...projectToken].filter(Boolean)\n      const header = `- **${hh}:${mm}** - ${summary}${headerTokens.length ? ` ${headerTokens.join(' ')}` : ''} ${segmentToken}`\n      const noteType = typeTag('note')\n      const questionType = hasQuestionIntent(captureText) ? typeTag('question') : ''\n      const { notes: detailNotes, questions: detailQuestions } = splitNotesAndQuestions(captureText)\n\n      const lines = [header]\n\n      if (detailNotes.length) {\n        lines.push(`  - Notes ${noteToken}${noteType ? ` ${noteType}` : ''}`)\n        lines.push(...detailNotes.map((line) => `    - ${line}`))\n      }\n      if (detailQuestions.length) {\n        lines.push(`  - Questions${questionType ? ` ${questionType}` : ''}`)\n        lines.push(...detailQuestions.map((line) => `    - ${line}`))\n      }\n\n      const taskSource = (opts?.tasks ?? []).filter((t) => typeof t?.title === 'string' && t.title.trim())\n      const taskCandidates = taskSource.length\n        ? taskSource.map((t) => ({\n            title: t.title,\n            estimateMinutes: t.estimateMinutes ?? durationOverride ?? null,\n            dueAt: t.dueAt ?? (t.dueAtIso ? new Date(t.dueAtIso).getTime() : null),\n            goal: t.goal ?? null,\n            project: t.project ?? null,\n          }))\n        : implicitShoppingItems.map((item) => ({\n            title: `Buy ${item}`,\n            estimateMinutes: 5,\n            dueAt: nowMs + 24 * 60 * 60 * 1000,\n            goal: null,\n            project: null,\n          }))\n\n      if (taskCandidates.length) {\n        lines.push('  - Tasks')\n        for (const task of taskCandidates.slice(0, 10)) {\n          const meta: string[] = []\n          if (task.estimateMinutes != null) meta.push(`est:${Math.round(task.estimateMinutes)}m`)\n          if (task.dueAt != null) meta.push(`due:${formatDateOnly(task.dueAt)}`)\n          const token = `{task:${makeTokenId('task', task.title)}${meta.length ? ` ${meta.join(' ')}` : ''}}`\n          const taskType = typeTag('task')\n          const chips = [\n            task.goal ? toInlineToken('^', 'goal', task.goal) : '',\n            task.project ? toInlineToken('$', 'project', task.project) : '',\n          ].filter(Boolean).join(' ')\n          lines.push(`    - [ ] ${task.title} ${token}${taskType ? ` ${taskType}` : ''}${chips ? ` ${chips}` : ''}`)\n        }\n      }\n\n      const eventSource = (opts?.events ?? []).filter((e) => typeof e?.title === 'string' && e.title.trim())\n      if (eventSource.length) {\n        let addedHeader = false\n        for (const ev of eventSource.slice(0, 6)) {\n          const kind = (ev.kind as any) ?? 'event'\n          if (kind === 'log') continue\n          const startMs = typeof ev.startAt === 'number' ? ev.startAt : (ev.startAtIso ? new Date(ev.startAtIso).getTime() : NaN)\n          const endMs = typeof ev.endAt === 'number' ? ev.endAt : (ev.endAtIso ? new Date(ev.endAtIso).getTime() : NaN)\n          if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) continue\n          if (!addedHeader) {\n            lines.push('  - Events')\n            addedHeader = true\n          }\n          const eventMeta = [\n            `date:${formatDateOnly(startMs)}`,\n            `start:${formatTimeOnly(startMs)}`,\n            `end:${formatTimeOnly(endMs)}`,\n          ]\n          const eventToken = `{event:${makeTokenId('event', ev.title)} ${eventMeta.join(' ')}}`\n          const eventType = typeTag('event')\n          const eventTags = Array.isArray(ev.tags) ? ev.tags.map((t: string) => toInlineToken('#', 'tag', String(t).replace(/^#/, ''))) : []\n          const eventPeople = Array.isArray(ev.people) ? ev.people.map((p: string) => toInlineToken('@', 'person', String(p))) : []\n          const eventLoc = ev.location ? [toInlineToken('!', 'loc', String(ev.location))] : []\n          const eventGoal = ev.goal ? [toInlineToken('^', 'goal', String(ev.goal))] : []\n          const eventProject = ev.project ? [toInlineToken('$', 'project', String(ev.project))] : []\n          const eventChips = [eventType, ...eventTags, ...eventPeople, ...eventLoc, ...eventGoal, ...eventProject].filter(Boolean).join(' ')\n          lines.push(`    - [event] ${ev.title} ${eventToken}${eventChips ? ` ${eventChips}` : ''}`)\n        }\n      }\n\n      if (trackerTokens.length) {\n        const trackerLine = trackerTokens\n          .slice(0, 4)\n          .map((t) => `#${t.name}(${Math.round(t.value)}){tracker:${makeTokenId('tracker', t.name)}}`)\n          .join(' ')\n        const trackerType = typeTag('tracker')\n        lines.push('  - Trackers')\n        lines.push(`    - ${trackerLine}${trackerType ? ` ${trackerType}` : ''}`)\n      }\n\n      if (habitHits.length) {\n        lines.push('  - Habits')\n        for (const h of habitHits.slice(0, 4)) {\n          const minutes = Math.max(5, h.estimateMinutes ?? 15)\n          const habitType = typeTag('habit')\n          lines.push(`    - [x] ${h.name} {habit:${makeTokenId('habit', h.name)} value:${minutes}m}${habitType ? ` ${habitType}` : ''}`)\n        }\n      }\n\n      if (localMeal && localMeal.items?.length) {\n        const mealTitle = localMeal.items.length === 1 ? localMeal.items[0].name : localMeal.type ?? 'Meal'\n        const mealType = typeTag('meal')\n        lines.push('  - Meal')\n        lines.push(`    - [meal] ${mealTitle} {meal:${makeTokenId('meal', mealTitle)}}${mealType ? ` ${mealType}` : ''}`)\n        for (const item of localMeal.items.slice(0, 5)) {\n          lines.push(`      - item: ${item.name}`)\n        }\n      }\n\n      if (localWorkout && localWorkout.exercises?.length) {\n        const workoutType = typeTag('workout')\n        lines.push('  - Workout')\n        lines.push(`    - [workout] ${localWorkout.title ?? 'Workout'} {workout:${makeTokenId('workout', 'workout')}}${workoutType ? ` ${workoutType}` : ''}`)\n        for (const ex of localWorkout.exercises.slice(0, 4)) {\n          lines.push(`      - exercise: ${ex.name}`)\n        }\n      }\n\n      return lines.join('\\n').trim()\n    }\n\n    const personMentions = cleanPeopleList(personCandidates)\n    for (const p of personMentions) {\n      const ent = await ensureEntity('person', p, p)\n      if (!entityIdSet.has(ent.id)) {\n        entityIdSet.add(ent.id)\n        entityIds.push(ent.id)\n      }\n    }\n    for (const pl of uniqStrings(placeMentions)) {\n      const ent = await ensureEntity('place', pl, pl)\n      if (!entityIdSet.has(ent.id)) {\n        entityIdSet.add(ent.id)\n        entityIds.push(ent.id)\n      }\n    }\n\n    const detectedTags = allTagTokens.slice(0, 16).join(' ')\n    const detectedPeople = uniqStrings(personMentions).slice(0, 10).join(', ')\n    const detectedPlaces = uniqStrings(placeMentions).slice(0, 10).join(', ')\n    const detectedContexts = allContexts.slice(0, 10).join(', ')\n    if (detectedTags) setCaptureProgress((p) => [...p, `Detected tags: ${detectedTags}`].slice(-10))\n    if (detectedPeople) setCaptureProgress((p) => [...p, `Detected people: ${detectedPeople}`].slice(-10))\n    if (detectedPlaces) setCaptureProgress((p) => [...p, `Detected places: ${detectedPlaces}`].slice(-10))\n    if (detectedContexts) setCaptureProgress((p) => [...p, `Detected contexts: ${detectedContexts}`].slice(-10))\n\n\t    const nowMs = anchorMs\n\t    const wallNowMs = Date.now()\n\t    const attachedMode = Boolean(captureAttachEventId)\n\t    const note = await addInboxCapture(text, { createdAt: anchorMs, entityIds })\n\t    setCaptures((prev) => [note, ...prev])\n\t    setCaptureProgress((p) => [...p, 'Saved transcript note'].slice(-10))\n\n\t    let activeForLogsId: string | null | undefined = undefined\n\t    async function getActiveForLogsId() {\n\t      if (activeForLogsId !== undefined) return activeForLogsId\n\t      activeForLogsId = (await findBestActiveEventAt(nowMs))?.id ?? null\n\t      return activeForLogsId\n\t    }\n\n    const createdTaskKeys = new Set<string>()\n    const createdEventKeys = new Set<string>()\n    const makeTaskKey = (title: string) => title.trim().toLowerCase()\n    const makeEventKey = (title: string, startAt: number, endAt: number) => {\n      const q = 5 * 60 * 1000\n      const s = Math.round(startAt / q)\n      const d = Math.round(Math.max(q, endAt - startAt) / q)\n      return `${title.trim().toLowerCase()}@${s}+${d}`\n    }\n\n\t    let lastCreated: Selection = { kind: 'none' }\n\t    let navigateToMs: number | null = null\n\t    let capturePrimaryEventId: string | null = null\n\t    let mealEventId: string | null = null\n\t    let mealEvent: CalendarEvent | null = null\n\t    let captureHasNonLogEvent = false\n\t    let createdEventCount = 0\n\t    let createdLogCount = 0\n\t    let createdTaskCount = 0\n    const createdTrackerKeys = new Set<string>()\n    const allowEventCreation = !attachedMode\n    const allowTaskCreation = !attachedMode\n    if (attachedMode && captureAttachEventId) {\n      capturePrimaryEventId = captureAttachEventId\n    }\n\n    async function createTrackerLog(opts: {\n      key: string\n      value?: number | null\n      label?: string\n      icon?: IconName | null\n      color?: string | null\n      atMs?: number\n      dedupeKey?: string\n    }) {\n      const trackerKey = opts.key.trim().toLowerCase()\n      const dedupeKey = (opts.dedupeKey ?? trackerKey).trim().toLowerCase()\n      if (createdTrackerKeys.has(dedupeKey)) return null\n      const def = ensureTrackerDefinition({ key: trackerKey, label: opts.label, icon: opts.icon, color: opts.color })\n      const unit = def?.unit ?? defaultTrackerUnit(trackerKey)\n      let value = typeof opts.value === 'number' && Number.isFinite(opts.value) ? opts.value : null\n      if (value != null) {\n        if (unit.step && unit.step > 0) value = Math.round(value / unit.step) * unit.step\n        if (unit.min != null) value = Math.max(unit.min, value)\n        if (unit.max != null) value = Math.min(unit.max, value)\n      }\n      const label = def?.label ?? opts.label ?? trackerKey\n      const unitSuffix = unit.label && unit.label !== 'value' && unit.label !== 'score' ? ` ${unit.label}` : ''\n      const title = value != null ? `${label}: ${value}${unitSuffix}` : label\n      const startAt = opts.atMs ?? nowMs\n      const endAt = startAt + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) return null\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: [`#${trackerKey}`] })\n      const log = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        trackerKey,\n        icon: opts.icon ?? def?.icon ?? null,\n        color: opts.color ?? def?.color ?? null,\n        goal: goalOverride,\n        project: projectOverride,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n      })\n      setEvents((prev) => [log, ...prev])\n      createdEventKeys.add(makeEventKey(log.title, log.startAt, log.endAt))\n      createdTrackerKeys.add(dedupeKey)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${log.title}`].slice(-10))\n      return log\n    }\n\n    function normalizeHashTag(x: string) {\n      const t = x.trim()\n      if (!t) return ''\n      return t.startsWith('#') ? t : `#${t}`\n    }\n\n    function deriveKeywordTag(title: string, category?: string | null, subcategory?: string | null) {\n      const stop = new Set(['the', 'a', 'an', 'with', 'and', 'for', 'to', 'from', 'at', 'in', 'on', 'of', 'my'])\n      const base = title\n        .toLowerCase()\n        .split(/[^a-z0-9]+/)\n        .filter(Boolean)\n        .filter((w) => w.length > 3 && !stop.has(w))\n      const avoid = new Set([category ?? '', subcategory ?? ''].map((x) => x.toLowerCase()))\n      const picked = base.find((w) => !avoid.has(w))\n      return picked ? toTagTokenFromLabel(picked) : ''\n    }\n\n    function buildTagTokens(\n      baseTags: string[],\n      opts?: { category?: string | null; subcategory?: string | null; title?: string; location?: string | null; includeGlobals?: string[] },\n    ) {\n      const normalized = new Set((opts?.includeGlobals ?? []).map(normalizeHashTag).filter(Boolean))\n      for (const t of baseTags) normalized.add(normalizeHashTag(t))\n      const derived: string[] = []\n      if (opts?.category) derived.push(toTagTokenFromLabel(opts.category))\n      if (opts?.subcategory) derived.push(toTagTokenFromLabel(opts.subcategory))\n      if (opts?.location) derived.push(toTagTokenFromLabel(opts.location.split(/[,|/]/)[0] ?? opts.location))\n      if (opts?.title) derived.push(deriveKeywordTag(opts.title, opts?.category ?? null, opts?.subcategory ?? null))\n      for (const tag of derived) {\n        if (!tag) continue\n        if (normalized.size >= 5) break\n        normalized.add(tag)\n      }\n      if (normalized.size < 3) normalized.add('#general')\n      return Array.from(normalized)\n    }\n\n    function mergeWithGlobalTags(\n      tags: string[] | null | undefined,\n      opts?: { category?: string | null; subcategory?: string | null; title?: string; location?: string | null; includeGlobals?: boolean },\n    ) {\n      const includeGlobals = opts?.includeGlobals ? allTagTokens : []\n      return buildTagTokens(tags ?? [], { ...opts, includeGlobals })\n    }\n\n    function finalizeCategorizedTags(opts: {\n      title: string\n      tags?: string[] | null\n      current?: { category?: string | null; subcategory?: string | null }\n      location?: string | null\n      includeGlobals?: boolean\n    }) {\n      const baseTags = [...(opts.tags ?? [])]\n      const inferred = resolveCategory(opts.title, baseTags, opts.current, activeRules.length ? activeRules : undefined)\n      const mergedTags = mergeWithGlobalTags(baseTags, {\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        title: opts.title,\n        location: opts.location ?? null,\n        includeGlobals: opts.includeGlobals,\n      })\n      return { mergedTags, inferred }\n    }\n\n    function isMealEventCandidate(title: string, tags?: string[] | null) {\n      const lower = `${title ?? ''} ${(tags ?? []).join(' ')}`.toLowerCase()\n      if (/\\b(breakfast|lunch|dinner|snack|meal|brunch)\\b/.test(lower)) return true\n      return (tags ?? []).some((tag) => normalizeTagName(tag) === 'food')\n    }\n\n    function rememberMealEvent(ev: CalendarEvent) {\n      if (mealEventId) return\n      if (ev.kind === 'log') return\n      if (!isMealEventCandidate(ev.title, ev.tags)) return\n      mealEventId = ev.id\n      mealEvent = ev\n    }\n\n  function inferCategorySubcategory(title: string, tags: string[], baseRules?: Array<{ match: string; category?: string; subcategory?: string; tags?: string[] }>) {\n    const t = title.toLowerCase()\n    const tagSet = new Set(tags.map((x) => x.replace(/^#/, '').toLowerCase()))\n\n    let category: string | null = null\n    let subcategory: string | null = null\n\n    if (baseRules?.length) {\n      for (const rule of baseRules) {\n        const rx = rule.match?.trim()\n        if (!rx) continue\n        try {\n          const re = new RegExp(rx, 'i')\n          if (!re.test(title)) continue\n          if (rule.category && !category) category = rule.category\n          if (rule.subcategory && !subcategory) subcategory = rule.subcategory\n          if (rule.tags?.length) {\n            for (const tag of rule.tags) tagSet.add(tag.replace(/^#/, '').toLowerCase())\n          }\n          break\n        } catch {\n          // ignore malformed rule\n        }\n      }\n    }\n\n    for (const rawTag of tags) {\n      const cleaned = rawTag.replace(/^#/, '').trim()\n      if (!cleaned || !cleaned.includes('/')) continue\n      const [cat, sub] = cleaned.split('/', 2)\n\t\t        if (cat) category = toTitleCase(cat)\n\t\t        if (sub) subcategory = toTitleCase(sub)\n\t\t        break\n\t\t      }\n\n      const workoutMatch = tagSet.has('workout') || /\\b(workout|gym|lift|lifting|run|cardio|yoga|training)\\b/.test(t)\n      if (workoutMatch) {\n        category = 'Health'\n        subcategory = subcategory ?? 'Workout'\n      }\n\n\t\t      if (!category && (tagSet.has('work') || /\\b(work|shift)\\b/.test(t))) category = 'Work'\n      if (tagSet.has('clinic') || /\\b(clinic|patients|rounds|inpatient)\\b/.test(t)) {\n        category = category ?? 'Work'\n        subcategory = 'Clinic'\n      }\n      if (tagSet.has('meeting') || /\\b(meeting|conference|rounds)\\b/.test(t)) {\n        category = category ?? 'Work'\n        subcategory = subcategory ?? 'Meeting'\n      }\n      if (tagSet.has('surgery') || /\\b(surgery)\\b/.test(t)) {\n        category = category ?? 'Work'\n        subcategory = 'Surgery'\n      }\n\t\t      if (tagSet.has('didactics') || /\\b(didactics)\\b/.test(t)) {\n\t\t        category = category ?? 'Work'\n\t\t        subcategory = subcategory ?? 'Didactics'\n\t\t      }\n\t\t      if (tagSet.has('study') || /\\b(study|lecture|reading)\\b/.test(t)) {\n\t\t        category = category ?? 'Learning'\n\t\t        subcategory = subcategory ?? (/\\b(read|reading)\\b/.test(t) ? 'Reading' : 'Practice')\n\t\t      }\n\t\t      if (tagSet.has('workout') || /\\b(workout|gym|lift|lifting|run|cardio|yoga|training)\\b/.test(t)) {\n\t\t        category = 'Health'\n\t\t        subcategory = subcategory ?? 'Workout'\n\t\t      }\n\t\t      if (tagSet.has('sleep') || /\\b(sleep|nap)\\b/.test(t)) {\n\t\t        category = category ?? 'Health'\n\t\t        subcategory = subcategory ?? 'Sleep'\n\t\t      }\n      if (tagSet.has('shopping') || /\\b(grocery|shopping|store|errand)\\b/.test(t)) {\n        category = category ?? 'Personal'\n        subcategory = subcategory ?? (/\\b(grocery|groceries)\\b/.test(t) ? 'Groceries' : 'Errands')\n      }\n      if (tagSet.has('morning') || /\\b(get ready|morning routine|prep|ready for work)\\b/.test(t)) {\n        category = category ?? 'Personal'\n        subcategory = subcategory ?? 'Morning Routine'\n      }\n      if (tagSet.has('food') || /\\b(dinner|lunch|breakfast|meal|restaurant|food)\\b/.test(t)) {\n        category = category ?? 'Food'\n        subcategory = subcategory ?? (/\\b(restaurant|dinner out|lunch out|eat out)\\b/.test(t) ? 'Restaurant' : 'Meal')\n      }\n      if (tagSet.has('walk') || /\\b(walk|stroll)\\b/.test(t)) {\n        category = category ?? 'Personal'\n        subcategory = subcategory ?? 'Health'\n      }\n\t\t      if (tagSet.has('transport') || /\\b(transport|drive|driving|commute|flight|fly|uber|lyft|train|bus|parking)\\b/.test(t)) {\n\t\t        category = category ?? 'Transport'\n\t\t        if (/\\b(flight|fly|airport)\\b/.test(t)) subcategory = subcategory ?? 'Flight'\n\t\t        else if (/\\b(train|bus|transit|subway)\\b/.test(t)) subcategory = subcategory ?? 'Transit'\n\t\t        else if (/\\b(parking)\\b/.test(t)) subcategory = subcategory ?? 'Parking'\n\t\t        else subcategory = subcategory ?? 'Driving'\n\t\t      }\n\t\t      if (tagSet.has('finance') || /\\b(bank|finance|mortgage|loan|bill|budget|expense)\\b/.test(t)) {\n\t\t        category = category ?? 'Finance'\n\t\t        subcategory = subcategory ?? (/\\b(bank)\\b/.test(t) ? 'Banking' : /\\b(bill|bills)\\b/.test(t) ? 'Bills' : 'Budget')\n\t\t      }\n\t\t      // Job applications\n\t\t      if (/\\b(job|application|apply|resume|interview|hiring|career)\\b/.test(t)) {\n\t\t        category = category ?? 'Work'\n\t\t        subcategory = subcategory ?? 'Job Applications'\n\t\t      }\n\t\t      // Rent payment\n\t\t      if (/\\b(rent|landlord|lease|tenant)\\b/.test(t)) {\n\t\t        category = category ?? 'Finance'\n\t\t        subcategory = subcategory ?? 'Rent'\n\t\t      }\n\t\t      // Skincare/self-care\n\t\t      if (/\\b(microneedle|skincare|facial|derma|beauty|skin)\\b/.test(t)) {\n\t\t        category = category ?? 'Personal'\n\t\t        subcategory = subcategory ?? 'Skincare'\n\t\t      }\n\t\t      // House chores/cleaning\n\t\t      if (/\\b(clean|cleaning|chore|chores|tidy|vacuum|laundry|dishes)\\b/.test(t)) {\n\t\t        category = category ?? 'Personal'\n\t\t        subcategory = subcategory ?? 'Chores'\n\t\t      }\n\t\t      // Costco/specific stores\n\t\t      if (/\\b(costco|walmart|target|trader joe|whole foods|safeway)\\b/i.test(t)) {\n\t\t        category = category ?? 'Personal'\n\t\t        subcategory = subcategory ?? 'Errands'\n\t\t      }\n\n\t\t      // Fall back to the starter taxonomy (keeps categories consistent).\n\t\t      if (category) {\n\t\t        const categoryLower = category.toLowerCase()\n\t\t        const canonical = categoriesFromStarter().find((c) => c.toLowerCase() === categoryLower)\n\t\t        if (canonical) category = canonical\n\t\t      }\n\t\t      if (category && subcategory) {\n\t\t        const subs = subcategoriesFromStarter(category)\n\t\t        const subLower = subcategory.toLowerCase()\n\t\t        const canonicalSub = subs.find((s) => s.toLowerCase() === subLower)\n\t\t        if (canonicalSub) subcategory = canonicalSub\n\t\t      }\n\n\t\t      return { category, subcategory }\n\t\t    }\n\n    function resolveCategory(\n      title: string,\n      tags: string[],\n      current?: { category?: string | null; subcategory?: string | null },\n      rules?: Array<{ match: string; category?: string; subcategory?: string; tags?: string[] }>,\n    ) {\n      const inferred = inferCategorySubcategory(title, tags, rules)\n      const fallbackCategory = categoryOverride ?? current?.category ?? inferred.category ?? 'Personal'\n      let fallbackSubcategory = subcategoryOverride ?? current?.subcategory ?? inferred.subcategory ?? null\n      if (!fallbackSubcategory) {\n        const categoryLower = fallbackCategory.toLowerCase()\n        if (/\\b(get ready|morning routine|prep|ready for work)\\b/.test(title.toLowerCase())) {\n          fallbackSubcategory = 'Morning Routine'\n        } else if (categoryLower === 'food') {\n          fallbackSubcategory = 'Meal'\n        } else {\n          fallbackSubcategory = 'General'\n        }\n      }\n      recordTaxonomyEntry(fallbackCategory, fallbackSubcategory)\n      return { category: fallbackCategory, subcategory: fallbackSubcategory }\n    }\n\n    function isWorkLikeParsedEvent(ev: ParsedEvent) {\n      const text = `${ev.title ?? ''} ${ev.sourceText ?? ''}`.toLowerCase()\n      const tagSet = new Set((ev.tags ?? []).map(normalizeTagName))\n      return tagSet.has('work') || tagSet.has('clinic') || /\\b(work|clinic|patients|inpatient|rounds|didactics)\\b/.test(text)\n    }\n\n    function isStandaloneUntimed(ev: ParsedEvent) {\n      const text = `${ev.title ?? ''} ${ev.sourceText ?? ''}`.toLowerCase()\n      const tagSet = new Set((ev.tags ?? []).map(normalizeTagName))\n      if (tagSet.has('food') || /\\b(dinner|lunch|breakfast|meal|restaurant)\\b/.test(text)) return true\n      if (tagSet.has('shopping') || /\\b(grocery|shopping|store|errand)\\b/.test(text)) return true\n      if (tagSet.has('finance') || /\\b(bank|finance|bill|budget)\\b/.test(text)) return true\n      if (tagSet.has('transport') || /\\b(transport|drive|driving|commute|flight|uber|lyft|train|bus)\\b/.test(text)) return true\n      return false\n    }\n\n    function appendSegment(notes: string | null | undefined, line: string) {\n      if (!line) return notes ?? ''\n      return notes && notes.trim().length ? `${notes}\\n${line}` : line\n    }\n\n    function groupParsedEvents(parsed: ParsedEvent[]) {\n      const output: ParsedEvent[] = []\n      const workCandidates = parsed.filter((e) => Boolean(e.explicitTime) && (e.kind ?? 'event') === 'event' && isWorkLikeParsedEvent(e))\n      const workBlock =\n        workCandidates.length >= 2\n          ? ({\n              title: 'Work',\n              startAt: Math.min(...workCandidates.map((e) => e.startAt)),\n              endAt: Math.max(...workCandidates.map((e) => e.endAt)),\n              kind: 'event',\n              notes: '',\n              estimateMinutes: Math.round(\n                (Math.max(...workCandidates.map((e) => e.endAt)) - Math.min(...workCandidates.map((e) => e.startAt))) / (60 * 1000),\n              ),\n              explicitTime: true,\n              sourceText: 'work block',\n            } as ParsedEvent)\n          : null\n      let workBlockInserted = false\n      let currentExplicit: ParsedEvent | null = null\n\n      for (const ev of parsed) {\n        const kind = (ev.kind ?? 'event') as CalendarEvent['kind']\n        const inWorkWindow =\n          Boolean(workBlock) &&\n          (ev.kind ?? 'event') === 'event' &&\n          ev.startAt >= workBlock!.startAt &&\n          ev.startAt < workBlock!.endAt\n\n        if (workBlock && inWorkWindow) {\n          if (!workBlockInserted) {\n            output.push(workBlock)\n            workBlockInserted = true\n          }\n          currentExplicit = workBlock\n          const line = formatSegmentLine(ev.startAt ?? null, segmentLabelForEvent(ev))\n          workBlock.notes = appendSegment(workBlock.notes ?? '', line)\n          continue\n        }\n\n        if (kind === 'log' || kind === 'episode') {\n          output.push(ev)\n          continue\n        }\n        if (ev.explicitTime) {\n          output.push(ev)\n          currentExplicit = ev\n          continue\n        }\n        if (currentExplicit && !isStandaloneUntimed(ev)) {\n          const atMs = ev.explicitTime ? ev.startAt : currentExplicit.startAt\n          const line = formatSegmentLine(atMs ?? null, segmentLabelForEvent(ev))\n          currentExplicit.notes = appendSegment(currentExplicit.notes ?? '', line)\n          continue\n        }\n        output.push(ev)\n      }\n      return output\n    }\n\n    function hasExplicitSplitSignals(text: string) {\n      return /\\b(later|after|afterwards|then|tomorrow|yesterday|next week|next month|next year|this morning|this afternoon|this evening|tonight|this noon|this midday|this lunch|morning|afternoon|evening|tonight|noon|midday|lunch|at \\d{1,2}(?::\\d{2})?\\s*(am|pm)?)\\b/i.test(text)\n    }\n\n    function hasMultipleMoneyAmounts(text: string) {\n      const matches = text.match(/\\$\\s*\\d+(?:\\.\\d{1,2})?/g) ?? []\n      const altMatches = text.match(/\\b\\d+(?:\\.\\d{1,2})?\\s*(?:dollars|bucks)\\b/gi) ?? []\n      const total = matches.length + altMatches.length\n      return total >= 2\n    }\n\n    function mergeNotes(base: string | null | undefined, lines: string[]) {\n      const cleaned = lines.map((l) => l.trim()).filter(Boolean)\n      if (!cleaned.length) return base ?? ''\n      const block = cleaned.map((l) => `- ${l}`).join('\\n')\n      if (!base || !base.trim()) return block\n      return `${base.trim()}\\n${block}`\n    }\n\n    function mergeUntimedLlmEvents(events: LlmParsedEvent[], shouldMerge: boolean) {\n      if (!shouldMerge) return events\n      const candidates = events.filter((e) => (e.kind ?? 'event') === 'event')\n      if (candidates.length <= 1) return events\n      const others = events.filter((e) => (e.kind ?? 'event') !== 'event')\n      const base = candidates[0]!\n      let startIso = base.startAtIso\n      let endIso = base.endAtIso\n      let startMs = Date.parse(startIso)\n      let endMs = Date.parse(endIso)\n      const titles: string[] = []\n      const extraNotes: string[] = []\n      const tags = new Set(base.tags ?? [])\n      const people = new Set(base.people ?? [])\n      const skills = new Set(base.skills ?? [])\n      const character = new Set(base.character ?? [])\n      let location = base.location ?? null\n      let goal = base.goal ?? null\n      let project = base.project ?? null\n      let importance = base.importance ?? null\n      let difficulty = base.difficulty ?? null\n      let costUsd = base.costUsd ?? null\n      let notes = base.notes ?? null\n\n      for (const ev of candidates.slice(1)) {\n        if (ev.title) titles.push(ev.title)\n        if (ev.notes) extraNotes.push(ev.notes)\n        for (const t of ev.tags ?? []) tags.add(t)\n        for (const p of ev.people ?? []) people.add(p)\n        for (const s of ev.skills ?? []) skills.add(s)\n        for (const c of ev.character ?? []) character.add(c)\n        if (!location && ev.location) location = ev.location\n        if (!goal && ev.goal) goal = ev.goal\n        if (!project && ev.project) project = ev.project\n        if (typeof ev.importance === 'number') importance = Math.max(importance ?? ev.importance, ev.importance)\n        if (typeof ev.difficulty === 'number') difficulty = Math.max(difficulty ?? ev.difficulty, ev.difficulty)\n        if (typeof ev.costUsd === 'number') costUsd = (costUsd ?? 0) + ev.costUsd\n\n        const evStart = Date.parse(ev.startAtIso)\n        const evEnd = Date.parse(ev.endAtIso)\n        if (Number.isFinite(evStart) && (!Number.isFinite(startMs) || evStart < startMs)) {\n          startMs = evStart\n          startIso = ev.startAtIso\n        }\n        if (Number.isFinite(evEnd) && (!Number.isFinite(endMs) || evEnd > endMs)) {\n          endMs = evEnd\n          endIso = ev.endAtIso\n        }\n      }\n\n      const mergedNotes = mergeNotes(notes, [...titles, ...extraNotes])\n      const merged: LlmParsedEvent = {\n        ...base,\n        startAtIso: startIso,\n        endAtIso: endIso,\n        tags: Array.from(tags),\n        people: Array.from(people),\n        skills: Array.from(skills),\n        character: Array.from(character),\n        location,\n        goal,\n        project,\n        importance,\n        difficulty,\n        costUsd,\n        notes: mergedNotes,\n      }\n      return [merged, ...others]\n    }\n\n    function mergeUntimedNaturalEvents(events: ParsedEvent[], shouldMerge: boolean) {\n      if (!shouldMerge) return events\n      const candidates = events.filter((e) => (e.kind ?? 'event') === 'event')\n      if (candidates.length <= 1) return events\n      const others = events.filter((e) => (e.kind ?? 'event') !== 'event')\n      const base = candidates[0]!\n      const titles: string[] = []\n      const extraNotes: string[] = []\n      const tags = new Set(base.tags ?? [])\n      const people = new Set(base.people ?? [])\n      const skills = new Set(base.skills ?? [])\n      const character = new Set(base.character ?? [])\n      let location = base.location ?? null\n      let goal = base.goal ?? null\n      let project = base.project ?? null\n      let importance = base.importance ?? null\n      let difficulty = base.difficulty ?? null\n      let startAt = base.startAt\n      let endAt = base.endAt\n\n      for (const ev of candidates.slice(1)) {\n        if (ev.title) titles.push(ev.title)\n        if (ev.notes) extraNotes.push(ev.notes)\n        for (const t of ev.tags ?? []) tags.add(t)\n        for (const p of ev.people ?? []) people.add(p)\n        for (const s of ev.skills ?? []) skills.add(s)\n        for (const c of ev.character ?? []) character.add(c)\n        if (!location && ev.location) location = ev.location\n        if (!goal && ev.goal) goal = ev.goal\n        if (!project && ev.project) project = ev.project\n        if (typeof ev.importance === 'number') importance = Math.max(importance ?? ev.importance, ev.importance)\n        if (typeof ev.difficulty === 'number') difficulty = Math.max(difficulty ?? ev.difficulty, ev.difficulty)\n        startAt = Math.min(startAt, ev.startAt)\n        endAt = Math.max(endAt, ev.endAt)\n      }\n\n      const mergedNotes = mergeNotes(base.notes, [...titles, ...extraNotes])\n      const merged: ParsedEvent = {\n        ...base,\n        startAt,\n        endAt,\n        tags: Array.from(tags),\n        people: Array.from(people),\n        skills: Array.from(skills),\n        character: Array.from(character),\n        location,\n        goal,\n        project,\n        importance,\n        difficulty,\n        notes: mergedNotes,\n      }\n      return [merged, ...others]\n    }\n\n\t    function applyDurationOverride(startAt: number, endAt: number, kind: CalendarEvent['kind']) {\n\t      if (!durationOverride || explicitTimeInCapture || kind === 'episode' || kind === 'log') return { startAt, endAt }\n\t      const nextEnd = startAt + Math.max(5, durationOverride) * 60 * 1000\n\t      return { startAt, endAt: Math.max(endAt, nextEnd) }\n\t    }\n\n\t    async function maybeCreateTaskCalendarBlock(opts: { task: Task; tags: string[]; location?: string | null; people?: string[]; contexts?: string[]; entityIds: string[] }) {\n\t      const startAt = opts.task.scheduledAt\n\t      if (!startAt) return null\n\t      const estimateMinutes = opts.task.estimateMinutes ?? durationOverride ?? 60\n\t      const endAt = startAt + Math.max(5, estimateMinutes) * 60 * 1000\n\t      const key = makeEventKey(opts.task.title, startAt, endAt)\n\t      if (createdEventKeys.has(key)) return null\n\n      const ev = await createEvent({\n        title: opts.task.title,\n        startAt,\n        endAt,\n        kind: 'task',\n        taskId: opts.task.id,\n        parentEventId: opts.task.parentEventId ?? null,\n        tags: opts.tags,\n        contexts: opts.contexts ?? opts.task.contexts ?? [],\n        notes: opts.task.notes ?? '',\n        location: opts.location ?? null,\n        people: opts.people ?? [],\n        skills: opts.task.skills ?? [],\n        character: opts.task.character ?? [],\n        category: opts.task.category ?? null,\n        subcategory: opts.task.subcategory ?? null,\n        goal: opts.task.goal ?? goalOverride ?? null,\n        project: opts.task.project ?? projectOverride ?? null,\n        importance: opts.task.importance ?? 5,\n        difficulty: opts.task.difficulty ?? 5,\n        estimateMinutes,\n        entityIds: opts.entityIds,\n        sourceNoteId: opts.task.sourceNoteId ?? null,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      setCaptureProgress((p) => [...p, `+ task block: ${ev.title}`].slice(-10))\n      return ev\n    }\n\n    // Optional: LLM-backed parsing (uses the key + parser model stored in Settings).\n    let llmSucceeded = false\n    let llmError: string | null = null\n    let llm: Awaited<ReturnType<typeof parseCaptureWithBlocksLlm>> | null = null\n    if (!llmKey && llmMode === 'llm') {\n      setCaptureError('OpenAI key is required for LLM mode. Add it in Settings and click Save.')\n      setCaptureSaving(false)\n      return\n    }\n    if (shouldTryLlm) {\n      try {\n        setCaptureAiStatus(`AI parsing (${llmParseModel})\u2026`)\n        llm = await parseCaptureWithBlocksLlm({ apiKey: llmKey, model: llmParseModel, text: captureText, anchorMs })\n        const shouldMergeUntimed = !explicitTimeInCapture && !hasExplicitSplitSignals(captureText) && !hasMultipleMoneyAmounts(captureText)\n        const mergedLlmEvents = mergeUntimedLlmEvents(llm.events, shouldMergeUntimed)\n        if (mergedLlmEvents.length !== llm.events.length) {\n          setCaptureProgress((p) => [...p, `Merged LLM events (${llm.events.length} \u2192 ${mergedLlmEvents.length})`].slice(-10))\n        }\n        llm = { ...llm, events: mergedLlmEvents }\n        setCaptureProgress((p) => [...p, `AI parsed (${llm.tasks.length} task(s), ${llm.events.length} event(s), ${llm.workouts.length} workout(s))`].slice(-10))\n        llmSucceeded = (llm.tasks.length + llm.events.length + llm.workouts.length + llm.meals.length) > 0\n        if (!llmSucceeded) {\n          const emptyMsg = allowLocalFallback ? 'AI returned empty; using local parser' : 'AI returned empty; local parsing is disabled'\n          setCaptureProgress((p) => [...p, emptyMsg].slice(-10))\n        }\n\n        // Pull any explicit people/places from the LLM result into entities + fallbacks.\n        const llmPeople = uniqStrings([\n          ...llm.tasks.flatMap((t) => (t.people ?? []).filter(Boolean)),\n          ...llm.events.flatMap((e) => (e.people ?? []).filter(Boolean)),\n        ]).slice(0, 16)\n        const llmPlaces = uniqStrings([\n          ...llm.tasks.map((t) => t.location).filter(Boolean) as string[],\n          ...llm.events.map((e) => e.location).filter(Boolean) as string[],\n        ]).slice(0, 16)\n        const cleanedLlmPeople = cleanPeopleList(llmPeople)\n        for (const p of cleanedLlmPeople) {\n          const ent = await ensureEntity('person', p, p)\n          if (!entityIdSet.has(ent.id)) {\n            entityIdSet.add(ent.id)\n            entityIds.push(ent.id)\n          }\n          personMentions.push(p)\n        }\n        for (const pl of llmPlaces) {\n          const ent = await ensureEntity('place', pl, pl)\n          if (!entityIdSet.has(ent.id)) {\n            entityIdSet.add(ent.id)\n            entityIds.push(ent.id)\n          }\n          placeMentions.push(pl)\n        }\n        if (cleanedLlmPeople.length || llmPlaces.length) {\n          await updateCaptureEntityIds(note.id, entityIds)\n          setCaptures((prev) => prev.map((c) => (c.id === note.id ? { ...c, entityIds } : c)))\n        }\n\n\t        const overrideTimes = Number.isFinite(fmStartAt ?? NaN) && Number.isFinite(fmEndAt ?? NaN) && llm.events.length === 1 && llm.tasks.length === 0\n\n\t        for (const e of llm.events) {\n\t          if (!allowEventCreation) continue\n\t          let startAt = new Date(e.startAtIso).getTime()\n\t          let endAt = new Date(e.endAtIso).getTime()\n          if (!Number.isFinite(startAt) || !Number.isFinite(endAt)) continue\n          if (overrideTimes && fmStartAt != null && fmEndAt != null) {\n            startAt = fmStartAt\n            endAt = fmEndAt\n          }\n          const shouldForceNow =\n            !overrideTimes && hasNowSignal && !explicitTimeInCapture && llm.events.length === 1 && llm.tasks.length === 0 && !e.allDay\n          if (shouldForceNow) {\n            startAt = anchorMs\n            const fallbackMinutes = e.estimateMinutes ?? durationOverride ?? 60\n            endAt = startAt + Math.max(5, fallbackMinutes) * 60 * 1000\n          }\n          const baseText = `${e.title ?? ''}\\n${e.notes ?? ''}\\n${(e.tags ?? []).join(' ')}`.trim()\n          const locationHint = e.location ?? pickLocationForText(baseText)\n          const autoImportance = e.importance ?? importanceOverride ?? inferImportanceFromText(baseText) ?? 5\n          const autoDifficulty = e.difficulty ?? difficultyOverride ?? inferDifficultyFromText(baseText) ?? 5\n          const autoCharacter = normalizeCharacterSelection(e.character ?? inferCharacterFromText(baseText, e.tags ?? []))\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: e.title, tags: e.tags ?? [], location: locationHint })\n          const rawKind = (e.kind as any) ?? 'event'\n          const inferredTrackerKey = e.trackerKey ?? inferTrackerKeyFromText(e.title, e.tags ?? [])\n          const isSleepTracker = inferredTrackerKey === 'sleep'\n          const trackerKey = isSleepTracker ? null : inferredTrackerKey\n          const kind = isSleepTracker\n            ? 'event'\n            : rawKind === 'log' || (trackerKey && LOG_TRACKER_KEYS.has(trackerKey))\n              ? 'log'\n              : rawKind\n          const times = applyDurationOverride(startAt, endAt, kind)\n            const ev = await createEvent({\n            title: e.title,\n            startAt: times.startAt,\n            endAt: Math.max(times.endAt, times.startAt + 5 * 60 * 1000),\n            kind,\n            allDay: Boolean(e.allDay),\n            active: Boolean(e.active) || shouldForceNow,\n            parentEventId: kind === 'log' ? await getActiveForLogsId() : null,\n            tags: mergedTags,\n            contexts: allContexts,\n            entityIds,\n            sourceNoteId: note.id,\n            icon: (e.icon as any) ?? null,\n            color: e.color ?? null,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            goal: e.goal ?? goalOverride ?? null,\n            project: e.project ?? projectOverride ?? null,\n            trackerKey: trackerKey ?? null,\n            importance: autoImportance,\n            difficulty: autoDifficulty,\n          })\n          const costLine = typeof e.costUsd === 'number' && Number.isFinite(e.costUsd) ? `\\nBudget: $${e.costUsd}` : ''\n          const nextNotes = e.notes ?? ev.notes\n          const normalizedNotes = normalizeTaskChecklistNotes(nextNotes)\n          const segmentedNotes = maybeSegmentNotes(normalizedNotes, times.startAt, times.endAt)\n          const next = await upsertEvent({\n            ...ev,\n            notes: (segmentedNotes ?? normalizedNotes ?? ev.notes) + costLine,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            estimateMinutes: e.estimateMinutes ?? durationOverride ?? (Boolean(e.allDay) || kind === 'episode' ? null : Math.round((times.endAt - times.startAt) / (60 * 1000))),\n            location: locationHint ?? null,\n            people: cleanPeopleList(e.people ?? uniqStrings(personMentions)),\n            skills: e.skills ?? [],\n            character: autoCharacter,\n            importance: autoImportance ?? ev.importance ?? 5,\n            difficulty: autoDifficulty ?? ev.difficulty ?? 5,\n            goal: e.goal ?? ev.goal ?? goalOverride ?? null,\n            project: e.project ?? ev.project ?? projectOverride ?? null,\n            contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n          })\n          rememberMealEvent(next)\n          if (next.active && next.kind !== 'log' && next.kind !== 'episode') {\n            await stopOtherActiveEvents(next.id, next.startAt)\n            activeForLogsId = next.id\n          }\n          setEvents((prev) => [next, ...prev])\n          createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n          if (next.kind === 'log') {\n            createdLogCount += 1\n            if (next.trackerKey) createdTrackerKeys.add(next.trackerKey)\n          }\n          else createdEventCount += 1\n          if (next.active && next.kind !== 'log' && next.kind !== 'episode') activeForLogsId = next.id\n          setCaptureProgress((p) => [...p, `+ ${next.kind}: ${next.title}`].slice(-10))\n\n\t          if (next.kind !== 'log') {\n\t            captureHasNonLogEvent = true\n\t            if (!capturePrimaryEventId) capturePrimaryEventId = next.id\n\t            lastCreated = { kind: 'event', id: next.id }\n\t            navigateToMs = next.startAt\n\t          }\n\t        }\n\n        for (const t of llm.tasks) {\n          if (!allowTaskCreation) continue\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: t.title, tags: t.tags ?? [] })\n          const taskBase = `${t.title ?? ''}\\n${t.notes ?? ''}\\n${(t.tags ?? []).join(' ')}`.trim()\n          const autoImportance = t.importance ?? importanceOverride ?? inferImportanceFromText(taskBase) ?? 5\n          const autoDifficulty = t.difficulty ?? difficultyOverride ?? inferDifficultyFromText(taskBase) ?? 5\n          const autoCharacter = normalizeCharacterSelection(t.character ?? inferCharacterFromText(taskBase, t.tags ?? []))\n          const locationHint = t.location ?? pickLocationForText(taskBase)\n          const peopleHint = cleanPeopleList(t.people ?? uniqStrings(personMentions))\n          let notes = (t.notes ?? '').trim()\n          if (!notes && implicitShoppingItems.length && (/\\b(shop|shopping|grocery|store|buy)\\b/i.test(t.title) || mergedTags.includes('#shopping'))) {\n            notes = buildShoppingNotes(implicitShoppingItems, typeof t.costUsd === 'number' ? t.costUsd : implicitMoneyUsd)\n          }\n          const task = await createTask({\n            title: t.title,\n            status: (t.status as any) ?? 'todo',\n            tags: mergedTags,\n            contexts: allContexts,\n            people: peopleHint,\n            location: locationHint ?? null,\n            skills: t.skills ?? [],\n            character: autoCharacter,\n            entityIds,\n            parentEventId: capturePrimaryEventId,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            goal: t.goal ?? goalOverride ?? null,\n            project: t.project ?? projectOverride ?? null,\n            estimateMinutes: t.estimateMinutes ?? durationOverride ?? 25,\n            importance: autoImportance,\n            difficulty: autoDifficulty,\n            sourceNoteId: note.id,\n          })\n          const next = await upsertTask({\n            ...task,\n            parentEventId: task.parentEventId ?? capturePrimaryEventId,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            notes: notes || task.notes || '',\n            estimateMinutes: t.estimateMinutes ?? durationOverride ?? task.estimateMinutes ?? 25,\n            status: (t.status as any) ?? task.status,\n            dueAt: parseIsoMs(t.dueAtIso) ?? task.dueAt ?? null,\n            scheduledAt: parseIsoMs(t.scheduledAtIso) ?? task.scheduledAt ?? null,\n            goal: t.goal ?? task.goal ?? goalOverride ?? null,\n            project: t.project ?? task.project ?? projectOverride ?? null,\n            importance: autoImportance ?? task.importance ?? 5,\n            difficulty: autoDifficulty ?? task.difficulty ?? 5,\n            people: peopleHint,\n            location: locationHint ?? null,\n            skills: t.skills ?? task.skills ?? [],\n            character: autoCharacter,\n            contexts: uniqStrings([...(task.contexts ?? []), ...allContexts]),\n          })\n\t          setTasks((prev) => [next, ...prev])\n\t          createdTaskCount += 1\n\t          createdTaskKeys.add(makeTaskKey(next.title))\n\t          setCaptureProgress((p) => [...p, `+ Task: ${next.title}`].slice(-10))\n\n\t          if (!captureHasNonLogEvent) {\n\t            lastCreated = { kind: 'task', id: next.id }\n\t            if (navigateToMs == null && next.scheduledAt) navigateToMs = next.scheduledAt\n\t          }\n\n          const block = await maybeCreateTaskCalendarBlock({\n            task: next,\n            tags: mergedTags,\n            location: t.location ?? pickLocationForText(taskBase),\n            people: cleanPeopleList(t.people ?? uniqStrings(personMentions)),\n            contexts: allContexts,\n            entityIds,\n          })\n\t          if (block && !captureHasNonLogEvent) {\n\t            lastCreated = { kind: 'event', id: block.id }\n\t            navigateToMs = block.startAt\n\t          }\n\t        }\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err)\n        llmError = msg\n        setCaptureError(msg)\n        const failMsg = allowLocalFallback\n          ? `AI parse failed; using local parser (${msg.slice(0, 80)})`\n          : `AI parse failed; local parsing is disabled (${msg.slice(0, 80)})`\n        setCaptureProgress((p) => [...p, failMsg].slice(-10))\n      } finally {\n        setCaptureAiStatus('')\n      }\n    }\n    if (!llmKey) setCaptureProgress((p) => [...p, 'AI parsing disabled (no OpenAI key set in Settings)'].slice(-10))\n\n    // Tracker token logs (#mood(7), #energy(8), etc.) are always recorded.\n    // If LLM also produced logs, the createdEventKeys de-dupe prevents duplicates.\n    for (const tok of trackerTokens.slice(0, 10)) {\n      if (tok.name.trim().toLowerCase() === 'sleep') continue\n      const title = `${tok.name}: ${tok.value}`\n      const startAt = nowMs\n      const endAt = nowMs + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: [`#${tok.name}`] })\n      const ev = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        goal: goalOverride,\n        project: projectOverride,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        trackerKey: tok.name,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      createdTrackerKeys.add(tok.name)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${ev.title}`].slice(-10))\n    }\n\n    const fmTrackersRaw = Array.isArray(fm.trackers) ? fm.trackers : typeof fm.trackers === 'string' ? [fm.trackers] : []\n    for (const raw of fmTrackersRaw.slice(0, 10)) {\n      const line = String(raw).trim()\n      if (!line) continue\n      const m = line.match(/^([a-zA-Z][\\w/-]*)\\s*[:=]\\s*([-+]?\\d*\\.?\\d+)/)\n      if (!m?.[1] || !m?.[2]) continue\n      const name = m[1]\n      if (name.trim().toLowerCase() === 'sleep') continue\n      const value = Number(m[2])\n      if (!Number.isFinite(value)) continue\n      const title = `${name}: ${value}`\n      const startAt = nowMs\n      const endAt = nowMs + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: [`#${name}`] })\n      const ev = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        goal: goalOverride,\n        project: projectOverride,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        trackerKey: name,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      createdTrackerKeys.add(name)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${ev.title}`].slice(-10))\n    }\n\n    function startOfDayMs(ms: number) {\n      const d = new Date(ms)\n      d.setHours(0, 0, 0, 0)\n      return d.getTime()\n    }\n\n    const dayStartMs = startOfDayMs(nowMs)\n    const dayEndMs = dayStartMs + 24 * 60 * 60 * 1000\n\n    // Explicit episode/session signals (explicit start + explicit end).\n    if (periodStartSignal && !periodEndSignal) {\n      const activePeriod = await findActiveEpisode('period')\n      if (!activePeriod) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: 'Period', tags: ['#period'] })\n        const ev = await createEvent({\n          title: 'Period',\n          startAt: dayStartMs,\n          endAt: dayEndMs,\n          allDay: true,\n          active: true,\n          kind: 'episode',\n          trackerKey: 'period',\n          icon: 'heart',\n          color: '#ef4444',\n          tags: mergedTags,\n          contexts: allContexts,\n          entityIds,\n          sourceNoteId: note.id,\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [ev, ...prev])\n      }\n    }\n    if (periodEndSignal) {\n      const activePeriod = await findActiveEpisode('period')\n      if (activePeriod) {\n        const next = await upsertEvent({ ...activePeriod, endAt: dayEndMs, active: false })\n        commitEvent(next)\n      }\n    }\n\n    if (painRatingMatch || painHealedSignal) {\n      const bodyTag = bodyPartMatch?.[1] ? `#${bodyPartMatch[1]}` : null\n      const painTags = [...new Set(['#pain', ...(bodyTag ? [bodyTag] : [])])]\n\n      const rating = painRatingMatch?.[1] ? Math.max(0, Math.min(10, Number(painRatingMatch[1]))) : null\n      if (rating != null && Number.isFinite(rating) && !createdTrackerKeys.has('pain')) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: `pain: ${rating}/10`, tags: painTags })\n        const log = await createEvent({\n          title: `pain: ${rating}/10`,\n          startAt: nowMs,\n          endAt: nowMs + 5 * 60 * 1000,\n          kind: 'log',\n          parentEventId: await getActiveForLogsId(),\n          tags: mergedTags,\n          contexts: allContexts,\n          icon: 'heart',\n          color: '#ef4444',\n          entityIds,\n          sourceNoteId: note.id,\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [log, ...prev])\n        createdTrackerKeys.add('pain')\n        createdLogCount += 1\n        setCaptureProgress((p) => [...p, `+ log: ${log.title}`].slice(-10))\n      }\n\n      if (!painHealedSignal) {\n        const activePain = await findActiveEpisode('pain')\n        if (!activePain) {\n          const painTitle = bodyPartMatch?.[1] ? `Pain: ${bodyPartMatch[1]}` : 'Pain'\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: painTitle, tags: painTags })\n          const ep = await createEvent({\n            title: painTitle,\n            startAt: dayStartMs,\n            endAt: dayEndMs,\n            allDay: true,\n            active: true,\n            kind: 'episode',\n            trackerKey: 'pain',\n            icon: 'heart',\n            color: '#ef4444',\n            tags: mergedTags,\n            contexts: allContexts,\n            entityIds,\n            sourceNoteId: note.id,\n            goal: goalOverride,\n            project: projectOverride,\n            importance: importanceOverride ?? 5,\n            difficulty: difficultyOverride ?? 5,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n          })\n          setEvents((prev) => [ep, ...prev])\n        } else {\n          const merged = [...new Set([...(activePain.tags ?? []), ...painTags])]\n          if (merged.join('|') !== (activePain.tags ?? []).join('|')) {\n            const next = await upsertEvent({ ...activePain, tags: merged })\n            commitEvent(next)\n          }\n        }\n      } else {\n        const activePain = await findActiveEpisode('pain')\n        if (activePain) {\n          const next = await upsertEvent({ ...activePain, endAt: dayEndMs, active: false })\n          commitEvent(next)\n        }\n      }\n    }\n\n    let moodLogged = false\n    if (moodMentions.length) {\n      if (moodMentions.length > 1) {\n        const startMention = moodMentions.find((m) => m.hint === 'start') ?? moodMentions[0]\n        const endMention = moodMentions.find((m) => m.hint === 'now') ?? moodMentions[moodMentions.length - 1]\n        await createTrackerLog({\n          key: 'mood',\n          value: startMention.value,\n          icon: 'smile',\n          color: '#f59e0b',\n          atMs: nowMs,\n          dedupeKey: `mood@start:${Math.round(nowMs / (5 * 60 * 1000))}`,\n        })\n        await createTrackerLog({\n          key: 'mood',\n          value: endMention.value,\n          icon: 'smile',\n          color: '#f59e0b',\n          atMs: wallNowMs,\n          dedupeKey: `mood@end:${Math.round(wallNowMs / (5 * 60 * 1000))}`,\n        })\n      } else {\n        const only = moodMentions[0]\n        const atMs = only.hint === 'now' ? wallNowMs : nowMs\n        await createTrackerLog({\n          key: 'mood',\n          value: only.value,\n          icon: 'smile',\n          color: '#f59e0b',\n          atMs,\n          dedupeKey: `mood@${Math.round(atMs / (5 * 60 * 1000))}`,\n        })\n      }\n      moodLogged = true\n    }\n    if (moodValue != null && !moodLogged) {\n      await createTrackerLog({ key: 'mood', value: moodValue, icon: 'smile', color: '#f59e0b' })\n    }\n    if (energyValue != null) {\n      await createTrackerLog({ key: 'energy', value: energyValue, icon: 'bolt', color: '#f59e0b' })\n    }\n    if (stressValue != null) {\n      await createTrackerLog({ key: 'stress', value: stressValue, icon: 'frown', color: '#db2777' })\n    }\n\n    if (workoutStartSignal && !workoutEndSignal) {\n      const active = await findActiveByTrackerKey('workout')\n      if (!active) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: 'Workout', tags: ['#workout'] })\n        const ev = await createEvent({\n          title: 'Workout',\n          startAt: nowMs,\n          endAt: nowMs + 60 * 60 * 1000,\n          active: true,\n          kind: 'event',\n          trackerKey: 'workout',\n          icon: 'dumbbell',\n          color: '#22c55e',\n          tags: mergedTags,\n          contexts: allContexts,\n          entityIds,\n          sourceNoteId: note.id,\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [ev, ...prev])\n        activeForLogsId = ev.id\n      }\n    }\n    if (workoutEndSignal) {\n      const active = await findActiveByTrackerKey('workout')\n      if (active) {\n        const next = await upsertEvent({ ...active, endAt: nowMs, active: false })\n        commitEvent(next)\n      }\n    }\n\n    if (boredSignal && !createdTrackerKeys.has('bored')) {\n      const value = 7\n      const title = `bored: ${value}/10`\n      const startAt = nowMs\n      const endAt = nowMs + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (!createdEventKeys.has(key)) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: ['#bored'] })\n        const log = await createEvent({\n          title,\n          startAt,\n          endAt,\n          kind: 'log',\n          parentEventId: await getActiveForLogsId(),\n          tags: mergedTags,\n          contexts: allContexts,\n          entityIds,\n          sourceNoteId: note.id,\n          trackerKey: 'bored',\n          icon: 'frown',\n          color: '#64748b',\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [log, ...prev])\n        createdEventKeys.add(makeEventKey(log.title, log.startAt, log.endAt))\n        createdTrackerKeys.add('bored')\n        createdLogCount += 1\n        setCaptureProgress((p) => [...p, `+ log: ${log.title}`].slice(-10))\n      }\n    }\n\n    for (const mention of habitMentions) {\n      const h = mention.habit\n      const isNegative = mention.polarity === 'negative'\n      const minutes = Math.max(5, h.estimateMinutes ?? 15)\n      const startAt = nowMs\n      const endAt = nowMs + minutes * 60 * 1000\n      const title = `habit: ${h.name}`\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const tags = [...new Set(['#habit', ...(h.tags ?? []), ...(isNegative ? ['#missed'] : [])])]\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags })\n      const ev = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: uniqStrings([...(allContexts ?? []), ...(h.contexts ?? [])]),\n        entityIds,\n        sourceNoteId: note.id,\n        trackerKey: `habit:${h.id}${isNegative ? ':neg' : ''}`,\n        category: h.category ?? inferred.category,\n        subcategory: h.subcategory ?? inferred.subcategory,\n        importance: Math.max(0, Math.min(10, h.importance)),\n        difficulty: Math.max(0, Math.min(10, h.difficulty)),\n        character: h.character,\n        skills: h.skills,\n        people: h.people ?? [],\n        location: h.location ?? null,\n        goal: h.goal ?? goalOverride ?? null,\n        project: h.project ?? projectOverride ?? null,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `${isNegative ? '+ habit (missed)' : '+ habit'}: ${h.name}`].slice(-10))\n    }\n\n    // Always record local log heuristics (mood, hydration, etc.) even if LLM parsing succeeds,\n    // so trackers reliably appear on the right-side log lane.\n    for (const e of natural.events) {\n      const kind = (e.kind ?? 'event') as CalendarEvent['kind']\n      if (kind !== 'log') continue\n      const startAt = e.startAt\n      const endAt = e.endAt\n      const key = makeEventKey(e.title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const logBase = `${e.title ?? ''}\\n${e.notes ?? ''}`.trim()\n      const locationHint = e.location ?? pickLocationForText(logBase)\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title: e.title, tags: e.tags ?? [], location: locationHint })\n      const inferredTrackerKey = inferTrackerKeyFromText(e.title, e.tags ?? [])\n      const ev = await createEvent({\n        title: e.title,\n        startAt,\n        endAt,\n        kind,\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        icon: e.icon ?? null,\n        color: e.color ?? null,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        goal: e.goal ?? goalOverride ?? null,\n        project: e.project ?? projectOverride ?? null,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        trackerKey: inferredTrackerKey ?? null,\n      })\n      const next = await upsertEvent({\n        ...ev,\n        notes: normalizeTaskChecklistNotes(e.notes ?? ev.notes),\n        icon: e.icon ?? null,\n        color: e.color ?? null,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        estimateMinutes: e.estimateMinutes ?? durationOverride ?? 5,\n        location: locationHint ?? null,\n        people: cleanPeopleList(e.people ?? uniqStrings(personMentions)),\n        skills: e.skills ?? [],\n        character: normalizeCharacterSelection(e.character ?? []),\n        importance: importanceOverride ?? ev.importance ?? 5,\n        difficulty: difficultyOverride ?? ev.difficulty ?? 5,\n        goal: e.goal ?? ev.goal ?? goalOverride ?? null,\n        project: e.project ?? ev.project ?? projectOverride ?? null,\n        contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n      })\n      setEvents((prev) => [next, ...prev])\n      createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n      if (next.trackerKey) createdTrackerKeys.add(next.trackerKey)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${next.title}`].slice(-10))\n    }\n\n    const groupedNaturalEvents = allowLocalFallback ? groupParsedEvents(natural.events) : []\n    const shouldMergeUntimedLocal = !explicitTimeInCapture && !hasExplicitSplitSignals(captureText) && !hasMultipleMoneyAmounts(captureText)\n    const mergedNaturalEvents = allowLocalFallback ? mergeUntimedNaturalEvents(groupedNaturalEvents, shouldMergeUntimedLocal) : []\n    const firstNaturalEvent = allowLocalFallback ? mergedNaturalEvents.find((e) => (e.kind ?? 'event') !== 'log') ?? null : null\n    if (firstNaturalEvent) {\n      const t = new Date(firstNaturalEvent.startAt)\n      const hh = String(t.getHours()).padStart(2, '0')\n      const mm = String(t.getMinutes()).padStart(2, '0')\n      setCaptureProgress((p) => [...p, `First event: ${firstNaturalEvent.title} @ ${hh}:${mm}`].slice(-10))\n    }\n\n\t\t    if (!llmSucceeded && !allowLocalFallback) {\n\t\t      setCaptureError('LLM returned empty; local parsing is disabled.')\n\t\t      setCaptureProgress((p) => [...p, 'LLM empty; local parsing disabled'].slice(-10))\n\t\t    } else if (!llmSucceeded) {\n          const shouldForceNowLocal =\n            hasNowSignal && !explicitTimeInCapture && mergedNaturalEvents.length === 1 && natural.tasks.length === 0\n\t\t      for (const e of mergedNaturalEvents) {\n\t\t        if (!allowEventCreation) continue\n\t\t        const startAt = e.startAt\n\t\t        const endAt = e.endAt\n\t\t        const key = makeEventKey(e.title, startAt, endAt)\n\t\t        if (createdEventKeys.has(key)) continue\n\t\t        const kind = (e.kind ?? 'event') as CalendarEvent['kind']\n\t\t        if (kind === 'log') continue\n        const baseText = `${e.title ?? ''}\\n${e.notes ?? ''}\\n${(e.tags ?? []).join(' ')}`.trim()\n\t\t        const autoImportance = e.importance ?? importanceOverride ?? inferImportanceFromText(baseText) ?? 5\n\t\t        const autoDifficulty = e.difficulty ?? difficultyOverride ?? inferDifficultyFromText(baseText) ?? 5\n\t\t        const autoCharacter = normalizeCharacterSelection(e.character ?? inferCharacterFromText(baseText, e.tags ?? []))\n        const locationHint = e.location ?? pickLocationForText(baseText)\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: e.title, tags: e.tags ?? [], location: locationHint })\n\t\t        const activeNow = shouldForceNowLocal && kind !== 'log' && kind !== 'episode'\n\t\t        const times = applyDurationOverride(startAt, endAt, kind)\n\t\t        const ev = await createEvent({\n\t\t          title: e.title,\n\t\t          startAt: times.startAt,\n\t\t          endAt: times.endAt,\n\t\t          kind,\n\t\t          active: activeNow,\n\t\t                                      parentEventId: null,\n\t\t                                      tags: mergedTags,\n\t\t                                      contexts: allContexts,\n\t\t                                      entityIds,\n\t\t                                      sourceNoteId: note.id,\n\t\t                                      icon: e.icon ?? null,\n\t\t                                      color: e.color ?? null,\n\t\t                                      category: inferred.category,\n\t\t                                      subcategory: inferred.subcategory,\n\t\t                                      goal: e.goal ?? goalOverride ?? null,\n\t\t                                      project: e.project ?? projectOverride ?? null,\n\t\t                                                                  importance: autoImportance,\n\t\t                                                                  difficulty: autoDifficulty,\n\t\t                                                                })\n\t\t        const next = await upsertEvent({\n\t\t          ...ev,\n\t\t          notes: normalizeTaskChecklistNotes(e.notes ?? ev.notes),\n\t\t          icon: e.icon ?? null,\n\t\t          color: e.color ?? null,\n\t\t          category: inferred.category,\n\t\t          subcategory: inferred.subcategory,\n\t\t          estimateMinutes: e.estimateMinutes ?? durationOverride ?? (kind === 'episode' ? null : Math.round((times.endAt - times.startAt) / (60 * 1000))),\n          location: locationHint ?? null,\n\t\t          people: cleanPeopleList(e.people ?? uniqStrings(personMentions)),\n\t\t          skills: e.skills ?? [],\n\t\t          character: autoCharacter,\n\t\t          importance: autoImportance ?? ev.importance ?? 5,\n\t\t          difficulty: autoDifficulty ?? ev.difficulty ?? 5,\n\t\t          goal: e.goal ?? ev.goal ?? goalOverride ?? null,\n\t\t          project: e.project ?? ev.project ?? projectOverride ?? null,\n\t\t          contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n\t\t        })\n\t\t        if (next.active && next.kind !== 'log' && next.kind !== 'episode') {\n\t\t          await stopOtherActiveEvents(next.id, next.startAt)\n\t\t          activeForLogsId = next.id\n\t\t        }\n\t\t        rememberMealEvent(next)\n\t\t        setEvents((prev) => [next, ...prev])\n\t\t        createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n\t\t                                  createdEventCount += 1\n\t\t                                  if (navigateToMs == null || next.startAt < navigateToMs) navigateToMs = next.startAt\n\t\t                                  captureHasNonLogEvent = true\n\t\t                                  if (!capturePrimaryEventId) capturePrimaryEventId = next.id\n\t\t                                  lastCreated = { kind: 'event', id: next.id }\n\t\t                                  setCaptureProgress((p) => [...p, `+ ${next.kind}: ${next.title}`].slice(-10))\t\t      }\n\n\t\t      for (const t of natural.tasks) {\n\t\t        if (!allowTaskCreation) continue\n\t\t        const key = makeTaskKey(t.title)\n\t\t        if (createdTaskKeys.has(key)) continue\n\t\t        const { mergedTags, inferred } = finalizeCategorizedTags({ title: t.title, tags: t.tags ?? [] })\n        const taskBase = `${t.title ?? ''}\\n${t.notes ?? ''}\\n${(t.tags ?? []).join(' ')}`.trim()\n\t\t        const autoImportance = t.importance ?? importanceOverride ?? inferImportanceFromText(taskBase) ?? 5\n\t\t        const autoDifficulty = t.difficulty ?? difficultyOverride ?? inferDifficultyFromText(taskBase) ?? 5\n        const autoCharacter = normalizeCharacterSelection(t.character ?? inferCharacterFromText(taskBase, t.tags ?? []))\n        const locationHint = t.location ?? pickLocationForText(taskBase)\n        const peopleHint = cleanPeopleList(t.people ?? uniqStrings(personMentions))\n\t\t        const task = await createTask({\n\t\t          title: t.title,\n\t\t          status: t.status ?? 'todo',\n\t\t          tags: mergedTags,\n\t\t          contexts: allContexts,\n          people: peopleHint,\n          location: locationHint ?? null,\n          skills: t.skills ?? [],\n          character: autoCharacter,\n\t\t          entityIds,\n\t\t          parentEventId: capturePrimaryEventId,\n\t\t          category: inferred.category,\n\t\t          subcategory: inferred.subcategory,\n\t\t          goal: t.goal ?? goalOverride ?? null,\n\t\t          project: t.project ?? projectOverride ?? null,\n\t\t          estimateMinutes: t.estimateMinutes ?? durationOverride ?? 25,\n\t\t          importance: autoImportance,\n\t\t          difficulty: autoDifficulty,\n\t\t          sourceNoteId: note.id,\n\t\t        })\n\t\t        const next = await upsertTask({\n\t\t          ...task,\n\t\t          parentEventId: task.parentEventId ?? capturePrimaryEventId,\n\t\t          category: inferred.category,\n\t\t          subcategory: inferred.subcategory,\n\t\t          notes: t.notes ?? '',\n\t\t          estimateMinutes: t.estimateMinutes ?? durationOverride ?? task.estimateMinutes ?? 25,\n\t\t          status: t.status ?? task.status,\n\t\t          scheduledAt: t.scheduledAt ?? task.scheduledAt ?? null,\n\t\t          dueAt: t.dueAt ?? task.dueAt ?? null,\n\t\t          importance: autoImportance ?? task.importance ?? 5,\n\t\t          difficulty: autoDifficulty ?? task.difficulty ?? 5,\n\t\t          goal: t.goal ?? task.goal ?? goalOverride ?? null,\n\t\t          project: t.project ?? task.project ?? projectOverride ?? null,\n          people: peopleHint,\n          location: locationHint ?? null,\n          skills: t.skills ?? task.skills ?? [],\n          character: autoCharacter,\n\t\t          contexts: uniqStrings([...(task.contexts ?? []), ...allContexts]),\n\t\t        })\n\t\t        setTasks((prev) => [next, ...prev])\n\t\t        createdTaskCount += 1\n\t\t        createdTaskKeys.add(makeTaskKey(next.title))\n\t\t        setCaptureProgress((p) => [...p, `+ Task: ${next.title}`].slice(-10))\n\n\t\t        if (!captureHasNonLogEvent) {\n\t\t          lastCreated = { kind: 'task', id: next.id }\n\t\t          if (navigateToMs == null && next.scheduledAt) navigateToMs = next.scheduledAt\n\t\t        }\n\n\t\t        const block = await maybeCreateTaskCalendarBlock({\n\t\t          task: next,\n\t\t          tags: mergedTags,\n          location: locationHint ?? null,\n          people: peopleHint,\n\t\t          contexts: allContexts,\n\t\t          entityIds,\n\t\t        })\n\t\t        if (block && !captureHasNonLogEvent) {\n\t\t          lastCreated = { kind: 'event', id: block.id }\n\t\t          navigateToMs = block.startAt\n\t\t        }\n\t\t      }\n\t\t    } else {\n\t\t      setCaptureProgress((p) => [...p, 'Skipped local parsing (AI parser succeeded)'].slice(-10))\n\t\t    }\n\n    if (attachedMode && captureAttachEventId) {\n      const attached = events.find((e) => e.id === captureAttachEventId) ?? null\n      if (attached) {\n        if (!mealEventId && isMealEventCandidate(attached.title, attached.tags)) {\n          mealEventId = attached.id\n          mealEvent = attached\n        }\n        const noteTasks = (llm?.tasks?.length ?? 0) > 0 ? llm!.tasks : natural.tasks\n        const noteEvents = (llm?.events?.length ?? 0) > 0 ? llm!.events : natural.events\n        const block = buildAttachedCaptureMarkdown(nowMs, { tasks: noteTasks, events: noteEvents })\n        const nextNotes = normalizeTaskChecklistNotes(appendMarkdownBlock(attached.notes, block))\n        const nextTags = uniqStrings([...(attached.tags ?? []), ...allTagTokens])\n        const nextPeople = uniqStrings([...(attached.people ?? []), ...personMentions])\n        const nextContexts = uniqStrings([...(attached.contexts ?? []), ...allContexts])\n        const nextLocation = attached.location ?? (placeMentions.length ? uniqStrings(placeMentions).join(', ') : null)\n        commitEvent({\n          ...attached,\n          notes: nextNotes,\n          tags: nextTags,\n          people: nextPeople,\n          contexts: nextContexts,\n          location: nextLocation,\n        })\n        setCaptureProgress((p) => [...p, `Appended transcript to \"${attached.title}\"`].slice(-10))\n      }\n    }\n\n    // Use LLM-parsed workouts if available, otherwise fall back to local regex parser\n    const llmWorkout = (llm?.workouts?.length ?? 0) > 0 ? llm!.workouts[0] : null\n    const normalizeExerciseName = (value: string) => value.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim()\n    const hasMeaningfulSets = (sets: Array<{ reps?: number; weight?: number; duration?: number; distance?: number; rpe?: number }>) =>\n      sets.some((set) => set.reps || set.weight || set.duration || set.distance || set.rpe)\n    const parsedWorkout = llmWorkout\n      ? (() => {\n          const localExercises = localWorkout?.exercises ?? []\n          const localMap = new Map(localExercises.map((ex) => [normalizeExerciseName(ex.name), ex]))\n\n          if (llmWorkout.isSetAddition) {\n            const llmExercises = llmWorkout.exercises.map((ex) => ({\n              id: `ex_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n              name: ex.name,\n              type: ex.type ?? 'strength',\n              sets: ex.sets,\n              muscleGroups: ex.muscleGroups,\n              notes: ex.notes,\n            }))\n            return {\n              type: llmWorkout.type,\n              exercises: llmExercises,\n              totalDuration: llmWorkout.totalDuration,\n              overallRpe: llmWorkout.overallRpe,\n              isSetAddition: llmWorkout.isSetAddition,\n              targetExerciseName: llmWorkout.targetExerciseName,\n            }\n          }\n\n          const used = new Set<string>()\n          const mergedExercises = llmWorkout.exercises.map((ex) => {\n            const key = normalizeExerciseName(ex.name)\n            const local = localMap.get(key)\n            if (local) used.add(key)\n            const nextSets = hasMeaningfulSets(ex.sets) ? ex.sets : (local?.sets ?? ex.sets)\n            return {\n              id: `ex_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n              name: ex.name,\n              type: ex.type ?? local?.type ?? 'strength',\n              sets: nextSets,\n              muscleGroups: ex.muscleGroups ?? local?.muscleGroups,\n              notes: ex.notes ?? local?.notes,\n            }\n          })\n          for (const local of localExercises) {\n            const key = normalizeExerciseName(local.name)\n            if (!used.has(key)) mergedExercises.push(local)\n          }\n\n          return {\n            type: llmWorkout.type ?? localWorkout?.type ?? 'mixed',\n            exercises: mergedExercises,\n            totalDuration: llmWorkout.totalDuration ?? localWorkout?.totalDuration,\n            overallRpe: llmWorkout.overallRpe ?? localWorkout?.overallRpe,\n            isSetAddition: llmWorkout.isSetAddition,\n            targetExerciseName: llmWorkout.targetExerciseName,\n          }\n        })()\n      : localWorkout\n\n    if (parsedWorkout && parsedWorkout.exercises?.length) {\n      const durationMinutes =\n        parsedWorkout.totalDuration ??\n        (Math.round(parsedWorkout.exercises.flatMap((ex) => ex.sets).reduce((sum, set) => sum + (set.duration ?? 0), 0) / 60) || undefined)\n      const startAt = anchorMs ?? nowMs\n      const endAt = durationMinutes ? startAt + durationMinutes * 60 * 1000 : startAt\n      const typeLabel = parsedWorkout.type ?? 'mixed'\n      const defaultTitle =\n        typeLabel === 'cardio'\n          ? 'Cardio'\n          : typeLabel === 'strength'\n            ? 'Strength'\n            : typeLabel === 'mobility'\n              ? 'Mobility'\n              : typeLabel === 'recovery'\n                ? 'Recovery'\n                : 'Workout'\n      const title =\n        parsedWorkout.exercises.length === 1\n          ? parsedWorkout.exercises[0].name\n          : defaultTitle === 'Workout'\n            ? 'Workout'\n            : `${defaultTitle} Workout`\n      const workoutId = `wrk_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`\n      const estimatedCalories = estimateCalories({\n        id: workoutId,\n        eventId: capturePrimaryEventId ?? note.id,\n        type: parsedWorkout.type ?? 'mixed',\n        title,\n        exercises: parsedWorkout.exercises,\n        startAt,\n        endAt,\n        totalDuration: durationMinutes,\n        overallRpe: parsedWorkout.overallRpe,\n        tags: ['#workout', `#${typeLabel}`],\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      })\n\n      await saveWorkout({\n        id: workoutId,\n        eventId: capturePrimaryEventId ?? note.id,\n        type: parsedWorkout.type ?? 'mixed',\n        title,\n        exercises: parsedWorkout.exercises,\n        startAt,\n        endAt,\n        totalDuration: durationMinutes,\n        estimatedCalories,\n        overallRpe: parsedWorkout.overallRpe,\n        tags: ['#workout', `#${typeLabel}`],\n      })\n    }\n\n    // Use LLM-parsed meals if available, otherwise fall back to local regex parser\n    const llmMeal = (llm?.meals?.length ?? 0) > 0 ? llm!.meals[0] : null\n    const parsedMeal = llmMeal\n      ? {\n          type: llmMeal.type,\n          items: llmMeal.items,\n          totalCalories: llmMeal.totalCalories,\n          macros: llmMeal.macros ?? { protein: 0, carbs: 0, fat: 0 },\n          location: llmMeal.location,\n          notes: llmMeal.notes,\n        }\n      : localMeal\n    if (parsedMeal && parsedMeal.items?.length) {\n      const eatenAt = anchorMs ?? nowMs\n      const mealTitle =\n        parsedMeal.items.length === 1\n          ? parsedMeal.items[0].name\n          : parsedMeal.type === 'breakfast'\n            ? 'Breakfast'\n            : parsedMeal.type === 'lunch'\n              ? 'Lunch'\n              : parsedMeal.type === 'dinner'\n                ? 'Dinner'\n                : parsedMeal.type === 'drink'\n                  ? 'Drink'\n                  : 'Snack'\n      const mealTags = ['#food', `#${parsedMeal.type}`]\n      const normalizeItem = (item: FoodItem) => ({\n        ...item,\n        id: item.id ?? makeFoodItemId(),\n        name: item.name?.trim() || 'Food',\n        quantity: Number.isFinite(item.quantity) ? item.quantity : 1,\n        unit: item.unit?.trim() || 'serving',\n      })\n\n      const sumMealFromItems = (items: FoodItem[]) => {\n        const sumField = (key: keyof FoodItem) => {\n          let total = 0\n          let has = false\n          for (const item of items) {\n            const value = item[key]\n            if (typeof value === 'number' && Number.isFinite(value)) {\n              total += value\n              has = true\n            }\n          }\n          return { total, has }\n        }\n\n        const calories = sumField('calories')\n        const protein = sumField('protein')\n        const carbs = sumField('carbs')\n        const fat = sumField('fat')\n        const fiber = sumField('fiber')\n        const saturatedFat = sumField('saturatedFat')\n        const transFat = sumField('transFat')\n        const sugar = sumField('sugar')\n        const sodium = sumField('sodium')\n        const potassium = sumField('potassium')\n        const cholesterol = sumField('cholesterol')\n\n        return {\n          totalCalories: calories.total,\n          hasCalories: calories.has,\n          macros: {\n            protein: protein.total,\n            carbs: carbs.total,\n            fat: fat.total,\n            fiber: fiber.has ? fiber.total : undefined,\n            saturatedFat: saturatedFat.has ? saturatedFat.total : undefined,\n            transFat: transFat.has ? transFat.total : undefined,\n            sugar: sugar.has ? sugar.total : undefined,\n            sodium: sodium.has ? sodium.total : undefined,\n            potassium: potassium.has ? potassium.total : undefined,\n            cholesterol: cholesterol.has ? cholesterol.total : undefined,\n          },\n          hasMacroData: protein.has || carbs.has || fat.has || fiber.has || saturatedFat.has || transFat.has || sugar.has || sodium.has || potassium.has || cholesterol.has,\n        }\n      }\n\n      const formatUnitLabel = (quantity: number, unit: string) => {\n        const base = unit.trim() || 'serving'\n        if (quantity === 1) return base\n        const noPlural = new Set(['oz', 'g', 'kg', 'mg', 'lb', 'lbs', 'ml'])\n        if (noPlural.has(base)) return base\n        if (base.endsWith('s')) return base\n        return `${base}s`\n      }\n\n      const formatMacroCell = (value: number | undefined, unit: string) =>\n        typeof value === 'number' && Number.isFinite(value) ? `${Math.round(value)}${unit}` : '-'\n\n      const buildNutritionTable = (items: FoodItem[], totalCalories: number, macros: ExtendedMacros) => {\n        if (!items.length) return ''\n        const header = [\n          '## Nutrition',\n          '',\n          '| Qty | Item | Calories | Protein | Carbs | Fat | Fiber | Sodium | Potassium |',\n          '| --- | --- | --- | --- | --- | --- | --- | --- | --- |',\n        ]\n        const rows = items.map((item) => {\n          const qty = Number.isFinite(item.quantity) ? item.quantity : 1\n          const unit = item.unit?.trim() || 'serving'\n          const qtyLabel = `${qty} ${formatUnitLabel(qty, unit)}`\n          return `| ${qtyLabel} | ${item.name} | ${formatMacroCell(item.calories, ' kcal')} | ${formatMacroCell(item.protein, 'g')} | ${formatMacroCell(item.carbs, 'g')} | ${formatMacroCell(item.fat, 'g')} | ${formatMacroCell(item.fiber, 'g')} | ${formatMacroCell(item.sodium, 'mg')} | ${formatMacroCell(item.potassium, 'mg')} |`\n        })\n        const totalRow = `| **Total** |  | ${formatMacroCell(totalCalories, ' kcal')} | ${formatMacroCell(macros.protein, 'g')} | ${formatMacroCell(macros.carbs, 'g')} | ${formatMacroCell(macros.fat, 'g')} | ${formatMacroCell(macros.fiber, 'g')} | ${formatMacroCell(macros.sodium, 'mg')} | ${formatMacroCell(macros.potassium, 'mg')} |`\n        return [...header, ...rows, totalRow].join('\\n')\n      }\n\n      const appendNutritionTable = (notes: string | null | undefined, table: string) => {\n        if (!table) return notes ?? ''\n        const existing = notes ?? ''\n        if (existing.includes('## Nutrition') || existing.includes('| Qty | Item |')) return existing\n        const spacer = existing.trim().length ? '\\n\\n' : ''\n        return `${existing}${spacer}${table}`.trim()\n      }\n\n      let items = parsedMeal.items.map((item) => normalizeItem(item as FoodItem))\n      let estimationModel: string | undefined\n\n      const itemsNeedNutrition = items.some((item) =>\n        item.calories == null ||\n        item.protein == null ||\n        item.carbs == null ||\n        item.fat == null ||\n        item.fiber == null ||\n        item.saturatedFat == null ||\n        item.sugar == null ||\n        item.sodium == null ||\n        item.potassium == null ||\n        item.cholesterol == null\n      )\n\n      let needsLocalEstimate = itemsNeedNutrition && !shouldTryLlm\n      if (itemsNeedNutrition && shouldTryLlm) {\n        const description = items\n          .map((item) => `${item.quantity} ${item.unit} ${item.name}`.trim())\n          .filter(Boolean)\n          .join(', ')\n        try {\n          setCaptureAiStatus('Estimating nutrition\u2026')\n          const estimate = await estimateNutritionWithLlm({\n            apiKey: llmKey,\n            model: (llmSettings.nutritionModel ?? llmSettings.chatModel ?? 'gpt-4.1-mini').trim() || 'gpt-4.1-mini',\n            foodDescription: description || captureText,\n            mealType: parsedMeal.type,\n          })\n          items = estimate.items.map((item) => normalizeItem(item))\n          estimationModel = estimate.model\n          const totals = sumMealFromItems(items)\n          parsedMeal.totalCalories = estimate.totalCalories || totals.totalCalories\n          parsedMeal.macros = estimate.macros\n          setCaptureProgress((p) => [...p, `Nutrition estimated (${estimate.model})`].slice(-10))\n        } catch (err) {\n          console.warn('Nutrition estimation failed:', err)\n          setCaptureProgress((p) => [...p, 'Nutrition estimate failed; used local totals'].slice(-10))\n          needsLocalEstimate = true\n        }\n      }\n\n      if (needsLocalEstimate) {\n        items = items.map((item) => {\n          if (item.calories != null && item.protein != null && item.carbs != null && item.fat != null) return item\n          const estimated = estimateFoodNutrition(item.name, item.quantity, item.unit)\n          return {\n            ...item,\n            calories: item.calories ?? estimated.calories,\n            protein: item.protein ?? estimated.protein,\n            carbs: item.carbs ?? estimated.carbs,\n            fat: item.fat ?? estimated.fat,\n            fiber: item.fiber ?? estimated.fiber,\n            saturatedFat: item.saturatedFat ?? estimated.saturatedFat,\n            transFat: item.transFat ?? estimated.transFat,\n            sugar: item.sugar ?? estimated.sugar,\n            sodium: item.sodium ?? estimated.sodium,\n            potassium: item.potassium ?? estimated.potassium,\n            cholesterol: item.cholesterol ?? estimated.cholesterol,\n            confidence: item.confidence ?? estimated.confidence,\n            source: item.source ?? estimated.source,\n          }\n        })\n      }\n\n      const totals = sumMealFromItems(items)\n      const totalCalories = parsedMeal.totalCalories && parsedMeal.totalCalories > 0\n        ? parsedMeal.totalCalories\n        : totals.totalCalories\n      const macros = {\n        protein: parsedMeal.macros?.protein ?? totals.macros.protein ?? 0,\n        carbs: parsedMeal.macros?.carbs ?? totals.macros.carbs ?? 0,\n        fat: parsedMeal.macros?.fat ?? totals.macros.fat ?? 0,\n        fiber: parsedMeal.macros?.fiber ?? totals.macros.fiber,\n        saturatedFat: parsedMeal.macros?.saturatedFat ?? totals.macros.saturatedFat,\n        transFat: parsedMeal.macros?.transFat ?? totals.macros.transFat,\n        sugar: parsedMeal.macros?.sugar ?? totals.macros.sugar,\n        sodium: parsedMeal.macros?.sodium ?? totals.macros.sodium,\n        potassium: parsedMeal.macros?.potassium ?? totals.macros.potassium,\n        cholesterol: parsedMeal.macros?.cholesterol ?? totals.macros.cholesterol,\n      }\n\n      const roundOptional = (value?: number) => (typeof value === 'number' && Number.isFinite(value) ? Math.round(value) : undefined)\n      const nutritionTable = buildNutritionTable(items, totalCalories ?? 0, macros)\n      const mealNotes = appendNutritionTable(parsedMeal.notes ?? '', nutritionTable)\n\n      if (!mealEventId && allowEventCreation) {\n        const startAt = eatenAt\n        const durationMinutes = Math.max(15, durationOverride ?? 30)\n        const endAt = startAt + durationMinutes * 60 * 1000\n        const key = makeEventKey(mealTitle, startAt, endAt)\n        if (!createdEventKeys.has(key)) {\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: mealTitle, tags: mealTags })\n          const ev = await createEvent({\n            title: mealTitle,\n            startAt,\n            endAt,\n            kind: 'event',\n            tags: mergedTags,\n            contexts: allContexts,\n            entityIds,\n            sourceNoteId: note.id,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            goal: goalOverride,\n            project: projectOverride,\n            importance: importanceOverride ?? 5,\n            difficulty: difficultyOverride ?? 5,\n          })\n          const next = await upsertEvent({\n            ...ev,\n            notes: mealNotes || ev.notes,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            estimateMinutes: durationMinutes,\n            location: parsedMeal.location ?? null,\n            people: cleanPeopleList(uniqStrings(personMentions)),\n            skills: [],\n            character: normalizeCharacterSelection([]),\n            importance: importanceOverride ?? ev.importance ?? 5,\n            difficulty: difficultyOverride ?? ev.difficulty ?? 5,\n            goal: ev.goal ?? goalOverride ?? null,\n            project: ev.project ?? projectOverride ?? null,\n            contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n          })\n          rememberMealEvent(next)\n          setEvents((prev) => [next, ...prev])\n          createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n          createdEventCount += 1\n          captureHasNonLogEvent = true\n          if (!capturePrimaryEventId) capturePrimaryEventId = next.id\n          lastCreated = { kind: 'event', id: next.id }\n          if (navigateToMs == null || next.startAt < navigateToMs) navigateToMs = next.startAt\n          setCaptureProgress((p) => [...p, `+ event: ${next.title}`].slice(-10))\n        }\n      }\n\n      await saveMeal({\n        id: `meal_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n        eventId: mealEventId ?? capturePrimaryEventId ?? note.id,\n        type: parsedMeal.type,\n        title: mealTitle,\n        items,\n        totalCalories: Math.round(totalCalories ?? 0),\n        macros: {\n          protein: Math.round(macros.protein ?? 0),\n          carbs: Math.round(macros.carbs ?? 0),\n          fat: Math.round(macros.fat ?? 0),\n          fiber: roundOptional(macros.fiber),\n          saturatedFat: roundOptional(macros.saturatedFat),\n          transFat: roundOptional(macros.transFat),\n          sugar: roundOptional(macros.sugar),\n          sodium: roundOptional(macros.sodium),\n          potassium: roundOptional(macros.potassium),\n          cholesterol: roundOptional(macros.cholesterol),\n        },\n        eatenAt,\n        tags: mealTags,\n        estimationModel,\n      })\n\n      if (mealEventId && mealEvent) {\n        const nextNotes = appendNutritionTable(mealEvent.notes, nutritionTable)\n        if (nextNotes !== mealEvent.notes) {\n          const updated = await upsertEvent({ ...mealEvent, notes: nextNotes })\n          setEvents((prev) => prev.map((ev) => (ev.id === updated.id ? updated : ev)))\n          mealEvent = updated\n        }\n      }\n    }\n\n    setCaptureProgress((p) => [...p, `Created: ${createdEventCount} event(s), ${createdLogCount} log(s), ${createdTaskCount} task(s)`].slice(-10))\n\n    if (createdEventCount > 0 || createdLogCount > 0 || createdTaskCount > 0) {\n      await refreshAll()\n    }\n\n    if (lastCreated.kind !== 'none') {\n      setSelection(lastCreated)\n    } else if (captureAttachEventId) {\n      setSelection({ kind: 'event', id: captureAttachEventId })\n    }\n\n    if (captureReturnView) {\n      if (captureReturnView === 'calendar' && navigateToMs != null) {\n        setAgendaDate(new Date(navigateToMs))\n      }\n      openView(captureReturnView)\n    }\n\n\t\t    if (!llmError) {\n\t\t      setCaptureDraft('')\n\t\t      setCaptureInterim('')\n\t\t      setCaptureAttachEventId(null)\n\t\t      setCaptureReturnView(null)\n\t\t      setCaptureOpen(false)\n\t\t    }\n\t\t    } finally {\n\t      setCaptureSaving(false)\n\t      setCaptureAiStatus('')\n\t    }\n\t  }\n\n  function requestDeleteSelection(opts?: { skipConfirm?: boolean }) {\n    void (async () => {\n      if (selection.kind === 'task') {\n        const t = tasks.find((x) => x.id === selection.id)\n        if (!t) return\n        const ok = opts?.skipConfirm ? true : window.confirm(`Delete task: \"${t.title}\"?`)\n        if (!ok) return\n        await deleteTask(t.id)\n        setTasks((prev) => prev.filter((x) => x.id !== t.id))\n        setSelection({ kind: 'none' })\n        return\n      }\n      if (selection.kind === 'event') {\n        const ev = events.find((x) => x.id === selection.id)\n        if (!ev) return\n        const ok = opts?.skipConfirm ? true : window.confirm(`Delete ${ev.kind}: \"${ev.title}\"?`)\n        if (!ok) return\n        await deleteEvent(ev.id)\n        setEvents((prev) => prev.filter((x) => x.id !== ev.id && x.parentEventId !== ev.id))\n        setSelection({ kind: 'none' })\n      }\n    })()\n  }\n\n  useEffect(() => {\n    function onKeyDown(e: KeyboardEvent) {\n      if (isTextInputTarget(e.target)) return\n      if (e.key !== 'Backspace' && e.key !== 'Delete') return\n      if (selection.kind !== 'task' && selection.kind !== 'event') return\n      e.preventDefault()\n      requestDeleteSelection({ skipConfirm: e.shiftKey })\n    }\n    window.addEventListener('keydown', onKeyDown)\n    return () => window.removeEventListener('keydown', onKeyDown)\n  }, [events, selection, tasks])\n\n  function renderView(view: WorkspaceViewKey) {\n    const renderNotes = (initialFilterType?: 'all' | 'category' | 'tag' | 'person' | 'place') => (\n      <NotesView\n        key={initialFilterType ?? 'all'}\n        captures={captures}\n        selectedCaptureId={selection.kind === 'capture' ? selection.id : null}\n        onSelectCapture={(id) => setSelection({ kind: 'capture', id })}\n        onOpenCapture={() => openCapture()}\n        onUpdateCapture={onUpdateCapture}\n        initialFilterType={initialFilterType}\n      />\n    )\n    switch (view) {\n      case 'dashboard':\n        return <DashboardView events={events} tasks={tasks} trackerDefs={trackerDefs} />\n      case 'notes':\n        return renderNotes('all')\n      case 'reflections':\n        return renderNotes('all')\n          case 'tasks':\n            return (          <TickTickTasksView\n            tasks={tasks}\n            selectedTaskId={selection.kind === 'task' ? selection.id : null}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n            onCreateTask={onCreateTaskFromInput}\n            onToggleComplete={onToggleTaskComplete}\n            onMoveTask={onMoveTaskStatus}\n          />\n        )\n      case 'calendar':\n        return (\n          <PlannerView\n            date={agendaDate}\n            onDateChange={setAgendaDate}\n            onRefresh={refreshAll}\n            tasks={tasks}\n            captures={captures}\n            events={events}\n            selection={selection}\n            setSelection={setSelection}\n            onCreateTask={onCreateTaskFromInput}\n            onToggleTaskComplete={onToggleTaskComplete}\n            onToggleTaskChecklistItem={onToggleTaskChecklistItem}\n            onRequestCreateEvent={openEventComposer}\n            onCreateEvent={onCreateEvent}\n            onMoveEvent={onMoveEvent}\n            onToggleEventComplete={onToggleEventComplete}\n            onUpdateEvent={onUpdateEvent}\n            eventTitleDetail={eventTitleDetail}\n          />\n        )\n      case 'assistant':\n        return (\n          <AssistantView\n            captures={captures}\n            events={events}\n            tasks={tasks}\n            onSelectCapture={(id) => setSelection({ kind: 'capture', id })}\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n          />\n        )\n      case 'settings':\n        return <SettingsView />\n      case 'timeline':\n        return (\n          <TimelineView\n            events={events}\n            captures={captures}\n            activeTagFilters={timelineTagFilters}\n            onToggleTag={(t) =>\n              setTimelineTagFilters((prev) => (prev.includes(t) ? prev.filter((x) => x !== t) : [...prev, t].slice(0, 6)))\n            }\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectCapture={(id) => setSelection({ kind: 'capture', id })}\n          />\n        )\n      case 'habits':\n        return (\n          <HabitsView\n            events={events}\n            onCreatedEvent={(ev) => setEvents((prev) => [ev, ...prev])}\n            onOpenReports={(habitId) => openHabitReports(habitId)}\n          />\n        )\n      case 'goals':\n        return (\n          <GoalsView\n            events={events}\n            tasks={tasks}\n            mode=\"list\"\n            onOpenGoal={openGoalDetail}\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n            onCreatedTask={(task) => setTasks((prev) => [task, ...prev])}\n            onCreatedEvent={(ev) => setEvents((prev) => [ev, ...prev])}\n            onUpdateEvent={onUpdateEvent}\n            onDeleteEvent={async (id) => {\n              await deleteEvent(id)\n              setEvents((prev) => prev.filter((x) => x.id !== id && x.parentEventId !== id))\n            }}\n          />\n        )\n      case 'goal-detail':\n        return (\n          <GoalsView\n            events={events}\n            tasks={tasks}\n            mode=\"detail\"\n            goalName={selectedGoal}\n            onOpenGoal={openGoalDetail}\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n            onCreatedTask={(task) => setTasks((prev) => [task, ...prev])}\n            onCreatedEvent={(ev) => setEvents((prev) => [ev, ...prev])}\n            onUpdateEvent={onUpdateEvent}\n            onDeleteEvent={async (id) => {\n              await deleteEvent(id)\n              setEvents((prev) => prev.filter((x) => x.id !== id && x.parentEventId !== id))\n            }}\n          />\n        )\n      case 'ecosystem':\n        return (\n          <EcosystemView\n            events={events}\n            tasks={tasks}\n            trackerDefs={trackerDefs}\n            onOpenGoal={openGoalDetail}\n            onOpenProject={openProjectDetail}\n            onOpenTracker={openTrackerDetail}\n            onTrackerDefsChange={setTrackerDefs}\n          />\n        )\n      case 'projects':\n        return (\n          <ProjectsView\n            events={events}\n            tasks={tasks}\n            projectName={selectedProject}\n            onSelectProject={setSelectedProject}\n          />\n        )\n      case 'trackers':\n        return (\n          <TrackersView\n            events={events}\n            trackerDefs={trackerDefs}\n            trackerKey={selectedTrackerKey}\n            onSelectTracker={setSelectedTrackerKey}\n            onTrackerDefsChange={setTrackerDefs}\n          />\n        )\n      case 'rewards':\n        return <RewardsView events={events} />\n      case 'reports':\n        return renderNotes('category')\n      case 'health':\n        return <HealthDashboard events={events} trackerDefs={trackerDefs} />\n      case 'people':\n        return renderNotes('person')\n      case 'places':\n        return renderNotes('place')\n      case 'tags':\n        return renderNotes('tag')\n      default:\n        return <PlaceholderView title=\"View\" subtitle=\"Coming soon.\" />\n    }\n  }\n\n\t  const active = getActiveTab(workspace)\n\n  const selectedTask = selection.kind === 'task' ? tasks.find((t) => t.id === selection.id) ?? null : null\n  const selectedEvent = selection.kind === 'event' ? events.find((e) => e.id === selection.id) ?? null : null\n  const selectedCapture = selection.kind === 'capture' ? captures.find((c) => c.id === selection.id) ?? null : null\n  const selectionKey = selection.kind === 'none' ? 'none' : `${selection.kind}:${selection.id}`\n  const docTranscriptText =\n    selection.kind === 'capture'\n      ? selectedCapture?.rawText ?? ''\n      : selection.kind === 'event'\n        ? selectedEvent?.notes ?? ''\n        : selection.kind === 'task'\n          ? selectedTask?.notes ?? ''\n          : ''\n  const docTranscriptLines = useMemo(() => parseTimestampedTranscript(docTranscriptText), [docTranscriptText])\n  const selectedTaskTags = selectedTask?.tags ?? []\n  const selectedTaskContexts = selectedTask?.contexts ?? []\n  const selectedTaskPeople = selectedTask?.people ?? []\n  const selectedTaskLocations = selectedTask?.location ? parseCommaList(selectedTask.location) : []\n  const selectedTaskSkills = selectedTask?.skills ?? []\n  const selectedTaskCharacter = selectedTask?.character ?? []\n  const selectedEventTags = selectedEvent?.tags ?? []\n  const selectedEventContexts = selectedEvent?.contexts ?? []\n  const selectedEventPeople = selectedEvent?.people ?? []\n  const selectedEventLocations = selectedEvent?.location ? parseCommaList(selectedEvent.location) : []\n  const selectedEventSkills = selectedEvent?.skills ?? []\n  const selectedEventTracker = useMemo(() => {\n    if (!selectedEvent?.trackerKey) return null\n    const raw = selectedEvent.trackerKey.trim()\n    if (!raw) return null\n    if (raw.startsWith('habit:')) {\n      const habitId = raw.slice('habit:'.length)\n      const habit = habitDefs.find((h) => h.id === habitId) ?? null\n      return { key: raw, label: habit?.name ?? 'Habit' }\n    }\n    const def = trackerDefs.find((t) => t.key === raw) ?? null\n    return { key: raw, label: def?.label ?? raw }\n  }, [habitDefs, selectedEvent?.trackerKey, trackerDefs])\n  const [nowTick, setNowTick] = useState(() => Date.now())\n\n  useEffect(() => {\n    if (!docOpen) return\n    setDocTab(selection.kind === 'capture' ? 'transcript' : 'notes')\n    setDocTranscriptFocus(null)\n  }, [docOpen, selectionKey])\n\n\t  const selectedEventLogs = useMemo(() => {\n\t    if (!selectedEvent) return []\n\t    return events\n      .filter((e) => e.kind === 'log' && e.parentEventId === selectedEvent.id)\n      .sort((a, b) => a.startAt - b.startAt)\n      .slice(0, 50)\n  }, [events, selectedEvent?.id])\n\n  const selectedEventTasks = useMemo(() => {\n    if (!selectedEvent) return []\n    return tasks\n      .filter((t) => t.parentEventId === selectedEvent.id)\n      .sort((a, b) => b.updatedAt - a.updatedAt)\n      .slice(0, 50)\n  }, [selectedEvent?.id, tasks])\n  const selectedEventNoteTasks = useMemo(() => {\n    if (!selectedEvent) return {}\n    const map: Record<string, { status: string; startedAt?: number | null }> = {}\n    for (const t of selectedEventTasks) {\n      const tokenId = noteItemTokenId(t.notes ?? '')\n      if (!tokenId) continue\n      map[tokenId] = {\n        status: t.status,\n        startedAt: t.status === 'in_progress' ? t.updatedAt : null,\n      }\n    }\n    for (const e of events) {\n      if (e.parentEventId !== selectedEvent.id) continue\n      const tokenId = noteItemTokenId(e.notes ?? '')\n      if (!tokenId) continue\n      const status = e.active ? 'in_progress' : 'done'\n      if (map[tokenId]?.status === 'in_progress' && !e.active) continue\n      map[tokenId] = {\n        status,\n        startedAt: e.active ? e.startAt : null,\n      }\n    }\n    return map\n  }, [events, selectedEvent, selectedEventTasks])\n  const hasRunningNoteTask = useMemo(\n    () => Object.values(selectedEventNoteTasks).some((t) => t.status === 'in_progress'),\n    [selectedEventNoteTasks],\n  )\n\n  useEffect(() => {\n    if (!selectedEvent?.active && !hasRunningNoteTask) return\n    const id = window.setInterval(() => setNowTick(Date.now()), 1000)\n    return () => window.clearInterval(id)\n  }, [selectedEvent?.active, hasRunningNoteTask])\n\n  const selectedEventMinutes = selectedEvent\n    ? Math.max(0, Math.round(((selectedEvent.active ? nowTick : selectedEvent.endAt) - selectedEvent.startAt) / (60 * 1000)))\n    : 0\n  const selectedEventBase = selectedEvent ? basePoints(selectedEvent.importance, selectedEvent.difficulty) : 0\n  const selectedEventMult = selectedEvent ? multiplierFor(selectedEvent.goal ?? null, selectedEvent.project ?? null) : 1\n  const selectedEventPoints = selectedEvent ? pointsForEventAt(selectedEvent, nowTick) : 0\n\n  const explorerTasks = useMemo(() => {\n    const needle = explorerTaskQuery.trim().toLowerCase()\n    const base = tasks.filter((t) => t.status !== 'done')\n    const filtered = needle\n      ? base.filter((t) => t.title.toLowerCase().includes(needle) || (t.tags ?? []).some((x) => x.toLowerCase().includes(needle)))\n      : base\n    return [...filtered].sort((a, b) => (b.dueAt ?? 0) - (a.dueAt ?? 0) || b.updatedAt - a.updatedAt).slice(0, 20)\n  }, [explorerTaskQuery, tasks])\n\n\t  // Pomodoro (MVP)\n\t  const [pomoRunning, setPomoRunning] = useState(false)\n\t  const [pomoSeconds, setPomoSeconds] = useState(25 * 60)\n\t\t  const [pomoActiveTaskId, setPomoActiveTaskId] = useState<string | null>(() => {\n\t\t    try {\n\t\t      return localStorage.getItem('insight5.pomo.activeTaskId') || null\n\t\t    } catch {\n\t\t      return null\n\t\t    }\n\t\t  })\n\t\t  const pomoActiveTask = pomoActiveTaskId ? tasks.find((t) => t.id === pomoActiveTaskId) ?? null : null\n\t\t  const pomoMinutes = Math.floor(pomoSeconds / 60)\n\t\t  const pomoRemainder = pomoSeconds % 60\n\n\t  useEffect(() => {\n\t    if (!pomoRunning) return\n\t    const id = window.setInterval(() => setPomoSeconds((s) => Math.max(0, s - 1)), 1000)\n\t    return () => window.clearInterval(id)\n\t  }, [pomoRunning])\n\n\t  useEffect(() => {\n\t    try {\n\t      if (pomoActiveTaskId) localStorage.setItem('insight5.pomo.activeTaskId', pomoActiveTaskId)\n\t      else localStorage.removeItem('insight5.pomo.activeTaskId')\n\t    } catch {\n\t      // ignore\n\t    }\n\t  }, [pomoActiveTaskId])\n\n\t\t  const pomoProgress = clamp01(1 - pomoSeconds / (25 * 60))\n\n\t\t  const taxonomyCategories = useMemo(() => {\n\t\t    const starter = categoriesFromStarter()\n\t\t    const fromData = uniqStrings([\n\t\t      ...tasks.map((t) => t.category ?? ''),\n\t\t      ...events.map((e) => e.category ?? ''),\n\t\t    ])\n\t\t    const extra = fromData.filter((c) => c && !starter.some((s) => s.toLowerCase() === c.toLowerCase())).sort((a, b) => a.localeCompare(b))\n\t\t    return [...starter, ...extra]\n\t\t  }, [events, tasks])\n\n\t\t  const taxonomyActiveCategory = (selectedTask?.category ?? selectedEvent?.category ?? '').trim() || null\n\n\t\t  const taxonomySubcategories = useMemo(() => {\n\t\t    const starterSubs = taxonomyActiveCategory ? subcategoriesFromStarter(taxonomyActiveCategory) : []\n\t\t    const fromData = uniqStrings([\n\t\t      ...tasks\n\t\t        .filter((t) => (taxonomyActiveCategory ? (t.category ?? '').toLowerCase() === taxonomyActiveCategory.toLowerCase() : true))\n\t\t        .map((t) => t.subcategory ?? ''),\n\t\t      ...events\n\t\t        .filter((e) => (taxonomyActiveCategory ? (e.category ?? '').toLowerCase() === taxonomyActiveCategory.toLowerCase() : true))\n\t\t        .map((e) => e.subcategory ?? ''),\n\t\t    ])\n\t\t    const extra = fromData\n\t\t      .filter((s) => s && !starterSubs.some((x) => x.toLowerCase() === s.toLowerCase()))\n\t\t      .sort((a, b) => a.localeCompare(b))\n\t\t    return [...starterSubs, ...extra]\n\t\t  }, [events, tasks, taxonomyActiveCategory])\n\n\t\t  const composerTagList = useMemo(() => parseTags(eventComposer.tagsRaw), [eventComposer.tagsRaw])\n\t\t  const composerPeopleList = useMemo(() => parseCommaList(eventComposer.peopleRaw), [eventComposer.peopleRaw])\n\t\t  const composerLocationList = useMemo(() => parseCommaList(eventComposer.location), [eventComposer.location])\n\n  function parseTags(raw: string) {\n    return raw\n      .split(/[,\\s]+/)\n      .map((t) => t.trim())\n      .filter(Boolean)\n      .map((t) => (t.startsWith('#') ? t : `#${t}`))\n      .slice(0, 12)\n  }\n\n  function normalizeContextToken(raw: string) {\n    const trimmed = raw.trim()\n    if (!trimmed) return null\n    const withoutPrefix = trimmed.replace(/^[@+]/, '').replace(/^at\\s+/i, '').trim()\n    return withoutPrefix || null\n  }\n\n  function parseContexts(raw: string) {\n    return uniqStrings(parseCommaList(raw).map(normalizeContextToken).filter(Boolean))\n  }\n\n  function formatContextLabel(value: string) {\n    const trimmed = value.trim()\n    if (!trimmed) return ''\n    if (/^(@|\\+|at\\s+)/i.test(trimmed)) return trimmed\n    return `at ${trimmed}`\n  }\n\n  function stopVoiceCapture() {\n    shouldListenRef.current = false\n    if (captureTimeoutRef.current) {\n      clearTimeout(captureTimeoutRef.current)\n      captureTimeoutRef.current = null\n    }\n    if (speechRecognitionRef.current) {\n      try {\n        speechRecognitionRef.current.stop()\n      } catch {}\n      speechRecognitionRef.current = null\n    }\n    setCaptureListening(false)\n    setCaptureInterim('')\n  }\n\n  function toggleVoiceCapture(opts?: { silentIfUnavailable?: boolean }) {\n    // If already listening, stop\n    if (shouldListenRef.current || captureListening) {\n      stopVoiceCapture()\n      return\n    }\n\n    const SpeechRecognition =\n      (window as any).SpeechRecognition ?? (window as any).webkitSpeechRecognition ?? (window as any).mozSpeechRecognition\n    if (!SpeechRecognition) {\n      if (!opts?.silentIfUnavailable) alert('Voice capture is not available in this build yet. (Next: Whisper.)')\n      return\n    }\n\n    const rec = new SpeechRecognition()\n    rec.lang = 'en-US'\n    rec.interimResults = true\n    rec.continuous = true // Enable continuous mode for longer recording\n\n    speechRecognitionRef.current = rec\n    shouldListenRef.current = true\n    setCaptureListening(true)\n    setCaptureInterim('')\n\n    // Set timeout based on mode: default 60s, extended 1hr\n    const timeoutMs = captureExtendedMode ? 60 * 60 * 1000 : 60 * 1000\n    captureTimeoutRef.current = setTimeout(() => {\n      stopVoiceCapture()\n    }, timeoutMs)\n\n    rec.onresult = (e: any) => {\n      let finalText = ''\n      let interim = ''\n      const results: SpeechRecognitionResultList | undefined = e.results\n      if (!results) return\n      for (let i = e.resultIndex ?? 0; i < results.length; i++) {\n        const r: any = results[i]\n        const t = r?.[0]?.transcript\n        if (typeof t !== 'string') continue\n        if (r.isFinal) finalText += ` ${t}`\n        else interim += ` ${t}`\n      }\n      const finalTrim = finalText.trim()\n      const interimTrim = interim.trim()\n      setCaptureInterim(interimTrim)\n      if (finalTrim) setCaptureDraft((prev) => (prev.trim() ? `${prev.trim()} ${finalTrim}` : finalTrim))\n    }\n\n    rec.onerror = (e: any) => {\n      // Only stop on fatal errors, not 'no-speech' or 'aborted'\n      if (e.error !== 'no-speech' && e.error !== 'aborted') {\n        stopVoiceCapture()\n      }\n    }\n\n    rec.onend = () => {\n      // Auto-restart if shouldListen is still true and timeout hasn't fired\n      if (shouldListenRef.current && captureTimeoutRef.current) {\n        try {\n          rec.start()\n        } catch {\n          stopVoiceCapture()\n        }\n      } else {\n        setCaptureListening(false)\n        setCaptureInterim('')\n      }\n    }\n\n    rec.start()\n  }\n\n  // Legacy function name for compatibility\n  function startVoiceCapture(opts?: { silentIfUnavailable?: boolean }) {\n    toggleVoiceCapture(opts)\n  }\n\n  function startComposerTranscription() {\n    const SpeechRecognition =\n      (window as any).SpeechRecognition ?? (window as any).webkitSpeechRecognition ?? (window as any).mozSpeechRecognition\n    if (!SpeechRecognition) {\n      alert('Voice transcription is not available in this build yet. (Next: Whisper.)')\n      return\n    }\n    const rec = new SpeechRecognition()\n    rec.lang = 'en-US'\n    rec.interimResults = true\n    rec.continuous = false\n    setComposerListening(true)\n    setComposerInterim('')\n    rec.onresult = (e: any) => {\n      let finalText = ''\n      let interim = ''\n      const results: SpeechRecognitionResultList | undefined = e.results\n      if (!results) return\n      for (let i = e.resultIndex ?? 0; i < results.length; i++) {\n        const r: any = results[i]\n        const t = r?.[0]?.transcript\n        if (typeof t !== 'string') continue\n        if (r.isFinal) finalText += ` ${t}`\n        else interim += ` ${t}`\n      }\n      const finalTrim = finalText.trim()\n      const interimTrim = interim.trim()\n      setComposerInterim(interimTrim)\n      if (finalTrim) {\n        setEventComposer((prev) => {\n          const base = prev.notes.trim()\n          const nextNotes = base ? `${base}\\n${finalTrim}` : finalTrim\n          return { ...prev, notes: nextNotes }\n        })\n      }\n    }\n    rec.onerror = () => {\n      setComposerListening(false)\n      setComposerInterim('')\n    }\n    rec.onend = () => {\n      setComposerListening(false)\n      setComposerInterim('')\n    }\n    rec.start()\n  }\n\n  useEffect(() => {\n    if (!captureOpen) return\n    if (captureListening) return\n    if (captureDraft.trim().length > 0) return\n    startVoiceCapture({ silentIfUnavailable: true })\n  }, [captureOpen, captureListening, captureDraft])\n\n  async function handleAuthSubmit() {\n    const supabase = getSupabaseClient()\n    if (!supabase) {\n      setAuthError('Supabase is not configured. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.')\n      return\n    }\n    const email = authEmail.trim()\n    const password = authPassword.trim()\n    if (!email || !password) {\n      setAuthError('Email and password are required.')\n      return\n    }\n    setAuthWorking(true)\n    setAuthError('')\n    setAuthStatus('')\n    try {\n      if (authMode === 'signup') {\n        const { data, error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: { emailRedirectTo: window.location.origin },\n        })\n        if (error) throw error\n        if (data.session) {\n          setAuthStatus('Account created and signed in.')\n        } else {\n          setAuthStatus('Check your email to confirm your account.')\n        }\n      } else {\n        const { data, error } = await supabase.auth.signInWithPassword({ email, password })\n        if (error) throw error\n        setAuthStatus(data.session ? 'Signed in.' : 'Signed in.')\n      }\n    } catch (err) {\n      setAuthError(err instanceof Error ? err.message : 'Sign in failed.')\n    } finally {\n      setAuthWorking(false)\n    }\n  }\n\n      return (\n\n        <div className=\"uiShell\">\n          {/* Toast Notifications */}\n          <Toaster\n            position=\"top-right\"\n            expand={false}\n            richColors\n            closeButton\n            toastOptions={{\n              style: {\n                fontFamily: 'Figtree, sans-serif',\n              },\n            }}\n          />\n\n                  <main\n\n                    className=\"uiMain\"\n\n                    style={{\n\n                      gridTemplateColumns: `72px ${leftCollapsed ? 0 : 260}px 1fr ${rightCollapsed ? '0px' : 'var(--right-panel-width)'}`,\n\n                      gap: '16px',\n\n                      padding: '16px'\n\n                    }}>             <aside\n                      className={`rail${railLabelsOpen ? ' showLabels' : ''}`}\n                      onMouseLeave={() => setRailLabelsOpen(false)}>\n\n                    <div\n                      className=\"flex flex-col items-center py-4 mb-4\"\n                      onMouseEnter={() => setRailLabelsOpen(true)}>\n\n                      <div className=\"w-12 h-12 bg-white rounded-2xl flex items-center justify-center shadow-lg border border-black/5\">\n\n                          <Icon name=\"sparkle\" className=\"text-[#D95D39]\" />\n\n                      </div>\n\n                    </div>\n\n                    <button \n\n                className={`railBtn ${getActiveTab(workspace).view === 'dashboard' ? 'active' : ''}`} \n\n                aria-label=\"Dashboard\" title=\"Dashboard\" onClick={() => openView('dashboard')}\n\n              >\n\n  \t            <Icon name=\"home\" />\n                <span className=\"railLabel\" aria-hidden=\"true\">Dashboard</span>\n\n  \t          </button>\n\n  \t          <button\n\n                className=\"railBtn railPrimary group\"\n\n                aria-label=\"Capture\"\n\n                title=\"Capture\"\n\n                          onClick={() => {\n\n                            openCapture()\n\n                          }}>\n\n  \t                        <Icon name=\"plus\" className=\"group-hover:rotate-90 transition-transform duration-500\" />\n                          <span className=\"railLabel\" aria-hidden=\"true\">Capture</span>\n\n  \t                      </button>\n\n  \t          <button \n\n                className={`railBtn ${getActiveTab(workspace).view === 'calendar' ? 'active' : ''}`} \n\n                aria-label=\"Calendar\" title=\"Calendar\" onClick={() => openView('calendar')}\n\n              >\n\n                <Icon name=\"calendar\" />\n                <span className=\"railLabel\" aria-hidden=\"true\">Calendar</span>\n\n  \t          </button>\n\n              <button \n\n                className={`railBtn ${getActiveTab(workspace).view === 'tasks' ? 'active' : ''}`} \n\n                aria-label=\"Tasks\" title=\"Tasks\" onClick={() => openView('tasks')}\n\n              >\n\n                <Icon name=\"check\" />\n                <span className=\"railLabel\" aria-hidden=\"true\">Tasks</span>\n\n              </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'notes' ? 'active' : ''}`} \n\n              aria-label=\"Notes\" title=\"Notes\" onClick={() => openView('notes')}\n\n            >\n\n              <Icon name=\"file\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Notes</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'reflections' ? 'active' : ''}`} \n\n              aria-label=\"Reflections\" title=\"Reflections\" onClick={() => openView('reflections')}\n\n            >\n\n              <Icon name=\"sparkle\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Reflections</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'assistant' ? 'active' : ''}`} \n\n              aria-label=\"Chat\" title=\"Chat\" onClick={() => openView('assistant')}\n\n            >\n\n              <Icon name=\"mic\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Chat</span>\n\n            </button>\n\n            <div className=\"railSep opacity-20\" />\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'habits' ? 'active' : ''}`} \n\n              aria-label=\"Habits\" title=\"Habits\" onClick={() => openView('habits')}\n\n            >\n\n              <Icon name=\"smile\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Habits</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'goals' || getActiveTab(workspace).view === 'goal-detail' ? 'active' : ''}`} \n\n              aria-label=\"Goals\" title=\"Goals\" onClick={() => openView('goals')}\n\n            >\n\n              <Icon name=\"target\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Goals</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'projects' ? 'active' : ''}`} \n\n              aria-label=\"Projects\" title=\"Projects\" onClick={() => openView('projects')}\n\n            >\n\n              <Icon name=\"briefcase\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Projects</span>\n\n            </button>\n\n            <button\n              className={`railBtn ${getActiveTab(workspace).view === 'ecosystem' ? 'active' : ''}`}\n              aria-label=\"Ecosystem\"\n              title=\"Ecosystem\"\n              onClick={() => openView('ecosystem')}\n            >\n              <Icon name=\"monitor\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Ecosystem</span>\n            </button>\n\n            <button\n              className={`railBtn ${getActiveTab(workspace).view === 'trackers' ? 'active' : ''}`}\n              aria-label=\"Trackers\"\n              title=\"Trackers\"\n              onClick={() => openView('trackers')}\n            >\n              <Icon name=\"droplet\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Trackers</span>\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'rewards' ? 'active' : ''}`} \n\n              aria-label=\"Rewards\" title=\"Rewards\" onClick={() => openView('rewards')}\n\n            >\n\n              <Icon name=\"trophy\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Rewards</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'reports' ? 'active' : ''}`} \n\n              aria-label=\"Reports\" title=\"Reports\" onClick={() => openView('reports')}\n\n            >\n\n              <Icon name=\"file\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Reports</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'health' ? 'active' : ''}`} \n\n              aria-label=\"Workout & Nutrition\" title=\"Workout & Nutrition\" onClick={() => openView('health')}\n\n            >\n\n              <Icon name=\"dumbbell\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Workout + Nutrition</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'people' ? 'active' : ''}`} \n\n              aria-label=\"People\" title=\"People\" onClick={() => openView('people')}\n\n            >\n\n              <Icon name=\"users\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">People</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'places' ? 'active' : ''}`} \n\n              aria-label=\"Places\" title=\"Places\" onClick={() => openView('places')}\n\n            >\n\n              <Icon name=\"pin\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Places</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'tags' ? 'active' : ''}`} \n\n              aria-label=\"Tags\" title=\"Tags\" onClick={() => openView('tags')}\n\n            >\n\n              <Icon name=\"tag\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Tags</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'timeline' ? 'active' : ''}`} \n\n              aria-label=\"Timeline\" title=\"Timeline\" onClick={() => openView('timeline')}\n\n            >\n\n              <Icon name=\"bolt\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Timeline</span>\n\n            </button>\n          <div className=\"railGrow\" />\n          <button className=\"railBtn\" aria-label=\"Refresh\" title=\"Refresh\" onClick={refreshAll}>\n            <Icon name=\"bolt\" />\n            <span className=\"railLabel\" aria-hidden=\"true\">Refresh</span>\n          </button>\n          <button\n            className=\"railBtn\"\n            aria-label=\"Toggle theme\"\n            title=\"Toggle theme\"\n            onClick={() => setThemePref((p) => nextThemePref(p))}>\n            <Icon name={resolveTheme(themePref) === 'dark' ? 'sun' : 'moon'} />\n            <span className=\"railLabel\" aria-hidden=\"true\">Theme</span>\n          </button>\n          <button className=\"railBtn\" aria-label=\"Toggle explorer\" title=\"Toggle explorer\" onClick={() => setLeftCollapsed((v) => !v)}>\n            <Icon name=\"panelLeft\" />\n            <span className=\"railLabel\" aria-hidden=\"true\">Explorer</span>\n          </button>\n          <button className=\"railBtn\" aria-label=\"Settings\" title=\"Settings\" onClick={() => openView('settings')}>\n            <Icon name=\"gear\" />\n            <span className=\"railLabel\" aria-hidden=\"true\">Settings</span>\n          </button>\n        </aside>\n\n        <aside className={leftCollapsed ? 'sb explorer collapsed' : 'sb explorer'}>\n          <div className=\"sbTop\">\n            <div className=\"sbTitle\">Vault</div>\n            <div className=\"sbSub\">Local-first (IndexedDB)</div>\n          </div>\n          <div className=\"sbSection\">\n            <div className=\"sbSectionHead\">\n              <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedOpen((v) => !v)} aria-label=\"Toggle pinned\">\n                <Icon name={explorerPinnedOpen ? 'chevronDown' : 'chevronRight'} size={16} />\n              </button>\n              <div className=\"sbSectionTitleInline\">Pinned</div>\n            </div>\n            {explorerPinnedOpen ? (\n              <div className=\"sbPinnedStack\">\n                {pinnedGroupOrder.map((key) => {\n                  if (key === 'tasks') {\n                    return (\n                      <div\n                        key=\"tasks\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('tasks', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('tasks', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedTasksOpen((v) => !v)} aria-label=\"Toggle tasks\">\n                            <Icon name={explorerPinnedTasksOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Tasks</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedTasksOpen ? (\n                          <div className=\"sbTasks\">\n                            <div className=\"sbTasksRow\">\n                              <input className=\"sbTasksSearch\" value={explorerTaskQuery} onChange={(e) => setExplorerTaskQuery(e.target.value)} placeholder=\"Search tasks\u2026\" />\n                            </div>\n                            <div className=\"sbTasksRow\">\n                              <input\n                                className=\"sbTasksQuick\"\n                                value={explorerTaskDraft}\n                                onChange={(e) => setExplorerTaskDraft(e.target.value)}\n                                placeholder=\"Quick add\u2026\"\n                                onKeyDown={(e) => {\n                                  if (e.key !== 'Enter') return\n                                  const title = explorerTaskDraft.trim()\n                                  if (!title) return\n                                  onCreateTaskFromInput({ title })\n                                  setExplorerTaskDraft('')\n                                }}\n                              />\n                              <button\n                                className=\"sbTasksAdd\"\n                                onClick={() => {\n                                  const title = explorerTaskDraft.trim()\n                                  if (!title) return\n                                  onCreateTaskFromInput({ title })\n                                  setExplorerTaskDraft('')\n                                }}>\n                                Add\n                              </button>\n                            </div>\n                            <div className=\"sbTasksList\">\n                              {explorerTasks.map((t) => (\n                                <div\n                                  key={t.id}\n                                  className={\n                                    t.status === 'done'\n                                      ? selection.kind === 'task' && selection.id === t.id\n                                        ? 'sbTaskRow done selected'\n                                        : 'sbTaskRow done'\n                                      : selection.kind === 'task' && selection.id === t.id\n                                        ? 'sbTaskRow selected'\n                                        : 'sbTaskRow'\n                                  }\n                                  draggable\n                                  onDragStart={(e) => {\n                                    e.dataTransfer.setData('text/taskId', t.id)\n                                    e.dataTransfer.setData('text/taskTitle', t.title)\n                                  }}\n                                  onClick={() => {\n                                    setSelection({ kind: 'task', id: t.id })\n                                    setRightCollapsed(false)\n                                    setRightMode('details')\n                                  }}>\n                                  <button\n                                    className={t.status === 'done' ? 'sbTaskCheck checked' : 'sbTaskCheck'}\n                                    onClick={(e) => {\n                                      e.preventDefault()\n                                      e.stopPropagation()\n                                      onToggleTaskComplete(t.id)\n                                    }}\n                                    aria-label={t.status === 'done' ? 'Mark incomplete' : 'Mark complete'}>\n                                    <span className=\"sbTaskBox\" />\n                                  </button>\n                                  <div className=\"sbTaskTitle\">{t.title}</div>\n                                </div>\n                              ))}\n                              {tasks.filter((t) => t.status !== 'done').length === 0 ? <div className=\"sbTasksEmpty\">No open tasks.</div> : null}\n                            </div>\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  if (key === 'habits') {\n                    return (\n                      <div\n                        key=\"habits\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('habits', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('habits', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedHabitsOpen((v) => !v)} aria-label=\"Toggle habits\">\n                            <Icon name={explorerPinnedHabitsOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Habits</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedHabitsOpen ? (\n                          <div className=\"sbQuickList\">\n                            {habitDefs.length === 0 ? (\n                              <div className=\"sbQuickEmpty\">No habits yet. Add one in the Habits tab.</div>\n                            ) : (\n                              habitDefs.map((h) => (\n                                <div\n                                  key={h.id}\n                                  className=\"sbQuickRow\"\n                                  draggable\n                                  onDragStart={(e) => {\n                                    const payload = {\n                                      id: h.id,\n                                      name: h.name,\n                                      tags: h.tags ?? [],\n                                      category: h.category ?? null,\n                                      subcategory: h.subcategory ?? null,\n                                      estimateMinutes: h.estimateMinutes ?? 15,\n                                    }\n                                    e.dataTransfer.setData(DND_HABIT, JSON.stringify(payload))\n                                    e.dataTransfer.setData('text/plain', h.name)\n                                  }}>\n                                  <span className=\"sbQuickIcon\">\n                                    <Icon name=\"check\" size={12} />\n                                  </span>\n                                  <div className=\"sbQuickTitle\">{h.name}</div>\n                                  <div className=\"sbQuickMeta\">{h.category ?? 'Habit'}</div>\n                                </div>\n                              ))\n                            )}\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  if (key === 'trackers') {\n                    return (\n                      <div\n                        key=\"trackers\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('trackers', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('trackers', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedTrackersOpen((v) => !v)} aria-label=\"Toggle trackers\">\n                            <Icon name={explorerPinnedTrackersOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Trackers</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedTrackersOpen ? (\n                          <div className=\"sbQuickList\">\n                            {trackerDefs.length === 0 ? (\n                              <div className=\"sbQuickEmpty\">No trackers yet.</div>\n                            ) : (\n                              trackerDefs.map((t) => (\n                                <div\n                                  key={t.key}\n                                  className=\"sbQuickRow\"\n                                  draggable\n                                  onDragStart={(e) => {\n                                    const payload = { key: t.key, label: t.label, defaultValue: t.defaultValue ?? null }\n                                    e.dataTransfer.setData(DND_TRACKER, JSON.stringify(payload))\n                                    e.dataTransfer.setData('text/plain', t.label)\n                                  }}>\n                                  <span className=\"sbQuickIcon\">\n                                    <Icon name={t.icon ?? 'sparkle'} size={12} />\n                                  </span>\n                                  <div className=\"sbQuickTitle\">{t.label}</div>\n                                  <div className=\"sbQuickMeta\">Tracker</div>\n                                </div>\n                              ))\n                            )}\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  if (key === 'shortcuts') {\n                    return (\n                      <div\n                        key=\"shortcuts\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('shortcuts', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('shortcuts', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedShortcutsOpen((v) => !v)} aria-label=\"Toggle shortcuts\">\n                            <Icon name={explorerPinnedShortcutsOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Shortcuts</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedShortcutsOpen ? (\n                          <div className=\"sbQuickList\">\n                            <button className=\"sbItem\" onClick={() => openView('calendar')}>\n                              Calendar\n                            </button>\n                            <button className=\"sbItem\" onClick={() => openView('notes')}>\n                              Notes\n                            </button>\n                            <button className=\"sbItem\" onClick={() => openView('assistant')}>\n                              Chat\n                            </button>\n                            <button className=\"sbItem\" onClick={() => openView('settings')}>\n                              Settings\n                            </button>\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  return null\n                })}\n              </div>\n            ) : null}\n          </div>\n          <div className=\"sbSection\">\n            <div className=\"sbSectionHead\">\n              <button className=\"sbSectionToggle\" onClick={() => setExplorerRecentOpen((v) => !v)} aria-label=\"Toggle recent notes\">\n                <Icon name={explorerRecentOpen ? 'chevronDown' : 'chevronRight'} size={16} />\n              </button>\n              <div className=\"sbSectionTitleInline\">Recent Notes</div>\n            </div>\n            {explorerRecentOpen ? (\n              <div className=\"sbTree\">\n                {captures.slice(0, 12).map((c) => {\n                  const title = (c.rawText.split(/\\r?\\n/)[0] ?? '').trim()\n                  const snippet = c.rawText.replace(/\\s+/g, ' ').slice(0, 72)\n                  return (\n                    <button\n                      key={c.id}\n                      className={selection.kind === 'capture' && selection.id === c.id ? 'sbTreeBtn active' : 'sbTreeBtn'}\n                      onClick={() => {\n                        setSelection({ kind: 'capture', id: c.id })\n                        openView('notes')\n                      }}\n                      title={c.rawText}>\n                      <span className=\"sbTreeTitle\">{(title || 'Untitled').slice(0, 40)}</span>\n                      <span className=\"sbTreeMeta\">{new Date(c.createdAt).toLocaleDateString()}</span>\n                      <span className=\"sbTreeSnippet\">{snippet}</span>\n                    </button>\n                  )\n                })}\n              </div>\n            ) : null}\n          </div>\n          <div className=\"sbSection\">\n            <div className=\"sbSectionHead\">\n              <button className=\"sbSectionToggle\" onClick={() => setExplorerPomoOpen((v) => !v)} aria-label=\"Toggle pomodoro\">\n                <Icon name={explorerPomoOpen ? 'chevronDown' : 'chevronRight'} size={16} />\n              </button>\n              <div className=\"sbSectionTitleInline\">Pomodoro</div>\n            </div>\n\t            {explorerPomoOpen ? (\n\t              <div className=\"sbPomodoro\">\n\t                <div className=\"pomoHeader\">\n\t                  <div className=\"pomoTitle\">Ready To Start</div>\n\t                </div>\n                <div className=\"pomoCircle\" style={{ ['--pomo' as any]: pomoProgress }}>\n                  <div className=\"pomoTime\">\n                    {String(pomoMinutes).padStart(2, '0')}:{String(pomoRemainder).padStart(2, '0')}\n                  </div>\n                </div>\n                <div className=\"pomoActions\">\n                  <button className=\"pomoBtn\" onClick={() => setPomoRunning((v) => !v)} aria-label={pomoRunning ? 'Pause' : 'Start'}>\n                    {pomoRunning ? 'Pause' : 'Start'}\n                  </button>\n                  <button\n                    className=\"pomoBtn secondary\"\n                    onClick={() => {\n                      setPomoRunning(false)\n                      setPomoSeconds(25 * 60)\n                    }}>\n                    Reset\n                  </button>\n                </div>\n\t                <div className=\"pomoTask\">\n\t                  <div className=\"pomoTaskLabel\">Active task</div>\n\t                  <div className=\"pomoTaskValueRow\">\n\t                    <div className=\"pomoTaskValue\">{pomoActiveTask?.title ?? selectedTask?.title ?? '\u2014'}</div>\n\t                    <button\n\t                      className=\"pomoTaskClear\"\n\t                      onClick={() => setPomoActiveTaskId(null)}\n\t                      disabled={!pomoActiveTaskId}\n\t                      aria-label=\"Clear active task\">\n\t                      \u00d7\n\t                    </button>\n\t                  </div>\n\t                  <div className=\"pomoPickRow\">\n\t                    <button\n\t                      className=\"pomoPickBtn\"\n\t                      onClick={() => {\n\t                        if (!selectedTask) return\n\t                        setPomoActiveTaskId(selectedTask.id)\n\t                      }}\n\t                      disabled={!selectedTask}\n\t                      aria-label=\"Set active task to selected task\">\n\t                      Use selected\n\t                    </button>\n\t                    <button\n\t                      className=\"pomoPickBtn secondary\"\n\t                      onClick={() => openView('tasks')}\n\t                      aria-label=\"Open tasks\">\n\t                      Open tasks\n\t                    </button>\n\t                  </div>\n\t                  <div className=\"pomoPickList\" aria-label=\"Quick pick tasks\">\n\t                    {explorerTasks.slice(0, 6).map((t) => (\n\t                      <button\n\t                        key={t.id}\n\t                        className={t.id === pomoActiveTaskId ? 'pomoPickItem active' : 'pomoPickItem'}\n\t                        onClick={() => setPomoActiveTaskId(t.id)}>\n\t                        {t.title}\n\t                      </button>\n\t                    ))}\n\t                    {explorerTasks.length === 0 ? <div className=\"pomoPickEmpty\">No open tasks.</div> : null}\n\t                  </div>\n\t                </div>\n\t                <div className=\"pomoNotes\">\n\t                  <div className=\"pomoNotesLabel\">Recent notes</div>\n\t                  <div className=\"pomoNotesList\" aria-label=\"Recent notes\">\n\t                    {captures.slice(0, 3).map((c) => {\n\t                      const title = (c.rawText.split(/\\r?\\n/)[0] ?? '').trim() || 'Untitled'\n\t                      return (\n\t                        <button\n\t                          key={c.id}\n\t                          className=\"pomoNoteItem\"\n\t                        onClick={() => {\n\t                          setSelection({ kind: 'capture', id: c.id })\n\t                            openView('notes')\n\t                          }}\n\t                          title={c.rawText}>\n\t                          {title}\n\t                        </button>\n\t                      )\n\t                    })}\n\t                  </div>\n\t                </div>\n\t              </div>\n\t            ) : null}\n\t          </div>\n\t        </aside>\n\n      <div className=\"ws\">\n        <Pane\n          tabs={workspace.tabs}\n          activeTabId={workspace.activeTabId}\n          onActivate={(id) => setWorkspace((p) => ({ ...p, activeTabId: id }))}\n          onClose={(id) => closeTab(id)}>\n          {renderView(active.view)}\n        </Pane>\n      </div>\n\n\t      <AnimatePresence>\n\t      {rightCollapsed ? null : (\n\t        <motion.aside\n\t          className=\"details\"\n\t          initial={{ x: 16, opacity: 0 }}\n\t          animate={{ x: 0, opacity: 1 }}\n\t          exit={{ x: 16, opacity: 0 }}\n\t          transition={{ duration: 0.16, ease: 'easeOut' }}>\n\t        <div className=\"detailsHeader\">\n\t          <div className=\"detailsHeaderRow\">\n\t            <div>\n\t              <div className=\"detailsTitle\">{rightMode === 'ai' ? 'AI' : 'Details'}</div>\n              <div className=\"detailsSub\">{rightMode === 'ai' ? 'Chat with your notes and calendar.' : 'Edit fields like importance and difficulty/energy plus notes.'}</div>\n\t            </div>\n\t            <div className=\"detailsHeaderActions\">\n\t              <button\n\t                className={rightMode === 'ai' ? 'detailsIconBtn active' : 'detailsIconBtn'}\n\t                onClick={() => setRightMode((m) => (m === 'ai' ? 'details' : 'ai'))}\n\t                aria-label=\"Toggle AI\">\n\t                <Icon name=\"sparkle\" size={16} />\n\t              </button>\n\t              <button\n\t                className=\"detailsIconBtn\"\n\t                onClick={() => {\n\t                  if (rightMode === 'ai') openView('assistant')\n\t                  else setDocOpen(true)\n\t                }}\n\t                aria-label={rightMode === 'ai' ? 'Open full chat' : 'Open page'}>\n\t                <Icon name=\"maximize\" size={16} />\n\t              </button>\n\t              <button className=\"detailsIconBtn\" onClick={() => setRightCollapsed(true)} aria-label=\"Collapse right panel\">\n\t                <Icon name=\"panelRight\" size={16} />\n\t              </button>\n\t            </div>\n\t          </div>\n\t        </div>\n\n\t        {rightMode === 'ai' ? (\n\t          <div className=\"detailsBody\">\n\t\t            <AssistantView\n\t\t              embedded\n\t\t              captures={captures}\n\t\t              events={events}\n\t\t              tasks={tasks}\n\t\t              onSelectCapture={(id) => {\n\t\t                setSelection({ kind: 'capture', id })\n\t\t                setRightMode('details')\n\t\t              }}\n\t\t              onSelectEvent={(id) => {\n\t\t                setSelection({ kind: 'event', id })\n\t\t                setRightMode('details')\n\t\t              }}\n\t\t              onSelectTask={(id) => {\n\t\t                setSelection({ kind: 'task', id })\n\t\t                setRightMode('details')\n\t\t              }}\n\t\t            />\n\t          </div>\n\t        ) : selection.kind === 'none' ? (\n\t          <div className=\"detailsBody\">\n\t            <div className=\"detailCard\">\n\t              <div className=\"detailTitle\">No selection</div>\n\t              <div className=\"detailMeta\">Click a task or calendar event to edit.</div>\n\t            </div>\n\t          </div>\n\t        ) : selection.kind === 'task' && selectedTask ? (\n\t          <div className=\"detailsBody\">\n\t            <div className=\"detailCard\">\n              <div className=\"detailTitle\">Task</div>\n              <div className=\"detailBadgeRow\">\n                <span className=\"detailBadge\">{selectedTask.status}</span>\n                <button\n                  className={selectedTask.status === 'done' ? 'detailToggle active' : 'detailToggle'}\n                  onClick={() => onToggleTaskComplete(selectedTask.id)}>\n                  {selectedTask.status === 'done' ? 'Completed' : 'Mark complete'}\n                </button>\n                <button className=\"secondaryButton\" onClick={() => requestDeleteSelection()}>\n                  Delete\n                </button>\n              </div>\n              <input\n                className=\"detailInput detailTitleInput\"\n                value={selectedTask.title}\n                onChange={(e) => commitTask({ ...selectedTask, title: e.target.value })}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault()\n                    ;(e.target as HTMLInputElement).blur()\n                    setSelection({ kind: 'none' })\n                  }\n                }}\n                placeholder=\"Task title...\"\n              />\n              <div className=\"detailRow\">\n                <label className=\"detailLabel\">\n                  Tags\n                  <input\n                    className=\"detailSmall\"\n                    value={(selectedTask.tags ?? []).join(' ')}\n                    onChange={(e) => commitTask({ ...selectedTask, tags: parseTags(e.target.value) })}\n                    placeholder=\"#work #health\"\n                  />\n                </label>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Context</div>\n                <div className=\"detailChips\">\n                  {selectedTaskContexts.map((ctx) => (\n                    <button\n                      key={ctx}\n                      className=\"detailChip\"\n                      onClick={() => commitTask({ ...selectedTask, contexts: selectedTaskContexts.filter((x) => x !== ctx) })}\n                      type=\"button\">\n                      {formatContextLabel(ctx)}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={contextDraft}\n                    onChange={(e) => setContextDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitTask({ ...selectedTask, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitTask({ ...selectedTask, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    placeholder=\"at computer, at email\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">People</div>\n                <div className=\"detailChips\">\n                  {selectedTaskPeople.map((person) => (\n                    <button\n                      key={person}\n                      className=\"detailChip\"\n                      onClick={() => commitTask({ ...selectedTask, people: selectedTaskPeople.filter((x) => x !== person) })}\n                      type=\"button\">\n                      {person}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={peopleDraft}\n                    onChange={(e) => setPeopleDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskPeople, ...next])\n                      commitTask({ ...selectedTask, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskPeople, ...next])\n                      commitTask({ ...selectedTask, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    placeholder=\"Mom, Alex\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Location</div>\n                <div className=\"detailChips\">\n                  {selectedTaskLocations.map((loc) => (\n                    <button\n                      key={loc}\n                      className=\"detailChip\"\n                      onClick={() => {\n                        const next = selectedTaskLocations.filter((x) => x !== loc)\n                        commitTask({ ...selectedTask, location: next.length ? next.join(', ') : null })\n                      }}\n                      type=\"button\">\n                      {loc}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={locationDraft}\n                    onChange={(e) => setLocationDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(locationDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskLocations, ...next])\n                      commitTask({ ...selectedTask, location: merged.length ? merged.join(', ') : null })\n                      setLocationDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(locationDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskLocations, ...next])\n                      commitTask({ ...selectedTask, location: merged.length ? merged.join(', ') : null })\n                      setLocationDraft('')\n                    }}\n                    placeholder=\"Home\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Skills</div>\n                <div className=\"detailChips\">\n                  {selectedTaskSkills.map((skill) => (\n                    <button\n                      key={skill}\n                      className=\"detailChip\"\n                      onClick={() => commitTask({ ...selectedTask, skills: selectedTaskSkills.filter((x) => x !== skill) })}\n                      type=\"button\">\n                      {skill}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={skillDraft}\n                    onChange={(e) => setSkillDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskSkills, ...next])\n                      commitTask({ ...selectedTask, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskSkills, ...next])\n                      commitTask({ ...selectedTask, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    placeholder=\"communication, lifting\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Character</div>\n                <div className=\"detailCharacterRow\">\n                  {CHARACTER_KEYS.map((k) => {\n                    const selected = normalizeCharacterSelection(selectedTaskCharacter).includes(k)\n                    return (\n                      <button\n                        key={k}\n                        className={selected ? 'detailCharacterBtn active' : 'detailCharacterBtn'}\n                        onClick={() => commitTask({ ...selectedTask, character: toggleCharacterSelection(selectedTaskCharacter, k) })}>\n                        {k}\n                      </button>\n                    )\n                  })}\n                </div>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Due\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedTask.dueAt)}\n                    onChange={(e) => commitTask({ ...selectedTask, dueAt: fromLocalDateTimeInput(e.target.value) })}\n                  />\n                </label>\n                <label>\n                  Scheduled\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedTask.scheduledAt)}\n                    onChange={(e) => commitTask({ ...selectedTask, scheduledAt: fromLocalDateTimeInput(e.target.value) })}\n                  />\n                </label>\n              </div>\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Goal\n\t                  <input\n\t                    className=\"detailSmall\"\n\t                    value={selectedTask.goal ?? ''}\n\t                    onChange={(e) => commitTask({ ...selectedTask, goal: e.target.value || null })}\n\t                    placeholder=\"get shredded\"\n\t                  />\n\t                </label>\n\t                <label>\n\t                  Project\n\t                  <input\n\t                    className=\"detailSmall\"\n\t                    value={selectedTask.project ?? ''}\n\t                    onChange={(e) => commitTask({ ...selectedTask, project: e.target.value || null })}\n\t                    placeholder=\"workout plan\"\n\t                  />\n\t                </label>\n\t              </div>\n\t\t              <div className=\"detailGrid\">\n\t\t                <label>\n\t\t                  Category\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxCatList\"\n\t\t                    value={selectedTask.category ?? ''}\n\t\t                    onChange={(e) => commitTask({ ...selectedTask, category: e.target.value || null })}\n\t\t                    placeholder=\"Work / Health / Study\"\n\t\t                  />\n\t\t                </label>\n\t\t                <label>\n\t\t                  Subcategory\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxSubcatList\"\n\t\t                    value={selectedTask.subcategory ?? ''}\n\t\t                    onChange={(e) => commitTask({ ...selectedTask, subcategory: e.target.value || null })}\n\t\t                    placeholder=\"Clinic / Surgery / Gym\"\n\t\t                  />\n\t\t                </label>\n\t\t              </div>\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Importance\n\t                  <div className=\"detailRangeRow\">\n\t                    <input\n\t                      className=\"detailRange\"\n\t                      type=\"range\"\n\t                      min={0}\n\t                      max={10}\n\t                      step={1}\n\t                      value={selectedTask.importance ?? 5}\n\t                      onChange={(e) => commitTask({ ...selectedTask, importance: Number(e.target.value) })}\n\t                      aria-label=\"Importance\"\n\t                    />\n\t                    <span className=\"detailRangeValue\">{selectedTask.importance ?? '\u2014'}</span>\n\t                    <button\n\t                      className=\"detailRangeClear\"\n\t                      type=\"button\"\n\t                      onClick={() => commitTask({ ...selectedTask, importance: null })}\n\t                      disabled={selectedTask.importance == null}\n\t                      aria-label=\"Clear importance\">\n\t                      \u00d7\n\t                    </button>\n\t                  </div>\n\t                </label>\n                <label>\n                  Difficulty / Energy\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={selectedTask.difficulty ?? 5}\n                      onChange={(e) => commitTask({ ...selectedTask, difficulty: Number(e.target.value) })}\n                      aria-label=\"Difficulty / Energy\"\n                    />\n                    <span className=\"detailRangeValue\">{selectedTask.difficulty ?? '\u2014'}</span>\n                    <button\n                      className=\"detailRangeClear\"\n                      type=\"button\"\n                      onClick={() => commitTask({ ...selectedTask, difficulty: null })}\n                      disabled={selectedTask.difficulty == null}\n                      aria-label=\"Clear difficulty or energy\">\n                      \u00d7\n                    </button>\n                  </div>\n                </label>\n\t                <label>\n\t                  Estimate (min)\n\t                  <input\n\t                    className=\"detailSmall\"\n                    value={selectedTask.estimateMinutes ?? ''}\n                    onChange={(e) => commitTask({ ...selectedTask, estimateMinutes: numberOrNull(e.target.value) })}\n                    placeholder=\"25\"\n                  />\n                </label>\n\t              </div>\n\t              {(() => {\n\t                const items = parseChecklistMarkdown(selectedTask.notes)\n\t                if (!items.length) return null\n\t                const remaining = items.filter((x) => !x.checked).length\n\t                return (\n\t                  <div className=\"detailRow\" style={{ marginTop: 8 }}>\n\t                    <div className=\"detailLabel\" style={{ marginBottom: 6 }}>\n\t                      Checklist <span style={{ color: 'var(--muted)', fontWeight: 800 }}>({remaining}/{items.length})</span>\n\t                    </div>\n\t                    <div className=\"detailChecklist\" aria-label=\"Task checklist\">\n\t                      {items.slice(0, 24).map((it) => (\n\t                        <button\n\t                          key={`${selectedTask.id}_${it.lineIndex}`}\n\t                          className={it.checked ? 'detailCheckItem checked' : 'detailCheckItem'}\n\t                          onClick={() => commitTask({ ...selectedTask, notes: toggleChecklistLine(selectedTask.notes, it.lineIndex) })}\n\t                          aria-label={it.checked ? `Uncheck ${it.text}` : `Check ${it.text}`}>\n\t                          <span className=\"detailCheckBox\" aria-hidden=\"true\" />\n\t                          <span className=\"detailCheckText\">{it.text}</span>\n\t                        </button>\n\t                      ))}\n\t                    </div>\n\t                  </div>\n\t                )\n\t              })()}\n\t            </div>\n\t          </div>\n\t        ) : selection.kind === 'event' && selectedEvent ? (\n          <div className=\"detailsBody\">\n            <div className=\"detailCard\">\n              {selectedEvent.active ? (\n                <div className=\"detailActiveSession\">\n                  <ActiveSessionBanner\n                    title={selectedEvent.title}\n                    category={selectedEvent.category}\n                    subcategory={selectedEvent.subcategory}\n                    startedAt={selectedEvent.startAt}\n                    estimatedMinutes={selectedEvent.estimateMinutes ?? Math.round((selectedEvent.endAt - selectedEvent.startAt) / (60 * 1000))}\n                    importance={selectedEvent.importance}\n                    difficulty={selectedEvent.difficulty}\n                    goal={selectedEvent.goal}\n                    project={selectedEvent.project}\n                    onStop={() => {\n                      const now = Date.now()\n                      commitEvent({ ...selectedEvent, endAt: Math.max(now, selectedEvent.startAt + 5 * 60 * 1000), active: false })\n                    }}\n                  />\n                </div>\n              ) : null}\n              <div className={selectedEvent.kind === 'task' ? 'detailBadgeRow detailBadgeRowSplit' : 'detailBadgeRow'}>\n                <div className=\"detailBadgeGroup\">\n                  <span className=\"detailBadge\">{selectedEvent.kind ?? 'event'}</span>\n                  {selectedEvent.kind !== 'log' && selectedEvent.kind !== 'task' ? (\n                    <button\n                      className={selectedEvent.allDay ? 'detailToggle active' : 'detailToggle'}\n                      onClick={() => commitEvent({ ...selectedEvent, allDay: !selectedEvent.allDay })}>\n                      All-day\n                    </button>\n                  ) : null}\n                  {selectedEvent.kind !== 'log' && selectedEvent.kind !== 'task' ? (\n                    <button\n                      className={selectedEvent.active ? 'detailToggle active' : 'detailToggle'}\n                      onClick={() => {\n                        if (selectedEvent.active) {\n                          const now = Date.now()\n                          commitEvent({ ...selectedEvent, endAt: Math.max(now, selectedEvent.startAt + 5 * 60 * 1000), active: false })\n                        } else {\n                          commitEvent({ ...selectedEvent, active: true })\n                        }\n                      }}>\n                      {selectedEvent.active ? 'Active' : 'Inactive'}\n                    </button>\n                  ) : null}\n                  {selectedEvent.kind !== 'task' ? (\n                    <>\n                      <button\n                        className=\"secondaryButton detailAiBtn\"\n                        onClick={() => {\n                          setCaptureDraft('')\n                          setCaptureInterim('')\n                          openCapture({ attachEventId: selectedEvent.id })\n                        }}>\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                      <button className=\"secondaryButton\" onClick={() => autoFillEventFromText(selectedEvent)}>\n                        Auto-fill\n                      </button>\n                      <button className=\"secondaryButton\" onClick={() => requestDeleteSelection()}>\n                        Delete\n                      </button>\n                    </>\n                  ) : null}\n                </div>\n                {selectedEvent.kind === 'task' ? (\n                  <button\n                    className={selectedEvent.completedAt ? 'detailCompleteToggle checked' : 'detailCompleteToggle'}\n                    onClick={() => onToggleEventComplete(selectedEvent.id)}\n                    aria-label={selectedEvent.completedAt ? 'Mark incomplete' : 'Mark complete'}\n                    title={selectedEvent.completedAt ? 'Mark incomplete' : 'Mark complete'}\n                    type=\"button\">\n                    <Icon name=\"check\" size={14} />\n                  </button>\n                ) : null}\n              </div>\n              {selectedEvent.kind !== 'log' ? (\n                <div className={selectedEvent.kind === 'task' ? 'detailActions compact' : 'detailActions'}>\n                  <button\n                    className=\"secondaryButton\"\n                    onClick={() => {\n                      const now = Date.now()\n                      const dur = Math.max(5 * 60 * 1000, selectedEvent.endAt - selectedEvent.startAt)\n                      commitEvent({ ...selectedEvent, startAt: now, endAt: now + dur, active: true })\n                    }}>\n                    Start now\n                  </button>\n                  {selectedEvent.kind !== 'task' ? (\n                    <button\n                      className=\"secondaryButton\"\n                      onClick={() => {\n                        setCaptureDraft('')\n                        setCaptureInterim('')\n                        openCapture({ attachEventId: selectedEvent.id })\n                      }}>\n                      Take note\n                    </button>\n                  ) : null}\n                  <button\n                    className=\"secondaryButton\"\n                    onClick={() => {\n                      const now = Date.now()\n                      commitEvent({ ...selectedEvent, endAt: Math.max(now, selectedEvent.startAt + 5 * 60 * 1000), active: false })\n                    }}\n                    disabled={!selectedEvent.active}>\n                    Stop now\n                  </button>\n                </div>\n              ) : null}\n              <input\n                className=\"detailInput detailTitleInput\"\n                value={selectedEvent.title}\n                onChange={(e) => commitEvent({ ...selectedEvent, title: e.target.value })}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault()\n                    ;(e.target as HTMLInputElement).blur()\n                    setSelection({ kind: 'none' })\n                  }\n                }}\n                placeholder=\"Event title...\"\n              />\n              {selectedEventTracker ? (\n                <div className=\"detailRow\">\n                  <div className=\"detailLabel\">Active tracker</div>\n                  <div className=\"detailChips\">\n                    <button\n                      className=\"detailChip active\"\n                      onClick={() => openTrackerDetail(selectedEventTracker.key)}\n                      type=\"button\">\n                      {selectedEventTracker.label}\n                    </button>\n                  </div>\n                </div>\n              ) : null}\n\n              <div className=\"detailRow detailNotesSection\" style={{ marginTop: 12 }}>\n                <div className=\"detailLabelRow\">\n                  <div className=\"detailLabel\">Notes</div>\n                  <div className=\"detailLabelActions\">\n                    <button\n                      className=\"detailInlineBtn\"\n                      onClick={() => {\n                        setCaptureDraft('')\n                        setCaptureInterim('')\n                        openCapture({ attachEventId: selectedEvent.id })\n                      }}\n                      type=\"button\">\n                      <Icon name=\"mic\" size={12} />\n                      Transcribe\n                    </button>\n                  </div>\n                </div>\n                <MarkdownEditor\n                  value={selectedEvent.notes ?? ''}\n                  onChange={(next) => commitEvent({ ...selectedEvent, notes: next })}\n                  onToggleChecklist={(lineIndex) => {\n                    if (selectedEvent.kind === 'task' && selectedEvent.taskId) {\n                      onToggleTaskChecklistItem(selectedEvent.taskId, lineIndex)\n                      return\n                    }\n                    void onToggleEventNoteChecklist(selectedEvent, lineIndex)\n                  }}\n                  onStartTask={(task) => onStartNoteTask(selectedEvent.id, task)}\n                  taskStateByToken={selectedEventNoteTasks}\n                  nowMs={nowTick}\n                  placeholder=\"Write notes\u2026\"\n                  ariaLabel=\"Event notes\"\n                />\n                <button\n                  className=\"secondaryButton detailSegmentBtn\"\n                  onClick={() => {\n                    const label = window.prompt('Segment label (e.g., Inpatient)')\n                    if (!label) return\n                    const t = new Date()\n                    const hh = String(t.getHours()).padStart(2, '0')\n                    const mm = String(t.getMinutes()).padStart(2, '0')\n                    const next = `${(selectedEvent.notes ?? '').trim()}\\n**${hh}:${mm}** - ${label}\\n`\n                    commitEvent({ ...selectedEvent, notes: next.trim() })\n                  }}>\n                  + Segment\n                </button>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Start\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedEvent.startAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      const dur = Math.max(5 * 60 * 1000, selectedEvent.endAt - selectedEvent.startAt)\n                      commitEvent({ ...selectedEvent, startAt: ms, endAt: ms + dur })\n                    }}\n                  />\n                </label>\n                <label>\n                  End\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedEvent.endAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      commitEvent({ ...selectedEvent, endAt: Math.max(ms, selectedEvent.startAt + 5 * 60 * 1000) })\n                    }}\n                  />\n                </label>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Icon\n                  <div className=\"detailIconSelect\">\n                    <select\n                      className=\"detailSmall\"\n                      value={selectedEvent.icon ?? ''}\n                      onChange={(e) => commitEvent({ ...selectedEvent, icon: e.target.value || null })}>\n                      <option value=\"\">Auto</option>\n                      {EVENT_ICON_OPTIONS.map((o) => (\n                        <option key={o.value} value={o.value}>\n                          {o.label}\n                        </option>\n                      ))}\n                    </select>\n                    <span className=\"detailIconPreview\">\n                      <Icon name={eventAccent(selectedEvent).icon} size={14} />\n                    </span>\n                  </div>\n                </label>\n                <label>\n                  Color\n                  <div className=\"detailColorRow\">\n                    <input\n                      className=\"detailColorInput\"\n                      type=\"color\"\n                      value={selectedEvent.color ?? eventAccent(selectedEvent).color}\n                      onChange={(e) => commitEvent({ ...selectedEvent, color: e.target.value })}\n                    />\n                    <button className=\"detailColorAuto\" onClick={() => commitEvent({ ...selectedEvent, color: null })}>\n                      Auto\n                    </button>\n                  </div>\n                  <div className=\"detailSwatches\">\n                    {EVENT_COLOR_PRESETS.slice(0, 9).map((c) => (\n                      <button\n                        key={c.hex}\n                        className={selectedEvent.color === c.hex ? 'detailSwatch active' : 'detailSwatch'}\n                        title={c.name}\n                        style={{ background: c.hex }}\n                        onClick={() => commitEvent({ ...selectedEvent, color: c.hex })}\n                      />\n                    ))}\n                  </div>\n                </label>\n              </div>\n\n              {/* Collapsible Properties Section */}\n              <button\n                className=\"detailPropsHeader\"\n                onClick={() => setPropsCollapsed(!propsCollapsed)}\n                type=\"button\">\n                <span className=\"detailPropsLabel\">Properties</span>\n                <span className={propsCollapsed ? 'detailPropsChevron' : 'detailPropsChevron open'}>\n                  <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                    <polyline points=\"6 9 12 15 18 9\" />\n                  </svg>\n                </span>\n              </button>\n\n              {!propsCollapsed && (\n                <>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Tags</div>\n                <div className=\"detailChips\">\n                  {selectedEventTags.map((t) => (\n                    <button\n                      key={t}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, tags: selectedEventTags.filter((x) => x !== t) })}\n                      type=\"button\">\n                      {t}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={tagDraft}\n                    onChange={(e) => setTagDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',' && e.key !== ' ') return\n                      e.preventDefault()\n                      const next = parseTags(tagDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                      commitEvent({ ...selectedEvent, tags: merged })\n                      setTagDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseTags(tagDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                      commitEvent({ ...selectedEvent, tags: merged })\n                      setTagDraft('')\n                    }}\n                    placeholder=\"#work #meeting\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Context</div>\n                <div className=\"detailChips\">\n                  {selectedEventContexts.map((ctx) => (\n                    <button\n                      key={ctx}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, contexts: selectedEventContexts.filter((x) => x !== ctx) })}\n                      type=\"button\">\n                      {formatContextLabel(ctx)}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={contextDraft}\n                    onChange={(e) => setContextDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitEvent({ ...selectedEvent, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitEvent({ ...selectedEvent, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    placeholder=\"at computer, at email\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Estimate (min)\n                  <input\n                    className=\"detailSmall\"\n                    value={selectedEvent.estimateMinutes ?? ''}\n                    onChange={(e) => commitEvent({ ...selectedEvent, estimateMinutes: numberOrNull(e.target.value) })}\n                    placeholder=\"30\"\n                  />\n                </label>\n                <label>\n                  Location\n                  <div className=\"detailChips\">\n                    {selectedEventLocations.map((loc) => (\n                      <button\n                        key={loc}\n                        className=\"detailChip\"\n                        onClick={() => {\n                          const next = selectedEventLocations.filter((x) => x !== loc)\n                          commitEvent({ ...selectedEvent, location: next.length ? next.join(', ') : null })\n                        }}\n                        type=\"button\">\n                        {loc}\n                        <span className=\"detailChipRemove\">\u00d7</span>\n                      </button>\n                    ))}\n                    <input\n                      className=\"detailChipInput\"\n                      value={locationDraft}\n                      onChange={(e) => setLocationDraft(e.target.value)}\n                      onKeyDown={(e) => {\n                        if (e.key !== 'Enter' && e.key !== ',') return\n                        e.preventDefault()\n                        const next = parseCommaList(locationDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...selectedEventLocations, ...next])\n                        commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                        setLocationDraft('')\n                      }}\n                      onBlur={() => {\n                        const next = parseCommaList(locationDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...selectedEventLocations, ...next])\n                        commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                        setLocationDraft('')\n                      }}\n                      placeholder=\"Home\"\n                    />\n                  </div>\n                </label>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Points\n                  <div className=\"detailPoints\">\n                    <div className=\"detailPointsValue\">{selectedEventPoints.toFixed(1)}</div>\n                    <div className=\"detailPointsMeta\">\n                      {selectedEventBase} \u00d7 {formatMinutesSpan(selectedEventMinutes)} \u00f7 60 \u00d7 {selectedEventMult.toFixed(2)}\n                    </div>\n                  </div>\n                </label>\n                <label>\n                  Running\n                  <div className=\"detailPoints\">\n                    <div className=\"detailPointsValue\">{selectedEvent.active ? 'Active' : '\u2014'}</div>\n                    <div className=\"detailPointsMeta\">\n                      {selectedEvent.active ? `${formatMinutesSpan(selectedEventMinutes)} elapsed` : 'Not running'}\n                    </div>\n                  </div>\n                </label>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">People</div>\n                <div className=\"detailChips\">\n                  {selectedEventPeople.map((p) => (\n                    <button\n                      key={p}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, people: selectedEventPeople.filter((x) => x !== p) })}\n                      type=\"button\">\n                      {p}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={peopleDraft}\n                    onChange={(e) => setPeopleDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventPeople, ...next])\n                      commitEvent({ ...selectedEvent, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventPeople, ...next])\n                      commitEvent({ ...selectedEvent, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    placeholder=\"Mom, Alex\"\n                  />\n                </div>\n              </div>\n\t              {selectedEventLogs.length ? (\n\t                <div className=\"detailRow\">\n\t                  <div className=\"detailLabel\">Signals</div>\n\t                  <div className=\"detailLogChips\">\n\t                    {selectedEventLogs.map((l) => (\n                        <button\n                          key={l.id}\n                          className=\"detailLogChip\"\n                          onClick={() => {\n                            setSelection({ kind: 'event', id: l.id })\n                            setRightMode('details')\n                          }}>\n                          <span className=\"detailLogChipTime\">{new Date(l.startAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>\n                          <span className=\"detailLogChipTitle\">{l.title}</span>\n                        </button>\n                      ))}\n\t                  </div>\n\t                </div>\n\t              ) : null}\n\t\t              {selectedEventTasks.length ? (\n\t\t                <div className=\"detailRow\">\n\t\t                  <div className=\"detailLabel\">\n\t\t                    Linked tasks\n\t\t                    <div className=\"detailLogList\">\n\t\t                      {selectedEventTasks.map((t) => {\n\t\t                        const checklist = parseChecklistMarkdown(t.notes)\n\t\t                        const remaining = checklist.filter((x) => !x.checked).length\n\t\t                        const checklistHint = checklist.length ? ` \u2022 ${remaining}/${checklist.length}` : ''\n\t\t                        return (\n\t\t                          <div key={t.id} className=\"detailTaskRow\">\n\t\t                            <button\n\t\t                              className={t.status === 'done' ? 'detailTaskCheck checked' : 'detailTaskCheck'}\n\t\t                              onClick={() => onToggleTaskComplete(t.id)}\n\t\t                              aria-label={t.status === 'done' ? 'Mark incomplete' : 'Mark complete'}>\n\t\t                              <Icon name=\"check\" size={14} />\n\t\t                            </button>\n\t\t                            <button\n\t\t                              className=\"detailTaskOpen\"\n\t\t                              onClick={() => {\n\t\t                                setSelection({ kind: 'task', id: t.id })\n\t\t                                setRightMode('details')\n\t\t                              }}\n\t\t                              title={t.title}>\n\t\t                              <span className=\"detailTaskTitle\">{t.title}</span>\n\t\t                              <span className=\"detailTaskMeta\">{t.status}{checklistHint}</span>\n\t\t                            </button>\n\t\t                          </div>\n\t\t                        )\n\t\t                      })}\n\t\t                    </div>\n\t\t                  </div>\n\t\t                </div>\n\t\t              ) : null}\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Skills</div>\n                <div className=\"detailChips\">\n                  {selectedEventSkills.map((skill) => (\n                    <button\n                      key={skill}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, skills: selectedEventSkills.filter((x) => x !== skill) })}\n                      type=\"button\">\n                      {skill}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={skillDraft}\n                    onChange={(e) => setSkillDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventSkills, ...next])\n                      commitEvent({ ...selectedEvent, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventSkills, ...next])\n                      commitEvent({ ...selectedEvent, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    placeholder=\"communication, lifting\"\n                  />\n                </div>\n              </div>\n\t              <div className=\"detailRow\">\n\t                <label className=\"detailLabel\">\n\t                  Character\n\t                  <div className=\"charGrid\" role=\"group\" aria-label=\"Character stats\">\n\t                    {CHARACTER_KEYS.map((k) => {\n\t                      const selected = normalizeCharacterSelection(selectedEvent.character).includes(k)\n\t                      return (\n\t                        <button\n\t                          key={k}\n\t                          className={selected ? 'charChip active' : 'charChip'}\n\t                          onClick={() => commitEvent({ ...selectedEvent, character: toggleCharacterSelection(selectedEvent.character, k) })}\n\t                          type=\"button\"\n\t                          aria-label={selected ? `Remove ${k}` : `Add ${k}`}>\n\t                          {k}\n\t                        </button>\n\t                      )\n\t                    })}\n\t                  </div>\n\t                </label>\n\t              </div>\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Goal\n\t                  <input\n\t                    className=\"detailSmall\"\n                    value={selectedEvent.goal ?? ''}\n                    onChange={(e) => commitEvent({ ...selectedEvent, goal: e.target.value || null })}\n                    placeholder=\"get shredded\"\n                  />\n\t                </label>\n\t                <label>\n\t                  Project\n\t                  <input\n\t                    className=\"detailSmall\"\n                    value={selectedEvent.project ?? ''}\n                    onChange={(e) => commitEvent({ ...selectedEvent, project: e.target.value || null })}\n                    placeholder=\"workout plan\"\n                  />\n\t                </label>\n\t              </div>\n\t\t              <div className=\"detailGrid\">\n\t\t                <label>\n\t\t                  Category\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxCatList\"\n\t\t                    value={selectedEvent.category ?? ''}\n\t\t                    onChange={(e) => commitEvent({ ...selectedEvent, category: e.target.value || null })}\n\t\t                    placeholder=\"Work / Health / Study\"\n\t\t                  />\n\t\t                </label>\n\t\t                <label>\n\t\t                  Subcategory\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxSubcatList\"\n\t\t                    value={selectedEvent.subcategory ?? ''}\n\t\t                    onChange={(e) => commitEvent({ ...selectedEvent, subcategory: e.target.value || null })}\n\t\t                    placeholder=\"Clinic / Surgery / Gym\"\n\t\t                  />\n\t\t                </label>\n\t\t              </div>\n\t\t              <div className=\"detailRow\">\n\t\t                <div className=\"detailLabel\">Category shortcuts</div>\n\t\t                <div className=\"detailChips\">\n\t\t                  {taxonomyCategories.slice(0, 12).map((c) => (\n\t\t                    <button\n\t\t                      key={c}\n\t\t                      className={selectedEvent.category?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n\t\t                      onClick={() => commitEvent({ ...selectedEvent, category: c })}\n\t\t                      type=\"button\">\n\t\t                      {c}\n\t\t                    </button>\n\t\t                  ))}\n\t\t                </div>\n\t\t              </div>\n\t\t              {taxonomySubcategories.length ? (\n\t\t                <div className=\"detailRow\">\n\t\t                  <div className=\"detailLabel\">Subcategory shortcuts</div>\n\t\t                  <div className=\"detailChips\">\n\t\t                    {taxonomySubcategories.slice(0, 12).map((c) => (\n\t\t                      <button\n\t\t                        key={c}\n\t\t                        className={selectedEvent.subcategory?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n\t\t                        onClick={() => commitEvent({ ...selectedEvent, subcategory: c })}\n\t\t                        type=\"button\">\n\t\t                        {c}\n\t\t                      </button>\n\t\t                    ))}\n\t\t                  </div>\n\t\t                </div>\n\t\t              ) : null}\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Importance\n\t                  <div className=\"detailRangeRow\">\n\t                    <input\n\t                      className=\"detailRange\"\n\t                      type=\"range\"\n\t                      min={0}\n\t                      max={10}\n\t                      step={1}\n\t                      value={selectedEvent.importance ?? 5}\n\t                      onChange={(e) => commitEvent({ ...selectedEvent, importance: Number(e.target.value) })}\n\t                      aria-label=\"Importance\"\n\t                    />\n\t                    <span className=\"detailRangeValue\">{selectedEvent.importance ?? '\u2014'}</span>\n\t                    <button\n\t                      className=\"detailRangeClear\"\n\t                      type=\"button\"\n\t                      onClick={() => commitEvent({ ...selectedEvent, importance: null })}\n\t                      disabled={selectedEvent.importance == null}\n\t                      aria-label=\"Clear importance\">\n\t                      \u00d7\n\t                    </button>\n\t                  </div>\n\t                </label>\n                <label>\n                  Difficulty / Energy\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={selectedEvent.difficulty ?? 5}\n                      onChange={(e) => commitEvent({ ...selectedEvent, difficulty: Number(e.target.value) })}\n                      aria-label=\"Difficulty / Energy\"\n                    />\n                    <span className=\"detailRangeValue\">{selectedEvent.difficulty ?? '\u2014'}</span>\n                    <button\n                      className=\"detailRangeClear\"\n                      type=\"button\"\n                      onClick={() => commitEvent({ ...selectedEvent, difficulty: null })}\n                      disabled={selectedEvent.difficulty == null}\n                      aria-label=\"Clear difficulty or energy\">\n                      \u00d7\n                    </button>\n                  </div>\n                </label>\n              </div>\n                </>\n              )}\n            </div>\n          </div>\n        ) : selection.kind === 'capture' && selectedCapture ? (\n          <div className=\"detailsBody\">\n            <div className=\"detailCard\">\n              <div className=\"detailTitle\">Capture</div>\n              <div className=\"detailMeta\">{new Date(selectedCapture.createdAt).toLocaleString()}</div>\n              <div className=\"detailText\">{selectedCapture.rawText}</div>\n              <div className=\"detailActions\">\n                <button className=\"secondaryButton\" onClick={() => openView('assistant')}>\n                  Ask about this\n                </button>\n                <button\n                  className=\"secondaryButton\"\n                  onClick={() => {\n                    setCaptureDraft(selectedCapture.rawText)\n                    openCapture()\n                  }}>\n                  Restore to editor\n                </button>\n                <button\n                  className=\"secondaryButton\"\n                  onClick={() => {\n                    const titles = extractTaskLines(selectedCapture.rawText)\n                    if (titles.length === 0) {\n                      alert('No tasks found. Use lines like: \"- [ ] pick up dry cleaning\"')\n                      return\n                    }\n                    for (const t of titles) onCreateTaskFromInput({ title: t })\n                    alert(`Created ${titles.length} task(s) from this note.`)\n                  }}>\n                  Extract tasks\n                </button>\n                <button\n                  className=\"secondaryButton\"\n                  onClick={() => {\n                    void (async () => {\n                      const result = await createTrackerLogsFromText({\n                        text: selectedCapture.rawText,\n                        atMs: selectedCapture.createdAt,\n                        sourceNoteId: selectedCapture.id,\n                        events,\n                        ensureTrackerDefinition,\n                        defaultTrackerUnit,\n                        findBestActiveEventAt,\n                        createEvent,\n                        setEvents,\n                      })\n                      if (result.created === 0) {\n                        alert('No trackers found. Try \u201cmood 7/10\u201d, \u201cenergy 6\u201d, or \u201cI feel great\u201d.')\n                      } else {\n                        alert(`Created ${result.created} tracker log(s) from this note.`)\n                      }\n                    })()\n                  }}>\n                  Extract trackers\n                </button>\n              </div>\n            </div>\n          </div>\n        ) : null}\n\t        </motion.aside>\n\t      )}\n                              </AnimatePresence>\n                              </main>      <button\n        className=\"captureFab\"\n        onClick={() => {\n          openCapture()\n        }}\n        aria-label=\"Capture\">\n        <Icon name=\"plus\" size={18} />\n      </button>\n\n      {rightCollapsed && !(active?.view && rightPanelHideViews.has(active.view)) ? (\n        <button className=\"rightExpand\" onClick={() => setRightCollapsed(false)} aria-label=\"Show details\">\n          <Icon name=\"panelRight\" />\n        </button>\n      ) : null}\n\n      <AnimatePresence>\n      {eventComposerOpen ? (\n        <motion.div\n          className=\"modalOverlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          transition={{ duration: 0.16, ease: 'easeOut' }}\n          onMouseDown={(e) => {\n            if (e.target === e.currentTarget) setEventComposerOpen(false)\n          }}>\n          <motion.div\n            className=\"modalCard\"\n            initial={{ y: 12, opacity: 0, scale: 0.98 }}\n            animate={{ y: 0, opacity: 1, scale: 1 }}\n            exit={{ y: 12, opacity: 0, scale: 0.98 }}\n            transition={{ duration: 0.18, ease: 'easeOut' }}>\n            <div className=\"modalHeader\">\n              <div>\n                <div className=\"modalTitle\">New event</div>\n                <div className=\"modalSub\">Title + time + tags + people/places + estimate (MVP).</div>\n              </div>\n              <div className=\"modalHeaderActions\">\n                <button className=\"secondaryButton modalMagic\" onClick={() => startComposerTranscription()}>\n                  <Icon name=\"mic\" size={14} />\n                  Magic\n                </button>\n                <button className=\"secondaryButton\" onClick={() => autoFillComposerFromText()}>\n                  Auto-fill\n                </button>\n                <button className=\"modalClose\" onClick={() => setEventComposerOpen(false)} aria-label=\"Close\">\n                  <Icon name=\"x\" />\n                </button>\n              </div>\n            </div>\n            <div className=\"eventBody\">\n              <div className=\"eventTitleRow\">\n                <input\n                  className=\"eventTitleInput\"\n                  value={eventComposer.title}\n                  onChange={(e) => setEventComposer((p) => ({ ...p, title: e.target.value }))}\n                  placeholder=\"Dinner with @Mom\"\n                  autoFocus\n                />\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Start\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(eventComposer.startAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      setEventComposer((p) => {\n                        const dur = Math.max(5 * 60 * 1000, p.endAt - p.startAt)\n                        const startAt = ms\n                        const endAt = startAt + dur\n                        return { ...p, startAt, endAt, estimateMinutesRaw: p.estimateMinutesRaw || estimateMinutesFromRange(startAt, endAt) }\n                      })\n                    }}\n                  />\n                </label>\n                <label>\n                  End\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(eventComposer.endAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      setEventComposer((p) => ({ ...p, endAt: Math.max(ms, p.startAt + 5 * 60 * 1000), estimateMinutesRaw: p.estimateMinutesRaw }))\n                    }}\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Kind\n                  <select\n                    className=\"detailSmall\"\n                    value={eventComposer.kind}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, kind: e.target.value as any }))}>\n                    <option value=\"event\">Event</option>\n                    <option value=\"task\">Task block</option>\n                    <option value=\"log\">Log</option>\n                    <option value=\"episode\">Episode (multi-day)</option>\n                  </select>\n                </label>\n                <label>\n                  Estimate (min)\n                  <input\n                    className=\"detailSmall\"\n                    value={eventComposer.estimateMinutesRaw}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, estimateMinutesRaw: e.target.value }))}\n                    placeholder=\"60\"\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label className=\"eventCheck\">\n                  <input\n                    type=\"checkbox\"\n                    checked={eventComposer.allDay || eventComposer.kind === 'episode'}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, allDay: e.target.checked }))}\n                  />\n                  All-day\n                </label>\n                <label className=\"eventCheck\">\n                  <input type=\"checkbox\" checked={eventComposer.active} onChange={(e) => setEventComposer((p) => ({ ...p, active: e.target.checked }))} />\n                  Active (running)\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Icon\n                  <div className=\"detailIconSelect\">\n                    <select\n                      className=\"detailSmall\"\n                      value={eventComposer.icon ?? ''}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, icon: e.target.value || null }))}>\n                      <option value=\"\">Auto</option>\n                      {EVENT_ICON_OPTIONS.map((o) => (\n                        <option key={o.value} value={o.value}>\n                          {o.label}\n                        </option>\n                      ))}\n                    </select>\n                    <span className=\"detailIconPreview\">\n                      <Icon name={eventComposer.icon ? (eventComposer.icon as any) : 'calendar'} size={14} />\n                    </span>\n                  </div>\n                </label>\n                <label>\n                  Color\n                  <div className=\"detailColorRow\">\n                    <input\n                      className=\"detailColorInput\"\n                      type=\"color\"\n                      value={eventComposer.color ?? '#7c3aed'}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, color: e.target.value }))}\n                    />\n                    <button className=\"detailColorAuto\" onClick={() => setEventComposer((p) => ({ ...p, color: null }))}>\n                      Auto\n                    </button>\n                  </div>\n                </label>\n              </div>\n\t              <div className=\"eventGrid\">\n\t                <label>\n\t                  Tags\n\t                  <div className=\"detailChips\">\n\t                    {composerTagList.map((t) => (\n\t                      <button\n\t                        key={t}\n\t                        className=\"detailChip\"\n\t                        onClick={() => {\n\t                          const next = composerTagList.filter((x) => x !== t)\n\t                          setEventComposer((p) => ({ ...p, tagsRaw: next.join(' ') }))\n\t                        }}\n\t                        type=\"button\">\n\t                        {t}\n\t                        <span className=\"detailChipRemove\">\u00d7</span>\n\t                      </button>\n\t                    ))}\n\t                    <input\n\t                      className=\"detailChipInput\"\n\t                      value={composerTagDraft}\n\t                      onChange={(e) => setComposerTagDraft(e.target.value)}\n\t                      onKeyDown={(e) => {\n\t                        if (e.key !== 'Enter' && e.key !== ',' && e.key !== ' ') return\n\t                        e.preventDefault()\n\t                        const next = parseTags(composerTagDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerTagList, ...next].map(normalizeHashTag).filter(Boolean))\n\t                        setEventComposer((p) => ({ ...p, tagsRaw: merged.join(' ') }))\n\t                        setComposerTagDraft('')\n\t                      }}\n\t                      onBlur={() => {\n\t                        const next = parseTags(composerTagDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerTagList, ...next].map(normalizeHashTag).filter(Boolean))\n\t                        setEventComposer((p) => ({ ...p, tagsRaw: merged.join(' ') }))\n\t                        setComposerTagDraft('')\n\t                      }}\n\t                      placeholder=\"#work #health\"\n\t                    />\n\t                  </div>\n\t                </label>\n\t                <label>\n\t                  Location\n\t                  <div className=\"detailChips\">\n\t                    {composerLocationList.map((loc) => (\n\t                      <button\n\t                        key={loc}\n\t                        className=\"detailChip\"\n\t                        onClick={() => {\n\t                          const next = composerLocationList.filter((x) => x !== loc)\n\t                          setEventComposer((p) => ({ ...p, location: next.join(', ') }))\n\t                        }}\n\t                        type=\"button\">\n\t                        {loc}\n\t                        <span className=\"detailChipRemove\">\u00d7</span>\n\t                      </button>\n\t                    ))}\n\t                    <input\n\t                      className=\"detailChipInput\"\n\t                      value={composerLocationDraft}\n\t                      onChange={(e) => setComposerLocationDraft(e.target.value)}\n\t                      onKeyDown={(e) => {\n\t                        if (e.key !== 'Enter' && e.key !== ',') return\n\t                        e.preventDefault()\n\t                        const next = parseCommaList(composerLocationDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerLocationList, ...next])\n\t                        setEventComposer((p) => ({ ...p, location: merged.join(', ') }))\n\t                        setComposerLocationDraft('')\n\t                      }}\n\t                      onBlur={() => {\n\t                        const next = parseCommaList(composerLocationDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerLocationList, ...next])\n\t                        setEventComposer((p) => ({ ...p, location: merged.join(', ') }))\n\t                        setComposerLocationDraft('')\n\t                      }}\n\t                      placeholder=\"Home\"\n\t                    />\n\t                  </div>\n\t                </label>\n\t              </div>\n\t              <div className=\"eventGrid\">\n\t                <label>\n\t                  Category\n\t                  <input\n\t                    className=\"detailSmall\"\n\t                    list=\"taxCatList\"\n\t                    value={eventComposer.category}\n\t                    onChange={(e) => setEventComposer((p) => ({ ...p, category: e.target.value }))}\n\t                    placeholder=\"Work / Health / Study\"\n\t                  />\n\t                </label>\n                <label>\n                  Subcategory\n                  <input\n                    className=\"detailSmall\"\n                    list=\"taxSubcatList\"\n                    value={eventComposer.subcategory}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, subcategory: e.target.value }))}\n                    placeholder=\"Clinic / Surgery / Gym\"\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Importance\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={eventComposer.importance ?? 5}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, importance: Number(e.target.value) }))}\n                      aria-label=\"Importance\"\n                    />\n                    <span className=\"detailRangeValue\">{eventComposer.importance ?? 5}</span>\n                  </div>\n                </label>\n                <label>\n                  Difficulty / Energy\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={eventComposer.difficulty ?? 5}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, difficulty: Number(e.target.value) }))}\n                      aria-label=\"Difficulty / Energy\"\n                    />\n                    <span className=\"detailRangeValue\">{eventComposer.difficulty ?? 5}</span>\n                  </div>\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  People\n                  <div className=\"detailChips\">\n                    {composerPeopleList.map((p) => (\n                      <button\n                        key={p}\n                        className=\"detailChip\"\n                        onClick={() => {\n                          const next = composerPeopleList.filter((x) => x !== p)\n                          setEventComposer((prev) => ({ ...prev, peopleRaw: next.join(', ') }))\n                        }}\n                        type=\"button\">\n                        {p}\n                        <span className=\"detailChipRemove\">\u00d7</span>\n                      </button>\n                    ))}\n                    <input\n                      className=\"detailChipInput\"\n                      value={composerPeopleDraft}\n                      onChange={(e) => setComposerPeopleDraft(e.target.value)}\n                      onKeyDown={(e) => {\n                        if (e.key !== 'Enter' && e.key !== ',') return\n                        e.preventDefault()\n                        const next = parseCommaList(composerPeopleDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...composerPeopleList, ...next])\n                        setEventComposer((prev) => ({ ...prev, peopleRaw: merged.join(', ') }))\n                        setComposerPeopleDraft('')\n                      }}\n                      onBlur={() => {\n                        const next = parseCommaList(composerPeopleDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...composerPeopleList, ...next])\n                        setEventComposer((prev) => ({ ...prev, peopleRaw: merged.join(', ') }))\n                        setComposerPeopleDraft('')\n                      }}\n                      placeholder=\"Mom, Alex\"\n                    />\n                  </div>\n                </label>\n                <label>\n                  Tracker key (optional)\n                  <input\n                    className=\"detailSmall\"\n                    value={eventComposer.trackerKey}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, trackerKey: e.target.value }))}\n                    placeholder=\"workout / pain / mood\"\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Skills\n                  <input\n                    className=\"detailSmall\"\n                    value={eventComposer.skillsRaw}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, skillsRaw: e.target.value }))}\n                    placeholder=\"communication, lifting\"\n                  />\n                </label>\n\t              <label>\n\t                Character\n\t                <div className=\"charGrid\" role=\"group\" aria-label=\"Character stats\">\n\t                  {CHARACTER_KEYS.map((k) => {\n\t                    const selected = normalizeCharacterSelection(eventComposer.character).includes(k)\n\t                    return (\n\t                      <button\n\t                        key={k}\n\t                        className={selected ? 'charChip active' : 'charChip'}\n\t                        onClick={() => setEventComposer((p) => ({ ...p, character: toggleCharacterSelection(p.character, k) }))}\n\t                        type=\"button\"\n\t                        aria-label={selected ? `Remove ${k}` : `Add ${k}`}>\n\t                        {k}\n\t                      </button>\n\t                    )\n\t                  })}\n\t                </div>\n\t              </label>\n\t            </div>\n              <div className=\"eventNotes\">\n                <div className=\"eventNotesHeader\">\n                  <span>Notes</span>\n                  <button className=\"detailInlineBtn\" onClick={() => startComposerTranscription()} type=\"button\">\n                    <Icon name=\"mic\" size={12} />\n                    {composerListening ? 'Listening\u2026' : 'Transcribe'}\n                  </button>\n                </div>\n                <textarea\n                  className=\"eventNotesArea\"\n                  value={eventComposer.notes}\n                  onChange={(e) => setEventComposer((p) => ({ ...p, notes: e.target.value }))}\n                  placeholder=\"Segments: use **HH:MM** - label (e.g., **13:00** - Clinic)\u2026\"\n                  aria-label=\"Event notes\"\n                />\n                {composerInterim ? <div className=\"capInterim\">\u2026 {composerInterim}</div> : null}\n              </div>\n            </div>\n            <div className=\"modalActions\">\n              <button className=\"secondaryButton\" onClick={() => setEventComposerOpen(false)}>\n                Cancel\n              </button>\n              <div className=\"modalSpacer\" />\n              <button\n                className=\"primaryButton\"\n                disabled={eventComposer.title.trim().length === 0}\n                onClick={() => {\n                  const title = eventComposer.title.trim()\n                  const kind = eventComposer.kind\n\t\t                  const tags = parseTags(eventComposer.tagsRaw)\n\t\t                  const people = parseCommaList(eventComposer.peopleRaw)\n\t\t                  const skills = parseCommaList(eventComposer.skillsRaw)\n\t\t                  const character = normalizeCharacterSelection(eventComposer.character)\n\t\t                  const estimateMinutesInput = numberOrNull(eventComposer.estimateMinutesRaw)\n\t\t                  const category = eventComposer.category.trim() ? eventComposer.category.trim() : null\n\t\t                  const subcategory = eventComposer.subcategory.trim() ? eventComposer.subcategory.trim() : null\n\t\t                  const importance = eventComposer.importance\n\t\t                  const difficulty = eventComposer.difficulty\n\n                  let startAt = eventComposer.startAt\n                  let endAt = Math.max(eventComposer.endAt, startAt + 5 * 60 * 1000)\n\n                  const allDay = eventComposer.allDay || kind === 'episode'\n                  if (allDay) {\n                    const s = new Date(startAt)\n                    s.setHours(0, 0, 0, 0)\n                    const e = new Date(endAt)\n                    e.setHours(0, 0, 0, 0)\n                    startAt = s.getTime()\n                    endAt = Math.max(e.getTime() + 24 * 60 * 60 * 1000, startAt + 24 * 60 * 60 * 1000)\n                  }\n\n                  const estimateMinutes =\n                    estimateMinutesInput ?? (allDay ? null : Math.round(Math.max(5 * 60 * 1000, endAt - startAt) / (60 * 1000)))\n\n\t                  onCreateEvent({\n\t                    title,\n\t                    startAt,\n\t                    endAt,\n\t                    kind,\n\t                    taskId: eventComposer.taskId || null,\n\t                    allDay,\n\t                    active: eventComposer.active,\n\t                    tags,\n\t                    notes: eventComposer.notes || null,\n\t                    icon: eventComposer.icon || null,\n\t                    color: eventComposer.color || null,\n\t                    estimateMinutes,\n\t                    location: eventComposer.location.trim() ? eventComposer.location.trim() : null,\n\t                    people,\n\t                    skills,\n\t                    character,\n\t                    category,\n\t                    subcategory,\n\t                    importance,\n\t                    difficulty,\n\t                    trackerKey: eventComposer.trackerKey.trim() ? eventComposer.trackerKey.trim() : null,\n\t                  })\n                  setEventComposerOpen(false)\n                }}>\n                Create\n              </button>\n            </div>\n          </motion.div>\n        </motion.div>\n      ) : null}\n      </AnimatePresence>\n\n      <CaptureModal\n        isOpen={captureOpen}\n        onClose={() => {\n          stopVoiceCapture()\n          setCaptureOpen(false)\n        }}\n        draft={captureDraft}\n        setDraft={setCaptureDraft}\n        isListening={captureListening}\n        onToggleListening={() => toggleVoiceCapture()}\n        interimTranscript={captureInterim}\n        isSaving={captureSaving}\n        onSave={onSaveCapture}\n        aiStatus={captureAiStatus}\n        error={captureError}\n        progress={captureProgress}\n        attachEventId={captureAttachEventId}\n        onDetachEvent={() => setCaptureAttachEventId(null)}\n        attachedEventTitle={captureAttachEventId ? events.find((e) => e.id === captureAttachEventId)?.title ?? 'Event' : null}\n        habitNames={habitDefs.map((h) => h.name).filter(Boolean)}\n        extendedMode={captureExtendedMode}\n        onToggleExtendedMode={() => setCaptureExtendedMode(!captureExtendedMode)}\n        anchorMs={captureAnchorMs}\n      />\n        \n              <AnimatePresence>\n              {docOpen ? (\t        <motion.div\n\t          className=\"modalOverlay docOverlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          transition={{ duration: 0.16, ease: 'easeOut' }}\n          onMouseDown={(e) => {\n            if (e.target === e.currentTarget) setDocOpen(false)\n          }}>\n          <motion.div\n            className=\"docCard\"\n            initial={{ y: 12, opacity: 0, scale: 0.98 }}\n            animate={{ y: 0, opacity: 1, scale: 1 }}\n            exit={{ y: 12, opacity: 0, scale: 0.98 }}\n            transition={{ duration: 0.18, ease: 'easeOut' }}>\n            <div className=\"modalHeader\">\n              <div>\n                <div className=\"modalTitle\">Page</div>\n              </div>\n              <button className=\"modalClose\" onClick={() => setDocOpen(false)} aria-label=\"Close\">\n                <Icon name=\"x\" />\n              </button>\n            </div>\n            <div className=\"docGrid\">\n              <div className=\"docBody\">\n                {selection.kind === 'task' && selectedTask ? (\n                  <>\n                    <div className=\"docTitleRow\">\n                      <input\n                        className=\"docTitleInput\"\n                        value={selectedTask.title}\n                        onChange={(e) => commitTask({ ...selectedTask, title: e.target.value })}\n                      />\n                      <button className=\"docMagicBtn\" type=\"button\">\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                    </div>\n                    <div className=\"docTabsRow\">\n                      <div className=\"docTabs\">\n                        <button\n                          className={docTab === 'notes' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('notes')}>\n                          Notes\n                        </button>\n                        <button\n                          className={docTab === 'transcript' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('transcript')}>\n                          Transcript\n                        </button>\n                      </div>\n                    </div>\n                    {docTab === 'notes' ? (\n                      <MarkdownEditor\n                        value={selectedTask.notes ?? ''}\n                        onChange={(next) => commitTask({ ...selectedTask, notes: next })}\n                        onToggleChecklist={(lineIndex) => onToggleTaskChecklistItem(selectedTask.id, lineIndex)}\n                        placeholder=\"Write markdown notes\u2026\"\n                        ariaLabel=\"Task notes (markdown)\"\n                      />\n                    ) : (\n                      <div className=\"docTranscriptPanel\">\n                        <div className=\"docTranscriptChips\">\n                          {docTranscriptLines.length ? (\n                            docTranscriptLines.map((line, index) => (\n                              <button\n                                key={`${line.time}-${index}`}\n                                className={docTranscriptFocus === line.time ? 'docTranscriptChip active' : 'docTranscriptChip'}\n                                type=\"button\"\n                                onClick={() => setDocTranscriptFocus(line.time)}\n                                title={line.text}>\n                                {line.time}\n                              </button>\n                            ))\n                          ) : (\n                            <div className=\"docTranscriptEmpty\">No timestamped lines yet.</div>\n                          )}\n                        </div>\n                        <div className=\"docTranscriptBox\">\n                          <textarea\n                            className=\"docTranscriptTextarea\"\n                            value={selectedTask.notes ?? ''}\n                            onChange={(e) => commitTask({ ...selectedTask, notes: e.target.value })}\n                            placeholder=\"Paste raw transcript with [HH:MM] timestamps\u2026\"\n                          />\n                        </div>\n                      </div>\n                    )}\n                  </>\n                ) : selection.kind === 'event' && selectedEvent ? (\n                  <>\n                    <div className=\"docTitleRow\">\n                      <input\n                        className=\"docTitleInput\"\n                        value={selectedEvent.title}\n                        onChange={(e) => commitEvent({ ...selectedEvent, title: e.target.value })}\n                      />\n                      <button className=\"docMagicBtn\" type=\"button\">\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                    </div>\n                    <div className=\"docTabsRow\">\n                      <div className=\"docTabs\">\n                        <button\n                          className={docTab === 'notes' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('notes')}>\n                          Notes\n                        </button>\n                        <button\n                          className={docTab === 'transcript' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('transcript')}>\n                          Transcript\n                        </button>\n                      </div>\n                    </div>\n                    {docTab === 'notes' ? (\n                      <MarkdownEditor\n                        value={selectedEvent.notes ?? ''}\n                        onChange={(next) => commitEvent({ ...selectedEvent, notes: next })}\n                        onToggleChecklist={(lineIndex) => {\n                          if (selectedEvent.kind === 'task' && selectedEvent.taskId) {\n                            onToggleTaskChecklistItem(selectedEvent.taskId, lineIndex)\n                            return\n                          }\n                          void onToggleEventNoteChecklist(selectedEvent, lineIndex)\n                        }}\n                        onStartTask={(task) => onStartNoteTask(selectedEvent.id, task)}\n                        taskStateByToken={selectedEventNoteTasks}\n                        nowMs={nowTick}\n                        placeholder=\"Write markdown notes\u2026\"\n                        ariaLabel=\"Event notes (markdown)\"\n                      />\n                    ) : (\n                      <div className=\"docTranscriptPanel\">\n                        <div className=\"docTranscriptChips\">\n                          {docTranscriptLines.length ? (\n                            docTranscriptLines.map((line, index) => (\n                              <button\n                                key={`${line.time}-${index}`}\n                                className={docTranscriptFocus === line.time ? 'docTranscriptChip active' : 'docTranscriptChip'}\n                                type=\"button\"\n                                onClick={() => setDocTranscriptFocus(line.time)}\n                                title={line.text}>\n                                {line.time}\n                              </button>\n                            ))\n                          ) : (\n                            <div className=\"docTranscriptEmpty\">No timestamped lines yet.</div>\n                          )}\n                        </div>\n                        <div className=\"docTranscriptBox\">\n                          <textarea\n                            className=\"docTranscriptTextarea\"\n                            value={selectedEvent.notes ?? ''}\n                            onChange={(e) => commitEvent({ ...selectedEvent, notes: e.target.value })}\n                            placeholder=\"Paste raw transcript with [HH:MM] timestamps\u2026\"\n                          />\n                        </div>\n                      </div>\n                    )}\n                  </>\n                ) : selection.kind === 'capture' && selectedCapture ? (\n                  <>\n                    <div className=\"docTitleRow\">\n                      <input className=\"docTitleInput\" value=\"Inbox note\" readOnly />\n                      <button className=\"docMagicBtn\" type=\"button\">\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                    </div>\n                    <div className=\"docTabsRow\">\n                      <div className=\"docTabs\">\n                        <button className=\"docTab active\" type=\"button\">\n                          Transcript\n                        </button>\n                      </div>\n                    </div>\n                    <div className=\"docTranscriptPanel\">\n                      <div className=\"docTranscriptChips\">\n                        {docTranscriptLines.length ? (\n                          docTranscriptLines.map((line, index) => (\n                            <button\n                              key={`${line.time}-${index}`}\n                              className={docTranscriptFocus === line.time ? 'docTranscriptChip active' : 'docTranscriptChip'}\n                              type=\"button\"\n                              onClick={() => setDocTranscriptFocus(line.time)}\n                              title={line.text}>\n                              {line.time}\n                            </button>\n                          ))\n                        ) : (\n                          <div className=\"docTranscriptEmpty\">No timestamped lines yet.</div>\n                        )}\n                      </div>\n                      <div className=\"docTranscriptBox\">\n                        <textarea\n                          className=\"docTranscriptTextarea\"\n                          value={selectedCapture.rawText}\n                          onChange={(e) => {\n                            void onUpdateCapture(selectedCapture.id, e.target.value)\n                          }}\n                          placeholder=\"Paste raw transcript with [HH:MM] timestamps\u2026\"\n                        />\n                      </div>\n                    </div>\n                  </>\n                ) : (\n                  <div className=\"docEmpty\">Select a task, event, or capture to open as a page.</div>\n                )}\n              </div>\n              <div className=\"docProps\">\n                <div className=\"docPropsTitle\">Properties</div>\n                {selection.kind === 'task' && selectedTask ? (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"detailRow\">\n                      <label className=\"detailLabel\">\n                        Tags\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTaskTags.join(' ')}\n                          onChange={(e) => commitTask({ ...selectedTask, tags: parseTags(e.target.value) })}\n                          placeholder=\"#work #health\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Context</div>\n                      <div className=\"detailChips\">\n                        {selectedTaskContexts.map((ctx) => (\n                          <button\n                            key={ctx}\n                            className=\"detailChip\"\n                            onClick={() =>\n                              commitTask({ ...selectedTask, contexts: selectedTaskContexts.filter((x) => x !== ctx) })\n                            }\n                            type=\"button\">\n                            {formatContextLabel(ctx)}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={contextDraft}\n                          onChange={(e) => setContextDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitTask({ ...selectedTask, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitTask({ ...selectedTask, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          placeholder=\"at computer, at email\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Due\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedTask.dueAt)}\n                          onChange={(e) => commitTask({ ...selectedTask, dueAt: fromLocalDateTimeInput(e.target.value) })}\n                        />\n                      </label>\n                      <label>\n                        Scheduled\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedTask.scheduledAt)}\n                          onChange={(e) => commitTask({ ...selectedTask, scheduledAt: fromLocalDateTimeInput(e.target.value) })}\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Goal\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTask.goal ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, goal: e.target.value || null })}\n                          placeholder=\"get shredded\"\n                        />\n                      </label>\n                      <label>\n                        Project\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTask.project ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, project: e.target.value || null })}\n                          placeholder=\"workout plan\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Category\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxCatList\"\n                          value={selectedTask.category ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, category: e.target.value || null })}\n                          placeholder=\"Work / Health / Study\"\n                        />\n                      </label>\n                      <label>\n                        Subcategory\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxSubcatList\"\n                          value={selectedTask.subcategory ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, subcategory: e.target.value || null })}\n                          placeholder=\"Clinic / Surgery / Gym\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Category shortcuts</div>\n                      <div className=\"detailChips\">\n                        {taxonomyCategories.slice(0, 12).map((c) => (\n                          <button\n                            key={c}\n                            className={selectedTask.category?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                            onClick={() => commitTask({ ...selectedTask, category: c })}\n                            type=\"button\">\n                            {c}\n                          </button>\n                        ))}\n                      </div>\n                    </div>\n                    {taxonomySubcategories.length ? (\n                      <div className=\"detailRow\">\n                        <div className=\"detailLabel\">Subcategory shortcuts</div>\n                        <div className=\"detailChips\">\n                          {taxonomySubcategories.slice(0, 12).map((c) => (\n                            <button\n                              key={c}\n                              className={selectedTask.subcategory?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                              onClick={() => commitTask({ ...selectedTask, subcategory: c })}\n                              type=\"button\">\n                              {c}\n                            </button>\n                          ))}\n                        </div>\n                      </div>\n                    ) : null}\n                    <div className=\"detailGrid\">\n                      <label>\n                        Importance\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedTask.importance ?? 5}\n                            onChange={(e) => commitTask({ ...selectedTask, importance: Number(e.target.value) })}\n                            aria-label=\"Importance\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedTask.importance ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitTask({ ...selectedTask, importance: null })}\n                            disabled={selectedTask.importance == null}\n                            aria-label=\"Clear importance\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                      <label>\n                        Difficulty / Energy\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedTask.difficulty ?? 5}\n                            onChange={(e) => commitTask({ ...selectedTask, difficulty: Number(e.target.value) })}\n                            aria-label=\"Difficulty / Energy\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedTask.difficulty ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitTask({ ...selectedTask, difficulty: null })}\n                            disabled={selectedTask.difficulty == null}\n                            aria-label=\"Clear difficulty or energy\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                      <label>\n                        Estimate (min)\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTask.estimateMinutes ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, estimateMinutes: numberOrNull(e.target.value) })}\n                          placeholder=\"25\"\n                        />\n                      </label>\n                    </div>\n                  </div>\n                ) : selection.kind === 'event' && selectedEvent ? (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"detailGrid\">\n                      <label>\n                        Start\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedEvent.startAt)}\n                          onChange={(e) => {\n                            const ms = fromLocalDateTimeInput(e.target.value)\n                            if (!ms) return\n                            const dur = Math.max(5 * 60 * 1000, selectedEvent.endAt - selectedEvent.startAt)\n                            commitEvent({ ...selectedEvent, startAt: ms, endAt: ms + dur })\n                          }}\n                        />\n                      </label>\n                      <label>\n                        End\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedEvent.endAt)}\n                          onChange={(e) => {\n                            const ms = fromLocalDateTimeInput(e.target.value)\n                            if (!ms) return\n                            commitEvent({ ...selectedEvent, endAt: Math.max(ms, selectedEvent.startAt + 5 * 60 * 1000) })\n                          }}\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Icon\n                        <div className=\"detailIconSelect\">\n                          <select\n                            className=\"detailSmall\"\n                            value={selectedEvent.icon ?? ''}\n                            onChange={(e) => commitEvent({ ...selectedEvent, icon: e.target.value || null })}>\n                            <option value=\"\">Auto</option>\n                            {EVENT_ICON_OPTIONS.map((o) => (\n                              <option key={o.value} value={o.value}>\n                                {o.label}\n                              </option>\n                            ))}\n                          </select>\n                          <span className=\"detailIconPreview\">\n                            <Icon name={eventAccent(selectedEvent).icon} size={14} />\n                          </span>\n                        </div>\n                      </label>\n                      <label>\n                        Color\n                        <div className=\"detailColorRow\">\n                          <input\n                            className=\"detailColorInput\"\n                            type=\"color\"\n                            value={selectedEvent.color ?? eventAccent(selectedEvent).color}\n                            onChange={(e) => commitEvent({ ...selectedEvent, color: e.target.value })}\n                          />\n                          <button className=\"detailColorAuto\" onClick={() => commitEvent({ ...selectedEvent, color: null })}>\n                            Auto\n                          </button>\n                        </div>\n                        <div className=\"detailSwatches\">\n                          {EVENT_COLOR_PRESETS.slice(0, 9).map((c) => (\n                            <button\n                              key={c.hex}\n                              className={selectedEvent.color === c.hex ? 'detailSwatch active' : 'detailSwatch'}\n                              title={c.name}\n                              style={{ background: c.hex }}\n                              onClick={() => commitEvent({ ...selectedEvent, color: c.hex })}\n                            />\n                          ))}\n                        </div>\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Tags</div>\n                      <div className=\"detailChips\">\n                        {selectedEventTags.map((t) => (\n                          <button\n                            key={t}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, tags: selectedEventTags.filter((x) => x !== t) })}\n                            type=\"button\">\n                            {t}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={tagDraft}\n                          onChange={(e) => setTagDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',' && e.key !== ' ') return\n                            e.preventDefault()\n                            const next = parseTags(tagDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                            commitEvent({ ...selectedEvent, tags: merged })\n                            setTagDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseTags(tagDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                            commitEvent({ ...selectedEvent, tags: merged })\n                            setTagDraft('')\n                          }}\n                          placeholder=\"#work #meeting\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Context</div>\n                      <div className=\"detailChips\">\n                        {selectedEventContexts.map((ctx) => (\n                          <button\n                            key={ctx}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, contexts: selectedEventContexts.filter((x) => x !== ctx) })}\n                            type=\"button\">\n                            {formatContextLabel(ctx)}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={contextDraft}\n                          onChange={(e) => setContextDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitEvent({ ...selectedEvent, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitEvent({ ...selectedEvent, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          placeholder=\"at computer, at email\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Estimate (min)\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedEvent.estimateMinutes ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, estimateMinutes: numberOrNull(e.target.value) })}\n                          placeholder=\"30\"\n                        />\n                      </label>\n                      <label>\n                        Location\n                        <div className=\"detailChips\">\n                          {selectedEventLocations.map((loc) => (\n                            <button\n                              key={loc}\n                              className=\"detailChip\"\n                              onClick={() => {\n                                const next = selectedEventLocations.filter((x) => x !== loc)\n                                commitEvent({ ...selectedEvent, location: next.length ? next.join(', ') : null })\n                              }}\n                              type=\"button\">\n                              {loc}\n                              <span className=\"detailChipRemove\">\u00d7</span>\n                            </button>\n                          ))}\n                          <input\n                            className=\"detailChipInput\"\n                            value={locationDraft}\n                            onChange={(e) => setLocationDraft(e.target.value)}\n                            onKeyDown={(e) => {\n                              if (e.key !== 'Enter' && e.key !== ',') return\n                              e.preventDefault()\n                              const next = parseCommaList(locationDraft)\n                              if (!next.length) return\n                              const merged = uniqStrings([...selectedEventLocations, ...next])\n                              commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                              setLocationDraft('')\n                            }}\n                            onBlur={() => {\n                              const next = parseCommaList(locationDraft)\n                              if (!next.length) return\n                              const merged = uniqStrings([...selectedEventLocations, ...next])\n                              commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                              setLocationDraft('')\n                            }}\n                            placeholder=\"Home\"\n                          />\n                        </div>\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Points\n                        <div className=\"detailPoints\">\n                          <div className=\"detailPointsValue\">{selectedEventPoints.toFixed(1)}</div>\n                          <div className=\"detailPointsMeta\">\n                            {selectedEventBase} \u00d7 {formatMinutesSpan(selectedEventMinutes)} \u00f7 60 \u00d7 {selectedEventMult.toFixed(2)}\n                          </div>\n                        </div>\n                      </label>\n                      <label>\n                        Running\n                        <div className=\"detailPoints\">\n                          <div className=\"detailPointsValue\">{selectedEvent.active ? 'Active' : '\u2014'}</div>\n                          <div className=\"detailPointsMeta\">\n                            {selectedEvent.active ? `${formatMinutesSpan(selectedEventMinutes)} elapsed` : 'Not running'}\n                          </div>\n                        </div>\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">People</div>\n                      <div className=\"detailChips\">\n                        {selectedEventPeople.map((p) => (\n                          <button\n                            key={p}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, people: selectedEventPeople.filter((x) => x !== p) })}\n                            type=\"button\">\n                            {p}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={peopleDraft}\n                          onChange={(e) => setPeopleDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseCommaList(peopleDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventPeople, ...next])\n                            commitEvent({ ...selectedEvent, people: merged })\n                            setPeopleDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseCommaList(peopleDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventPeople, ...next])\n                            commitEvent({ ...selectedEvent, people: merged })\n                            setPeopleDraft('')\n                          }}\n                          placeholder=\"Mom, Alex\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Skills</div>\n                      <div className=\"detailChips\">\n                        {selectedEventSkills.map((skill) => (\n                          <button\n                            key={skill}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, skills: selectedEventSkills.filter((x) => x !== skill) })}\n                            type=\"button\">\n                            {skill}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={skillDraft}\n                          onChange={(e) => setSkillDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseCommaList(skillDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventSkills, ...next])\n                            commitEvent({ ...selectedEvent, skills: merged })\n                            setSkillDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseCommaList(skillDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventSkills, ...next])\n                            commitEvent({ ...selectedEvent, skills: merged })\n                            setSkillDraft('')\n                          }}\n                          placeholder=\"communication, lifting\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">\n                        Character\n                        <div className=\"charGrid\" role=\"group\" aria-label=\"Character stats\">\n                          {CHARACTER_KEYS.map((k) => {\n                            const selected = normalizeCharacterSelection(selectedEvent.character).includes(k)\n                            return (\n                              <button\n                                key={k}\n                                className={selected ? 'charChip active' : 'charChip'}\n                                onClick={() => commitEvent({ ...selectedEvent, character: toggleCharacterSelection(selectedEvent.character, k) })}\n                                type=\"button\"\n                                aria-label={selected ? `Remove ${k}` : `Add ${k}`}>\n                                {k}\n                              </button>\n                            )\n                          })}\n                        </div>\n                      </div>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Goal\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedEvent.goal ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, goal: e.target.value || null })}\n                          placeholder=\"get shredded\"\n                        />\n                      </label>\n                      <label>\n                        Project\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedEvent.project ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, project: e.target.value || null })}\n                          placeholder=\"workout plan\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Category\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxCatList\"\n                          value={selectedEvent.category ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, category: e.target.value || null })}\n                          placeholder=\"Work / Health / Study\"\n                        />\n                      </label>\n                      <label>\n                        Subcategory\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxSubcatList\"\n                          value={selectedEvent.subcategory ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, subcategory: e.target.value || null })}\n                          placeholder=\"Clinic / Surgery / Gym\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Category shortcuts</div>\n                      <div className=\"detailChips\">\n                        {taxonomyCategories.slice(0, 12).map((c) => (\n                          <button\n                            key={c}\n                            className={selectedEvent.category?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                            onClick={() => commitEvent({ ...selectedEvent, category: c })}\n                            type=\"button\">\n                            {c}\n                          </button>\n                        ))}\n                      </div>\n                    </div>\n                    {taxonomySubcategories.length ? (\n                      <div className=\"detailRow\">\n                        <div className=\"detailLabel\">Subcategory shortcuts</div>\n                        <div className=\"detailChips\">\n                          {taxonomySubcategories.slice(0, 12).map((c) => (\n                            <button\n                              key={c}\n                              className={selectedEvent.subcategory?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                              onClick={() => commitEvent({ ...selectedEvent, subcategory: c })}\n                              type=\"button\">\n                              {c}\n                            </button>\n                          ))}\n                        </div>\n                      </div>\n                    ) : null}\n                    <div className=\"detailGrid\">\n                      <label>\n                        Importance\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedEvent.importance ?? 5}\n                            onChange={(e) => commitEvent({ ...selectedEvent, importance: Number(e.target.value) })}\n                            aria-label=\"Importance\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedEvent.importance ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitEvent({ ...selectedEvent, importance: null })}\n                            disabled={selectedEvent.importance == null}\n                            aria-label=\"Clear importance\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                      <label>\n                        Difficulty / Energy\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedEvent.difficulty ?? 5}\n                            onChange={(e) => commitEvent({ ...selectedEvent, difficulty: Number(e.target.value) })}\n                            aria-label=\"Difficulty / Energy\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedEvent.difficulty ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitEvent({ ...selectedEvent, difficulty: null })}\n                            disabled={selectedEvent.difficulty == null}\n                            aria-label=\"Clear difficulty or energy\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                    </div>\n                  </div>\n                ) : selection.kind === 'capture' && selectedCapture ? (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Created</div>\n                      <div className=\"docPropValue\">{new Date(selectedCapture.createdAt).toLocaleString()}</div>\n                    </div>\n                  </div>\n                ) : (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"docPropValue\">Select something first.</div>\n                  </div>\n                )}\n              </div>\n            </div>\n          </motion.div>\n        </motion.div>\n\t      ) : null}\n\t      </AnimatePresence>\n\n\t      <datalist id=\"taxCatList\">\n\t        {taxonomyCategories.map((c) => (\n\t          <option key={c} value={c} />\n\t        ))}\n\t      </datalist>\n      <datalist id=\"taxSubcatList\">\n        {taxonomySubcategories.map((s) => (\n          <option key={s} value={s} />\n        ))}\n      </datalist>\n      {authReady && !authSession && !authDismissed ? (\n        <div className=\"authOverlay\">\n          <div className=\"authCard\">\n            <div className=\"authHeader\">\n              <div>\n                <div className=\"authTitle\">Sign in to sync</div>\n                <div className=\"authSubtitle\">Use the same account on web and iPhone.</div>\n              </div>\n              <button className=\"authDismiss\" type=\"button\" onClick={() => setAuthDismissed(true)}>\n                Not now\n              </button>\n            </div>\n            {!supabaseConfigured ? (\n              <div className=\"authError\">\n                Supabase is not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.\n              </div>\n            ) : (\n              <>\n                <div className=\"authField\">\n                  <label className=\"authLabel\" htmlFor=\"authEmail\">Email</label>\n                  <input\n                    id=\"authEmail\"\n                    type=\"email\"\n                    value={authEmail}\n                    onChange={(e) => setAuthEmail(e.target.value)}\n                    placeholder=\"you@example.com\"\n                  />\n                </div>\n                <div className=\"authField\">\n                  <label className=\"authLabel\" htmlFor=\"authPassword\">Password</label>\n                  <input\n                    id=\"authPassword\"\n                    type=\"password\"\n                    value={authPassword}\n                    onChange={(e) => setAuthPassword(e.target.value)}\n                    placeholder=\"password\"\n                  />\n                </div>\n                {authError ? <div className=\"authError\">{authError}</div> : null}\n                {authStatus ? <div className=\"authStatus\">{authStatus}</div> : null}\n                <div className=\"authActions\">\n                  <button className=\"primaryButton\" type=\"button\" onClick={handleAuthSubmit} disabled={authWorking}>\n                    {authWorking ? 'Working...' : authMode === 'signup' ? 'Create account' : 'Sign in'}\n                  </button>\n                  <button\n                    className=\"secondaryButton\"\n                    type=\"button\"\n                    onClick={() => setAuthMode(authMode === 'signin' ? 'signup' : 'signin')}\n                  >\n                    {authMode === 'signin' ? 'Create account' : 'Have an account? Sign in'}\n                  </button>\n                </div>\n              </>\n            )}\n          </div>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n\nexport default App\n",
        "timestamp": "2026-01-13T11:38:50.910359"
      },
      "worktree_state": {
        "content": "import './App.css'\nimport { useEffect, useMemo, useState, useRef, type DragEvent, useCallback, type SetStateAction } from 'react'\nimport { AnimatePresence, motion } from 'framer-motion'\nimport type { Session } from '@supabase/supabase-js'\nimport { Toaster, toast } from 'sonner'\n\nimport { addInboxCapture, listInboxCaptures, updateCaptureEntityIds, updateCaptureText, type InboxCapture } from './storage/inbox'\nimport { createTask, deleteTask, listTasks, startTask, upsertTask, type Task, type TaskStatus } from './storage/tasks'\nimport { createEvent, deleteEvent, findActiveByTrackerKey, findActiveEpisode, findBestActiveEventAt, listEvents, upsertEvent, type CalendarEvent } from './storage/calendar'\nimport { ensureEntity } from './storage/entities'\nimport { estimateCalories, parseWorkoutFromText, saveWorkout } from './storage/workouts'\nimport { estimateFoodNutrition, parseMealFromText, saveMeal } from './storage/nutrition'\nimport { emptySharedMeta, loadTrackerDefs, saveTrackerDefs, upsertTrackerDef, type TrackerDef } from './storage/ecosystem'\nimport { parseCaptureNatural, type ParsedEvent } from './nlp/natural'\nimport { parseCaptureWithBlocksLlm, type LlmParsedEvent } from './nlp/llm-parse'\nimport { estimateNutritionWithLlm } from './nlp/nutrition-estimate'\nimport { loadSettings } from './assistant/storage'\nimport { makeFoodItemId, type ExtendedMacros, type FoodItem } from './db/insight-db'\nimport { getSupabaseClient } from './supabase/client'\nimport { migrateLocalDataToSupabase, pullSupabaseToLocal } from './supabase/sync'\n\nimport { Icon, type IconName } from './ui/icons'\nimport { EVENT_COLOR_PRESETS, eventAccent } from './ui/event-visual'\nimport { DISPLAY_SETTINGS_CHANGED_EVENT, loadDisplaySettings, type EventTitleDetail } from './ui/display-settings'\nimport { applyTheme, loadThemePreference, resolveTheme, saveThemePreference, THEME_CHANGED_EVENT, type ThemePreference } from './ui/theme'\nimport { parseChecklistMarkdown, toggleChecklistLine } from './ui/checklist'\nimport { MarkdownEditor } from './ui/markdown-editor'\nimport { CaptureModal } from './ui/CaptureModal'\nimport { ActiveSessionBanner } from './ui/ActiveSessionBanner'\nimport { Pane, type WorkspaceTab, type WorkspaceViewKey } from './workspace/pane'\nimport { TickTickTasksView } from './workspace/views/ticktick-tasks'\nimport { AssistantView } from './workspace/views/assistant'\nimport { DashboardView } from './workspace/views/dashboard'\nimport { HealthDashboard } from './workspace/views/health'\nimport { PlaceholderView } from './workspace/views/placeholder'\nimport { TimelineView } from './workspace/views/timeline'\nimport { PlannerView } from './workspace/views/planner'\nimport { NotesView } from './workspace/views/notes'\nimport { SettingsView } from './workspace/views/settings'\nimport { RewardsView } from './workspace/views/rewards'\nimport { GoalsView } from './workspace/views/goals'\nimport { EcosystemView } from './workspace/views/ecosystem'\nimport { ProjectsView } from './workspace/views/projects'\nimport { TrackersView } from './workspace/views/trackers'\nimport { HabitsView } from './workspace/views/habits'\nimport { basePoints, multiplierFor, pointsForMinutes } from './scoring/points'\nimport { loadCustomTaxonomy, saveCustomTaxonomy } from './taxonomy/custom'\nimport { categoriesFromStarter, subcategoriesFromStarter } from './taxonomy/starter'\nimport { loadTaxonomyRules, TAXONOMY_RULES_CHANGED_EVENT, type TaxonomyRule } from './taxonomy/rules'\nimport { collectMarkdownTokens, extractInlineTokens, toTokenCollections } from './markdown/schema'\nimport { parseNoteItemMeta, type NoteItemKind } from './markdown/note-items'\n\ntype PaneState = {\n  tabs: WorkspaceTab[]\n  activeTabId: string\n}\n\ntype CreateEventSeed = {\n  startAt: number\n  endAt: number\n  kind?: CalendarEvent['kind']\n  taskId?: string | null\n}\n\ntype EventComposerDraft = {\n  title: string\n  startAt: number\n  endAt: number\n  kind: CalendarEvent['kind']\n  allDay: boolean\n  active: boolean\n  icon: string | null\n  color: string | null\n  tagsRaw: string\n  location: string\n  peopleRaw: string\n  skillsRaw: string\n  character: string[]\n  category: string\n  subcategory: string\n  importance: number | null\n  difficulty: number | null\n  estimateMinutesRaw: string\n  notes: string\n  taskId: string | null\n  trackerKey: string\n}\n\ntype HabitDef = {\n  id: string\n  name: string\n  category: string | null\n  subcategory: string | null\n  difficulty: number\n  importance: number\n  character: Array<'STR' | 'INT' | 'CON' | 'PER'>\n  skills: string[]\n  tags: string[]\n  contexts: string[]\n  people: string[]\n  location?: string | null\n  goal?: string | null\n  project?: string | null\n  estimateMinutes?: number | null\n  polarity?: 'positive' | 'negative' | 'both'\n  schedule?: string | null\n  targetPerWeek?: number | null\n  color?: string | null\n  icon?: string | null\n  isTimed?: boolean\n}\n\ntype Selection =\n  | { kind: 'none' }\n  | { kind: 'task'; id: string }\n  | { kind: 'event'; id: string }\n  | { kind: 'capture'; id: string }\n\nconst HABITS_UPDATED_EVENT = 'insight5.habits.updated'\nconst DND_HABIT = 'application/insight5-habit'\nconst DND_TRACKER = 'application/insight5-tracker'\nconst REPORTS_HABIT_ID_KEY = 'insight5.reports.habitId'\n\nfunction makeTabId(view: WorkspaceViewKey) {\n  return `tab_${view}_${Date.now()}_${Math.random().toString(16).slice(2)}`\n}\n\nfunction defaultTabTitle(view: WorkspaceViewKey) {\n  switch (view) {\n    case 'notes':\n      return 'Notes'\n    case 'reflections':\n      return 'Thoughts'\n    case 'tasks':\n      return 'Tasks'\n    case 'calendar':\n      return 'Day'\n    case 'dashboard':\n      return 'Life Tracker'\n    case 'assistant':\n      return 'Chat'\n    case 'habits':\n      return 'Habits'\n    case 'goals':\n      return 'Goals'\n    case 'goal-detail':\n      return 'Goal'\n    case 'ecosystem':\n      return 'Ecosystem'\n    case 'projects':\n      return 'Projects'\n    case 'trackers':\n      return 'Trackers'\n    case 'rewards':\n      return 'Rewards'\n    case 'reports':\n      return 'Reports'\n    case 'health':\n      return 'Health'\n    case 'timeline':\n      return 'Timeline'\n    case 'settings':\n      return 'Settings'\n    default:\n      return view\n  }\n}\n\nfunction clamp01(n: number) {\n  return Math.max(0, Math.min(1, n))\n}\n\nfunction numberOrNull(v: string) {\n  const n = Number(v)\n  return Number.isFinite(n) ? n : null\n}\n\nfunction toLocalDateTimeInput(ms: number | null | undefined) {\n  if (!ms) return ''\n  const d = new Date(ms)\n  const yyyy = d.getFullYear()\n  const mm = String(d.getMonth() + 1).padStart(2, '0')\n  const dd = String(d.getDate()).padStart(2, '0')\n  const hh = String(d.getHours()).padStart(2, '0')\n  const mi = String(d.getMinutes()).padStart(2, '0')\n  return `${yyyy}-${mm}-${dd}T${hh}:${mi}`\n}\n\nfunction fromLocalDateTimeInput(v: string) {\n  const ms = new Date(v).getTime()\n  return Number.isFinite(ms) ? ms : null\n}\n\nfunction estimateMinutesFromRange(startAt: number, endAt: number) {\n  const minutes = Math.round(Math.max(5 * 60 * 1000, endAt - startAt) / (60 * 1000))\n  return Number.isFinite(minutes) ? String(minutes) : ''\n}\n\nconst EVENT_ICON_OPTIONS: Array<{ value: IconName; label: string }> = [\n  { value: 'calendar', label: 'Calendar' },\n  { value: 'check', label: 'Task' },\n  { value: 'phone', label: 'Call' },\n  { value: 'food', label: 'Food' },\n  { value: 'cart', label: 'Shopping' },\n  { value: 'dumbbell', label: 'Workout' },\n  { value: 'tooth', label: 'Teeth' },\n  { value: 'briefcase', label: 'Work' },\n  { value: 'stethoscope', label: 'Clinic' },\n  { value: 'book', label: 'Study' },\n  { value: 'moonStar', label: 'Sleep' },\n  { value: 'pin', label: 'Location' },\n  { value: 'users', label: 'People' },\n]\n\nfunction toTitleCase(input: string) {\n  return input\n    .trim()\n    .split(/\\s+/)\n    .map((w) => (w ? w[0]!.toUpperCase() + w.slice(1).toLowerCase() : ''))\n    .join(' ')\n}\n\nfunction inferCategorySubcategoryLoose(title: string, tags: string[]) {\n  const t = title.toLowerCase()\n  const tagSet = new Set(tags.map((x) => x.replace(/^#/, '').toLowerCase()))\n  let category: string | null = null\n  let subcategory: string | null = null\n\n  for (const rawTag of tags) {\n    const cleaned = rawTag.replace(/^#/, '').trim()\n    if (!cleaned || !cleaned.includes('/')) continue\n    const [cat, sub] = cleaned.split('/', 2)\n    if (cat) category = toTitleCase(cat)\n    if (sub) subcategory = toTitleCase(sub)\n    break\n  }\n\n  if (!category && (tagSet.has('work') || /\\b(work|shift)\\b/.test(t))) category = 'Work'\n  if (tagSet.has('clinic') || /\\b(clinic|patients|rounds|inpatient)\\b/.test(t)) {\n    category = category ?? 'Work'\n    subcategory = subcategory ?? 'Clinic'\n  }\n  if (tagSet.has('meeting') || /\\b(meeting|conference|rounds)\\b/.test(t)) {\n    category = category ?? 'Work'\n    subcategory = subcategory ?? 'Meeting'\n  }\n  if (tagSet.has('study') || /\\b(study|lecture|reading)\\b/.test(t)) {\n    category = category ?? 'Learning'\n    subcategory = subcategory ?? (/\\b(read|reading)\\b/.test(t) ? 'Reading' : 'Practice')\n  }\n  if (tagSet.has('workout') || /\\b(workout|gym|lift|lifting|run|cardio|yoga|training)\\b/.test(t)) {\n    category = category ?? 'Health'\n    subcategory = subcategory ?? 'Workout'\n  }\n  if (tagSet.has('sleep') || /\\b(sleep|nap)\\b/.test(t)) {\n    category = category ?? 'Health'\n    subcategory = subcategory ?? 'Sleep'\n  }\n  if (tagSet.has('shopping') || /\\b(grocery|shopping|store|errand)\\b/.test(t)) {\n    category = category ?? 'Personal'\n    subcategory = subcategory ?? (/\\b(grocery|groceries)\\b/.test(t) ? 'Groceries' : 'Errands')\n  }\n  if (tagSet.has('morning') || /\\b(get ready|morning routine|prep|ready for work)\\b/.test(t)) {\n    category = category ?? 'Personal'\n    subcategory = subcategory ?? 'Morning Routine'\n  }\n  if (tagSet.has('food') || /\\b(dinner|lunch|breakfast|meal|restaurant|food)\\b/.test(t)) {\n    category = category ?? 'Food'\n    subcategory = subcategory ?? (/\\b(restaurant|dinner out|lunch out|eat out)\\b/.test(t) ? 'Restaurant' : 'Meal')\n  }\n  if (tagSet.has('walk') || /\\b(walk|stroll)\\b/.test(t)) {\n    category = category ?? 'Personal'\n    subcategory = subcategory ?? 'Health'\n  }\n  if (tagSet.has('transport') || /\\b(transport|drive|driving|commute|flight|fly|uber|lyft|train|bus|parking)\\b/.test(t)) {\n    category = category ?? 'Transport'\n    if (/\\b(flight|fly|airport)\\b/.test(t)) subcategory = subcategory ?? 'Flight'\n    else if (/\\b(train|bus|transit|subway)\\b/.test(t)) subcategory = subcategory ?? 'Transit'\n    else if (/\\b(parking)\\b/.test(t)) subcategory = subcategory ?? 'Parking'\n    else subcategory = subcategory ?? 'Driving'\n  }\n  if (tagSet.has('finance') || /\\b(bank|finance|mortgage|loan|bill|budget|expense)\\b/.test(t)) {\n    category = category ?? 'Finance'\n    subcategory = subcategory ?? (/\\b(bank)\\b/.test(t) ? 'Banking' : /\\b(bill|bills)\\b/.test(t) ? 'Bills' : 'Budget')\n  }\n\n  if (category) {\n    const canonical = categoriesFromStarter().find((c) => c.toLowerCase() === category!.toLowerCase())\n    if (canonical) category = canonical\n  }\n  if (category && subcategory) {\n    const subs = subcategoriesFromStarter(category)\n    const canonicalSub = subs.find((s) => s.toLowerCase() === subcategory!.toLowerCase())\n    if (canonicalSub) subcategory = canonicalSub\n  }\n\n  return { category, subcategory }\n}\n\nfunction normalizeHashTag(raw: string) {\n  const t = raw.trim()\n  if (!t) return ''\n  return t.startsWith('#') ? t : `#${t}`\n}\n\nfunction recordTaxonomyEntry(category: string | null, subcategory: string | null) {\n  if (!category) return\n  const next = loadCustomTaxonomy()\n  const idx = next.findIndex((c) => c.category.toLowerCase() === category.toLowerCase())\n  if (idx >= 0) {\n    const current = next[idx]!\n    const subs = new Set(current.subcategories.map((s) => s.trim()).filter(Boolean))\n    if (subcategory) subs.add(subcategory)\n    next[idx] = { category: current.category, subcategories: Array.from(subs) }\n  } else {\n    next.push({ category, subcategories: subcategory ? [subcategory] : [] })\n  }\n  saveCustomTaxonomy(next)\n}\n\nfunction loadHabitDefsFromStorage(): HabitDef[] {\n  try {\n    const raw = localStorage.getItem('insight5.habits.defs.v1')\n    if (!raw) return []\n    const parsed = JSON.parse(raw) as HabitDef[]\n    if (!Array.isArray(parsed)) return []\n    return parsed\n      .filter((h) => h && typeof h.id === 'string' && typeof h.name === 'string')\n      .map((h) => ({\n        ...h,\n        tags: (h.tags ?? []).map((t) => normalizeHashTag(String(t))).filter(Boolean),\n        contexts: Array.isArray(h.contexts) ? h.contexts.map((c) => String(c).trim()).filter(Boolean) : [],\n        people: Array.isArray(h.people) ? h.people.map((p) => String(p).trim()).filter(Boolean) : [],\n        location: typeof h.location === 'string' ? h.location : null,\n        goal: typeof h.goal === 'string' ? h.goal : null,\n        project: typeof h.project === 'string' ? h.project : null,\n        estimateMinutes: typeof h.estimateMinutes === 'number' ? h.estimateMinutes : null,\n        polarity: h.polarity ?? 'both',\n        color: h.color ?? null,\n        icon: h.icon ?? null,\n        isTimed: h.isTimed ?? false,\n      }))\n  } catch {\n    return []\n  }\n}\n\n/*\nfunction trackerTitleFor(def: TrackerDef) {\n  if (def.defaultValue == null || !Number.isFinite(def.defaultValue)) return def.label\n  return `${def.key}: ${Math.round(def.defaultValue)}/10`\n}\n*/\n\nfunction extractContextTokens(rawText: string) {\n  const out = new Set<string>()\n  for (const m of rawText.matchAll(/(^|[\\s(])\\+([a-zA-Z][\\w/-]*)/g)) {\n    const name = (m[2] ?? '').trim()\n    if (name) out.add(name)\n  }\n  return [...out].slice(0, 16)\n}\n\nfunction extractDurationToken(rawText: string) {\n  const t = rawText.toLowerCase()\n  const hm = t.match(/~\\s*(\\d{1,2})\\s*h(?:ours?)?\\s*(\\d{1,2})\\s*m(?:in(?:ute)?s?)?\\b/)\n  if (hm?.[1]) {\n    const h = Number(hm[1])\n    const m = Number(hm[2] ?? 0)\n    if (Number.isFinite(h) && Number.isFinite(m)) return h * 60 + m\n  }\n  const h = t.match(/~\\s*(\\d{1,2})(?:\\.(\\d))?\\s*h(?:ours?)?\\b/)\n  if (h?.[1]) {\n    const whole = Number(h[1])\n    const tenth = h[2] ? Number(h[2]) / 10 : 0\n    if (Number.isFinite(whole)) return Math.max(1, Math.round((whole + tenth) * 60))\n  }\n  const m = t.match(/~\\s*(\\d{1,3})\\s*(m|min|mins|minute|minutes)\\b/)\n  if (m?.[1]) {\n    const mins = Number(m[1])\n    if (Number.isFinite(mins)) return Math.max(1, Math.min(24 * 60, mins))\n  }\n  return null\n}\n\nfunction extractImportanceToken(rawText: string) {\n  const m = rawText.match(/!(\\d{1,2})\\b/)\n  const v = m?.[1] ? Number(m[1]) : null\n  const kv = rawText.match(/\\bimportance[:=]\\s*(\\d{1,2})\\b/i)?.[1]\n  const vv = kv ? Number(kv) : null\n  const val = Number.isFinite(v ?? NaN) ? v : Number.isFinite(vv ?? NaN) ? vv : null\n  return val != null ? Math.max(1, Math.min(10, val)) : null\n}\n\nfunction extractDifficultyToken(rawText: string) {\n  const m = rawText.match(/\\^(\\d{1,2})\\b/)\n  const v = m?.[1] ? Number(m[1]) : null\n  const kv = rawText.match(/\\b(?:difficulty|energy)[:=]\\s*(\\d{1,2})\\b/i)?.[1]\n  const ratio = rawText.match(/\\b(\\d{1,2})\\s*\\/\\s*10\\b/)?.[1]\n  const vv = kv ? Number(kv) : ratio ? Number(ratio) : null\n  const val = Number.isFinite(v ?? NaN) ? v : Number.isFinite(vv ?? NaN) ? vv : null\n  return val != null ? Math.max(1, Math.min(10, val)) : null\n}\n\nfunction hasExplicitTimeRange(rawText: string) {\n  const t = rawText.toLowerCase()\n  if (/\\b(\\d{1,2}(?::\\d{2})?\\s*(?:am|pm)?\\s*(?:-|\u2013|\u2014|\\s+to\\s+)\\s*\\d{1,2}(?::\\d{2})?\\s*(?:am|pm)?)\\b/.test(t)) return true\n  if (/\\b(at|@)\\s*\\d{1,2}(?::\\d{2})?\\s*(?:am|pm)?\\b/.test(t)) return true\n  return false\n}\n\nfunction parseInlineList(raw: string) {\n  return raw\n    .replace(/^\\[/, '')\n    .replace(/\\]$/, '')\n    .split(',')\n    .map((x) => x.trim().replace(/^['\"]|['\"]$/g, ''))\n    .filter(Boolean)\n}\n\nfunction parseSimpleFrontmatter(lines: string[]) {\n  const out: Record<string, any> = {}\n  let activeKey: string | null = null\n  let listBuffer: string[] = []\n\n  const flushList = () => {\n    if (activeKey) out[activeKey] = [...listBuffer]\n    activeKey = null\n    listBuffer = []\n  }\n\n  for (const rawLine of lines) {\n    const line = rawLine.replace(/\\t/g, '  ')\n    if (!line.trim() || /^\\s*#/.test(line)) continue\n    const listMatch = line.match(/^\\s*-\\s+(.+)$/)\n    if (listMatch && activeKey) {\n      listBuffer.push(listMatch[1].trim().replace(/^['\"]|['\"]$/g, ''))\n      continue\n    }\n    if (activeKey) flushList()\n    const m = line.match(/^\\s*([A-Za-z][\\w-]*)\\s*:\\s*(.*)$/)\n    if (!m?.[1]) continue\n    const key = m[1]\n    const value = (m[2] ?? '').trim()\n    if (!value) {\n      activeKey = key\n      listBuffer = []\n      continue\n    }\n    if (value.startsWith('[') && value.endsWith(']')) {\n      out[key] = parseInlineList(value)\n      continue\n    }\n    const unquoted = value.replace(/^['\"]|['\"]$/g, '')\n    if (/^(true|false)$/i.test(unquoted)) {\n      out[key] = unquoted.toLowerCase() === 'true'\n      continue\n    }\n    const num = Number(unquoted)\n    out[key] = Number.isFinite(num) && unquoted !== '' ? num : unquoted\n  }\n  if (activeKey) flushList()\n  return out\n}\n\nfunction extractFrontmatter(rawText: string) {\n  const lines = rawText.split(/\\r?\\n/)\n  if ((lines[0] ?? '').trim() !== '---') return { frontmatter: null, body: rawText }\n  const endIdx = lines.slice(1).findIndex((l) => l.trim() === '---')\n  if (endIdx === -1) return { frontmatter: null, body: rawText }\n  const fmLines = lines.slice(1, endIdx + 1)\n  const body = lines.slice(endIdx + 2).join('\\n').trim()\n  const frontmatter = parseSimpleFrontmatter(fmLines)\n  return { frontmatter, body }\n}\n\nfunction toStringList(value: unknown) {\n  if (Array.isArray(value)) return value.map((x) => String(x)).filter(Boolean)\n  if (typeof value === 'string') return value.split(/[,;]+/).map((x) => x.trim()).filter(Boolean)\n  return []\n}\n\nconst NUMBER_WORDS: Record<string, number> = {\n  zero: 0,\n  one: 1,\n  two: 2,\n  three: 3,\n  four: 4,\n  five: 5,\n  six: 6,\n  seven: 7,\n  eight: 8,\n  nine: 9,\n  ten: 10,\n}\n\nconst NUMBER_WORD_PATTERN = Object.keys(NUMBER_WORDS).join('|')\n\nfunction parseNumberToken(raw: string) {\n  const cleaned = raw.trim().toLowerCase()\n  if (!cleaned) return null\n  if (NUMBER_WORDS[cleaned] != null) return NUMBER_WORDS[cleaned]\n  const num = Number(cleaned)\n  return Number.isFinite(num) ? num : null\n}\n\nfunction parseRatingRange(first: string, second?: string | null) {\n  const a = parseNumberToken(first)\n  if (a == null) return null\n  const b = second ? parseNumberToken(second) : null\n  const value = b != null ? (a + b) / 2 : a\n  return Math.max(0, Math.min(10, value))\n}\n\nfunction parseRatingNearText(text: string, keyword: string) {\n  const tokenPattern = String.raw`(?:\\d{1,2}|${NUMBER_WORD_PATTERN})`\n  const re = new RegExp(\n    String.raw`\\b${keyword}\\b(?:\\s*(?:is|was|were|like|around|about|at|score|rating|of|=|:)?\\s*)(${tokenPattern})(?:\\s*(?:-|to)\\s*(${tokenPattern}))?(?:\\s*\\/\\s*10)?`,\n    'i',\n  )\n  const m = text.match(re)\n  if (!m?.[1]) return null\n  return parseRatingRange(m[1], m[2])\n}\n\nfunction inferMoodFromAdjectives(text: string) {\n  const moodSignal = /\\b(feel(?:ing)?|mood|looking forward|cant wait|can't wait|excited|love (?:doing|this|it))\\b/i.test(text)\n  if (!moodSignal) return null\n  const moodAdjectives: Array<{ re: RegExp; value: number }> = [\n    { re: /\\b(amazing|awesome|fantastic|incredible)\\b/i, value: 9 },\n    { re: /\\b(great)\\b/i, value: 8 },\n    { re: /\\b(very good|really good|pretty good|good)\\b/i, value: 7 },\n    { re: /\\b(looking forward)\\b/i, value: 7 },\n    { re: /\\b(cant wait|can't wait|excited)\\b/i, value: 8 },\n    { re: /\\b(love (?:doing|this|it))\\b/i, value: 8 },\n    { re: /\\b(okay|ok|fine|neutral)\\b/i, value: 5 },\n    { re: /\\b(meh)\\b/i, value: 4 },\n    { re: /\\b(not good|bad|down)\\b/i, value: 3 },\n    { re: /\\b(sad|depressed)\\b/i, value: 2 },\n    { re: /\\b(awful|terrible|miserable)\\b/i, value: 1 },\n    { re: /\\b(happy|joyful|excited)\\b/i, value: 8 },\n    { re: /\\b(anxious|stressed|angry)\\b/i, value: 4 },\n  ]\n  for (const entry of moodAdjectives) {\n    if (entry.re.test(text)) return entry.value\n  }\n  return null\n}\n\nfunction inferEnergyFromAdjectives(text: string) {\n  const energySignal =\n    /\\benergy\\b/i.test(text) ||\n    /\\b(energized|wired|pumped|tired|exhausted|drained|fatigued|sleepy|sluggish)\\b/i.test(text)\n  if (!energySignal) return null\n  const energyAdjectives: Array<{ re: RegExp; value: number }> = [\n    { re: /\\b(energized|wired|pumped|high energy|very high energy)\\b/i, value: 8 },\n    { re: /\\b(great energy|good energy|solid energy)\\b/i, value: 7 },\n    { re: /\\b(okay energy|fine|average|medium)\\b/i, value: 5 },\n    { re: /\\b(low energy|tired|fatigued|sluggish)\\b/i, value: 3 },\n    { re: /\\b(exhausted|drained|wiped|spent)\\b/i, value: 2 },\n  ]\n  for (const entry of energyAdjectives) {\n    if (entry.re.test(text)) return entry.value\n  }\n  return null\n}\n\nfunction inferStressFromAdjectives(text: string) {\n  if (!/\\b(stress|stressed|overwhelmed|anxious|calm|relaxed)\\b/i.test(text)) return null\n  if (/\\b(calm|relaxed)\\b/i.test(text)) return 2\n  if (/\\b(overwhelmed|very stressed|extremely stressed)\\b/i.test(text)) return 8\n  if (/\\b(stressed|anxious)\\b/i.test(text)) return 7\n  return null\n}\n\nfunction extractTrackerTokens(text: string) {\n  const out: Array<{ name: string; value: number }> = []\n  for (const m of text.matchAll(/#([a-zA-Z][\\w/-]*)\\(([-+]?\\d*\\.?\\d+)\\)/g)) {\n    const name = m[1].toLowerCase()\n    if (name === 'sleep') continue\n    out.push({ name: m[1], value: Number(m[2]) })\n  }\n  for (const m of text.matchAll(/#([a-zA-Z][\\w/-]*):([-+]?\\d*\\.?\\d+)/g)) {\n    const name = m[1].toLowerCase()\n    if (name === 'sleep') continue\n    out.push({ name: m[1], value: Number(m[2]) })\n  }\n  const lower = text.toLowerCase()\n  const keys = ['mood', 'energy', 'stress', 'pain', 'anxiety', 'focus', 'motivation', 'productivity'] as const\n  for (const key of keys) {\n    if (out.some((t) => t.name.toLowerCase() === key)) continue\n    const value = parseRatingNearText(lower, key)\n    if (value != null) {\n      out.push({ name: key, value })\n    }\n  }\n  if (!out.some((t) => t.name.toLowerCase() === 'mood')) {\n    const moodValue = inferMoodFromAdjectives(lower)\n    if (moodValue != null) out.push({ name: 'mood', value: moodValue })\n  }\n  if (!out.some((t) => t.name.toLowerCase() === 'energy')) {\n    const energyValue = inferEnergyFromAdjectives(lower)\n    if (energyValue != null) out.push({ name: 'energy', value: energyValue })\n  }\n  if (!out.some((t) => t.name.toLowerCase() === 'stress')) {\n    const stressValue = inferStressFromAdjectives(lower)\n    if (stressValue != null) out.push({ name: 'stress', value: stressValue })\n  }\n  return out\n}\n\nfunction extractMoodMentions(text: string) {\n  const out: Array<{ value: number; hint: 'start' | 'now' | 'unknown' }> = []\n  const tokenPattern = String.raw`(?:\\d{1,2}|${NUMBER_WORD_PATTERN})`\n  const re = new RegExp(\n    String.raw`\\b(?:mood|feel(?:ing)?)\\b(?:\\s*(?:is|was|were|like|around|about|at|:)?\\s*)(${tokenPattern})(?:\\s*(?:-|to)\\s*(${tokenPattern}))?(?:\\s*\\/\\s*10)?`,\n    'gi',\n  )\n  for (const m of text.matchAll(re)) {\n    const value = parseRatingRange(m[1], m[2])\n    if (value == null) continue\n    const idx = m.index ?? 0\n    const window = text.slice(Math.max(0, idx - 16), Math.min(text.length, idx + m[0].length + 16)).toLowerCase()\n    const hint = /\\b(now|right now|currently|at the moment|after|later|end(?:ed)?|finished)\\b/.test(window)\n      ? 'now'\n      : /\\b(before|earlier|previously|start(?:ed|ing)?|begin(?:ning)?|at first)\\b/.test(window)\n        ? 'start'\n        : 'unknown'\n    out.push({ value: Math.max(0, Math.min(10, Math.round(value))), hint })\n  }\n  return out\n}\n\nfunction extractTaskLines(markdown: string) {\n  const titles: string[] = []\n  for (const line of markdown.split(/\\r?\\n/)) {\n    const checklist = line.match(/^\\s*[-*+]\\s*\\[( |x|X)\\]\\s*(.+)$/)\n    if (checklist?.[2]) {\n      titles.push(checklist[2].trim())\n      continue\n    }\n    if (!/(?:\\{task:[^}]+\\}|#task\\b)/i.test(line)) continue\n    const cleaned = line\n      .replace(/^\\s*[-*+]\\s+/, '')\n      .replace(/\\{task:[^}]+\\}/gi, '')\n      .replace(/\\s+#task\\b/gi, '')\n      .trim()\n    if (cleaned) titles.push(cleaned)\n  }\n  return titles.slice(0, 50)\n}\n\nasync function createTrackerLogsFromText(opts: {\n  text: string\n  atMs: number\n  sourceNoteId?: string\n  parentEventId?: string | null\n  events: CalendarEvent[]\n  ensureTrackerDefinition: (opts: { key: string; label?: string; icon?: IconName | null; color?: string | null; defaultValue?: number | null }) => TrackerDef | null\n  defaultTrackerUnit: (key: string) => TrackerDef['unit']\n  findBestActiveEventAt: (atMs: number) => Promise<CalendarEvent | null>\n  createEvent: typeof createEvent\n  setEvents: (value: SetStateAction<CalendarEvent[]>) => void\n}) {\n  const tokens = extractTrackerTokens(opts.text)\n  if (!tokens.length) return { created: 0, skipped: 0 }\n  const parentId =\n    typeof opts.parentEventId !== 'undefined'\n      ? opts.parentEventId\n      : (await opts.findBestActiveEventAt(opts.atMs))?.id ?? null\n  const createdKeys = new Set<string>()\n  let created = 0\n  let skipped = 0\n  for (const tok of tokens) {\n    const key = tok.name.trim().toLowerCase()\n    if (!key) continue\n    if (key === 'sleep') continue\n    const dedupeKey = `${key}|${opts.sourceNoteId ?? ''}`\n    if (createdKeys.has(dedupeKey)) continue\n    const already = opts.events.find((e) => e.kind === 'log' && e.trackerKey === key && e.sourceNoteId === opts.sourceNoteId)\n    if (already) {\n      skipped += 1\n      continue\n    }\n    const def = opts.ensureTrackerDefinition({ key })\n    const unit = def?.unit ?? opts.defaultTrackerUnit(key)\n    let value = typeof tok.value === 'number' && Number.isFinite(tok.value) ? tok.value : null\n    if (value != null) {\n      if (unit.step && unit.step > 0) value = Math.round(value / unit.step) * unit.step\n      if (unit.min != null) value = Math.max(unit.min, value)\n      if (unit.max != null) value = Math.min(unit.max, value)\n    }\n    if (value == null) continue\n    const label = def?.label ?? key\n    const unitSuffix = unit.label && unit.label !== 'value' && unit.label !== 'score' ? ` ${unit.label}` : ''\n    const title = `${label}: ${value}${unitSuffix}`\n    const log = await opts.createEvent({\n      title,\n      startAt: opts.atMs,\n      endAt: opts.atMs + 5 * 60 * 1000,\n      kind: 'log',\n      parentEventId: parentId,\n      tags: [`#${key}`],\n      sourceNoteId: opts.sourceNoteId ?? null,\n      trackerKey: key,\n      icon: def?.icon ?? null,\n      color: def?.color ?? null,\n      category: null,\n      subcategory: null,\n    })\n    opts.setEvents((prev) => [log, ...prev])\n    createdKeys.add(dedupeKey)\n    created += 1\n  }\n  return { created, skipped }\n}\n\nfunction parseCommaList(raw: string) {\n  return raw\n    .split(/[,\\n]+/)\n    .map((x) => x.trim())\n    .filter(Boolean)\n    .slice(0, 20)\n}\n\nfunction formatCommaList(values: string[] | null | undefined) {\n  return (values ?? []).join(', ')\n}\n\nconst CHARACTER_KEYS = ['STR', 'INT', 'CON', 'PER'] as const\n\nfunction normalizeCharacterKey(raw: string) {\n  const t = raw.trim().toLowerCase()\n  if (!t) return null\n  if (t === 'str' || t === 'strength') return 'STR'\n  if (t === 'int' || t === 'intelligence') return 'INT'\n  if (t === 'con' || t === 'constitution') return 'CON'\n  if (t === 'per' || t === 'perception') return 'PER'\n  return null\n}\n\nfunction normalizeCharacterSelection(values: string[] | null | undefined) {\n  const out: string[] = []\n  const seen = new Set<string>()\n  for (const v of values ?? []) {\n    const k = normalizeCharacterKey(v)\n    if (!k) continue\n    if (seen.has(k)) continue\n    seen.add(k)\n    out.push(k)\n  }\n  return out\n}\n\nfunction toggleCharacterSelection(values: string[] | null | undefined, key: (typeof CHARACTER_KEYS)[number]) {\n  const current = new Set(normalizeCharacterSelection(values))\n  if (current.has(key)) current.delete(key)\n  else current.add(key)\n  return [...current]\n}\n\nfunction extractTagTokens(rawText: string) {\n  const out = new Set<string>()\n  for (const m of rawText.matchAll(/#([a-zA-Z][\\w/-]*)(?!\\s*(\\(|:\\s*[-+]?\\d))/g)) out.add(m[1].toLowerCase())\n  return [...out].slice(0, 24)\n}\n\nfunction extractAtMentions(rawText: string) {\n  const out: Array<{ raw: string; before: string }> = []\n  for (const m of rawText.matchAll(/(^|[\\s(])@(?:\"([^\"]+)\"|'([^']+)'|([A-Za-z][\\w'\u2019-]*(?:\\s+[A-Za-z][\\w'\u2019-]*){0,3}))/g)) {\n    const before = (m[1] ?? '').toLowerCase()\n    const raw = (m[2] ?? m[3] ?? m[4] ?? '').trim()\n    if (!raw) continue\n    out.push({ raw, before })\n  }\n  return out.slice(0, 16)\n}\n\nfunction uniqStrings(values: string[]) {\n  const out: string[] = []\n  const seen = new Set<string>()\n  for (const v of values) {\n    const s = v.trim()\n    if (!s) continue\n    const k = s.toLowerCase()\n    if (seen.has(k)) continue\n    seen.add(k)\n    out.push(s)\n  }\n  return out\n}\n\nfunction formatMinutesSpan(totalMinutes: number) {\n  const mins = Math.max(0, Math.round(totalMinutes))\n  const h = Math.floor(mins / 60)\n  const m = mins % 60\n  if (h > 0) return `${h}h ${m}m`\n  return `${m}m`\n}\n\nconst PINNED_GROUP_ORDER_KEY = 'insight5.explorer.pinnedGroupOrder.v1'\nconst DEFAULT_PINNED_GROUP_ORDER = ['tasks', 'habits', 'trackers', 'shortcuts'] as const\n\nfunction loadPinnedGroupOrder() {\n  try {\n    const raw = localStorage.getItem(PINNED_GROUP_ORDER_KEY)\n    if (!raw) return [...DEFAULT_PINNED_GROUP_ORDER]\n    const parsed = JSON.parse(raw) as string[]\n    if (!Array.isArray(parsed)) return [...DEFAULT_PINNED_GROUP_ORDER]\n    const allowed = new Set(DEFAULT_PINNED_GROUP_ORDER)\n    const next = parsed.filter((k) => allowed.has(k as any))\n    for (const k of DEFAULT_PINNED_GROUP_ORDER) if (!next.includes(k)) next.push(k)\n    return next\n  } catch {\n    return [...DEFAULT_PINNED_GROUP_ORDER]\n  }\n}\n\nfunction savePinnedGroupOrder(order: string[]) {\n  try {\n    localStorage.setItem(PINNED_GROUP_ORDER_KEY, JSON.stringify(order))\n  } catch {\n    // ignore\n  }\n}\n\nfunction nextThemePref(current: ThemePreference): ThemePreference {\n  if (current === 'light') return 'dark'\n  if (current === 'dark') return 'system'\n  return 'light'\n}\n\nfunction extractImplicitPeople(rawText: string) {\n  const out: string[] = []\n  for (const m of rawText.matchAll(/\\bwith\\s+(?:(?:dr|doctor|mr|ms|mrs|prof|professor)\\.?\\s+)?([A-Z][\\w'\u2019.-]*(?:\\s+[A-Z][\\w'\u2019.-]*){0,2})\\b/gim)) {\n    const name = (m[1] ?? '').trim()\n    if (!name) continue\n    out.push(name)\n  }\n  for (const m of rawText.matchAll(/\\b(?:call|text|dm|email)\\s+(mom|dad|mother|father|wife|husband|partner)\\b/gim)) {\n    const raw = (m[1] ?? '').trim()\n    if (!raw) continue\n    out.push(raw[0]!.toUpperCase() + raw.slice(1).toLowerCase())\n  }\n  return uniqStrings(out).slice(0, 8)\n}\n\nfunction normalizePersonName(raw: string) {\n  const cleaned = raw\n    .replace(/^@+/, '')\n    .replace(/^[\\s,;:.!]+/, '')\n    .replace(/[\\s,;:.!]+$/, '')\n    .replace(/\\s+/g, ' ')\n    .trim()\n  if (!cleaned) return null\n  const relationMap: Record<string, string> = {\n    mom: 'Mom',\n    mother: 'Mother',\n    dad: 'Dad',\n    father: 'Father',\n    wife: 'Wife',\n    husband: 'Husband',\n    partner: 'Partner',\n  }\n  const dropWords = new Set([\n    'a',\n    'an',\n    'the',\n    'at',\n    'in',\n    'on',\n    'with',\n    'for',\n    'to',\n    'from',\n    'and',\n    'or',\n    'him',\n    'her',\n    'them',\n    'me',\n    'my',\n    'their',\n    'his',\n    'hers',\n    'i',\n    'im',\n    \"i'm\",\n    'talked',\n    'talking',\n    'met',\n    'see',\n    'saw',\n    'baby',\n  ])\n  const bannedWords = new Set([\n    'patient',\n    'patients',\n    'nurse',\n    'nursing',\n    'clinic',\n    'hospital',\n    'staff',\n    'team',\n    'coworker',\n    'coworkers',\n    'people',\n    'unit',\n    'room',\n    'chart',\n    'charting',\n    'shift',\n    'rounds',\n  ])\n  const titleWords = new Set(['dr', 'doctor', 'mr', 'mrs', 'ms', 'prof', 'professor', 'aunt', 'uncle'])\n  const parts = cleaned.split(' ').filter(Boolean)\n  while (parts.length && titleWords.has(parts[0]!.toLowerCase())) parts.shift()\n  const filtered = parts.filter((p) => !dropWords.has(p.toLowerCase()))\n  if (filtered.length === 0) return null\n  if (filtered.length > 3) return null\n  const joined = filtered.join(' ')\n  const lowerJoined = joined.toLowerCase()\n  if (relationMap[lowerJoined]) return relationMap[lowerJoined]\n  if (!/[A-Z]/.test(joined)) return null\n  if (filtered.some((p) => bannedWords.has(p.toLowerCase()))) return null\n  if (/^(he|she|they|him|her|them|someone|somebody|anyone|anybody|me|my)$/i.test(joined)) return null\n  if (!/[a-z]/i.test(joined)) return null\n  if (joined.length > 40) return null\n  return joined\n}\n\nfunction cleanPeopleList(values: string[]) {\n  const out: string[] = []\n  for (const raw of values) {\n    for (const piece of raw.split(/\\s*(?:,|&|and)\\s*/i)) {\n      const name = normalizePersonName(piece)\n      if (!name) continue\n      out.push(name)\n    }\n  }\n  return uniqStrings(out).slice(0, 12)\n}\n\nfunction escapeRegExp(text: string) {\n  return text.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction normalizeHabitKeyword(raw: string) {\n  const trimmed = raw.trim().replace(/^#/, '')\n  if (!trimmed) return null\n  if (trimmed.length < 3) return null\n  return trimmed.toLowerCase()\n}\n\nfunction buildHabitKeywordList(def: HabitDef) {\n  const keywords = new Set<string>()\n  const name = normalizeHabitKeyword(def.name ?? '')\n  if (name) keywords.add(name)\n  for (const tag of def.tags ?? []) {\n    const cleaned = normalizeHabitKeyword(tag)\n    if (cleaned) keywords.add(cleaned)\n  }\n  const category = normalizeHabitKeyword(def.category ?? '')\n  if (category) keywords.add(category)\n  const subcategory = normalizeHabitKeyword(def.subcategory ?? '')\n  if (subcategory) keywords.add(subcategory)\n\n  const joined = [...keywords].join(' ')\n  const workoutLike = /\\b(workout|exercise|gym)\\b/i.test(joined)\n  if (workoutLike) {\n    ;[\n      'workout',\n      'work out',\n      'exercise',\n      'gym',\n      'run',\n      'running',\n      'ran',\n      'jog',\n      'jogging',\n      'lift',\n      'lifting',\n      'weights',\n      'push up',\n      'pushup',\n      'pull up',\n      'pullup',\n      'squat',\n      'squats',\n      'deadlift',\n      'bench',\n      'cardio',\n    ].forEach((k) => keywords.add(k))\n  }\n\n  return Array.from(keywords)\n}\n\nfunction habitMatchesText(text: string, def: HabitDef) {\n  const lower = text.toLowerCase()\n  for (const keyword of buildHabitKeywordList(def)) {\n    const escaped = escapeRegExp(keyword).replace(/\\s+/g, String.raw`\\\\s+`)\n    const rx = new RegExp(String.raw`\\\\b${escaped}\\\\b`, 'i')\n    if (rx.test(lower)) return true\n  }\n  return false\n}\n\nfunction detectHabitMentions(text: string, defs: HabitDef[]) {\n  return defs.filter((h) => habitMatchesText(text, h))\n}\n\nfunction detectHabitMentionsWithPolarity(text: string, defs: HabitDef[]) {\n  const sentences = text.split(/[\\n.!?;]+/).map((s) => s.trim()).filter(Boolean)\n  const negationRe = /\\b(didn['\u2019]?t|did not|skip(?:ped)?|miss(?:ed)?|couldn['\u2019]?t|could not|wasn['\u2019]?t able|was not able|did not do)\\b/i\n  const states = new Map<string, { habit: HabitDef; pos: boolean; neg: boolean }>()\n\n  for (const sentence of sentences) {\n    const hasNegation = negationRe.test(sentence)\n    for (const habit of defs) {\n      if (!habitMatchesText(sentence, habit)) continue\n      const state = states.get(habit.id) ?? { habit, pos: false, neg: false }\n      if (hasNegation) state.neg = true\n      else state.pos = true\n      states.set(habit.id, state)\n    }\n  }\n\n  return Array.from(states.values()).map((state) => ({\n    habit: state.habit,\n    polarity: state.pos ? 'positive' : 'negative',\n  }))\n}\n\nfunction extractImplicitPlaces(rawText: string) {\n  const out: string[] = []\n  const banned = new Set(['AM', 'PM', 'Today', 'Tomorrow', 'Yesterday', 'I'])\n  for (const m of rawText.matchAll(/\\b(?:at|in|to)\\s+([A-Z][\\w'\u2019.-]*(?:\\s+[A-Z][\\w'\u2019.-]*){0,4})\\b/g)) {\n    const name = (m[1] ?? '').trim()\n    if (!name) continue\n    if (banned.has(name)) continue\n    out.push(name)\n  }\n  const commonPlaceMap: Record<string, string> = {\n    gym: 'Gym',\n    bank: 'Bank',\n    clinic: 'Clinic',\n    hospital: 'Hospital',\n    er: 'ER',\n    home: 'Home',\n    work: 'Work',\n    office: 'Office',\n  }\n  for (const m of rawText.matchAll(/\\b(?:at|in|to)\\s+(?:the\\s+)?(gym|bank|clinic|hospital|er|home|work|office)\\b/gim)) {\n    const key = (m[1] ?? '').trim().toLowerCase()\n    const mapped = commonPlaceMap[key]\n    if (mapped) out.push(mapped)\n  }\n  return uniqStrings(out).slice(0, 8)\n}\n\nfunction extractMoneyUsd(rawText: string) {\n  const t = rawText.toLowerCase()\n  const usd = t.match(/\\$\\s*(\\d+(?:\\.\\d{1,2})?)/)?.[1]\n  if (usd) return Number(usd)\n  const dollars = t.match(/\\b(\\d+(?:\\.\\d{1,2})?)\\s*(?:dollars|bucks)\\b/)?.[1]\n  if (dollars) return Number(dollars)\n  const spend = t.match(/\\bspend\\s*(?:about\\s*)?(\\d+(?:\\.\\d{1,2})?)\\b/)?.[1]\n  if (spend) return Number(spend)\n  return null\n}\n\nfunction extractShoppingItems(rawText: string) {\n  const m = rawText.match(/\\b(?:buy|get|pick up|grab)\\b\\s+([^.;\\n]+)/i)?.[1]\n  if (!m) return []\n  const cut = m.split(/\\b(?:at|in|to|with|for|tomorrow|today|next|on)\\b/i)[0] ?? m\n  return uniqStrings(\n    cut\n      .split(/,|\\band\\b/i)\n      .map((x) => x.trim())\n      .filter(Boolean),\n  ).slice(0, 12)\n}\n\nfunction buildShoppingNotes(items: string[], moneyUsd: number | null) {\n  const lines: string[] = []\n  if (items.length) {\n    lines.push('| Item | Cost |')\n    lines.push('| --- | --- |')\n    lines.push(...items.map((x) => `| ${x} |  |`))\n  }\n  if (moneyUsd != null && Number.isFinite(moneyUsd)) lines.push(`Total budget: $${moneyUsd}`)\n  return lines.join('\\n')\n}\n\ntype TranscriptLine = { time: string; text: string; line: string }\n\nfunction parseTimestampedTranscript(rawText: string | null | undefined) {\n  if (!rawText) return []\n  const out: TranscriptLine[] = []\n  for (const line of rawText.split(/\\r?\\n/)) {\n    const match = line.match(/^\\s*(?:[-*]\\s*)?\\[(\\d{1,2}:\\d{2})\\]\\s*(.+)\\s*$/)\n    if (!match) continue\n    out.push({ time: match[1], text: match[2], line })\n  }\n  return out\n}\n\nfunction isTextInputTarget(target: EventTarget | null) {\n  const el = target as HTMLElement | null\n  if (!el) return false\n  const tag = el.tagName?.toLowerCase()\n  if (tag === 'input' || tag === 'textarea' || tag === 'select') return true\n  return Boolean(el.isContentEditable)\n}\n\nfunction App() {\n  const [captures, setCaptures] = useState<InboxCapture[]>([])\n  const [tasks, setTasks] = useState<Task[]>([])\n  const [events, setEvents] = useState<CalendarEvent[]>([])\n  const eventsRef = useRef<CalendarEvent[]>([])\n  const [authSession, setAuthSession] = useState<Session | null>(null)\n  const [authReady, setAuthReady] = useState(false)\n  const [authEmail, setAuthEmail] = useState('')\n  const [authPassword, setAuthPassword] = useState('')\n  const [authMode, setAuthMode] = useState<'signin' | 'signup'>('signin')\n  const [authError, setAuthError] = useState('')\n  const [authStatus, setAuthStatus] = useState('')\n  const [authWorking, setAuthWorking] = useState(false)\n  const [authDismissed, setAuthDismissed] = useState(false)\n  const supabaseConfigured = Boolean(getSupabaseClient())\n  const taxonomyRulesRef = useRef<TaxonomyRule[]>([])\n  const [trackerDefs, setTrackerDefs] = useState<TrackerDef[]>(() => loadTrackerDefs())\n\n  function defaultTrackerUnit(key: string): TrackerDef['unit'] {\n    const normalized = key.trim().toLowerCase()\n    if (['mood', 'energy', 'stress', 'pain', 'focus'].includes(normalized)) {\n      return { label: 'score', min: 1, max: 10, step: 1, presets: [1, 5, 7, 10] }\n    }\n    if (normalized.includes('water') || normalized.includes('hydration')) {\n      return { label: 'oz', min: 0, max: 200, step: 1, presets: [8, 16, 24, 32, 64] }\n    }\n    return { label: 'value', min: null, max: null, step: null, presets: [] }\n  }\n\n  function buildTrackerDef(opts: { key: string; label?: string; icon?: IconName | null; color?: string | null; defaultValue?: number | null }) {\n    const key = opts.key.trim().toLowerCase()\n    const now = Date.now()\n    const def: TrackerDef = {\n      id: `trk_${key}_${now}`,\n      key,\n      label: (opts.label ?? toTitleCase(key)).trim() || key,\n      createdAt: now,\n      defaultValue: opts.defaultValue ?? null,\n      icon: opts.icon ?? null,\n      color: opts.color ?? null,\n      unit: defaultTrackerUnit(key),\n      meta: emptySharedMeta(),\n    }\n    return def\n  }\n\n  function ensureTrackerDefinition(opts: { key: string; label?: string; icon?: IconName | null; color?: string | null; defaultValue?: number | null }) {\n    const key = opts.key.trim().toLowerCase()\n    if (!key) return null\n    const existing = loadTrackerDefs().find((t) => t.key === key)\n    if (existing) return existing\n    const next = buildTrackerDef(opts)\n    upsertTrackerDef(next)\n    setTrackerDefs(loadTrackerDefs())\n    return next\n  }\n\n  const [captureOpen, setCaptureOpen] = useState(false)\n  const [captureDraft, setCaptureDraft] = useState('')\n  const [captureInterim, setCaptureInterim] = useState('')\n  const [captureAttachEventId, setCaptureAttachEventId] = useState<string | null>(null)\n\t\t  const [captureListening, setCaptureListening] = useState(false)\n\t\t  const [captureSaving, setCaptureSaving] = useState(false)\n\t\t  const [captureAiStatus, setCaptureAiStatus] = useState<string>('')\n\t\t  const [captureError, setCaptureError] = useState<string>('')\n  const [captureProgress, setCaptureProgress] = useState<string[]>([])\n  const [captureAnchorMs, setCaptureAnchorMs] = useState<number>(() => Date.now())\n  const [captureReturnView, setCaptureReturnView] = useState<WorkspaceViewKey | null>(null)\n  const [captureExtendedMode, setCaptureExtendedMode] = useState(false)\n\n  // Refs for voice capture toggle behavior\n  const speechRecognitionRef = useRef<any>(null)\n  const shouldListenRef = useRef(false)\n  const captureTimeoutRef = useRef<NodeJS.Timeout | null>(null)\n  const trackerExtractionTimeoutRef = useRef<Record<string, number>>({})\n\n  useEffect(() => {\n    const supabase = getSupabaseClient()\n    if (!supabase) {\n      setAuthReady(true)\n      return\n    }\n    let mounted = true\n\n    async function runInitialSync() {\n      const { data } = await supabase.auth.getSession()\n      if (!mounted) return\n      setAuthSession(data.session ?? null)\n      setAuthReady(true)\n      if (!data.session) return\n      await migrateLocalDataToSupabase()\n      await pullSupabaseToLocal()\n    }\n\n    void runInitialSync()\n\n    const { data: listener } = supabase.auth.onAuthStateChange((_event, session) => {\n      if (!mounted) return\n      setAuthSession(session ?? null)\n      if (!session) return\n      void migrateLocalDataToSupabase().then(() => pullSupabaseToLocal())\n    })\n\n    const interval = window.setInterval(() => {\n      supabase.auth.getSession().then(({ data }) => {\n        if (!data.session) return\n        void pullSupabaseToLocal()\n      })\n    }, 120000)\n\n    return () => {\n      mounted = false\n      listener?.subscription?.unsubscribe()\n      window.clearInterval(interval)\n    }\n  }, [])\n\n  useEffect(() => {\n    eventsRef.current = events\n  }, [events])\n\n  useEffect(() => {\n    if (authSession) {\n      setAuthDismissed(false)\n    }\n  }, [authSession])\n\n  const [agendaDate, setAgendaDate] = useState<Date>(() => new Date())\n  const [timelineTagFilters, setTimelineTagFilters] = useState<string[]>([])\n\n  const [selection, setSelection] = useState<Selection>({ kind: 'none' })\n  const selectedEventId = selection.kind === 'event' ? selection.id : null\n  const [selectedGoal, setSelectedGoal] = useState<string | null>(null)\n  const [selectedProject, setSelectedProject] = useState<string | null>(null)\n  const [selectedTrackerKey, setSelectedTrackerKey] = useState<string | null>(null)\n\n  const [leftCollapsed, setLeftCollapsed] = useState(false)\n  const [rightCollapsed, setRightCollapsed] = useState(false)\n  const [railLabelsOpen, setRailLabelsOpen] = useState(false)\n  const [rightMode, setRightMode] = useState<'details' | 'ai'>('details')\n  const rightPanelHideViews = useMemo<Set<WorkspaceViewKey>>(\n    () => new Set(['ecosystem', 'habits', 'goals', 'goal-detail', 'notes']),\n    [],\n  )\n  const [propsCollapsed, setPropsCollapsed] = useState(true)\n  const [docOpen, setDocOpen] = useState(false)\n  const [docTab, setDocTab] = useState<'notes' | 'transcript'>('notes')\n  const [docTranscriptFocus, setDocTranscriptFocus] = useState<string | null>(null)\n  const [themePref, setThemePref] = useState<ThemePreference>(() => loadThemePreference())\n  const [eventTitleDetail, setEventTitleDetail] = useState<EventTitleDetail>(() => loadDisplaySettings().eventTitleDetail)\n\n  const [tagDraft, setTagDraft] = useState('')\n  const [peopleDraft, setPeopleDraft] = useState('')\n  const [locationDraft, setLocationDraft] = useState('')\n  const [contextDraft, setContextDraft] = useState('')\n  const [skillDraft, setSkillDraft] = useState('')\n  const [composerTagDraft, setComposerTagDraft] = useState('')\n  const [composerPeopleDraft, setComposerPeopleDraft] = useState('')\n  const [composerLocationDraft, setComposerLocationDraft] = useState('')\n  const [composerListening, setComposerListening] = useState(false)\n  const [composerInterim, setComposerInterim] = useState('')\n\n  const [eventComposerOpen, setEventComposerOpen] = useState(false)\n  const [eventComposer, setEventComposer] = useState<EventComposerDraft>(() => ({\n    title: '',\n    startAt: Date.now(),\n    endAt: Date.now() + 60 * 60 * 1000,\n    kind: 'event',\n    allDay: false,\n    active: false,\n    icon: null,\n    color: null,\n    tagsRaw: '',\n    location: '',\n    peopleRaw: '',\n    skillsRaw: '',\n    character: [],\n    category: '',\n    subcategory: '',\n    importance: 5,\n    difficulty: 5,\n    estimateMinutesRaw: '60',\n    notes: '',\n    taskId: null,\n    trackerKey: '',\n  }))\n\n  const [explorerPinnedOpen, setExplorerPinnedOpen] = useState(true)\n  const [explorerPinnedTasksOpen, setExplorerPinnedTasksOpen] = useState(true)\n  const [explorerPinnedHabitsOpen, setExplorerPinnedHabitsOpen] = useState(true)\n  const [explorerPinnedTrackersOpen, setExplorerPinnedTrackersOpen] = useState(true)\n  const [explorerPinnedShortcutsOpen, setExplorerPinnedShortcutsOpen] = useState(true)\n  const [pinnedGroupOrder, setPinnedGroupOrder] = useState(() => loadPinnedGroupOrder())\n  const [dragPinnedKey, setDragPinnedKey] = useState<string | null>(null)\n\n  useEffect(() => {\n    savePinnedGroupOrder(pinnedGroupOrder)\n  }, [pinnedGroupOrder])\n  const [explorerRecentOpen, setExplorerRecentOpen] = useState(true)\n  const [explorerPomoOpen, setExplorerPomoOpen] = useState(true)\n  const [explorerTaskQuery, setExplorerTaskQuery] = useState('')\n  const [explorerTaskDraft, setExplorerTaskDraft] = useState('')\n  const [habitDefs, setHabitDefs] = useState<HabitDef[]>(() => loadHabitDefsFromStorage())\n\n  useEffect(() => {\n    const resolved = resolveTheme(themePref)\n    applyTheme(resolved)\n    saveThemePreference(themePref)\n    if (themePref !== 'system') return\n    const media = window.matchMedia?.('(prefers-color-scheme: dark)')\n    if (!media) return\n    const onChange = () => applyTheme(resolveTheme('system'))\n    if (media.addEventListener) media.addEventListener('change', onChange)\n    else media.addListener?.(onChange)\n    return () => {\n      if (media.removeEventListener) media.removeEventListener('change', onChange)\n      else media.removeListener?.(onChange)\n    }\n  }, [themePref])\n\n  useEffect(() => {\n    function onThemeChanged() {\n      setThemePref(loadThemePreference())\n    }\n    window.addEventListener(THEME_CHANGED_EVENT, onThemeChanged)\n    return () => window.removeEventListener(THEME_CHANGED_EVENT, onThemeChanged)\n  }, [])\n\n  useEffect(() => {\n    function onDisplayChanged() {\n      setEventTitleDetail(loadDisplaySettings().eventTitleDetail)\n    }\n    window.addEventListener(DISPLAY_SETTINGS_CHANGED_EVENT, onDisplayChanged)\n    return () => window.removeEventListener(DISPLAY_SETTINGS_CHANGED_EVENT, onDisplayChanged)\n  }, [])\n\n  // Global keyboard shortcuts\n  useEffect(() => {\n    const handleKeyDown = (e: KeyboardEvent) => {\n      // Cmd/Ctrl + K: Open capture modal\n      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {\n        e.preventDefault()\n        setCaptureOpen(true)\n        toast.info('Quick capture opened', { duration: 1500 })\n      }\n\n      // Escape: Close modals\n      if (e.key === 'Escape') {\n        if (captureOpen) {\n          setCaptureOpen(false)\n        }\n        if (eventComposerOpen) {\n          setEventComposerOpen(false)\n        }\n        if (selection.kind !== 'none') {\n          setSelection({ kind: 'none' })\n        }\n      }\n\n      // Cmd/Ctrl + Shift + H: Go to habits\n      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'h') {\n        e.preventDefault()\n        openView('habits')\n        toast.info('Navigated to Habits', { duration: 1500 })\n      }\n\n      // Cmd/Ctrl + Shift + D: Go to dashboard\n      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'd') {\n        e.preventDefault()\n        openView('dashboard')\n        toast.info('Navigated to Dashboard', { duration: 1500 })\n      }\n\n      // Cmd/Ctrl + Shift + R: Go to rewards\n      if ((e.metaKey || e.ctrlKey) && e.shiftKey && e.key.toLowerCase() === 'r') {\n        e.preventDefault()\n        openView('rewards')\n        toast.info('Navigated to Rewards', { duration: 1500 })\n      }\n    }\n\n    window.addEventListener('keydown', handleKeyDown)\n    return () => window.removeEventListener('keydown', handleKeyDown)\n  }, [captureOpen, eventComposerOpen, selection])\n\n  useEffect(() => {\n    function refreshHabits() {\n      setHabitDefs(loadHabitDefsFromStorage())\n    }\n    window.addEventListener(HABITS_UPDATED_EVENT, refreshHabits)\n    window.addEventListener('storage', refreshHabits)\n    return () => {\n      window.removeEventListener(HABITS_UPDATED_EVENT, refreshHabits)\n      window.removeEventListener('storage', refreshHabits)\n    }\n  }, [])\n\n  useEffect(() => {\n    const stored = loadTrackerDefs()\n    const byKey = new Map<string, TrackerDef>()\n    for (const def of stored) byKey.set(def.key, def)\n\n    let changed = false\n    for (const e of events) {\n      if (e.kind !== 'log') continue\n      if (e.trackerKey?.startsWith('habit:')) continue\n      const key = (e.trackerKey ?? '').trim().toLowerCase()\n      if (key && !byKey.has(key)) {\n        byKey.set(key, buildTrackerDef({ key }))\n        changed = true\n      }\n      for (const tag of e.tags ?? []) {\n        const clean = tag.replace(/^#/, '').trim().toLowerCase()\n        if (!clean || clean === 'habit') continue\n        if (!byKey.has(clean)) {\n          byKey.set(clean, buildTrackerDef({ key: clean }))\n          changed = true\n        }\n      }\n    }\n\n    const next = Array.from(byKey.values()).slice(0, 24)\n    if (changed) saveTrackerDefs(next)\n    setTrackerDefs(next)\n  }, [events])\n\n  useEffect(() => {\n    setTagDraft('')\n    setPeopleDraft('')\n    setLocationDraft('')\n    setContextDraft('')\n    setSkillDraft('')\n  }, [selection.kind, selection.id])\n\n  useEffect(() => {\n    if (!eventComposerOpen) return\n    setComposerTagDraft('')\n    setComposerPeopleDraft('')\n    setComposerLocationDraft('')\n    setComposerListening(false)\n    setComposerInterim('')\n  }, [eventComposerOpen])\n\n  const [workspace, setWorkspace] = useState<PaneState>(() => {\n    const dashId = makeTabId('dashboard')\n    const notesId = makeTabId('notes')\n    const tasksId = makeTabId('tasks')\n    const calendarId = makeTabId('calendar')\n    return {\n      tabs: [\n        { id: dashId, title: defaultTabTitle('dashboard'), view: 'dashboard' },\n        { id: notesId, title: defaultTabTitle('notes'), view: 'notes' },\n        { id: tasksId, title: defaultTabTitle('tasks'), view: 'tasks' },\n        { id: calendarId, title: defaultTabTitle('calendar'), view: 'calendar' },\n      ],\n      activeTabId: notesId,\n    }\n  })\n\n  useEffect(() => {\n    const view = getActiveTab(workspace)?.view\n    if (view && rightPanelHideViews.has(view)) {\n      setRightCollapsed(true)\n    }\n  }, [rightPanelHideViews, workspace.activeTabId, workspace.tabs])\n\n  async function refreshAll() {\n    const [c, t, e] = await Promise.all([listInboxCaptures(), listTasks(), listEvents()])\n    setCaptures(c)\n    setTasks(t)\n    setEvents(e)\n  }\n\n  useEffect(() => {\n    void refreshAll()\n  }, [])\n\n  useEffect(() => {\n    const { rules } = loadTaxonomyRules()\n    taxonomyRulesRef.current = rules\n    function onRulesChanged() {\n      taxonomyRulesRef.current = loadTaxonomyRules().rules\n    }\n    window.addEventListener(TAXONOMY_RULES_CHANGED_EVENT, onRulesChanged)\n    return () => window.removeEventListener(TAXONOMY_RULES_CHANGED_EVENT, onRulesChanged)\n  }, [])\n\n  function openCapture(opts?: { attachEventId?: string | null }) {\n    const nowMs = Date.now()\n    const attached = opts?.attachEventId ? events.find((e) => e.id === opts.attachEventId) ?? null : null\n    const activeTab = getActiveTab(workspace)\n    let anchorMs = nowMs\n    if (attached?.startAt) {\n      anchorMs = attached.startAt\n    } else if (activeTab?.view === 'calendar') {\n      const base = new Date(agendaDate)\n      const now = new Date(nowMs)\n      base.setHours(now.getHours(), now.getMinutes(), 0, 0)\n      anchorMs = base.getTime()\n    }\n    setCaptureAnchorMs(anchorMs)\n    setCaptureProgress([])\n    setCaptureReturnView(activeTab?.view ?? null)\n    setCaptureAttachEventId(opts?.attachEventId ?? null)\n    setCaptureOpen(true)\n  }\n\n  async function onUpdateCapture(id: string, rawText: string) {\n    await updateCaptureText(id, rawText)\n    setCaptures((prev) => prev.map((c) => (c.id === id ? { ...c, rawText } : c)))\n  }\n\n  function appendTimestampedLine(existing: string | null | undefined, atMs: number, text: string) {\n    const trimmed = text.trim()\n    if (!trimmed) return existing ?? ''\n    const d = new Date(atMs)\n    const hh = String(d.getHours()).padStart(2, '0')\n    const mm = String(d.getMinutes()).padStart(2, '0')\n    const line = `- [${hh}:${mm}] ${trimmed}`\n    const base = (existing ?? '').trimEnd()\n    return base ? `${base}\\n${line}` : line\n  }\n\n  function noteItemTokenId(notes?: string | null) {\n    const match = notes?.match(/\\btoken:([A-Za-z0-9_-]+)\\b/)\n    return match?.[1] ?? null\n  }\n\n  function normalizeTaskTitle(raw: string) {\n    return raw.trim().toLowerCase().replace(/\\s+/g, ' ')\n  }\n\n  function appendTokenToNotes(notes: string | null | undefined, tokenId: string) {\n    const base = notes ?? ''\n    if (!tokenId) return base\n    const tokenRe = new RegExp(String.raw`\\btoken:${escapeRegExp(tokenId)}\\b`)\n    if (tokenRe.test(base)) return base\n    const trimmed = base.trimEnd()\n    return trimmed ? `${trimmed}\\n token:${tokenId}` : `token:${tokenId}`\n  }\n\n  const NOTE_ITEM_INLINE_RE = /\\{(task|habit):([^\\s}]+)[^}]*\\}/i\n\n  function detectInlineItemKind(rawLine: string): NoteItemKind | null {\n    const tokenMatch = rawLine.match(NOTE_ITEM_INLINE_RE)\n    if (tokenMatch?.[1]) return tokenMatch[1] as NoteItemKind\n    if (/#habit\\b/i.test(rawLine)) return 'habit'\n    if (/#task\\b/i.test(rawLine)) return 'task'\n    return null\n  }\n\n  function deriveNoteItemTitle(rawLine: string) {\n    const cleaned = rawLine\n      .replace(/\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g, '')\n      .replace(/[#@!*^$~][^\\s{]+\\{[^}]+\\}/g, '')\n      .replace(/\\s+/g, ' ')\n      .trim()\n    return cleaned.replace(/^[-*+]\\s*(?:\\[[ xX]\\]\\s*)?/, '').replace(/\\s+#(?:task|habit)\\b/gi, '').trim()\n  }\n\n  function makeNoteItemTokenId(kind: NoteItemKind, title: string) {\n    const slug = title\n      .toLowerCase()\n      .replace(/[^a-z0-9]+/g, '-')\n      .replace(/^-+|-+$/g, '')\n      .slice(0, 32) || 'item'\n    return `${kind}_${slug}_${Date.now().toString(36)}_${Math.random().toString(36).slice(2, 6)}`\n  }\n\n  function ensureNoteItemTokenInNotes(\n    notes: string | null | undefined,\n    lineIndex: number | null | undefined,\n    kind: NoteItemKind,\n    title: string,\n  ) {\n    const raw = notes ?? ''\n    if (lineIndex == null) return { notes: raw, tokenId: '', line: '' }\n    const lines = raw.split(/\\r?\\n/)\n    const line = lines[lineIndex] ?? ''\n    const match = line.match(NOTE_ITEM_INLINE_RE)\n    if (match?.[2]) return { notes: raw, tokenId: match[2], line }\n    const tokenId = makeNoteItemTokenId(kind, title)\n    const token = `{${kind}:${tokenId}}`\n    lines[lineIndex] = line.trimEnd() ? `${line.trimEnd()} ${token}` : token\n    return { notes: lines.join('\\n'), tokenId, line: lines[lineIndex] ?? line }\n  }\n\n  function formatNoteItemTimestamp(ms: number) {\n    const d = new Date(ms)\n    const yyyy = d.getFullYear()\n    const mm = String(d.getMonth() + 1).padStart(2, '0')\n    const dd = String(d.getDate()).padStart(2, '0')\n    const hh = String(d.getHours()).padStart(2, '0')\n    const min = String(d.getMinutes()).padStart(2, '0')\n    return `${yyyy}-${mm}-${dd}T${hh}:${min}`\n  }\n\n  function upsertNoteItemMeta(line: string, key: string, value: string) {\n    const match = line.match(NOTE_ITEM_INLINE_RE)\n    if (!match) return line\n    const kind = match[1]\n    const tokenId = match[2]\n    const meta = (match[3] ?? '').trim()\n    const keyRe = new RegExp(String.raw`\\b${key}:[^\\s}]+`)\n    const nextMeta = keyRe.test(meta)\n      ? meta.replace(keyRe, `${key}:${value}`)\n      : `${meta} ${key}:${value}`.trim()\n    const replacement = `{${kind}:${tokenId}${nextMeta ? ` ${nextMeta}` : ''}}`\n    return line.replace(match[0], replacement)\n  }\n\n  function removeNoteItemMeta(line: string, key: string) {\n    const match = line.match(NOTE_ITEM_INLINE_RE)\n    if (!match) return line\n    const kind = match[1]\n    const tokenId = match[2]\n    const meta = (match[3] ?? '').trim()\n    const keyRe = new RegExp(String.raw`\\s*\\b${key}:[^\\s}]+`)\n    const nextMeta = meta.replace(keyRe, '').trim()\n    const replacement = `{${kind}:${tokenId}${nextMeta ? ` ${nextMeta}` : ''}}`\n    return line.replace(match[0], replacement)\n  }\n\n  function updateNoteItemLine(\n    notes: string | null | undefined,\n    lineIndex: number | null | undefined,\n    update: (line: string) => string,\n  ) {\n    const raw = notes ?? ''\n    if (lineIndex == null) return { notes: raw, line: '' }\n    const lines = raw.split(/\\r?\\n/)\n    const line = lines[lineIndex] ?? ''\n    const nextLine = update(line)\n    lines[lineIndex] = nextLine\n    return { notes: lines.join('\\n'), line: nextLine }\n  }\n\n  function extractNoteItemLine(notes: string | null | undefined, lineIndex: number) {\n    const lines = (notes ?? '').split(/\\r?\\n/)\n    return lines[lineIndex] ?? ''\n  }\n\n  function extractLineTokenCollections(rawLine: string) {\n    const cleaned = rawLine.replace(/\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g, '')\n    return toTokenCollections(extractInlineTokens(cleaned))\n  }\n\n  function appendMarkdownBlock(existing: string | null | undefined, block: string) {\n    const trimmed = block.trim()\n    if (!trimmed) return (existing ?? '').trimEnd()\n    const base = (existing ?? '').trimEnd()\n    return base ? `${base}\\n\\n---\\n\\n${trimmed}` : trimmed\n  }\n\n  function normalizeTaskChecklistNotes(notes: string | null | undefined) {\n    const raw = notes ?? ''\n    if (!raw.trim()) return raw\n    const lines = raw.split(/\\r?\\n/)\n    let changed = false\n    const next = lines.map((line) => {\n      const trimmed = line.trimStart()\n      if (!/^[-*+]\\s+/.test(trimmed)) return line\n      if (/^[-*+]\\s*\\[[ xX]\\]\\s+/.test(trimmed)) return line\n      if (!/(?:\\{task:[^}]+\\}|\\{habit:[^}]+\\}|#task\\b|#habit\\b)/i.test(line)) return line\n      const indent = line.match(/^\\s*/)?.[0] ?? ''\n      const rest = trimmed.replace(/^[-*+]\\s+/, '')\n      changed = true\n      return `${indent}- [ ] ${rest}`\n    })\n    return changed ? next.join('\\n') : raw\n  }\n\n  function inferDifficultyFromText(text: string) {\n    const t = text.toLowerCase()\n    if (/\\bmarathon|half[-\\s]?marathon\\b/.test(t)) return 10\n    const miles = t.match(/\\b(\\d+(?:\\.\\d+)?)\\s*(mi|mile|miles|km|kilometer|kilometers)\\b/)\n    if (miles?.[1]) {\n      const dist = Number(miles[1])\n      if (Number.isFinite(dist)) {\n        if (dist >= 10) return 9\n        if (dist >= 5) return 8\n        if (dist >= 3) return 7\n      }\n    }\n    const reps = t.match(/\\b(\\d{2,})\\s*(pushups|situps|burpees|squats)\\b/)\n    if (reps?.[1]) {\n      const count = Number(reps[1])\n      if (Number.isFinite(count)) {\n        if (count >= 200) return 9\n        if (count >= 100) return 8\n        if (count >= 50) return 7\n      }\n    }\n    if (/\\b(brutal|exhausting|wrecked|destroyed)\\b/.test(t)) return 9\n    if (/\\b(hard|tough|intense|stressful|rough)\\b/.test(t)) return 8\n    if (/\\b(challenging)\\b/.test(t)) return 7\n    if (/\\b(workout|gym|lift|lifting|run|running|cardio|training)\\b/.test(t)) return 6\n    if (/\\b(normal|okay)\\b/.test(t)) return 5\n    if (/\\b(easy|light|chill)\\b/.test(t)) return 3\n    return null\n  }\n\n  function inferImportanceFromText(text: string) {\n    const t = text.toLowerCase()\n    if (/\\b(critical|urgent|life[-\\s]?changing)\\b/.test(t)) return 10\n    if (/\\b(deadline|exam|interview|surgery|presentation)\\b/.test(t)) return 9\n    if (/\\b(important|major|big|huge|milestone)\\b/.test(t)) return 8\n    if (/\\b(work|clinic|patients|meeting|rounds|inpatient)\\b/.test(t)) return 7\n    if (/\\b(good|productive)\\b/.test(t)) return 6\n    if (/\\b(minor|small|trivial)\\b/.test(t)) return 3\n    return null\n  }\n\n  function inferCharacterFromText(text: string, tags: string[] = []) {\n    const t = `${text} ${tags.join(' ')}`.toLowerCase()\n    const out = new Set<(typeof CHARACTER_KEYS)[number]>()\n    if (/\\b(workout|gym|lift|weights|strength|pushups|squats)\\b/.test(t)) out.add('STR')\n    if (/\\b(run|cardio|walk|stairs|endurance|long)\\b/.test(t)) out.add('CON')\n    if (/\\b(study|read|reading|learn|code|research|write|writing)\\b/.test(t)) out.add('INT')\n    if (/\\b(meet|meeting|call|talk|chat|social|family|friends)\\b/.test(t)) out.add('PER')\n    return [...out]\n  }\n\n  function pointsForEventAt(ev: CalendarEvent, nowMs: number) {\n    const base = basePoints(ev.importance, ev.difficulty)\n    if (base <= 0) return 0\n    const endAt = ev.active ? nowMs : ev.endAt\n    const minutes = Math.max(0, Math.round((endAt - ev.startAt) / (60 * 1000)))\n    const mult = multiplierFor(ev.goal ?? null, ev.project ?? null)\n    return pointsForMinutes(base, minutes, mult)\n  }\n\n  function autoFillEventFromText(ev: CalendarEvent) {\n    const base = `${ev.title ?? ''}\\n${ev.notes ?? ''}`.trim()\n    if (!base) return\n    const detectedTags = extractTagTokens(base).map((t) => normalizeHashTag(t))\n    const mergedTags = uniqStrings([...(ev.tags ?? []), ...detectedTags].map(normalizeHashTag).filter(Boolean))\n    const mentions = extractAtMentions(base).map((m) => m.raw)\n    const nextPeople = uniqStrings([...(ev.people ?? []), ...mentions])\n    const duration = extractDurationToken(base)\n    const nextEstimate = ev.estimateMinutes ?? duration ?? null\n    const inferred = inferCategorySubcategoryLoose(base, mergedTags)\n    const nextImportance = ev.importance ?? inferImportanceFromText(base) ?? 5\n    const nextDifficulty = ev.difficulty ?? inferDifficultyFromText(base) ?? 5\n    commitEvent({\n      ...ev,\n      tags: mergedTags,\n      people: nextPeople,\n      estimateMinutes: nextEstimate,\n      category: ev.category ?? inferred.category ?? null,\n      subcategory: ev.subcategory ?? inferred.subcategory ?? null,\n      importance: nextImportance,\n      difficulty: nextDifficulty,\n    })\n  }\n\n  function autoFillComposerFromText() {\n    const base = `${eventComposer.title ?? ''}\\n${eventComposer.notes ?? ''}`.trim()\n    if (!base) return\n    const detectedTags = extractTagTokens(base).map((t) => normalizeHashTag(t))\n    const mergedTags = uniqStrings([...composerTagList, ...detectedTags].map(normalizeHashTag).filter(Boolean))\n    const mentions = extractAtMentions(base).map((m) => m.raw)\n    const nextPeople = uniqStrings([...composerPeopleList, ...mentions])\n    const duration = extractDurationToken(base)\n    const inferred = inferCategorySubcategoryLoose(base, mergedTags)\n    const nextImportance = eventComposer.importance ?? inferImportanceFromText(base) ?? 5\n    const nextDifficulty = eventComposer.difficulty ?? inferDifficultyFromText(base) ?? 5\n    setEventComposer((prev) => ({\n      ...prev,\n      tagsRaw: mergedTags.join(' '),\n      peopleRaw: nextPeople.join(', '),\n      estimateMinutesRaw: prev.estimateMinutesRaw || (duration ? String(duration) : prev.estimateMinutesRaw),\n      category: prev.category || inferred.category || '',\n      subcategory: prev.subcategory || inferred.subcategory || '',\n      importance: nextImportance,\n      difficulty: nextDifficulty,\n    }))\n  }\n\n\t  function openEventComposer(seed: CreateEventSeed) {\n\t    const startAt = seed.startAt\n\t    const endAt = Math.max(seed.endAt, startAt + 5 * 60 * 1000)\n\t    setEventComposer({\n\t      title: '',\n\t      startAt,\n\t      endAt,\n\t      kind: seed.kind ?? 'event',\n\t      allDay: false,\n\t      active: false,\n\t      icon: null,\n\t      color: null,\n\t      tagsRaw: '',\n\t      location: '',\n\t      peopleRaw: '',\n\t      skillsRaw: '',\n      character: [],\n      category: '',\n      subcategory: '',\n      importance: 5,\n      difficulty: 5,\n      estimateMinutesRaw: estimateMinutesFromRange(startAt, endAt),\n      notes: '',\n      taskId: seed.taskId ?? null,\n\t      trackerKey: '',\n\t    })\n\t    setEventComposerOpen(true)\n\t  }\n\n  function commitTask(next: Task) {\n    setTasks((prev) => prev.map((t) => (t.id === next.id ? next : t)))\n    void upsertTask(next)\n    setEvents((prev) => {\n      let changed = false\n      const updates: CalendarEvent[] = []\n      const nextEvents = prev.map((e) => {\n        if (e.taskId !== next.id) return e\n        const completedAt = next.status === 'done' ? e.completedAt ?? Date.now() : null\n        if (completedAt === e.completedAt) return e\n        const updated = { ...e, completedAt, kind: (e.kind ?? 'task') as any }\n        updates.push(updated)\n        changed = true\n        return updated\n      })\n      for (const ev of updates) void upsertEvent(ev)\n      return changed ? nextEvents : prev\n    })\n  }\n\n  async function stopOtherActiveEvents(excludeId?: string | null, endAtOverride?: number | null) {\n    const now = Date.now()\n    const stopAt = endAtOverride ?? now\n    const activeEvents = events.filter(\n      (e) => e.active && e.id !== excludeId && e.kind !== 'log' && e.kind !== 'episode',\n    )\n    if (!activeEvents.length) return\n    const updates = activeEvents.map((ev) => ({\n      ...ev,\n      active: false,\n      endAt: Math.max(ev.startAt, stopAt),\n    }))\n    for (const next of updates) await upsertEvent(next)\n    setEvents((prev) => prev.map((e) => updates.find((u) => u.id === e.id) ?? e))\n  }\n\n  function resolveTrackerLogAtMs(ev: CalendarEvent) {\n    const now = Date.now()\n    const startAt = Number.isFinite(ev.startAt) ? ev.startAt : now\n    const endAt = Number.isFinite(ev.endAt) ? ev.endAt : startAt\n    if (now < startAt) return startAt\n    if (now > endAt) return endAt\n    return now\n  }\n\n  function scheduleTrackerExtractionFromEventNotes(ev: CalendarEvent) {\n    if (ev.kind === 'log') return\n    const text = (ev.notes ?? '').trim()\n    if (!text) return\n    if (!extractTrackerTokens(text).length) return\n    const existing = trackerExtractionTimeoutRef.current[ev.id]\n    if (existing) window.clearTimeout(existing)\n    trackerExtractionTimeoutRef.current[ev.id] = window.setTimeout(() => {\n      delete trackerExtractionTimeoutRef.current[ev.id]\n      void createTrackerLogsFromText({\n        text,\n        atMs: resolveTrackerLogAtMs(ev),\n        sourceNoteId: ev.id,\n        parentEventId: ev.id,\n        events: eventsRef.current,\n        ensureTrackerDefinition,\n        defaultTrackerUnit,\n        findBestActiveEventAt,\n        createEvent,\n        setEvents,\n      })\n    }, 400)\n  }\n\n  function commitEvent(next: CalendarEvent) {\n    const current = events.find((e) => e.id === next.id)\n    const notesChanged = current?.notes !== next.notes\n    const shouldStopOthers =\n      next.active &&\n      !current?.active &&\n      next.kind !== 'log' &&\n      next.kind !== 'episode'\n    if (shouldStopOthers) void stopOtherActiveEvents(next.id, next.startAt)\n    setEvents((prev) => prev.map((e) => (e.id === next.id ? next : e)))\n    void upsertEvent(next)\n    if (notesChanged) scheduleTrackerExtractionFromEventNotes(next)\n  }\n\n  function onUpdateEvent(eventId: string, patch: Partial<CalendarEvent>) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev) return\n    commitEvent({ ...ev, ...patch })\n  }\n\n  function openView(view: WorkspaceViewKey) {\n    if (view === 'calendar') {\n      setRightCollapsed(false)\n      setRightMode('details')\n    }\n    setWorkspace((p) => {\n      const existing = p.tabs.find((t) => t.view === view)\n      if (existing) return { ...p, activeTabId: existing.id }\n      const id = makeTabId(view)\n      const nextTab: WorkspaceTab = { id, title: defaultTabTitle(view), view }\n      return { tabs: [...p.tabs, nextTab], activeTabId: id }\n    })\n  }\n\n  function openHabitReports(habitId: string) {\n    try {\n      localStorage.setItem(REPORTS_HABIT_ID_KEY, habitId)\n    } catch {\n      // ignore\n    }\n    openView('reports')\n  }\n\n  function openGoalDetail(goalName: string) {\n    setSelectedGoal(goalName)\n    setWorkspace((p) => {\n      const existing = p.tabs.find((t) => t.view === 'goal-detail')\n      const title = goalName || defaultTabTitle('goal-detail')\n      if (existing) {\n        const nextTabs = p.tabs.map((t) => (t.id === existing.id ? { ...t, title } : t))\n        return { tabs: nextTabs, activeTabId: existing.id }\n      }\n      const id = makeTabId('goal-detail')\n      const nextTab: WorkspaceTab = { id, title, view: 'goal-detail' }\n      return { tabs: [...p.tabs, nextTab], activeTabId: id }\n    })\n  }\n\n  function openProjectDetail(projectName: string) {\n    setSelectedProject(projectName)\n    openView('projects')\n  }\n\n  function openTrackerDetail(trackerKey: string) {\n    setSelectedTrackerKey(trackerKey)\n    openView('trackers')\n  }\n\n  function closeTab(id: string) {\n    setWorkspace((p) => {\n      const nextTabs = p.tabs.filter((t) => t.id !== id)\n      const nextActive = p.activeTabId === id ? nextTabs[0]?.id ?? '' : p.activeTabId\n      return { tabs: nextTabs.length ? nextTabs : p.tabs, activeTabId: nextActive }\n    })\n  }\n\n  function onPinnedDragStart(key: string, e: DragEvent) {\n    setDragPinnedKey(key)\n    e.dataTransfer.setData('text/pinned-group', key)\n    e.dataTransfer.effectAllowed = 'move'\n  }\n\n  function onPinnedDrop(targetKey: string, e: DragEvent) {\n    e.preventDefault()\n    const dragged = dragPinnedKey ?? e.dataTransfer.getData('text/pinned-group')\n    if (!dragged || dragged === targetKey) return\n    const from = pinnedGroupOrder.indexOf(dragged)\n    const to = pinnedGroupOrder.indexOf(targetKey)\n    if (from < 0 || to < 0) return\n    const next = [...pinnedGroupOrder]\n    next.splice(from, 1)\n    next.splice(to, 0, dragged)\n    setPinnedGroupOrder(next)\n    setDragPinnedKey(null)\n  }\n\n  function onPinnedDragOver(e: DragEvent) {\n    e.preventDefault()\n  }\n\n  function getActiveTab(pane: PaneState) {\n    return pane.tabs.find((t) => t.id === pane.activeTabId) ?? pane.tabs[0]!\n  }\n\n  function onCreateTaskFromInput(input: { title: string; tags?: string[] }) {\n    void (async () => {\n      const task = await createTask({ title: input.title, tags: input.tags })\n      setTasks((prev) => [task, ...prev])\n      setSelection({ kind: 'task', id: task.id })\n      setRightCollapsed(false)\n      setRightMode('details')\n    })()\n  }\n\n  function onToggleTaskComplete(taskId: string) {\n    const t = tasks.find((x) => x.id === taskId)\n    if (!t) return\n    const nextStatus: TaskStatus = t.status === 'done' ? 'todo' : 'done'\n    commitTask({ ...t, status: nextStatus })\n  }\n\n  function onMoveTaskStatus(taskId: string, status: TaskStatus) {\n    const t = tasks.find((x) => x.id === taskId)\n    if (!t || t.status === status) return\n    commitTask({ ...t, status })\n  }\n\n  function onToggleTaskChecklistItem(taskId: string, lineIndex: number) {\n    const t = tasks.find((x) => x.id === taskId)\n    if (!t) return\n    const nextNotes = toggleChecklistLine(t.notes ?? '', lineIndex)\n    commitTask({ ...t, notes: nextNotes })\n\n    setEvents((prev) => {\n      const changed: CalendarEvent[] = []\n      const next = prev.map((e) => {\n        if (e.taskId !== taskId) return e\n        const updated = { ...e, notes: nextNotes }\n        changed.push(updated)\n        return updated\n      })\n      for (const ev of changed) void upsertEvent(ev)\n      return next\n    })\n  }\n\n  function onCreateEvent(input: {\n    title: string\n    startAt: number\n    endAt: number\n    kind?: CalendarEvent['kind']\n    taskId?: string | null\n    parentEventId?: string | null\n    allDay?: boolean\n    active?: boolean\n    tags?: string[]\n    contexts?: string[]\n    notes?: string | null\n    icon?: string | null\n    color?: string | null\n    estimateMinutes?: number | null\n    location?: string | null\n    people?: string[]\n    skills?: string[]\n    character?: string[]\n    category?: string | null\n    subcategory?: string | null\n    importance?: number | null\n    difficulty?: number | null\n    trackerKey?: string | null\n  }) {\n    void (async () => {\n      const ev = await createEvent({\n        title: input.title,\n        startAt: input.startAt,\n        endAt: input.endAt,\n        kind: input.kind,\n        taskId: input.taskId,\n        parentEventId: input.parentEventId,\n        allDay: input.allDay,\n        active: input.active,\n        tags: input.tags,\n        contexts: input.contexts,\n        notes: input.notes,\n        icon: input.icon,\n        color: input.color,\n        estimateMinutes: input.estimateMinutes,\n        location: input.location,\n\t        people: input.people,\n\t        skills: input.skills,\n\t        character: normalizeCharacterSelection(input.character),\n\t        category: input.category,\n\t        subcategory: input.subcategory,\n\t        importance: input.importance,\n\t        difficulty: input.difficulty,\n\t        trackerKey: input.trackerKey,\n\t      })\n      setEvents((prev) => [ev, ...prev])\n      setSelection({ kind: 'event', id: ev.id })\n      setRightCollapsed(false)\n      setRightMode('details')\n    })()\n  }\n\n  function onMoveEvent(eventId: string, startAt: number, endAt: number) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev) return\n    commitEvent({ ...ev, startAt, endAt })\n  }\n\n  function onToggleEventComplete(eventId: string) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev) return\n    const completing = !ev.completedAt\n    const completedAt = completing ? Date.now() : null\n    commitEvent({ ...ev, completedAt, kind: (ev.kind ?? 'event') as any })\n    if (ev.kind === 'task' && ev.taskId) {\n      const task = tasks.find((t) => t.id === ev.taskId)\n      if (task) commitTask({ ...task, status: completing ? 'done' : 'todo' })\n    }\n  }\n\n  async function stopActiveNoteSessions(parentEventId: string, excludeTokenId?: string | null) {\n    const now = Date.now()\n    const activeChildren = events.filter(\n      (e) => e.parentEventId === parentEventId && e.active && noteItemTokenId(e.notes ?? '') !== excludeTokenId,\n    )\n    if (!activeChildren.length) return\n    const updates: CalendarEvent[] = activeChildren.map((child) => ({\n      ...child,\n      active: false,\n      endAt: Math.max(child.startAt, now),\n    }))\n    for (const next of updates) await upsertEvent(next)\n    setEvents((prev) => prev.map((e) => updates.find((u) => u.id === e.id) ?? e))\n  }\n\n  function findNoteSubEvent(parentEventId: string, tokenId: string) {\n    return events.find((e) => e.parentEventId === parentEventId && noteItemTokenId(e.notes ?? '') === tokenId) ?? null\n  }\n\n  async function ensureNoteSubEvent(opts: {\n    parentEvent: CalendarEvent\n    tokenId: string\n    title: string\n    estimateMinutes?: number | null\n    tags: string[]\n    contexts: string[]\n    people: string[]\n    location: string | null\n    trackerKey?: string | null\n    active: boolean\n    startAt?: number\n  }) {\n    const now = Date.now()\n    const startAt = opts.startAt ?? now\n    const minutes = Math.max(1, Math.round(opts.estimateMinutes ?? 5))\n    const endAt = startAt + minutes * 60 * 1000\n    const existing = events.find(\n      (e) => e.parentEventId === opts.parentEvent.id && noteItemTokenId(e.notes ?? '') === opts.tokenId,\n    )\n    const baseEvent =\n      existing ??\n      (await createEvent({\n        title: opts.title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: opts.parentEvent.id,\n        tags: opts.tags,\n        contexts: opts.contexts,\n        entityIds: opts.parentEvent.entityIds ?? [],\n        active: opts.active,\n        category: opts.parentEvent.category,\n        subcategory: opts.parentEvent.subcategory,\n        goal: opts.parentEvent.goal ?? null,\n        project: opts.parentEvent.project ?? null,\n        importance: opts.parentEvent.importance ?? 5,\n        difficulty: opts.parentEvent.difficulty ?? 5,\n        estimateMinutes: opts.estimateMinutes ?? null,\n        location: opts.location,\n        people: opts.people,\n        trackerKey: opts.trackerKey ?? null,\n        notes: `token:${opts.tokenId}`,\n      }))\n\n    const next = await upsertEvent({\n      ...baseEvent,\n      title: opts.title,\n      startAt,\n      endAt,\n      active: opts.active,\n      tags: opts.tags,\n      contexts: opts.contexts,\n      people: opts.people,\n      location: opts.location,\n      trackerKey: opts.trackerKey ?? baseEvent.trackerKey ?? null,\n      notes: `token:${opts.tokenId}`,\n      parentEventId: opts.parentEvent.id,\n      kind: 'log',\n      category: opts.parentEvent.category,\n      subcategory: opts.parentEvent.subcategory,\n      goal: opts.parentEvent.goal ?? null,\n      project: opts.parentEvent.project ?? null,\n      importance: opts.parentEvent.importance ?? 5,\n      difficulty: opts.parentEvent.difficulty ?? 5,\n      estimateMinutes: opts.estimateMinutes ?? baseEvent.estimateMinutes ?? null,\n    })\n    setEvents((prev) => {\n      const existingIdx = prev.findIndex((e) => e.id === next.id)\n      if (existingIdx === -1) return [next, ...prev]\n      const copy = [...prev]\n      copy[existingIdx] = next\n      return copy\n    })\n    return next\n  }\n\n  async function onStartNoteTask(\n    eventId: string,\n    task: {\n      tokenId: string\n      title: string\n      estimateMinutes?: number | null\n      dueAt?: number | null\n      kind?: NoteItemKind\n      rawText?: string\n      lineIndex?: number | null\n    },\n  ) {\n    const ev = events.find((e) => e.id === eventId)\n    if (!ev || !task.title) return\n    const kind = task.kind ?? 'task'\n    let workingNotes = ev.notes ?? ''\n    let rawLine = task.rawText ?? task.title\n    let tokenId = task.tokenId?.trim() ?? ''\n\n    if (!NOTE_ITEM_INLINE_RE.test(rawLine)) {\n      const ensured = ensureNoteItemTokenInNotes(workingNotes, task.lineIndex ?? null, kind, task.title)\n      if (ensured.tokenId) {\n        tokenId = ensured.tokenId\n        rawLine = ensured.line || rawLine\n        if (ensured.notes !== workingNotes) {\n          const normalized = normalizeTaskChecklistNotes(ensured.notes)\n          workingNotes = normalized\n          commitEvent({ ...ev, notes: normalized })\n        }\n      }\n    }\n    if (!tokenId) return\n\n    if (task.lineIndex != null) {\n      const startStamp = formatNoteItemTimestamp(Date.now())\n      const stamped = updateNoteItemLine(workingNotes, task.lineIndex, (line) => {\n        if (/\\bstart:[^\\s}]+/.test(line)) return line\n        return upsertNoteItemMeta(line, 'start', startStamp)\n      })\n      if (stamped.notes !== workingNotes) {\n        workingNotes = stamped.notes\n        commitEvent({ ...ev, notes: stamped.notes })\n      }\n      rawLine = stamped.line || rawLine\n    }\n\n    const lineTokens = extractLineTokenCollections(rawLine)\n    const lineTags = lineTokens.tags.map((t) => normalizeHashTag(t))\n    const tags = uniqStrings([...(ev.tags ?? []), ...lineTags, kind === 'habit' ? '#habit' : '#task'])\n    const contexts = uniqStrings([...(ev.contexts ?? []), ...lineTokens.contexts])\n    const people = uniqStrings([...(ev.people ?? []), ...lineTokens.people])\n    const location = ev.location ?? (lineTokens.places.length ? lineTokens.places.join(', ') : null)\n\n    await stopActiveNoteSessions(eventId, tokenId)\n\n    if (kind === 'task') {\n      const existing = tasks.find(\n        (t) => t.parentEventId === eventId && noteItemTokenId(t.notes ?? '') === tokenId,\n      )\n      let target = existing ?? null\n      if (!target) {\n        const titleKey = normalizeTaskTitle(task.title)\n        const byTitle = tasks.find((t) => t.parentEventId === eventId && normalizeTaskTitle(t.title) === titleKey) ?? null\n        if (byTitle) {\n          const updated = await upsertTask({ ...byTitle, notes: appendTokenToNotes(byTitle.notes, tokenId) })\n          setTasks((prev) => prev.map((t) => (t.id === updated.id ? updated : t)))\n          target = updated\n        }\n      }\n      if (!target) {\n        const created = await createTask({\n          title: task.title,\n          status: 'todo',\n          tags,\n          contexts,\n          people,\n          location,\n          skills: ev.skills ?? [],\n          character: ev.character ?? [],\n          entityIds: ev.entityIds ?? [],\n          parentEventId: eventId,\n          category: ev.category ?? null,\n          subcategory: ev.subcategory ?? null,\n          importance: ev.importance ?? 5,\n          difficulty: ev.difficulty ?? 5,\n          estimateMinutes: task.estimateMinutes ?? null,\n          dueAt: task.dueAt ?? null,\n          goal: ev.goal ?? null,\n          project: ev.project ?? null,\n          sourceNoteId: ev.sourceNoteId ?? null,\n        })\n        const withToken = await upsertTask({ ...created, notes: `token:${tokenId}` })\n        setTasks((prev) => [withToken, ...prev])\n        target = withToken\n      }\n      const started = await startTask(target.id)\n      if (started) setTasks((prev) => prev.map((t) => (t.id === started.id ? started : t)))\n    }\n\n    let habitTrackerKey: string | null = null\n    let habitEstimate: number | null | undefined = task.estimateMinutes ?? null\n    if (kind === 'habit') {\n      const habit = detectHabitMentions(task.title, habitDefs)[0] ?? null\n      habitTrackerKey = habit ? `habit:${habit.id}` : null\n      habitEstimate = task.estimateMinutes ?? habit?.estimateMinutes ?? null\n    }\n\n    await ensureNoteSubEvent({\n      parentEvent: ev,\n      tokenId,\n      title: task.title,\n      estimateMinutes: habitEstimate ?? null,\n      tags,\n      contexts,\n      people,\n      location,\n      trackerKey: habitTrackerKey,\n      active: true,\n    })\n  }\n\n  async function onToggleEventNoteChecklist(ev: CalendarEvent, lineIndex: number) {\n    let rawLine = extractNoteItemLine(ev.notes, lineIndex)\n    const baseMeta = parseNoteItemMeta(rawLine)\n    const inferredKind = baseMeta?.kind ?? detectInlineItemKind(rawLine)\n    let workingNotes = ev.notes ?? ''\n    let tokenId = baseMeta?.tokenId ?? ''\n    let meta = baseMeta\n\n    if (inferredKind && (!tokenId || !NOTE_ITEM_INLINE_RE.test(rawLine))) {\n      const ensured = ensureNoteItemTokenInNotes(workingNotes, lineIndex, inferredKind, deriveNoteItemTitle(rawLine))\n      if (ensured.notes !== workingNotes) {\n        workingNotes = ensured.notes\n        rawLine = ensured.line || rawLine\n      }\n      tokenId = ensured.tokenId || tokenId\n      meta = parseNoteItemMeta(rawLine) ?? meta\n    }\n\n    let nextNotes = toggleChecklistLine(workingNotes, lineIndex)\n    let nextLine = extractNoteItemLine(nextNotes, lineIndex)\n    const nextChecked = /^\\s*[-*+]\\s*\\[[xX]\\]\\s+/.test(nextLine)\n    if (tokenId) {\n      if (nextChecked) {\n        const endStamp = formatNoteItemTimestamp(Date.now())\n        const stamped = updateNoteItemLine(nextNotes, lineIndex, (line) => {\n          if (/\\bend:[^\\s}]+/.test(line)) return line\n          return upsertNoteItemMeta(line, 'end', endStamp)\n        })\n        nextNotes = stamped.notes\n        nextLine = stamped.line || nextLine\n      } else {\n        const cleaned = updateNoteItemLine(nextNotes, lineIndex, (line) => removeNoteItemMeta(line, 'end'))\n        nextNotes = cleaned.notes\n        nextLine = cleaned.line || nextLine\n      }\n    }\n\n    commitEvent({ ...ev, notes: nextNotes })\n\n    if (!inferredKind || !tokenId) return\n    const finalMeta =\n      meta ??\n      ({\n        kind: inferredKind,\n        tokenId,\n        title: deriveNoteItemTitle(nextLine),\n        estimateMinutes: null,\n        dueAt: null,\n        rawText: nextLine,\n      } as const)\n\n    const lineTokens = extractLineTokenCollections(nextLine)\n    const lineTags = lineTokens.tags.map((t) => normalizeHashTag(t))\n    const tags = uniqStrings([...(ev.tags ?? []), ...lineTags, finalMeta.kind === 'habit' ? '#habit' : '#task'])\n    const contexts = uniqStrings([...(ev.contexts ?? []), ...lineTokens.contexts])\n    const people = uniqStrings([...(ev.people ?? []), ...lineTokens.people])\n    const location = ev.location ?? (lineTokens.places.length ? lineTokens.places.join(', ') : null)\n\n    const existingSub = findNoteSubEvent(ev.id, tokenId)\n\n    if (finalMeta.kind === 'task') {\n      let target = tasks.find((t) => t.parentEventId === ev.id && noteItemTokenId(t.notes ?? '') === tokenId) ?? null\n      if (!target) {\n        const titleKey = normalizeTaskTitle(finalMeta.title)\n        const byTitle = tasks.find((t) => t.parentEventId === ev.id && normalizeTaskTitle(t.title) === titleKey) ?? null\n        if (byTitle) {\n          const updated = await upsertTask({ ...byTitle, notes: appendTokenToNotes(byTitle.notes, tokenId) })\n          setTasks((prev) => prev.map((t) => (t.id === updated.id ? updated : t)))\n          target = updated\n        }\n      }\n      if (!target && nextChecked) {\n        const created = await createTask({\n          title: finalMeta.title,\n          status: 'done',\n          tags,\n          contexts,\n          people,\n          location,\n          skills: ev.skills ?? [],\n          character: ev.character ?? [],\n          entityIds: ev.entityIds ?? [],\n          parentEventId: ev.id,\n          category: ev.category ?? null,\n          subcategory: ev.subcategory ?? null,\n          importance: ev.importance ?? 5,\n          difficulty: ev.difficulty ?? 5,\n          estimateMinutes: finalMeta.estimateMinutes ?? null,\n          dueAt: finalMeta.dueAt ?? null,\n          goal: ev.goal ?? null,\n          project: ev.project ?? null,\n          sourceNoteId: ev.sourceNoteId ?? null,\n        })\n        target = await upsertTask({ ...created, notes: `token:${tokenId}` })\n        setTasks((prev) => [target!, ...prev])\n      } else if (target) {\n        const updated = await upsertTask({ ...target, status: nextChecked ? 'done' : 'todo' })\n        setTasks((prev) => prev.map((t) => (t.id === updated.id ? updated : t)))\n      }\n    }\n\n    if (finalMeta.kind === 'habit') {\n      const habit = detectHabitMentions(finalMeta.title, habitDefs)[0] ?? null\n      const trackerKey = habit ? `habit:${habit.id}` : null\n\n      if (nextChecked) {\n        if (existingSub?.active) {\n          const stopped = await upsertEvent({ ...existingSub, active: false, endAt: Date.now() })\n          setEvents((prev) => prev.map((e) => (e.id === stopped.id ? stopped : e)))\n          return\n        }\n        await ensureNoteSubEvent({\n          parentEvent: ev,\n          tokenId,\n          title: finalMeta.title,\n          estimateMinutes: finalMeta.estimateMinutes ?? habit?.estimateMinutes ?? null,\n          tags,\n          contexts,\n          people,\n          location,\n          trackerKey,\n          active: false,\n          startAt: Date.now(),\n        })\n      } else if (existingSub) {\n        await deleteEvent(existingSub.id)\n        setEvents((prev) => prev.filter((e) => e.id !== existingSub.id))\n      }\n    } else if (!nextChecked && existingSub) {\n      await deleteEvent(existingSub.id)\n      setEvents((prev) => prev.filter((e) => e.id !== existingSub.id))\n    } else if (nextChecked) {\n      if (existingSub?.active) {\n        const stopped = await upsertEvent({ ...existingSub, active: false, endAt: Date.now() })\n        setEvents((prev) => prev.map((e) => (e.id === stopped.id ? stopped : e)))\n      } else if (!existingSub) {\n        await ensureNoteSubEvent({\n          parentEvent: ev,\n          tokenId,\n          title: finalMeta.title,\n          estimateMinutes: finalMeta.estimateMinutes ?? null,\n          tags,\n          contexts,\n          people,\n          location,\n          active: false,\n          startAt: Date.now(),\n        })\n      }\n    }\n  }\n\n  async function onSaveCapture() {\n    if (captureSaving) return\n    const text = captureDraft.trim()\n    if (!text) return\n    const { frontmatter, body } = extractFrontmatter(text)\n    const captureText = body.trim() ? body.trim() : text\n    const markdownTokens = collectMarkdownTokens(captureText)\n    setCaptureSaving(true)\n    setCaptureAiStatus('')\n    setCaptureError('')\n    setCaptureProgress([])\n\t    try {\n\n    const attachedCaptureEvent = captureAttachEventId ? events.find((e) => e.id === captureAttachEventId) ?? null : null\n    const anchorMs = attachedCaptureEvent?.startAt ?? captureAnchorMs ?? Date.now()\n\n    function normalizeTagName(tag: string) {\n      return tag.replace(/^#/, '').trim().toLowerCase()\n    }\n\n    function slugifyTag(raw: string) {\n      return raw\n        .toLowerCase()\n        .replace(/[^a-z0-9]+/g, '-')\n        .replace(/^-+|-+$/g, '')\n    }\n\n    function toTagTokenFromLabel(raw: string) {\n      const slug = slugifyTag(raw)\n      return slug ? `#${slug}` : ''\n    }\n\n    const tokenSeed = Date.now().toString(36)\n    let tokenCounter = 0\n    function makeTokenId(prefix: string, value: string) {\n      const slug = slugifyTag(value) || value.replace(/\\s+/g, '-').toLowerCase()\n      return `${prefix}_${slug}_${tokenSeed}_${tokenCounter++}`\n    }\n\n    function toInlineToken(prefix: string, type: string, value: string) {\n      const clean = value.trim()\n      if (!clean) return ''\n      const id = makeTokenId(type, clean)\n      return `${prefix}${clean}{${type}:${id}}`\n    }\n\n    function inferTrackerKeyFromText(title: string, tags?: string[] | null) {\n      const tagSet = new Set((tags ?? []).map((t) => normalizeTagName(t)))\n      const text = `${title} ${[...tagSet].join(' ')}`.toLowerCase()\n      const candidates = ['mood', 'energy', 'stress', 'pain', 'workout', 'period', 'bored', 'water']\n      for (const key of candidates) {\n        if (tagSet.has(key)) return key\n      }\n      if (/\\bmood\\b/.test(text)) return 'mood'\n      if (/\\b(happy|sad|angry|anxious|depressed|excited|great|good|okay|ok)\\b/.test(text)) return 'mood'\n      if (/\\benergy\\b/.test(text)) return 'energy'\n      if (/\\b(tired|exhausted|drained|wired|energized)\\b/.test(text)) return 'energy'\n    if (/\\bstress\\b/.test(text)) return 'stress'\n    if (/\\b(stressed|overwhelmed|anxious)\\b/.test(text)) return 'stress'\n    if (/\\bpain\\b/.test(text)) return 'pain'\n    if (/\\bworkout\\b/.test(text)) return 'workout'\n      if (/\\bwater\\b|\\bhydrat(?:e|ion|ing)?\\b/.test(text)) return 'water'\n      if (/\\bperiod\\b/.test(text)) return 'period'\n      if (/\\bbored\\b/.test(text)) return 'bored'\n      return null\n    }\n\n    const LOG_TRACKER_KEYS = new Set(['mood', 'energy', 'stress', 'pain', 'period', 'bored', 'water'])\n\n    function formatSegmentLine(atMs: number | null, label: string) {\n      const cleaned = label.trim()\n      if (!cleaned) return ''\n      if (atMs == null) return `- ${cleaned}`\n      const d = new Date(atMs)\n      const hh = String(d.getHours()).padStart(2, '0')\n      const mm = String(d.getMinutes()).padStart(2, '0')\n      return `- **${hh}:${mm}** - ${cleaned}`\n    }\n\n    function maybeSegmentNotes(notes: string | null | undefined, startAt: number, endAt: number) {\n      const raw = (notes ?? '').trim()\n      if (!raw) return notes ?? ''\n      if (/\\*\\*\\d{2}:\\d{2}\\*\\*|\\-\\s*\\[\\d{2}:\\d{2}\\]/.test(raw)) return raw\n      if (/^\\s*[-*]\\s+/m.test(raw)) return raw\n      const parts = raw\n        .split(/[\\n;]+/)\n        .map((p) => p.trim())\n        .filter(Boolean)\n      if (parts.length < 2) return raw\n      const span = endAt - startAt\n      if (!Number.isFinite(span) || span < 60 * 60 * 1000) return raw\n      const step = Math.max(5 * 60 * 1000, Math.floor(span / (parts.length + 1)))\n      return parts.slice(0, 5).map((p, i) => formatSegmentLine(startAt + step * (i + 1), p)).join('\\n')\n    }\n\n    function parseIsoMs(raw?: string | null) {\n      if (!raw) return null\n      const ms = new Date(raw).getTime()\n      return Number.isFinite(ms) ? ms : null\n    }\n\n    function segmentLabelForEvent(ev: { title?: string; sourceText?: string }) {\n      const title = (ev.title ?? '').trim()\n      const lowerTitle = title.toLowerCase()\n      const preferSource = !title || lowerTitle === 'event' || lowerTitle === 'work' || lowerTitle === 'clinic'\n      const raw = (preferSource ? ev.sourceText ?? '' : title).trim()\n      if (!raw) return 'Segment'\n      return raw\n        .replace(/^(?:i\\s+)?(?:did|was|went|got|started|finished|worked on)\\s+/i, '')\n        .replace(/\\s+/g, ' ')\n        .trim()\n    }\n\n\t    const fm = frontmatter ?? {}\n\t    const llmSettings = loadSettings()\n\t    const llmKey = (llmSettings.openAiKey ?? '').trim()\n\t    const llmParseModel = (llmSettings.parseModel ?? llmSettings.chatModel ?? 'gpt-4.1-mini').trim() || 'gpt-4.1-mini'\n\t    const fmTags = toStringList(fm.tags).map((t) => normalizeTagName(t)).filter(Boolean)\n\t    const fmPeople = toStringList(fm.people)\n\t      .map((p) => p.replace(/^@/, '').trim())\n\t      .filter(Boolean)\n\t    const fmContexts = toStringList(fm.contexts)\n\t      .map((c) => c.replace(/^\\+/, '').trim())\n\t      .filter(Boolean)\n\t    const fmCategory = typeof fm.category === 'string' ? fm.category.trim() : ''\n\t    const fmSubcategory = typeof fm.subcategory === 'string' ? fm.subcategory.trim() : ''\n\t    const fmGoal = typeof fm.goal === 'string' ? fm.goal.trim() : ''\n\t    const fmProject = typeof fm.project === 'string' ? fm.project.trim() : ''\n\t    const fmLocation = typeof fm.location === 'string' ? fm.location.trim() : ''\n\t    const fmImportance = typeof fm.importance === 'number' ? fm.importance : null\n\t    const fmDifficulty = typeof fm.difficulty === 'number' ? fm.difficulty : null\n\t    const fmDuration = typeof fm.durationMinutes === 'number' ? fm.durationMinutes : typeof fm.duration === 'number' ? fm.duration : null\n\t    const fmStartAt = typeof fm.startAt === 'string' ? new Date(fm.startAt).getTime() : null\n\t    const fmEndAt = typeof fm.endAt === 'string' ? new Date(fm.endAt).getTime() : null\n\t    const fmRules = Array.isArray(fm.rules) ? fm.rules : []\n\t    const taxonomyRules = fmRules\n\t      .map((r: any) => ({\n\t        match: typeof r?.match === 'string' ? r.match : '',\n\t        category: typeof r?.category === 'string' ? r.category : undefined,\n\t        subcategory: typeof r?.subcategory === 'string' ? r.subcategory : undefined,\n\t        tags: Array.isArray(r?.tags) ? r.tags.map((t: any) => String(t)).filter(Boolean) : undefined,\n\t      }))\n\t      .filter((r: any) => r.match)\n\t    const activeRules = taxonomyRules.length ? taxonomyRules : taxonomyRulesRef.current\n\n    const durationOverride = fmDuration ?? extractDurationToken(captureText)\n    const importanceOverride = fmImportance ?? extractImportanceToken(captureText)\n    const difficultyOverride = fmDifficulty ?? extractDifficultyToken(captureText)\n    const categoryOverride = fmCategory ? toTitleCase(fmCategory) : null\n    const subcategoryOverride = fmSubcategory ? toTitleCase(fmSubcategory) : null\n    const goalOverride = fmGoal ? fmGoal : null\n    const projectOverride = fmProject ? fmProject : null\n\t    const explicitTimeInCapture = hasExplicitTimeRange(captureText)\n\t    const hasNowSignal = /\\b(currently|right now|at the moment)\\b/i.test(captureText)\n\n    function ruleTagsForText(text: string, rules: TaxonomyRule[]) {\n      const tags: string[] = []\n      for (const rule of rules) {\n        const rx = rule.match?.trim()\n        if (!rx) continue\n        try {\n          const re = new RegExp(rx, 'i')\n          if (!re.test(text)) continue\n        } catch {\n          continue\n        }\n        for (const t of rule.tags ?? []) {\n          const cleaned = normalizeTagName(String(t))\n          if (cleaned) tags.push(cleaned)\n        }\n      }\n      return tags\n    }\n\n    const storedMode = llmSettings.mode ?? 'local'\n    const llmMode = storedMode\n    const shouldTryLlm = llmMode !== 'local' && Boolean(llmKey)\n    const allowLocalFallback = llmMode === 'local' || llmMode === 'hybrid'\n    if (!llmKey && llmMode !== 'local') {\n      setCaptureProgress((p) => [...p, 'AI parsing disabled (no OpenAI key); using local parser'].slice(-10))\n    }\n    const natural = allowLocalFallback ? parseCaptureNatural(captureText, anchorMs) : { tasks: [], events: [] }\n    if (!allowLocalFallback) {\n      setCaptureProgress((p) => [...p, 'Parser mode: LLM (no local fallback)'].slice(-10))\n    }\n    if (allowLocalFallback) {\n      setCaptureProgress((p) => [...p, `Local parse: ${natural.events.length} event(s), ${natural.tasks.length} task(s)`].slice(-10))\n    }\n    const ruleTagNames = ruleTagsForText(captureText, activeRules)\n    const tagNames = new Set<string>(\n      [\n        ...extractTagTokens(captureText),\n        ...fmTags,\n        ...ruleTagNames,\n        ...markdownTokens.tags.map((t) => normalizeTagName(t)),\n      ].filter(Boolean),\n    )\n\t    for (const t of natural.tasks) {\n\t      for (const tag of t.tags ?? []) {\n\t        const name = normalizeTagName(tag)\n\t        if (name) tagNames.add(name)\n\t      }\n\t    }\n\t    for (const e of natural.events) {\n\t      for (const tag of e.tags ?? []) {\n\t        const name = normalizeTagName(tag)\n\t        if (name) tagNames.add(name)\n\t      }\n\t    }\n\n    const explicitTagNames = new Set<string>(\n      [\n        ...extractTagTokens(captureText),\n        ...fmTags,\n        ...ruleTagNames,\n        ...markdownTokens.tags.map((t) => normalizeTagName(t)),\n      ].filter(Boolean),\n    )\n\n    const lowerText = captureText.toLowerCase()\n    const periodStartSignal =\n      /\\b(started|starting|got)\\b.*\\bperiod\\b/.test(lowerText) || /\\bon (my )?period\\b/.test(lowerText) || /\\bmy period\\b.*\\b(started|began)\\b/.test(lowerText)\n    const periodEndSignal =\n      /\\bperiod\\b.*\\b(ended|over|finished)\\b/.test(lowerText) || /\\b(period ended|period is over|period is done)\\b/.test(lowerText)\n\n    const painRatingMatch = lowerText.match(/(\\d{1,2})\\s*\\/\\s*10/)\n    const painSignal = /\\b(pain|hurts|ache|aches|sore)\\b/.test(lowerText) || Boolean(painRatingMatch)\n    const painHealedSignal = /\\b(healed|pain[-\\s]?free|no longer hurts|doesn['\u2019]?t hurt anymore|back to normal)\\b/.test(lowerText)\n    const bodyPartMatch = lowerText.match(/\\bmy\\s+([a-z][a-z-]{1,20})\\s+(hurts|aches|is\\s+(sore|aching))\\b/)\n\n    const workoutStartSignal = /\\b(going to|gonna|start(?:ing)?|begin(?:ning)?|about to)\\b.*\\b(work\\s*out|workout)\\b/.test(lowerText)\n    const workoutEndSignal = /\\b(done|finished|ended|stop(?:ping)?)\\b.*\\b(work\\s*out|workout)\\b/.test(lowerText)\n    const boredSignal = /\\b(bored|boredom|boring)\\b/.test(lowerText)\n    const moodValue =\n      parseRatingNearText(lowerText, 'mood') ??\n      parseRatingNearText(lowerText, 'feeling') ??\n      parseRatingNearText(lowerText, 'feel') ??\n      inferMoodFromAdjectives(lowerText)\n    const energyValue =\n      parseRatingNearText(lowerText, 'energy') ??\n      inferEnergyFromAdjectives(lowerText)\n    const stressValue =\n      parseRatingNearText(lowerText, 'stress') ??\n      inferStressFromAdjectives(lowerText)\n\n    if (periodStartSignal || periodEndSignal) tagNames.add('period')\n    if (painSignal || painHealedSignal) tagNames.add('pain')\n    if (bodyPartMatch?.[1]) tagNames.add(bodyPartMatch[1])\n    if (workoutStartSignal || workoutEndSignal) tagNames.add('workout')\n    if (/\\b(work|shift)\\b/.test(lowerText)) tagNames.add('work')\n    if (/\\b(clinic|patients|inpatient|rounds)\\b/.test(lowerText)) tagNames.add('clinic')\n    if (/\\b(call|phone)\\b/.test(lowerText)) tagNames.add('call')\n    if (/\\b(bank|loan|mortgage|finance)\\b/.test(lowerText)) tagNames.add('finance')\n    if (/\\b(gym)\\b/.test(lowerText)) tagNames.add('gym')\n    if (/\\b(run|running|ran)\\b/.test(lowerText)) tagNames.add('run')\n    if (/\\b(ate|eat|eating|meal|breakfast|lunch|dinner|snack|protein)\\b/.test(lowerText)) tagNames.add('food')\n    if (/\\b(drink|drank|water|hydration|hydrate)\\b/.test(lowerText)) tagNames.add('hydration')\n    if (/\\b(sleep|nap)\\b/.test(lowerText)) tagNames.add('sleep')\n    if (boredSignal) tagNames.add('bored')\n    if (moodValue != null) tagNames.add('mood')\n    if (energyValue != null) tagNames.add('energy')\n    if (stressValue != null) tagNames.add('stress')\n\n    const implicitPeople = extractImplicitPeople(captureText)\n    const implicitPlaces = extractImplicitPlaces(captureText)\n    const implicitMoneyUsd = extractMoneyUsd(captureText)\n    const implicitShoppingItems = extractShoppingItems(captureText)\n    const trackerTokens = extractTrackerTokens(captureText)\n    const moodMentions = extractMoodMentions(captureText)\n    const habitMentions = detectHabitMentionsWithPolarity(captureText, habitDefs)\n    const habitHits = habitMentions.filter((m) => m.polarity === 'positive').map((m) => m.habit)\n    const localWorkout = parseWorkoutFromText(captureText)\n    const localMeal = parseMealFromText(captureText, { nowMs: anchorMs ?? Date.now() })\n    if (implicitMoneyUsd != null && Number.isFinite(implicitMoneyUsd)) tagNames.add('money')\n    if (implicitShoppingItems.length) tagNames.add('shopping')\n\n    const allTagTokens = [...tagNames].map((t) => `#${t}`)\n\n    const contextTokens = extractContextTokens(captureText)\n    const allContexts = uniqStrings([...contextTokens, ...fmContexts, ...markdownTokens.contexts])\n\n    const mentions = extractAtMentions(captureText)\n    const personCandidates: string[] = []\n    const placeMentions: string[] = []\n    const entityIds: string[] = []\n    const entityIdSet = new Set<string>()\n    if (fmLocation) placeMentions.push(fmLocation)\n\n    for (const tag of tagNames) {\n      const ent = await ensureEntity('tag', tag, `#${tag}`)\n      if (!entityIdSet.has(ent.id)) {\n        entityIdSet.add(ent.id)\n        entityIds.push(ent.id)\n      }\n    }\n\n    for (const p of fmPeople) {\n      if (!p) continue\n      personCandidates.push(p)\n    }\n\n    for (const p of markdownTokens.people) {\n      if (!p) continue\n      personCandidates.push(p)\n    }\n\n    for (const pl of markdownTokens.places) {\n      if (!pl) continue\n      placeMentions.push(pl)\n    }\n\n    for (const m of mentions) {\n      const lower = m.raw.toLowerCase()\n      const looksPerson = /\\b(with|call|text|dm|email)\\b/.test(m.before) || ['mom', 'dad', 'doctor', 'dr', 'alex'].includes(lower)\n      if (looksPerson) personCandidates.push(m.raw)\n      else placeMentions.push(m.raw)\n    }\n\n    for (const p of implicitPeople) {\n      if (!p) continue\n      personCandidates.push(p)\n    }\n\n    for (const pl of implicitPlaces) {\n      if (!pl) continue\n      placeMentions.push(pl)\n    }\n\n    function pickLocationForText(text: string) {\n      const hay = text.toLowerCase()\n      for (const pl of placeMentions) {\n        if (!pl) continue\n        if (hay.includes(pl.toLowerCase())) return pl\n      }\n      return null\n    }\n\n    function formatDateOnly(ms: number) {\n      const d = new Date(ms)\n      const yyyy = d.getFullYear()\n      const mm = String(d.getMonth() + 1).padStart(2, '0')\n      const dd = String(d.getDate()).padStart(2, '0')\n      return `${yyyy}-${mm}-${dd}`\n    }\n\n    function formatTimeOnly(ms: number) {\n      const d = new Date(ms)\n      const hh = String(d.getHours()).padStart(2, '0')\n      const mm = String(d.getMinutes()).padStart(2, '0')\n      return `${hh}:${mm}`\n    }\n\n    function summarizeCapture(text: string) {\n      const cleaned = text.replace(/\\s+/g, ' ').trim()\n      if (!cleaned) return 'Capture'\n      const sentence = cleaned.split(/[.!?]/)[0] ?? cleaned\n      const words = sentence.split(/\\s+/).filter(Boolean)\n      return words.slice(0, 10).join(' ')\n    }\n\n    function hasQuestionIntent(text: string) {\n      return /\\?|\\b(what|why|how|when|where|who|which|should|could|do i|do we|need to|how do i|how do we|what do i|what do we)\\b/i.test(text)\n    }\n\n    function stripNoteArtifacts(text: string) {\n      return text\n        .replace(/\\{(?:task|note|seg|event|meal|workout|tracker|habit):[^}]+\\}/g, '')\n        .replace(/\\[(?:event|task|meal|workout|tracker|habit)\\]/gi, '')\n        .replace(/\\s+/g, ' ')\n        .trim()\n    }\n\n    function splitCaptureDetails(text: string) {\n      const cleaned = stripNoteArtifacts(text)\n      if (!cleaned) return []\n      const parts = cleaned.match(/[^.!?]+[.!?]?/g) ?? [cleaned]\n      const trimmed = parts\n        .map((p) => p.trim())\n        .filter(Boolean)\n        .map((p) => (p.length > 180 ? `${p.slice(0, 177).trimEnd()}...` : p))\n      return uniqStrings(trimmed).slice(0, 8)\n    }\n\n    function splitNotesAndQuestions(text: string) {\n      const sentences = splitCaptureDetails(text)\n      const notes: string[] = []\n      const questions: string[] = []\n      const questionRe = /\\?|\\b(what|why|how|when|where|who|which|should|could|do i|do we|need to|how do i|how do we|what do i|what do we)\\b/i\n      for (const sentence of sentences) {\n        if (questionRe.test(sentence)) questions.push(sentence.replace(/\\?+$/, '?'))\n        else notes.push(sentence)\n      }\n      return { notes, questions }\n    }\n\n    function buildAttachedCaptureMarkdown(\n      nowMs: number,\n      opts?: { tasks?: Array<any>; events?: Array<any> },\n    ) {\n      const d = new Date(nowMs)\n      const hh = String(d.getHours()).padStart(2, '0')\n      const mm = String(d.getMinutes()).padStart(2, '0')\n      const summary = summarizeCapture(captureText)\n      const segmentToken = `{seg:${makeTokenId('seg', `${hh}${mm}`)}}`\n      const noteToken = `{note:${makeTokenId('note', `${hh}${mm}`)}}`\n      const typeTag = (label: string) => toInlineToken('#', 'tag', label)\n\n      const summaryLower = summary.toLowerCase()\n      const headerTags = Array.from(tagNames).filter((t) => {\n        if (explicitTagNames.has(t)) return true\n        if (!t) return false\n        const rx = new RegExp(String.raw`\\b${escapeRegExp(t)}\\b`, 'i')\n        return rx.test(summaryLower)\n      })\n      const tagTokens = headerTags.slice(0, 6).map((t) => toInlineToken('#', 'tag', t))\n      const peopleTokens = uniqStrings(personMentions).slice(0, 4).map((p) => toInlineToken('@', 'person', p))\n      const contextTokens = allContexts.slice(0, 4).map((c) => toInlineToken('*', 'ctx', c))\n      const placeTokens = uniqStrings(placeMentions).slice(0, 3).map((p) => toInlineToken('!', 'loc', p))\n      const goalToken = goalOverride ? [toInlineToken('^', 'goal', goalOverride)] : []\n      const projectToken = projectOverride ? [toInlineToken('$', 'project', projectOverride)] : []\n\n      const headerTokens = [...tagTokens, ...peopleTokens, ...contextTokens, ...placeTokens, ...goalToken, ...projectToken].filter(Boolean)\n      const header = `- **${hh}:${mm}** - ${summary}${headerTokens.length ? ` ${headerTokens.join(' ')}` : ''} ${segmentToken}`\n      const noteType = typeTag('note')\n      const questionType = hasQuestionIntent(captureText) ? typeTag('question') : ''\n      const { notes: detailNotes, questions: detailQuestions } = splitNotesAndQuestions(captureText)\n\n      const lines = [header]\n\n      if (detailNotes.length) {\n        lines.push(`  - Notes ${noteToken}${noteType ? ` ${noteType}` : ''}`)\n        lines.push(...detailNotes.map((line) => `    - ${line}`))\n      }\n      if (detailQuestions.length) {\n        lines.push(`  - Questions${questionType ? ` ${questionType}` : ''}`)\n        lines.push(...detailQuestions.map((line) => `    - ${line}`))\n      }\n\n      const taskSource = (opts?.tasks ?? []).filter((t) => typeof t?.title === 'string' && t.title.trim())\n      const taskCandidates = taskSource.length\n        ? taskSource.map((t) => ({\n            title: t.title,\n            estimateMinutes: t.estimateMinutes ?? durationOverride ?? null,\n            dueAt: t.dueAt ?? (t.dueAtIso ? new Date(t.dueAtIso).getTime() : null),\n            goal: t.goal ?? null,\n            project: t.project ?? null,\n          }))\n        : implicitShoppingItems.map((item) => ({\n            title: `Buy ${item}`,\n            estimateMinutes: 5,\n            dueAt: nowMs + 24 * 60 * 60 * 1000,\n            goal: null,\n            project: null,\n          }))\n\n      if (taskCandidates.length) {\n        lines.push('  - Tasks')\n        for (const task of taskCandidates.slice(0, 10)) {\n          const meta: string[] = []\n          if (task.estimateMinutes != null) meta.push(`est:${Math.round(task.estimateMinutes)}m`)\n          if (task.dueAt != null) meta.push(`due:${formatDateOnly(task.dueAt)}`)\n          const token = `{task:${makeTokenId('task', task.title)}${meta.length ? ` ${meta.join(' ')}` : ''}}`\n          const taskType = typeTag('task')\n          const chips = [\n            task.goal ? toInlineToken('^', 'goal', task.goal) : '',\n            task.project ? toInlineToken('$', 'project', task.project) : '',\n          ].filter(Boolean).join(' ')\n          lines.push(`    - [ ] ${task.title} ${token}${taskType ? ` ${taskType}` : ''}${chips ? ` ${chips}` : ''}`)\n        }\n      }\n\n      const eventSource = (opts?.events ?? []).filter((e) => typeof e?.title === 'string' && e.title.trim())\n      if (eventSource.length) {\n        let addedHeader = false\n        for (const ev of eventSource.slice(0, 6)) {\n          const kind = (ev.kind as any) ?? 'event'\n          if (kind === 'log') continue\n          const startMs = typeof ev.startAt === 'number' ? ev.startAt : (ev.startAtIso ? new Date(ev.startAtIso).getTime() : NaN)\n          const endMs = typeof ev.endAt === 'number' ? ev.endAt : (ev.endAtIso ? new Date(ev.endAtIso).getTime() : NaN)\n          if (!Number.isFinite(startMs) || !Number.isFinite(endMs)) continue\n          if (!addedHeader) {\n            lines.push('  - Events')\n            addedHeader = true\n          }\n          const eventMeta = [\n            `date:${formatDateOnly(startMs)}`,\n            `start:${formatTimeOnly(startMs)}`,\n            `end:${formatTimeOnly(endMs)}`,\n          ]\n          const eventToken = `{event:${makeTokenId('event', ev.title)} ${eventMeta.join(' ')}}`\n          const eventType = typeTag('event')\n          const eventTags = Array.isArray(ev.tags) ? ev.tags.map((t: string) => toInlineToken('#', 'tag', String(t).replace(/^#/, ''))) : []\n          const eventPeople = Array.isArray(ev.people) ? ev.people.map((p: string) => toInlineToken('@', 'person', String(p))) : []\n          const eventLoc = ev.location ? [toInlineToken('!', 'loc', String(ev.location))] : []\n          const eventGoal = ev.goal ? [toInlineToken('^', 'goal', String(ev.goal))] : []\n          const eventProject = ev.project ? [toInlineToken('$', 'project', String(ev.project))] : []\n          const eventChips = [eventType, ...eventTags, ...eventPeople, ...eventLoc, ...eventGoal, ...eventProject].filter(Boolean).join(' ')\n          lines.push(`    - [event] ${ev.title} ${eventToken}${eventChips ? ` ${eventChips}` : ''}`)\n        }\n      }\n\n      if (trackerTokens.length) {\n        const trackerLine = trackerTokens\n          .slice(0, 4)\n          .map((t) => `#${t.name}(${Math.round(t.value)}){tracker:${makeTokenId('tracker', t.name)}}`)\n          .join(' ')\n        const trackerType = typeTag('tracker')\n        lines.push('  - Trackers')\n        lines.push(`    - ${trackerLine}${trackerType ? ` ${trackerType}` : ''}`)\n      }\n\n      if (habitHits.length) {\n        lines.push('  - Habits')\n        for (const h of habitHits.slice(0, 4)) {\n          const minutes = Math.max(5, h.estimateMinutes ?? 15)\n          const habitType = typeTag('habit')\n          lines.push(`    - [x] ${h.name} {habit:${makeTokenId('habit', h.name)} value:${minutes}m}${habitType ? ` ${habitType}` : ''}`)\n        }\n      }\n\n      if (localMeal && localMeal.items?.length) {\n        const mealTitle = localMeal.items.length === 1 ? localMeal.items[0].name : localMeal.type ?? 'Meal'\n        const mealType = typeTag('meal')\n        lines.push('  - Meal')\n        lines.push(`    - [meal] ${mealTitle} {meal:${makeTokenId('meal', mealTitle)}}${mealType ? ` ${mealType}` : ''}`)\n        for (const item of localMeal.items.slice(0, 5)) {\n          lines.push(`      - item: ${item.name}`)\n        }\n      }\n\n      if (localWorkout && localWorkout.exercises?.length) {\n        const workoutType = typeTag('workout')\n        lines.push('  - Workout')\n        lines.push(`    - [workout] ${localWorkout.title ?? 'Workout'} {workout:${makeTokenId('workout', 'workout')}}${workoutType ? ` ${workoutType}` : ''}`)\n        for (const ex of localWorkout.exercises.slice(0, 4)) {\n          lines.push(`      - exercise: ${ex.name}`)\n        }\n      }\n\n      return lines.join('\\n').trim()\n    }\n\n    const personMentions = cleanPeopleList(personCandidates)\n    for (const p of personMentions) {\n      const ent = await ensureEntity('person', p, p)\n      if (!entityIdSet.has(ent.id)) {\n        entityIdSet.add(ent.id)\n        entityIds.push(ent.id)\n      }\n    }\n    for (const pl of uniqStrings(placeMentions)) {\n      const ent = await ensureEntity('place', pl, pl)\n      if (!entityIdSet.has(ent.id)) {\n        entityIdSet.add(ent.id)\n        entityIds.push(ent.id)\n      }\n    }\n\n    const detectedTags = allTagTokens.slice(0, 16).join(' ')\n    const detectedPeople = uniqStrings(personMentions).slice(0, 10).join(', ')\n    const detectedPlaces = uniqStrings(placeMentions).slice(0, 10).join(', ')\n    const detectedContexts = allContexts.slice(0, 10).join(', ')\n    if (detectedTags) setCaptureProgress((p) => [...p, `Detected tags: ${detectedTags}`].slice(-10))\n    if (detectedPeople) setCaptureProgress((p) => [...p, `Detected people: ${detectedPeople}`].slice(-10))\n    if (detectedPlaces) setCaptureProgress((p) => [...p, `Detected places: ${detectedPlaces}`].slice(-10))\n    if (detectedContexts) setCaptureProgress((p) => [...p, `Detected contexts: ${detectedContexts}`].slice(-10))\n\n\t    const nowMs = anchorMs\n\t    const wallNowMs = Date.now()\n\t    const attachedMode = Boolean(captureAttachEventId)\n\t    const note = await addInboxCapture(text, { createdAt: anchorMs, entityIds })\n\t    setCaptures((prev) => [note, ...prev])\n\t    setCaptureProgress((p) => [...p, 'Saved transcript note'].slice(-10))\n\n\t    let activeForLogsId: string | null | undefined = undefined\n\t    async function getActiveForLogsId() {\n\t      if (activeForLogsId !== undefined) return activeForLogsId\n\t      activeForLogsId = (await findBestActiveEventAt(nowMs))?.id ?? null\n\t      return activeForLogsId\n\t    }\n\n    const createdTaskKeys = new Set<string>()\n    const createdEventKeys = new Set<string>()\n    const makeTaskKey = (title: string) => title.trim().toLowerCase()\n    const makeEventKey = (title: string, startAt: number, endAt: number) => {\n      const q = 5 * 60 * 1000\n      const s = Math.round(startAt / q)\n      const d = Math.round(Math.max(q, endAt - startAt) / q)\n      return `${title.trim().toLowerCase()}@${s}+${d}`\n    }\n\n\t    let lastCreated: Selection = { kind: 'none' }\n\t    let navigateToMs: number | null = null\n\t    let capturePrimaryEventId: string | null = null\n\t    let mealEventId: string | null = null\n\t    let mealEvent: CalendarEvent | null = null\n\t    let captureHasNonLogEvent = false\n\t    let createdEventCount = 0\n\t    let createdLogCount = 0\n\t    let createdTaskCount = 0\n    const createdTrackerKeys = new Set<string>()\n    const allowEventCreation = !attachedMode\n    const allowTaskCreation = !attachedMode\n    if (attachedMode && captureAttachEventId) {\n      capturePrimaryEventId = captureAttachEventId\n    }\n\n    async function createTrackerLog(opts: {\n      key: string\n      value?: number | null\n      label?: string\n      icon?: IconName | null\n      color?: string | null\n      atMs?: number\n      dedupeKey?: string\n    }) {\n      const trackerKey = opts.key.trim().toLowerCase()\n      const dedupeKey = (opts.dedupeKey ?? trackerKey).trim().toLowerCase()\n      if (createdTrackerKeys.has(dedupeKey)) return null\n      const def = ensureTrackerDefinition({ key: trackerKey, label: opts.label, icon: opts.icon, color: opts.color })\n      const unit = def?.unit ?? defaultTrackerUnit(trackerKey)\n      let value = typeof opts.value === 'number' && Number.isFinite(opts.value) ? opts.value : null\n      if (value != null) {\n        if (unit.step && unit.step > 0) value = Math.round(value / unit.step) * unit.step\n        if (unit.min != null) value = Math.max(unit.min, value)\n        if (unit.max != null) value = Math.min(unit.max, value)\n      }\n      const label = def?.label ?? opts.label ?? trackerKey\n      const unitSuffix = unit.label && unit.label !== 'value' && unit.label !== 'score' ? ` ${unit.label}` : ''\n      const title = value != null ? `${label}: ${value}${unitSuffix}` : label\n      const startAt = opts.atMs ?? nowMs\n      const endAt = startAt + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) return null\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: [`#${trackerKey}`] })\n      const log = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        trackerKey,\n        icon: opts.icon ?? def?.icon ?? null,\n        color: opts.color ?? def?.color ?? null,\n        goal: goalOverride,\n        project: projectOverride,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n      })\n      setEvents((prev) => [log, ...prev])\n      createdEventKeys.add(makeEventKey(log.title, log.startAt, log.endAt))\n      createdTrackerKeys.add(dedupeKey)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${log.title}`].slice(-10))\n      return log\n    }\n\n    function normalizeHashTag(x: string) {\n      const t = x.trim()\n      if (!t) return ''\n      return t.startsWith('#') ? t : `#${t}`\n    }\n\n    function deriveKeywordTag(title: string, category?: string | null, subcategory?: string | null) {\n      const stop = new Set(['the', 'a', 'an', 'with', 'and', 'for', 'to', 'from', 'at', 'in', 'on', 'of', 'my'])\n      const base = title\n        .toLowerCase()\n        .split(/[^a-z0-9]+/)\n        .filter(Boolean)\n        .filter((w) => w.length > 3 && !stop.has(w))\n      const avoid = new Set([category ?? '', subcategory ?? ''].map((x) => x.toLowerCase()))\n      const picked = base.find((w) => !avoid.has(w))\n      return picked ? toTagTokenFromLabel(picked) : ''\n    }\n\n    function buildTagTokens(\n      baseTags: string[],\n      opts?: { category?: string | null; subcategory?: string | null; title?: string; location?: string | null; includeGlobals?: string[] },\n    ) {\n      const normalized = new Set((opts?.includeGlobals ?? []).map(normalizeHashTag).filter(Boolean))\n      for (const t of baseTags) normalized.add(normalizeHashTag(t))\n      const derived: string[] = []\n      if (opts?.category) derived.push(toTagTokenFromLabel(opts.category))\n      if (opts?.subcategory) derived.push(toTagTokenFromLabel(opts.subcategory))\n      if (opts?.location) derived.push(toTagTokenFromLabel(opts.location.split(/[,|/]/)[0] ?? opts.location))\n      if (opts?.title) derived.push(deriveKeywordTag(opts.title, opts?.category ?? null, opts?.subcategory ?? null))\n      for (const tag of derived) {\n        if (!tag) continue\n        if (normalized.size >= 5) break\n        normalized.add(tag)\n      }\n      if (normalized.size < 3) normalized.add('#general')\n      return Array.from(normalized)\n    }\n\n    function mergeWithGlobalTags(\n      tags: string[] | null | undefined,\n      opts?: { category?: string | null; subcategory?: string | null; title?: string; location?: string | null; includeGlobals?: boolean },\n    ) {\n      const includeGlobals = opts?.includeGlobals ? allTagTokens : []\n      return buildTagTokens(tags ?? [], { ...opts, includeGlobals })\n    }\n\n    function finalizeCategorizedTags(opts: {\n      title: string\n      tags?: string[] | null\n      current?: { category?: string | null; subcategory?: string | null }\n      location?: string | null\n      includeGlobals?: boolean\n    }) {\n      const baseTags = [...(opts.tags ?? [])]\n      const inferred = resolveCategory(opts.title, baseTags, opts.current, activeRules.length ? activeRules : undefined)\n      const mergedTags = mergeWithGlobalTags(baseTags, {\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        title: opts.title,\n        location: opts.location ?? null,\n        includeGlobals: opts.includeGlobals,\n      })\n      return { mergedTags, inferred }\n    }\n\n    function isMealEventCandidate(title: string, tags?: string[] | null) {\n      const lower = `${title ?? ''} ${(tags ?? []).join(' ')}`.toLowerCase()\n      if (/\\b(breakfast|lunch|dinner|snack|meal|brunch)\\b/.test(lower)) return true\n      return (tags ?? []).some((tag) => normalizeTagName(tag) === 'food')\n    }\n\n    function rememberMealEvent(ev: CalendarEvent) {\n      if (mealEventId) return\n      if (ev.kind === 'log') return\n      if (!isMealEventCandidate(ev.title, ev.tags)) return\n      mealEventId = ev.id\n      mealEvent = ev\n    }\n\n  function inferCategorySubcategory(title: string, tags: string[], baseRules?: Array<{ match: string; category?: string; subcategory?: string; tags?: string[] }>) {\n    const t = title.toLowerCase()\n    const tagSet = new Set(tags.map((x) => x.replace(/^#/, '').toLowerCase()))\n\n    let category: string | null = null\n    let subcategory: string | null = null\n\n    if (baseRules?.length) {\n      for (const rule of baseRules) {\n        const rx = rule.match?.trim()\n        if (!rx) continue\n        try {\n          const re = new RegExp(rx, 'i')\n          if (!re.test(title)) continue\n          if (rule.category && !category) category = rule.category\n          if (rule.subcategory && !subcategory) subcategory = rule.subcategory\n          if (rule.tags?.length) {\n            for (const tag of rule.tags) tagSet.add(tag.replace(/^#/, '').toLowerCase())\n          }\n          break\n        } catch {\n          // ignore malformed rule\n        }\n      }\n    }\n\n    for (const rawTag of tags) {\n      const cleaned = rawTag.replace(/^#/, '').trim()\n      if (!cleaned || !cleaned.includes('/')) continue\n      const [cat, sub] = cleaned.split('/', 2)\n\t\t        if (cat) category = toTitleCase(cat)\n\t\t        if (sub) subcategory = toTitleCase(sub)\n\t\t        break\n\t\t      }\n\n      const workoutMatch = tagSet.has('workout') || /\\b(workout|gym|lift|lifting|run|cardio|yoga|training)\\b/.test(t)\n      if (workoutMatch) {\n        category = 'Health'\n        subcategory = subcategory ?? 'Workout'\n      }\n\n\t\t      if (!category && (tagSet.has('work') || /\\b(work|shift)\\b/.test(t))) category = 'Work'\n      if (tagSet.has('clinic') || /\\b(clinic|patients|rounds|inpatient)\\b/.test(t)) {\n        category = category ?? 'Work'\n        subcategory = 'Clinic'\n      }\n      if (tagSet.has('meeting') || /\\b(meeting|conference|rounds)\\b/.test(t)) {\n        category = category ?? 'Work'\n        subcategory = subcategory ?? 'Meeting'\n      }\n      if (tagSet.has('surgery') || /\\b(surgery)\\b/.test(t)) {\n        category = category ?? 'Work'\n        subcategory = 'Surgery'\n      }\n\t\t      if (tagSet.has('didactics') || /\\b(didactics)\\b/.test(t)) {\n\t\t        category = category ?? 'Work'\n\t\t        subcategory = subcategory ?? 'Didactics'\n\t\t      }\n\t\t      if (tagSet.has('study') || /\\b(study|lecture|reading)\\b/.test(t)) {\n\t\t        category = category ?? 'Learning'\n\t\t        subcategory = subcategory ?? (/\\b(read|reading)\\b/.test(t) ? 'Reading' : 'Practice')\n\t\t      }\n\t\t      if (tagSet.has('workout') || /\\b(workout|gym|lift|lifting|run|cardio|yoga|training)\\b/.test(t)) {\n\t\t        category = 'Health'\n\t\t        subcategory = subcategory ?? 'Workout'\n\t\t      }\n\t\t      if (tagSet.has('sleep') || /\\b(sleep|nap)\\b/.test(t)) {\n\t\t        category = category ?? 'Health'\n\t\t        subcategory = subcategory ?? 'Sleep'\n\t\t      }\n      if (tagSet.has('shopping') || /\\b(grocery|shopping|store|errand)\\b/.test(t)) {\n        category = category ?? 'Personal'\n        subcategory = subcategory ?? (/\\b(grocery|groceries)\\b/.test(t) ? 'Groceries' : 'Errands')\n      }\n      if (tagSet.has('morning') || /\\b(get ready|morning routine|prep|ready for work)\\b/.test(t)) {\n        category = category ?? 'Personal'\n        subcategory = subcategory ?? 'Morning Routine'\n      }\n      if (tagSet.has('food') || /\\b(dinner|lunch|breakfast|meal|restaurant|food)\\b/.test(t)) {\n        category = category ?? 'Food'\n        subcategory = subcategory ?? (/\\b(restaurant|dinner out|lunch out|eat out)\\b/.test(t) ? 'Restaurant' : 'Meal')\n      }\n      if (tagSet.has('walk') || /\\b(walk|stroll)\\b/.test(t)) {\n        category = category ?? 'Personal'\n        subcategory = subcategory ?? 'Health'\n      }\n\t\t      if (tagSet.has('transport') || /\\b(transport|drive|driving|commute|flight|fly|uber|lyft|train|bus|parking)\\b/.test(t)) {\n\t\t        category = category ?? 'Transport'\n\t\t        if (/\\b(flight|fly|airport)\\b/.test(t)) subcategory = subcategory ?? 'Flight'\n\t\t        else if (/\\b(train|bus|transit|subway)\\b/.test(t)) subcategory = subcategory ?? 'Transit'\n\t\t        else if (/\\b(parking)\\b/.test(t)) subcategory = subcategory ?? 'Parking'\n\t\t        else subcategory = subcategory ?? 'Driving'\n\t\t      }\n\t\t      if (tagSet.has('finance') || /\\b(bank|finance|mortgage|loan|bill|budget|expense)\\b/.test(t)) {\n\t\t        category = category ?? 'Finance'\n\t\t        subcategory = subcategory ?? (/\\b(bank)\\b/.test(t) ? 'Banking' : /\\b(bill|bills)\\b/.test(t) ? 'Bills' : 'Budget')\n\t\t      }\n\t\t      // Job applications\n\t\t      if (/\\b(job|application|apply|resume|interview|hiring|career)\\b/.test(t)) {\n\t\t        category = category ?? 'Work'\n\t\t        subcategory = subcategory ?? 'Job Applications'\n\t\t      }\n\t\t      // Rent payment\n\t\t      if (/\\b(rent|landlord|lease|tenant)\\b/.test(t)) {\n\t\t        category = category ?? 'Finance'\n\t\t        subcategory = subcategory ?? 'Rent'\n\t\t      }\n\t\t      // Skincare/self-care\n\t\t      if (/\\b(microneedle|skincare|facial|derma|beauty|skin)\\b/.test(t)) {\n\t\t        category = category ?? 'Personal'\n\t\t        subcategory = subcategory ?? 'Skincare'\n\t\t      }\n\t\t      // House chores/cleaning\n\t\t      if (/\\b(clean|cleaning|chore|chores|tidy|vacuum|laundry|dishes)\\b/.test(t)) {\n\t\t        category = category ?? 'Personal'\n\t\t        subcategory = subcategory ?? 'Chores'\n\t\t      }\n\t\t      // Costco/specific stores\n\t\t      if (/\\b(costco|walmart|target|trader joe|whole foods|safeway)\\b/i.test(t)) {\n\t\t        category = category ?? 'Personal'\n\t\t        subcategory = subcategory ?? 'Errands'\n\t\t      }\n\n\t\t      // Fall back to the starter taxonomy (keeps categories consistent).\n\t\t      if (category) {\n\t\t        const categoryLower = category.toLowerCase()\n\t\t        const canonical = categoriesFromStarter().find((c) => c.toLowerCase() === categoryLower)\n\t\t        if (canonical) category = canonical\n\t\t      }\n\t\t      if (category && subcategory) {\n\t\t        const subs = subcategoriesFromStarter(category)\n\t\t        const subLower = subcategory.toLowerCase()\n\t\t        const canonicalSub = subs.find((s) => s.toLowerCase() === subLower)\n\t\t        if (canonicalSub) subcategory = canonicalSub\n\t\t      }\n\n\t\t      return { category, subcategory }\n\t\t    }\n\n    function resolveCategory(\n      title: string,\n      tags: string[],\n      current?: { category?: string | null; subcategory?: string | null },\n      rules?: Array<{ match: string; category?: string; subcategory?: string; tags?: string[] }>,\n    ) {\n      const inferred = inferCategorySubcategory(title, tags, rules)\n      const fallbackCategory = categoryOverride ?? current?.category ?? inferred.category ?? 'Personal'\n      let fallbackSubcategory = subcategoryOverride ?? current?.subcategory ?? inferred.subcategory ?? null\n      if (!fallbackSubcategory) {\n        const categoryLower = fallbackCategory.toLowerCase()\n        if (/\\b(get ready|morning routine|prep|ready for work)\\b/.test(title.toLowerCase())) {\n          fallbackSubcategory = 'Morning Routine'\n        } else if (categoryLower === 'food') {\n          fallbackSubcategory = 'Meal'\n        } else {\n          fallbackSubcategory = 'General'\n        }\n      }\n      recordTaxonomyEntry(fallbackCategory, fallbackSubcategory)\n      return { category: fallbackCategory, subcategory: fallbackSubcategory }\n    }\n\n    function isWorkLikeParsedEvent(ev: ParsedEvent) {\n      const text = `${ev.title ?? ''} ${ev.sourceText ?? ''}`.toLowerCase()\n      const tagSet = new Set((ev.tags ?? []).map(normalizeTagName))\n      return tagSet.has('work') || tagSet.has('clinic') || /\\b(work|clinic|patients|inpatient|rounds|didactics)\\b/.test(text)\n    }\n\n    function isStandaloneUntimed(ev: ParsedEvent) {\n      const text = `${ev.title ?? ''} ${ev.sourceText ?? ''}`.toLowerCase()\n      const tagSet = new Set((ev.tags ?? []).map(normalizeTagName))\n      if (tagSet.has('food') || /\\b(dinner|lunch|breakfast|meal|restaurant)\\b/.test(text)) return true\n      if (tagSet.has('shopping') || /\\b(grocery|shopping|store|errand)\\b/.test(text)) return true\n      if (tagSet.has('finance') || /\\b(bank|finance|bill|budget)\\b/.test(text)) return true\n      if (tagSet.has('transport') || /\\b(transport|drive|driving|commute|flight|uber|lyft|train|bus)\\b/.test(text)) return true\n      return false\n    }\n\n    function appendSegment(notes: string | null | undefined, line: string) {\n      if (!line) return notes ?? ''\n      return notes && notes.trim().length ? `${notes}\\n${line}` : line\n    }\n\n    function groupParsedEvents(parsed: ParsedEvent[]) {\n      const output: ParsedEvent[] = []\n      const workCandidates = parsed.filter((e) => Boolean(e.explicitTime) && (e.kind ?? 'event') === 'event' && isWorkLikeParsedEvent(e))\n      const workBlock =\n        workCandidates.length >= 2\n          ? ({\n              title: 'Work',\n              startAt: Math.min(...workCandidates.map((e) => e.startAt)),\n              endAt: Math.max(...workCandidates.map((e) => e.endAt)),\n              kind: 'event',\n              notes: '',\n              estimateMinutes: Math.round(\n                (Math.max(...workCandidates.map((e) => e.endAt)) - Math.min(...workCandidates.map((e) => e.startAt))) / (60 * 1000),\n              ),\n              explicitTime: true,\n              sourceText: 'work block',\n            } as ParsedEvent)\n          : null\n      let workBlockInserted = false\n      let currentExplicit: ParsedEvent | null = null\n\n      for (const ev of parsed) {\n        const kind = (ev.kind ?? 'event') as CalendarEvent['kind']\n        const inWorkWindow =\n          Boolean(workBlock) &&\n          (ev.kind ?? 'event') === 'event' &&\n          ev.startAt >= workBlock!.startAt &&\n          ev.startAt < workBlock!.endAt\n\n        if (workBlock && inWorkWindow) {\n          if (!workBlockInserted) {\n            output.push(workBlock)\n            workBlockInserted = true\n          }\n          currentExplicit = workBlock\n          const line = formatSegmentLine(ev.startAt ?? null, segmentLabelForEvent(ev))\n          workBlock.notes = appendSegment(workBlock.notes ?? '', line)\n          continue\n        }\n\n        if (kind === 'log' || kind === 'episode') {\n          output.push(ev)\n          continue\n        }\n        if (ev.explicitTime) {\n          output.push(ev)\n          currentExplicit = ev\n          continue\n        }\n        if (currentExplicit && !isStandaloneUntimed(ev)) {\n          const atMs = ev.explicitTime ? ev.startAt : currentExplicit.startAt\n          const line = formatSegmentLine(atMs ?? null, segmentLabelForEvent(ev))\n          currentExplicit.notes = appendSegment(currentExplicit.notes ?? '', line)\n          continue\n        }\n        output.push(ev)\n      }\n      return output\n    }\n\n    function hasExplicitSplitSignals(text: string) {\n      return /\\b(later|after|afterwards|then|tomorrow|yesterday|next week|next month|next year|this morning|this afternoon|this evening|tonight|this noon|this midday|this lunch|morning|afternoon|evening|tonight|noon|midday|lunch|at \\d{1,2}(?::\\d{2})?\\s*(am|pm)?)\\b/i.test(text)\n    }\n\n    function hasMultipleMoneyAmounts(text: string) {\n      const matches = text.match(/\\$\\s*\\d+(?:\\.\\d{1,2})?/g) ?? []\n      const altMatches = text.match(/\\b\\d+(?:\\.\\d{1,2})?\\s*(?:dollars|bucks)\\b/gi) ?? []\n      const total = matches.length + altMatches.length\n      return total >= 2\n    }\n\n    function mergeNotes(base: string | null | undefined, lines: string[]) {\n      const cleaned = lines.map((l) => l.trim()).filter(Boolean)\n      if (!cleaned.length) return base ?? ''\n      const block = cleaned.map((l) => `- ${l}`).join('\\n')\n      if (!base || !base.trim()) return block\n      return `${base.trim()}\\n${block}`\n    }\n\n    function mergeUntimedLlmEvents(events: LlmParsedEvent[], shouldMerge: boolean) {\n      if (!shouldMerge) return events\n      const candidates = events.filter((e) => (e.kind ?? 'event') === 'event')\n      if (candidates.length <= 1) return events\n      const others = events.filter((e) => (e.kind ?? 'event') !== 'event')\n      const base = candidates[0]!\n      let startIso = base.startAtIso\n      let endIso = base.endAtIso\n      let startMs = Date.parse(startIso)\n      let endMs = Date.parse(endIso)\n      const titles: string[] = []\n      const extraNotes: string[] = []\n      const tags = new Set(base.tags ?? [])\n      const people = new Set(base.people ?? [])\n      const skills = new Set(base.skills ?? [])\n      const character = new Set(base.character ?? [])\n      let location = base.location ?? null\n      let goal = base.goal ?? null\n      let project = base.project ?? null\n      let importance = base.importance ?? null\n      let difficulty = base.difficulty ?? null\n      let costUsd = base.costUsd ?? null\n      let notes = base.notes ?? null\n\n      for (const ev of candidates.slice(1)) {\n        if (ev.title) titles.push(ev.title)\n        if (ev.notes) extraNotes.push(ev.notes)\n        for (const t of ev.tags ?? []) tags.add(t)\n        for (const p of ev.people ?? []) people.add(p)\n        for (const s of ev.skills ?? []) skills.add(s)\n        for (const c of ev.character ?? []) character.add(c)\n        if (!location && ev.location) location = ev.location\n        if (!goal && ev.goal) goal = ev.goal\n        if (!project && ev.project) project = ev.project\n        if (typeof ev.importance === 'number') importance = Math.max(importance ?? ev.importance, ev.importance)\n        if (typeof ev.difficulty === 'number') difficulty = Math.max(difficulty ?? ev.difficulty, ev.difficulty)\n        if (typeof ev.costUsd === 'number') costUsd = (costUsd ?? 0) + ev.costUsd\n\n        const evStart = Date.parse(ev.startAtIso)\n        const evEnd = Date.parse(ev.endAtIso)\n        if (Number.isFinite(evStart) && (!Number.isFinite(startMs) || evStart < startMs)) {\n          startMs = evStart\n          startIso = ev.startAtIso\n        }\n        if (Number.isFinite(evEnd) && (!Number.isFinite(endMs) || evEnd > endMs)) {\n          endMs = evEnd\n          endIso = ev.endAtIso\n        }\n      }\n\n      const mergedNotes = mergeNotes(notes, [...titles, ...extraNotes])\n      const merged: LlmParsedEvent = {\n        ...base,\n        startAtIso: startIso,\n        endAtIso: endIso,\n        tags: Array.from(tags),\n        people: Array.from(people),\n        skills: Array.from(skills),\n        character: Array.from(character),\n        location,\n        goal,\n        project,\n        importance,\n        difficulty,\n        costUsd,\n        notes: mergedNotes,\n      }\n      return [merged, ...others]\n    }\n\n    function mergeUntimedNaturalEvents(events: ParsedEvent[], shouldMerge: boolean) {\n      if (!shouldMerge) return events\n      const candidates = events.filter((e) => (e.kind ?? 'event') === 'event')\n      if (candidates.length <= 1) return events\n      const others = events.filter((e) => (e.kind ?? 'event') !== 'event')\n      const base = candidates[0]!\n      const titles: string[] = []\n      const extraNotes: string[] = []\n      const tags = new Set(base.tags ?? [])\n      const people = new Set(base.people ?? [])\n      const skills = new Set(base.skills ?? [])\n      const character = new Set(base.character ?? [])\n      let location = base.location ?? null\n      let goal = base.goal ?? null\n      let project = base.project ?? null\n      let importance = base.importance ?? null\n      let difficulty = base.difficulty ?? null\n      let startAt = base.startAt\n      let endAt = base.endAt\n\n      for (const ev of candidates.slice(1)) {\n        if (ev.title) titles.push(ev.title)\n        if (ev.notes) extraNotes.push(ev.notes)\n        for (const t of ev.tags ?? []) tags.add(t)\n        for (const p of ev.people ?? []) people.add(p)\n        for (const s of ev.skills ?? []) skills.add(s)\n        for (const c of ev.character ?? []) character.add(c)\n        if (!location && ev.location) location = ev.location\n        if (!goal && ev.goal) goal = ev.goal\n        if (!project && ev.project) project = ev.project\n        if (typeof ev.importance === 'number') importance = Math.max(importance ?? ev.importance, ev.importance)\n        if (typeof ev.difficulty === 'number') difficulty = Math.max(difficulty ?? ev.difficulty, ev.difficulty)\n        startAt = Math.min(startAt, ev.startAt)\n        endAt = Math.max(endAt, ev.endAt)\n      }\n\n      const mergedNotes = mergeNotes(base.notes, [...titles, ...extraNotes])\n      const merged: ParsedEvent = {\n        ...base,\n        startAt,\n        endAt,\n        tags: Array.from(tags),\n        people: Array.from(people),\n        skills: Array.from(skills),\n        character: Array.from(character),\n        location,\n        goal,\n        project,\n        importance,\n        difficulty,\n        notes: mergedNotes,\n      }\n      return [merged, ...others]\n    }\n\n\t    function applyDurationOverride(startAt: number, endAt: number, kind: CalendarEvent['kind']) {\n\t      if (!durationOverride || explicitTimeInCapture || kind === 'episode' || kind === 'log') return { startAt, endAt }\n\t      const nextEnd = startAt + Math.max(5, durationOverride) * 60 * 1000\n\t      return { startAt, endAt: Math.max(endAt, nextEnd) }\n\t    }\n\n\t    async function maybeCreateTaskCalendarBlock(opts: { task: Task; tags: string[]; location?: string | null; people?: string[]; contexts?: string[]; entityIds: string[] }) {\n\t      const startAt = opts.task.scheduledAt\n\t      if (!startAt) return null\n\t      const estimateMinutes = opts.task.estimateMinutes ?? durationOverride ?? 60\n\t      const endAt = startAt + Math.max(5, estimateMinutes) * 60 * 1000\n\t      const key = makeEventKey(opts.task.title, startAt, endAt)\n\t      if (createdEventKeys.has(key)) return null\n\n      const ev = await createEvent({\n        title: opts.task.title,\n        startAt,\n        endAt,\n        kind: 'task',\n        taskId: opts.task.id,\n        parentEventId: opts.task.parentEventId ?? null,\n        tags: opts.tags,\n        contexts: opts.contexts ?? opts.task.contexts ?? [],\n        notes: opts.task.notes ?? '',\n        location: opts.location ?? null,\n        people: opts.people ?? [],\n        skills: opts.task.skills ?? [],\n        character: opts.task.character ?? [],\n        category: opts.task.category ?? null,\n        subcategory: opts.task.subcategory ?? null,\n        goal: opts.task.goal ?? goalOverride ?? null,\n        project: opts.task.project ?? projectOverride ?? null,\n        importance: opts.task.importance ?? 5,\n        difficulty: opts.task.difficulty ?? 5,\n        estimateMinutes,\n        entityIds: opts.entityIds,\n        sourceNoteId: opts.task.sourceNoteId ?? null,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      setCaptureProgress((p) => [...p, `+ task block: ${ev.title}`].slice(-10))\n      return ev\n    }\n\n    // Optional: LLM-backed parsing (uses the key + parser model stored in Settings).\n    let llmSucceeded = false\n    let llmError: string | null = null\n    let llm: Awaited<ReturnType<typeof parseCaptureWithBlocksLlm>> | null = null\n    if (!llmKey && llmMode === 'llm') {\n      setCaptureError('OpenAI key is required for LLM mode. Add it in Settings and click Save.')\n      setCaptureSaving(false)\n      return\n    }\n    if (shouldTryLlm) {\n      try {\n        setCaptureAiStatus(`AI parsing (${llmParseModel})\u2026`)\n        llm = await parseCaptureWithBlocksLlm({ apiKey: llmKey, model: llmParseModel, text: captureText, anchorMs })\n        const shouldMergeUntimed = !explicitTimeInCapture && !hasExplicitSplitSignals(captureText) && !hasMultipleMoneyAmounts(captureText)\n        const mergedLlmEvents = mergeUntimedLlmEvents(llm.events, shouldMergeUntimed)\n        if (mergedLlmEvents.length !== llm.events.length) {\n          setCaptureProgress((p) => [...p, `Merged LLM events (${llm.events.length} \u2192 ${mergedLlmEvents.length})`].slice(-10))\n        }\n        llm = { ...llm, events: mergedLlmEvents }\n        setCaptureProgress((p) => [...p, `AI parsed (${llm.tasks.length} task(s), ${llm.events.length} event(s), ${llm.workouts.length} workout(s))`].slice(-10))\n        llmSucceeded = (llm.tasks.length + llm.events.length + llm.workouts.length + llm.meals.length) > 0\n        if (!llmSucceeded) {\n          const emptyMsg = allowLocalFallback ? 'AI returned empty; using local parser' : 'AI returned empty; local parsing is disabled'\n          setCaptureProgress((p) => [...p, emptyMsg].slice(-10))\n        }\n\n        // Pull any explicit people/places from the LLM result into entities + fallbacks.\n        const llmPeople = uniqStrings([\n          ...llm.tasks.flatMap((t) => (t.people ?? []).filter(Boolean)),\n          ...llm.events.flatMap((e) => (e.people ?? []).filter(Boolean)),\n        ]).slice(0, 16)\n        const llmPlaces = uniqStrings([\n          ...llm.tasks.map((t) => t.location).filter(Boolean) as string[],\n          ...llm.events.map((e) => e.location).filter(Boolean) as string[],\n        ]).slice(0, 16)\n        const cleanedLlmPeople = cleanPeopleList(llmPeople)\n        for (const p of cleanedLlmPeople) {\n          const ent = await ensureEntity('person', p, p)\n          if (!entityIdSet.has(ent.id)) {\n            entityIdSet.add(ent.id)\n            entityIds.push(ent.id)\n          }\n          personMentions.push(p)\n        }\n        for (const pl of llmPlaces) {\n          const ent = await ensureEntity('place', pl, pl)\n          if (!entityIdSet.has(ent.id)) {\n            entityIdSet.add(ent.id)\n            entityIds.push(ent.id)\n          }\n          placeMentions.push(pl)\n        }\n        if (cleanedLlmPeople.length || llmPlaces.length) {\n          await updateCaptureEntityIds(note.id, entityIds)\n          setCaptures((prev) => prev.map((c) => (c.id === note.id ? { ...c, entityIds } : c)))\n        }\n\n\t        const overrideTimes = Number.isFinite(fmStartAt ?? NaN) && Number.isFinite(fmEndAt ?? NaN) && llm.events.length === 1 && llm.tasks.length === 0\n\n\t        for (const e of llm.events) {\n\t          if (!allowEventCreation) continue\n\t          let startAt = new Date(e.startAtIso).getTime()\n\t          let endAt = new Date(e.endAtIso).getTime()\n          if (!Number.isFinite(startAt) || !Number.isFinite(endAt)) continue\n          if (overrideTimes && fmStartAt != null && fmEndAt != null) {\n            startAt = fmStartAt\n            endAt = fmEndAt\n          }\n          const shouldForceNow =\n            !overrideTimes && hasNowSignal && !explicitTimeInCapture && llm.events.length === 1 && llm.tasks.length === 0 && !e.allDay\n          if (shouldForceNow) {\n            startAt = anchorMs\n            const fallbackMinutes = e.estimateMinutes ?? durationOverride ?? 60\n            endAt = startAt + Math.max(5, fallbackMinutes) * 60 * 1000\n          }\n          const baseText = `${e.title ?? ''}\\n${e.notes ?? ''}\\n${(e.tags ?? []).join(' ')}`.trim()\n          const locationHint = e.location ?? pickLocationForText(baseText)\n          const autoImportance = e.importance ?? importanceOverride ?? inferImportanceFromText(baseText) ?? 5\n          const autoDifficulty = e.difficulty ?? difficultyOverride ?? inferDifficultyFromText(baseText) ?? 5\n          const autoCharacter = normalizeCharacterSelection(e.character ?? inferCharacterFromText(baseText, e.tags ?? []))\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: e.title, tags: e.tags ?? [], location: locationHint })\n          const rawKind = (e.kind as any) ?? 'event'\n          const inferredTrackerKey = e.trackerKey ?? inferTrackerKeyFromText(e.title, e.tags ?? [])\n          const isSleepTracker = inferredTrackerKey === 'sleep'\n          const trackerKey = isSleepTracker ? null : inferredTrackerKey\n          const kind = isSleepTracker\n            ? 'event'\n            : rawKind === 'log' || (trackerKey && LOG_TRACKER_KEYS.has(trackerKey))\n              ? 'log'\n              : rawKind\n          const times = applyDurationOverride(startAt, endAt, kind)\n            const ev = await createEvent({\n            title: e.title,\n            startAt: times.startAt,\n            endAt: Math.max(times.endAt, times.startAt + 5 * 60 * 1000),\n            kind,\n            allDay: Boolean(e.allDay),\n            active: Boolean(e.active) || shouldForceNow,\n            parentEventId: kind === 'log' ? await getActiveForLogsId() : null,\n            tags: mergedTags,\n            contexts: allContexts,\n            entityIds,\n            sourceNoteId: note.id,\n            icon: (e.icon as any) ?? null,\n            color: e.color ?? null,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            goal: e.goal ?? goalOverride ?? null,\n            project: e.project ?? projectOverride ?? null,\n            trackerKey: trackerKey ?? null,\n            importance: autoImportance,\n            difficulty: autoDifficulty,\n          })\n          const costLine = typeof e.costUsd === 'number' && Number.isFinite(e.costUsd) ? `\\nBudget: $${e.costUsd}` : ''\n          const nextNotes = e.notes ?? ev.notes\n          const normalizedNotes = normalizeTaskChecklistNotes(nextNotes)\n          const segmentedNotes = maybeSegmentNotes(normalizedNotes, times.startAt, times.endAt)\n          const next = await upsertEvent({\n            ...ev,\n            notes: (segmentedNotes ?? normalizedNotes ?? ev.notes) + costLine,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            estimateMinutes: e.estimateMinutes ?? durationOverride ?? (Boolean(e.allDay) || kind === 'episode' ? null : Math.round((times.endAt - times.startAt) / (60 * 1000))),\n            location: locationHint ?? null,\n            people: cleanPeopleList(e.people ?? uniqStrings(personMentions)),\n            skills: e.skills ?? [],\n            character: autoCharacter,\n            importance: autoImportance ?? ev.importance ?? 5,\n            difficulty: autoDifficulty ?? ev.difficulty ?? 5,\n            goal: e.goal ?? ev.goal ?? goalOverride ?? null,\n            project: e.project ?? ev.project ?? projectOverride ?? null,\n            contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n          })\n          rememberMealEvent(next)\n          if (next.active && next.kind !== 'log' && next.kind !== 'episode') {\n            await stopOtherActiveEvents(next.id, next.startAt)\n            activeForLogsId = next.id\n          }\n          setEvents((prev) => [next, ...prev])\n          createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n          if (next.kind === 'log') {\n            createdLogCount += 1\n            if (next.trackerKey) createdTrackerKeys.add(next.trackerKey)\n          }\n          else createdEventCount += 1\n          if (next.active && next.kind !== 'log' && next.kind !== 'episode') activeForLogsId = next.id\n          setCaptureProgress((p) => [...p, `+ ${next.kind}: ${next.title}`].slice(-10))\n\n\t          if (next.kind !== 'log') {\n\t            captureHasNonLogEvent = true\n\t            if (!capturePrimaryEventId) capturePrimaryEventId = next.id\n\t            lastCreated = { kind: 'event', id: next.id }\n\t            navigateToMs = next.startAt\n\t          }\n\t        }\n\n        for (const t of llm.tasks) {\n          if (!allowTaskCreation) continue\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: t.title, tags: t.tags ?? [] })\n          const taskBase = `${t.title ?? ''}\\n${t.notes ?? ''}\\n${(t.tags ?? []).join(' ')}`.trim()\n          const autoImportance = t.importance ?? importanceOverride ?? inferImportanceFromText(taskBase) ?? 5\n          const autoDifficulty = t.difficulty ?? difficultyOverride ?? inferDifficultyFromText(taskBase) ?? 5\n          const autoCharacter = normalizeCharacterSelection(t.character ?? inferCharacterFromText(taskBase, t.tags ?? []))\n          const locationHint = t.location ?? pickLocationForText(taskBase)\n          const peopleHint = cleanPeopleList(t.people ?? uniqStrings(personMentions))\n          let notes = (t.notes ?? '').trim()\n          if (!notes && implicitShoppingItems.length && (/\\b(shop|shopping|grocery|store|buy)\\b/i.test(t.title) || mergedTags.includes('#shopping'))) {\n            notes = buildShoppingNotes(implicitShoppingItems, typeof t.costUsd === 'number' ? t.costUsd : implicitMoneyUsd)\n          }\n          const task = await createTask({\n            title: t.title,\n            status: (t.status as any) ?? 'todo',\n            tags: mergedTags,\n            contexts: allContexts,\n            people: peopleHint,\n            location: locationHint ?? null,\n            skills: t.skills ?? [],\n            character: autoCharacter,\n            entityIds,\n            parentEventId: capturePrimaryEventId,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            goal: t.goal ?? goalOverride ?? null,\n            project: t.project ?? projectOverride ?? null,\n            estimateMinutes: t.estimateMinutes ?? durationOverride ?? 25,\n            importance: autoImportance,\n            difficulty: autoDifficulty,\n            sourceNoteId: note.id,\n          })\n          const next = await upsertTask({\n            ...task,\n            parentEventId: task.parentEventId ?? capturePrimaryEventId,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            notes: notes || task.notes || '',\n            estimateMinutes: t.estimateMinutes ?? durationOverride ?? task.estimateMinutes ?? 25,\n            status: (t.status as any) ?? task.status,\n            dueAt: parseIsoMs(t.dueAtIso) ?? task.dueAt ?? null,\n            scheduledAt: parseIsoMs(t.scheduledAtIso) ?? task.scheduledAt ?? null,\n            goal: t.goal ?? task.goal ?? goalOverride ?? null,\n            project: t.project ?? task.project ?? projectOverride ?? null,\n            importance: autoImportance ?? task.importance ?? 5,\n            difficulty: autoDifficulty ?? task.difficulty ?? 5,\n            people: peopleHint,\n            location: locationHint ?? null,\n            skills: t.skills ?? task.skills ?? [],\n            character: autoCharacter,\n            contexts: uniqStrings([...(task.contexts ?? []), ...allContexts]),\n          })\n\t          setTasks((prev) => [next, ...prev])\n\t          createdTaskCount += 1\n\t          createdTaskKeys.add(makeTaskKey(next.title))\n\t          setCaptureProgress((p) => [...p, `+ Task: ${next.title}`].slice(-10))\n\n\t          if (!captureHasNonLogEvent) {\n\t            lastCreated = { kind: 'task', id: next.id }\n\t            if (navigateToMs == null && next.scheduledAt) navigateToMs = next.scheduledAt\n\t          }\n\n          const block = await maybeCreateTaskCalendarBlock({\n            task: next,\n            tags: mergedTags,\n            location: t.location ?? pickLocationForText(taskBase),\n            people: cleanPeopleList(t.people ?? uniqStrings(personMentions)),\n            contexts: allContexts,\n            entityIds,\n          })\n\t          if (block && !captureHasNonLogEvent) {\n\t            lastCreated = { kind: 'event', id: block.id }\n\t            navigateToMs = block.startAt\n\t          }\n\t        }\n      } catch (err) {\n        const msg = err instanceof Error ? err.message : String(err)\n        llmError = msg\n        setCaptureError(msg)\n        const failMsg = allowLocalFallback\n          ? `AI parse failed; using local parser (${msg.slice(0, 80)})`\n          : `AI parse failed; local parsing is disabled (${msg.slice(0, 80)})`\n        setCaptureProgress((p) => [...p, failMsg].slice(-10))\n      } finally {\n        setCaptureAiStatus('')\n      }\n    }\n    if (!llmKey) setCaptureProgress((p) => [...p, 'AI parsing disabled (no OpenAI key set in Settings)'].slice(-10))\n\n    // Tracker token logs (#mood(7), #energy(8), etc.) are always recorded.\n    // If LLM also produced logs, the createdEventKeys de-dupe prevents duplicates.\n    for (const tok of trackerTokens.slice(0, 10)) {\n      if (tok.name.trim().toLowerCase() === 'sleep') continue\n      const title = `${tok.name}: ${tok.value}`\n      const startAt = nowMs\n      const endAt = nowMs + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: [`#${tok.name}`] })\n      const ev = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        goal: goalOverride,\n        project: projectOverride,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        trackerKey: tok.name,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      createdTrackerKeys.add(tok.name)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${ev.title}`].slice(-10))\n    }\n\n    const fmTrackersRaw = Array.isArray(fm.trackers) ? fm.trackers : typeof fm.trackers === 'string' ? [fm.trackers] : []\n    for (const raw of fmTrackersRaw.slice(0, 10)) {\n      const line = String(raw).trim()\n      if (!line) continue\n      const m = line.match(/^([a-zA-Z][\\w/-]*)\\s*[:=]\\s*([-+]?\\d*\\.?\\d+)/)\n      if (!m?.[1] || !m?.[2]) continue\n      const name = m[1]\n      if (name.trim().toLowerCase() === 'sleep') continue\n      const value = Number(m[2])\n      if (!Number.isFinite(value)) continue\n      const title = `${name}: ${value}`\n      const startAt = nowMs\n      const endAt = nowMs + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: [`#${name}`] })\n      const ev = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        goal: goalOverride,\n        project: projectOverride,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        trackerKey: name,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      createdTrackerKeys.add(name)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${ev.title}`].slice(-10))\n    }\n\n    function startOfDayMs(ms: number) {\n      const d = new Date(ms)\n      d.setHours(0, 0, 0, 0)\n      return d.getTime()\n    }\n\n    const dayStartMs = startOfDayMs(nowMs)\n    const dayEndMs = dayStartMs + 24 * 60 * 60 * 1000\n\n    // Explicit episode/session signals (explicit start + explicit end).\n    if (periodStartSignal && !periodEndSignal) {\n      const activePeriod = await findActiveEpisode('period')\n      if (!activePeriod) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: 'Period', tags: ['#period'] })\n        const ev = await createEvent({\n          title: 'Period',\n          startAt: dayStartMs,\n          endAt: dayEndMs,\n          allDay: true,\n          active: true,\n          kind: 'episode',\n          trackerKey: 'period',\n          icon: 'heart',\n          color: '#ef4444',\n          tags: mergedTags,\n          contexts: allContexts,\n          entityIds,\n          sourceNoteId: note.id,\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [ev, ...prev])\n      }\n    }\n    if (periodEndSignal) {\n      const activePeriod = await findActiveEpisode('period')\n      if (activePeriod) {\n        const next = await upsertEvent({ ...activePeriod, endAt: dayEndMs, active: false })\n        commitEvent(next)\n      }\n    }\n\n    if (painRatingMatch || painHealedSignal) {\n      const bodyTag = bodyPartMatch?.[1] ? `#${bodyPartMatch[1]}` : null\n      const painTags = [...new Set(['#pain', ...(bodyTag ? [bodyTag] : [])])]\n\n      const rating = painRatingMatch?.[1] ? Math.max(0, Math.min(10, Number(painRatingMatch[1]))) : null\n      if (rating != null && Number.isFinite(rating) && !createdTrackerKeys.has('pain')) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: `pain: ${rating}/10`, tags: painTags })\n        const log = await createEvent({\n          title: `pain: ${rating}/10`,\n          startAt: nowMs,\n          endAt: nowMs + 5 * 60 * 1000,\n          kind: 'log',\n          parentEventId: await getActiveForLogsId(),\n          tags: mergedTags,\n          contexts: allContexts,\n          icon: 'heart',\n          color: '#ef4444',\n          entityIds,\n          sourceNoteId: note.id,\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [log, ...prev])\n        createdTrackerKeys.add('pain')\n        createdLogCount += 1\n        setCaptureProgress((p) => [...p, `+ log: ${log.title}`].slice(-10))\n      }\n\n      if (!painHealedSignal) {\n        const activePain = await findActiveEpisode('pain')\n        if (!activePain) {\n          const painTitle = bodyPartMatch?.[1] ? `Pain: ${bodyPartMatch[1]}` : 'Pain'\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: painTitle, tags: painTags })\n          const ep = await createEvent({\n            title: painTitle,\n            startAt: dayStartMs,\n            endAt: dayEndMs,\n            allDay: true,\n            active: true,\n            kind: 'episode',\n            trackerKey: 'pain',\n            icon: 'heart',\n            color: '#ef4444',\n            tags: mergedTags,\n            contexts: allContexts,\n            entityIds,\n            sourceNoteId: note.id,\n            goal: goalOverride,\n            project: projectOverride,\n            importance: importanceOverride ?? 5,\n            difficulty: difficultyOverride ?? 5,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n          })\n          setEvents((prev) => [ep, ...prev])\n        } else {\n          const merged = [...new Set([...(activePain.tags ?? []), ...painTags])]\n          if (merged.join('|') !== (activePain.tags ?? []).join('|')) {\n            const next = await upsertEvent({ ...activePain, tags: merged })\n            commitEvent(next)\n          }\n        }\n      } else {\n        const activePain = await findActiveEpisode('pain')\n        if (activePain) {\n          const next = await upsertEvent({ ...activePain, endAt: dayEndMs, active: false })\n          commitEvent(next)\n        }\n      }\n    }\n\n    let moodLogged = false\n    if (moodMentions.length) {\n      if (moodMentions.length > 1) {\n        const startMention = moodMentions.find((m) => m.hint === 'start') ?? moodMentions[0]\n        const endMention = moodMentions.find((m) => m.hint === 'now') ?? moodMentions[moodMentions.length - 1]\n        await createTrackerLog({\n          key: 'mood',\n          value: startMention.value,\n          icon: 'smile',\n          color: '#f59e0b',\n          atMs: nowMs,\n          dedupeKey: `mood@start:${Math.round(nowMs / (5 * 60 * 1000))}`,\n        })\n        await createTrackerLog({\n          key: 'mood',\n          value: endMention.value,\n          icon: 'smile',\n          color: '#f59e0b',\n          atMs: wallNowMs,\n          dedupeKey: `mood@end:${Math.round(wallNowMs / (5 * 60 * 1000))}`,\n        })\n      } else {\n        const only = moodMentions[0]\n        const atMs = only.hint === 'now' ? wallNowMs : nowMs\n        await createTrackerLog({\n          key: 'mood',\n          value: only.value,\n          icon: 'smile',\n          color: '#f59e0b',\n          atMs,\n          dedupeKey: `mood@${Math.round(atMs / (5 * 60 * 1000))}`,\n        })\n      }\n      moodLogged = true\n    }\n    if (moodValue != null && !moodLogged) {\n      await createTrackerLog({ key: 'mood', value: moodValue, icon: 'smile', color: '#f59e0b' })\n    }\n    if (energyValue != null) {\n      await createTrackerLog({ key: 'energy', value: energyValue, icon: 'bolt', color: '#f59e0b' })\n    }\n    if (stressValue != null) {\n      await createTrackerLog({ key: 'stress', value: stressValue, icon: 'frown', color: '#db2777' })\n    }\n\n    if (workoutStartSignal && !workoutEndSignal) {\n      const active = await findActiveByTrackerKey('workout')\n      if (!active) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: 'Workout', tags: ['#workout'] })\n        const ev = await createEvent({\n          title: 'Workout',\n          startAt: nowMs,\n          endAt: nowMs + 60 * 60 * 1000,\n          active: true,\n          kind: 'event',\n          trackerKey: 'workout',\n          icon: 'dumbbell',\n          color: '#22c55e',\n          tags: mergedTags,\n          contexts: allContexts,\n          entityIds,\n          sourceNoteId: note.id,\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [ev, ...prev])\n        activeForLogsId = ev.id\n      }\n    }\n    if (workoutEndSignal) {\n      const active = await findActiveByTrackerKey('workout')\n      if (active) {\n        const next = await upsertEvent({ ...active, endAt: nowMs, active: false })\n        commitEvent(next)\n      }\n    }\n\n    if (boredSignal && !createdTrackerKeys.has('bored')) {\n      const value = 7\n      const title = `bored: ${value}/10`\n      const startAt = nowMs\n      const endAt = nowMs + 5 * 60 * 1000\n      const key = makeEventKey(title, startAt, endAt)\n      if (!createdEventKeys.has(key)) {\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags: ['#bored'] })\n        const log = await createEvent({\n          title,\n          startAt,\n          endAt,\n          kind: 'log',\n          parentEventId: await getActiveForLogsId(),\n          tags: mergedTags,\n          contexts: allContexts,\n          entityIds,\n          sourceNoteId: note.id,\n          trackerKey: 'bored',\n          icon: 'frown',\n          color: '#64748b',\n          goal: goalOverride,\n          project: projectOverride,\n          importance: importanceOverride ?? 5,\n          difficulty: difficultyOverride ?? 5,\n          category: inferred.category,\n          subcategory: inferred.subcategory,\n        })\n        setEvents((prev) => [log, ...prev])\n        createdEventKeys.add(makeEventKey(log.title, log.startAt, log.endAt))\n        createdTrackerKeys.add('bored')\n        createdLogCount += 1\n        setCaptureProgress((p) => [...p, `+ log: ${log.title}`].slice(-10))\n      }\n    }\n\n    for (const mention of habitMentions) {\n      const h = mention.habit\n      const isNegative = mention.polarity === 'negative'\n      const minutes = Math.max(5, h.estimateMinutes ?? 15)\n      const startAt = nowMs\n      const endAt = nowMs + minutes * 60 * 1000\n      const title = `habit: ${h.name}`\n      const key = makeEventKey(title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const tags = [...new Set(['#habit', ...(h.tags ?? []), ...(isNegative ? ['#missed'] : [])])]\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title, tags })\n      const ev = await createEvent({\n        title,\n        startAt,\n        endAt,\n        kind: 'log',\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: uniqStrings([...(allContexts ?? []), ...(h.contexts ?? [])]),\n        entityIds,\n        sourceNoteId: note.id,\n        trackerKey: `habit:${h.id}${isNegative ? ':neg' : ''}`,\n        category: h.category ?? inferred.category,\n        subcategory: h.subcategory ?? inferred.subcategory,\n        importance: Math.max(0, Math.min(10, h.importance)),\n        difficulty: Math.max(0, Math.min(10, h.difficulty)),\n        character: h.character,\n        skills: h.skills,\n        people: h.people ?? [],\n        location: h.location ?? null,\n        goal: h.goal ?? goalOverride ?? null,\n        project: h.project ?? projectOverride ?? null,\n      })\n      setEvents((prev) => [ev, ...prev])\n      createdEventKeys.add(makeEventKey(ev.title, ev.startAt, ev.endAt))\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `${isNegative ? '+ habit (missed)' : '+ habit'}: ${h.name}`].slice(-10))\n    }\n\n    // Always record local log heuristics (mood, hydration, etc.) even if LLM parsing succeeds,\n    // so trackers reliably appear on the right-side log lane.\n    for (const e of natural.events) {\n      const kind = (e.kind ?? 'event') as CalendarEvent['kind']\n      if (kind !== 'log') continue\n      const startAt = e.startAt\n      const endAt = e.endAt\n      const key = makeEventKey(e.title, startAt, endAt)\n      if (createdEventKeys.has(key)) continue\n      const logBase = `${e.title ?? ''}\\n${e.notes ?? ''}`.trim()\n      const locationHint = e.location ?? pickLocationForText(logBase)\n      const { mergedTags, inferred } = finalizeCategorizedTags({ title: e.title, tags: e.tags ?? [], location: locationHint })\n      const inferredTrackerKey = inferTrackerKeyFromText(e.title, e.tags ?? [])\n      const ev = await createEvent({\n        title: e.title,\n        startAt,\n        endAt,\n        kind,\n        parentEventId: await getActiveForLogsId(),\n        tags: mergedTags,\n        contexts: allContexts,\n        entityIds,\n        sourceNoteId: note.id,\n        icon: e.icon ?? null,\n        color: e.color ?? null,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        goal: e.goal ?? goalOverride ?? null,\n        project: e.project ?? projectOverride ?? null,\n        importance: importanceOverride ?? 5,\n        difficulty: difficultyOverride ?? 5,\n        trackerKey: inferredTrackerKey ?? null,\n      })\n      const next = await upsertEvent({\n        ...ev,\n        notes: normalizeTaskChecklistNotes(e.notes ?? ev.notes),\n        icon: e.icon ?? null,\n        color: e.color ?? null,\n        category: inferred.category,\n        subcategory: inferred.subcategory,\n        estimateMinutes: e.estimateMinutes ?? durationOverride ?? 5,\n        location: locationHint ?? null,\n        people: cleanPeopleList(e.people ?? uniqStrings(personMentions)),\n        skills: e.skills ?? [],\n        character: normalizeCharacterSelection(e.character ?? []),\n        importance: importanceOverride ?? ev.importance ?? 5,\n        difficulty: difficultyOverride ?? ev.difficulty ?? 5,\n        goal: e.goal ?? ev.goal ?? goalOverride ?? null,\n        project: e.project ?? ev.project ?? projectOverride ?? null,\n        contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n      })\n      setEvents((prev) => [next, ...prev])\n      createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n      if (next.trackerKey) createdTrackerKeys.add(next.trackerKey)\n      createdLogCount += 1\n      setCaptureProgress((p) => [...p, `+ log: ${next.title}`].slice(-10))\n    }\n\n    const groupedNaturalEvents = allowLocalFallback ? groupParsedEvents(natural.events) : []\n    const shouldMergeUntimedLocal = !explicitTimeInCapture && !hasExplicitSplitSignals(captureText) && !hasMultipleMoneyAmounts(captureText)\n    const mergedNaturalEvents = allowLocalFallback ? mergeUntimedNaturalEvents(groupedNaturalEvents, shouldMergeUntimedLocal) : []\n    const firstNaturalEvent = allowLocalFallback ? mergedNaturalEvents.find((e) => (e.kind ?? 'event') !== 'log') ?? null : null\n    if (firstNaturalEvent) {\n      const t = new Date(firstNaturalEvent.startAt)\n      const hh = String(t.getHours()).padStart(2, '0')\n      const mm = String(t.getMinutes()).padStart(2, '0')\n      setCaptureProgress((p) => [...p, `First event: ${firstNaturalEvent.title} @ ${hh}:${mm}`].slice(-10))\n    }\n\n\t\t    if (!llmSucceeded && !allowLocalFallback) {\n\t\t      setCaptureError('LLM returned empty; local parsing is disabled.')\n\t\t      setCaptureProgress((p) => [...p, 'LLM empty; local parsing disabled'].slice(-10))\n\t\t    } else if (!llmSucceeded) {\n          const shouldForceNowLocal =\n            hasNowSignal && !explicitTimeInCapture && mergedNaturalEvents.length === 1 && natural.tasks.length === 0\n\t\t      for (const e of mergedNaturalEvents) {\n\t\t        if (!allowEventCreation) continue\n\t\t        const startAt = e.startAt\n\t\t        const endAt = e.endAt\n\t\t        const key = makeEventKey(e.title, startAt, endAt)\n\t\t        if (createdEventKeys.has(key)) continue\n\t\t        const kind = (e.kind ?? 'event') as CalendarEvent['kind']\n\t\t        if (kind === 'log') continue\n        const baseText = `${e.title ?? ''}\\n${e.notes ?? ''}\\n${(e.tags ?? []).join(' ')}`.trim()\n\t\t        const autoImportance = e.importance ?? importanceOverride ?? inferImportanceFromText(baseText) ?? 5\n\t\t        const autoDifficulty = e.difficulty ?? difficultyOverride ?? inferDifficultyFromText(baseText) ?? 5\n\t\t        const autoCharacter = normalizeCharacterSelection(e.character ?? inferCharacterFromText(baseText, e.tags ?? []))\n        const locationHint = e.location ?? pickLocationForText(baseText)\n        const { mergedTags, inferred } = finalizeCategorizedTags({ title: e.title, tags: e.tags ?? [], location: locationHint })\n\t\t        const activeNow = shouldForceNowLocal && kind !== 'log' && kind !== 'episode'\n\t\t        const times = applyDurationOverride(startAt, endAt, kind)\n\t\t        const ev = await createEvent({\n\t\t          title: e.title,\n\t\t          startAt: times.startAt,\n\t\t          endAt: times.endAt,\n\t\t          kind,\n\t\t          active: activeNow,\n\t\t                                      parentEventId: null,\n\t\t                                      tags: mergedTags,\n\t\t                                      contexts: allContexts,\n\t\t                                      entityIds,\n\t\t                                      sourceNoteId: note.id,\n\t\t                                      icon: e.icon ?? null,\n\t\t                                      color: e.color ?? null,\n\t\t                                      category: inferred.category,\n\t\t                                      subcategory: inferred.subcategory,\n\t\t                                      goal: e.goal ?? goalOverride ?? null,\n\t\t                                      project: e.project ?? projectOverride ?? null,\n\t\t                                                                  importance: autoImportance,\n\t\t                                                                  difficulty: autoDifficulty,\n\t\t                                                                })\n\t\t        const next = await upsertEvent({\n\t\t          ...ev,\n\t\t          notes: normalizeTaskChecklistNotes(e.notes ?? ev.notes),\n\t\t          icon: e.icon ?? null,\n\t\t          color: e.color ?? null,\n\t\t          category: inferred.category,\n\t\t          subcategory: inferred.subcategory,\n\t\t          estimateMinutes: e.estimateMinutes ?? durationOverride ?? (kind === 'episode' ? null : Math.round((times.endAt - times.startAt) / (60 * 1000))),\n          location: locationHint ?? null,\n\t\t          people: cleanPeopleList(e.people ?? uniqStrings(personMentions)),\n\t\t          skills: e.skills ?? [],\n\t\t          character: autoCharacter,\n\t\t          importance: autoImportance ?? ev.importance ?? 5,\n\t\t          difficulty: autoDifficulty ?? ev.difficulty ?? 5,\n\t\t          goal: e.goal ?? ev.goal ?? goalOverride ?? null,\n\t\t          project: e.project ?? ev.project ?? projectOverride ?? null,\n\t\t          contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n\t\t        })\n\t\t        if (next.active && next.kind !== 'log' && next.kind !== 'episode') {\n\t\t          await stopOtherActiveEvents(next.id, next.startAt)\n\t\t          activeForLogsId = next.id\n\t\t        }\n\t\t        rememberMealEvent(next)\n\t\t        setEvents((prev) => [next, ...prev])\n\t\t        createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n\t\t                                  createdEventCount += 1\n\t\t                                  if (navigateToMs == null || next.startAt < navigateToMs) navigateToMs = next.startAt\n\t\t                                  captureHasNonLogEvent = true\n\t\t                                  if (!capturePrimaryEventId) capturePrimaryEventId = next.id\n\t\t                                  lastCreated = { kind: 'event', id: next.id }\n\t\t                                  setCaptureProgress((p) => [...p, `+ ${next.kind}: ${next.title}`].slice(-10))\t\t      }\n\n\t\t      for (const t of natural.tasks) {\n\t\t        if (!allowTaskCreation) continue\n\t\t        const key = makeTaskKey(t.title)\n\t\t        if (createdTaskKeys.has(key)) continue\n\t\t        const { mergedTags, inferred } = finalizeCategorizedTags({ title: t.title, tags: t.tags ?? [] })\n        const taskBase = `${t.title ?? ''}\\n${t.notes ?? ''}\\n${(t.tags ?? []).join(' ')}`.trim()\n\t\t        const autoImportance = t.importance ?? importanceOverride ?? inferImportanceFromText(taskBase) ?? 5\n\t\t        const autoDifficulty = t.difficulty ?? difficultyOverride ?? inferDifficultyFromText(taskBase) ?? 5\n        const autoCharacter = normalizeCharacterSelection(t.character ?? inferCharacterFromText(taskBase, t.tags ?? []))\n        const locationHint = t.location ?? pickLocationForText(taskBase)\n        const peopleHint = cleanPeopleList(t.people ?? uniqStrings(personMentions))\n\t\t        const task = await createTask({\n\t\t          title: t.title,\n\t\t          status: t.status ?? 'todo',\n\t\t          tags: mergedTags,\n\t\t          contexts: allContexts,\n          people: peopleHint,\n          location: locationHint ?? null,\n          skills: t.skills ?? [],\n          character: autoCharacter,\n\t\t          entityIds,\n\t\t          parentEventId: capturePrimaryEventId,\n\t\t          category: inferred.category,\n\t\t          subcategory: inferred.subcategory,\n\t\t          goal: t.goal ?? goalOverride ?? null,\n\t\t          project: t.project ?? projectOverride ?? null,\n\t\t          estimateMinutes: t.estimateMinutes ?? durationOverride ?? 25,\n\t\t          importance: autoImportance,\n\t\t          difficulty: autoDifficulty,\n\t\t          sourceNoteId: note.id,\n\t\t        })\n\t\t        const next = await upsertTask({\n\t\t          ...task,\n\t\t          parentEventId: task.parentEventId ?? capturePrimaryEventId,\n\t\t          category: inferred.category,\n\t\t          subcategory: inferred.subcategory,\n\t\t          notes: t.notes ?? '',\n\t\t          estimateMinutes: t.estimateMinutes ?? durationOverride ?? task.estimateMinutes ?? 25,\n\t\t          status: t.status ?? task.status,\n\t\t          scheduledAt: t.scheduledAt ?? task.scheduledAt ?? null,\n\t\t          dueAt: t.dueAt ?? task.dueAt ?? null,\n\t\t          importance: autoImportance ?? task.importance ?? 5,\n\t\t          difficulty: autoDifficulty ?? task.difficulty ?? 5,\n\t\t          goal: t.goal ?? task.goal ?? goalOverride ?? null,\n\t\t          project: t.project ?? task.project ?? projectOverride ?? null,\n          people: peopleHint,\n          location: locationHint ?? null,\n          skills: t.skills ?? task.skills ?? [],\n          character: autoCharacter,\n\t\t          contexts: uniqStrings([...(task.contexts ?? []), ...allContexts]),\n\t\t        })\n\t\t        setTasks((prev) => [next, ...prev])\n\t\t        createdTaskCount += 1\n\t\t        createdTaskKeys.add(makeTaskKey(next.title))\n\t\t        setCaptureProgress((p) => [...p, `+ Task: ${next.title}`].slice(-10))\n\n\t\t        if (!captureHasNonLogEvent) {\n\t\t          lastCreated = { kind: 'task', id: next.id }\n\t\t          if (navigateToMs == null && next.scheduledAt) navigateToMs = next.scheduledAt\n\t\t        }\n\n\t\t        const block = await maybeCreateTaskCalendarBlock({\n\t\t          task: next,\n\t\t          tags: mergedTags,\n          location: locationHint ?? null,\n          people: peopleHint,\n\t\t          contexts: allContexts,\n\t\t          entityIds,\n\t\t        })\n\t\t        if (block && !captureHasNonLogEvent) {\n\t\t          lastCreated = { kind: 'event', id: block.id }\n\t\t          navigateToMs = block.startAt\n\t\t        }\n\t\t      }\n\t\t    } else {\n\t\t      setCaptureProgress((p) => [...p, 'Skipped local parsing (AI parser succeeded)'].slice(-10))\n\t\t    }\n\n    if (attachedMode && captureAttachEventId) {\n      const attached = events.find((e) => e.id === captureAttachEventId) ?? null\n      if (attached) {\n        if (!mealEventId && isMealEventCandidate(attached.title, attached.tags)) {\n          mealEventId = attached.id\n          mealEvent = attached\n        }\n        const noteTasks = (llm?.tasks?.length ?? 0) > 0 ? llm!.tasks : natural.tasks\n        const noteEvents = (llm?.events?.length ?? 0) > 0 ? llm!.events : natural.events\n        const block = buildAttachedCaptureMarkdown(nowMs, { tasks: noteTasks, events: noteEvents })\n        const nextNotes = normalizeTaskChecklistNotes(appendMarkdownBlock(attached.notes, block))\n        const nextTags = uniqStrings([...(attached.tags ?? []), ...allTagTokens])\n        const nextPeople = uniqStrings([...(attached.people ?? []), ...personMentions])\n        const nextContexts = uniqStrings([...(attached.contexts ?? []), ...allContexts])\n        const nextLocation = attached.location ?? (placeMentions.length ? uniqStrings(placeMentions).join(', ') : null)\n        commitEvent({\n          ...attached,\n          notes: nextNotes,\n          tags: nextTags,\n          people: nextPeople,\n          contexts: nextContexts,\n          location: nextLocation,\n        })\n        setCaptureProgress((p) => [...p, `Appended transcript to \"${attached.title}\"`].slice(-10))\n      }\n    }\n\n    // Use LLM-parsed workouts if available, otherwise fall back to local regex parser\n    const llmWorkout = (llm?.workouts?.length ?? 0) > 0 ? llm!.workouts[0] : null\n    const normalizeExerciseName = (value: string) => value.toLowerCase().replace(/[^a-z0-9]+/g, ' ').trim()\n    const hasMeaningfulSets = (sets: Array<{ reps?: number; weight?: number; duration?: number; distance?: number; rpe?: number }>) =>\n      sets.some((set) => set.reps || set.weight || set.duration || set.distance || set.rpe)\n    const parsedWorkout = llmWorkout\n      ? (() => {\n          const localExercises = localWorkout?.exercises ?? []\n          const localMap = new Map(localExercises.map((ex) => [normalizeExerciseName(ex.name), ex]))\n\n          if (llmWorkout.isSetAddition) {\n            const llmExercises = llmWorkout.exercises.map((ex) => ({\n              id: `ex_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n              name: ex.name,\n              type: ex.type ?? 'strength',\n              sets: ex.sets,\n              muscleGroups: ex.muscleGroups,\n              notes: ex.notes,\n            }))\n            return {\n              type: llmWorkout.type,\n              exercises: llmExercises,\n              totalDuration: llmWorkout.totalDuration,\n              overallRpe: llmWorkout.overallRpe,\n              isSetAddition: llmWorkout.isSetAddition,\n              targetExerciseName: llmWorkout.targetExerciseName,\n            }\n          }\n\n          const used = new Set<string>()\n          const mergedExercises = llmWorkout.exercises.map((ex) => {\n            const key = normalizeExerciseName(ex.name)\n            const local = localMap.get(key)\n            if (local) used.add(key)\n            const nextSets = hasMeaningfulSets(ex.sets) ? ex.sets : (local?.sets ?? ex.sets)\n            return {\n              id: `ex_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n              name: ex.name,\n              type: ex.type ?? local?.type ?? 'strength',\n              sets: nextSets,\n              muscleGroups: ex.muscleGroups ?? local?.muscleGroups,\n              notes: ex.notes ?? local?.notes,\n            }\n          })\n          for (const local of localExercises) {\n            const key = normalizeExerciseName(local.name)\n            if (!used.has(key)) mergedExercises.push(local)\n          }\n\n          return {\n            type: llmWorkout.type ?? localWorkout?.type ?? 'mixed',\n            exercises: mergedExercises,\n            totalDuration: llmWorkout.totalDuration ?? localWorkout?.totalDuration,\n            overallRpe: llmWorkout.overallRpe ?? localWorkout?.overallRpe,\n            isSetAddition: llmWorkout.isSetAddition,\n            targetExerciseName: llmWorkout.targetExerciseName,\n          }\n        })()\n      : localWorkout\n\n    if (parsedWorkout && parsedWorkout.exercises?.length) {\n      const durationMinutes =\n        parsedWorkout.totalDuration ??\n        (Math.round(parsedWorkout.exercises.flatMap((ex) => ex.sets).reduce((sum, set) => sum + (set.duration ?? 0), 0) / 60) || undefined)\n      const startAt = anchorMs ?? nowMs\n      const endAt = durationMinutes ? startAt + durationMinutes * 60 * 1000 : startAt\n      const typeLabel = parsedWorkout.type ?? 'mixed'\n      const defaultTitle =\n        typeLabel === 'cardio'\n          ? 'Cardio'\n          : typeLabel === 'strength'\n            ? 'Strength'\n            : typeLabel === 'mobility'\n              ? 'Mobility'\n              : typeLabel === 'recovery'\n                ? 'Recovery'\n                : 'Workout'\n      const title =\n        parsedWorkout.exercises.length === 1\n          ? parsedWorkout.exercises[0].name\n          : defaultTitle === 'Workout'\n            ? 'Workout'\n            : `${defaultTitle} Workout`\n      const workoutId = `wrk_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`\n      const estimatedCalories = estimateCalories({\n        id: workoutId,\n        eventId: capturePrimaryEventId ?? note.id,\n        type: parsedWorkout.type ?? 'mixed',\n        title,\n        exercises: parsedWorkout.exercises,\n        startAt,\n        endAt,\n        totalDuration: durationMinutes,\n        overallRpe: parsedWorkout.overallRpe,\n        tags: ['#workout', `#${typeLabel}`],\n        createdAt: Date.now(),\n        updatedAt: Date.now(),\n      })\n\n      await saveWorkout({\n        id: workoutId,\n        eventId: capturePrimaryEventId ?? note.id,\n        type: parsedWorkout.type ?? 'mixed',\n        title,\n        exercises: parsedWorkout.exercises,\n        startAt,\n        endAt,\n        totalDuration: durationMinutes,\n        estimatedCalories,\n        overallRpe: parsedWorkout.overallRpe,\n        tags: ['#workout', `#${typeLabel}`],\n      })\n    }\n\n    // Use LLM-parsed meals if available, otherwise fall back to local regex parser\n    const llmMeal = (llm?.meals?.length ?? 0) > 0 ? llm!.meals[0] : null\n    const parsedMeal = llmMeal\n      ? {\n          type: llmMeal.type,\n          items: llmMeal.items,\n          totalCalories: llmMeal.totalCalories,\n          macros: llmMeal.macros ?? { protein: 0, carbs: 0, fat: 0 },\n          location: llmMeal.location,\n          notes: llmMeal.notes,\n        }\n      : localMeal\n    if (parsedMeal && parsedMeal.items?.length) {\n      const eatenAt = anchorMs ?? nowMs\n      const mealTitle =\n        parsedMeal.items.length === 1\n          ? parsedMeal.items[0].name\n          : parsedMeal.type === 'breakfast'\n            ? 'Breakfast'\n            : parsedMeal.type === 'lunch'\n              ? 'Lunch'\n              : parsedMeal.type === 'dinner'\n                ? 'Dinner'\n                : parsedMeal.type === 'drink'\n                  ? 'Drink'\n                  : 'Snack'\n      const mealTags = ['#food', `#${parsedMeal.type}`]\n      const normalizeItem = (item: FoodItem) => ({\n        ...item,\n        id: item.id ?? makeFoodItemId(),\n        name: item.name?.trim() || 'Food',\n        quantity: Number.isFinite(item.quantity) ? item.quantity : 1,\n        unit: item.unit?.trim() || 'serving',\n      })\n\n      const sumMealFromItems = (items: FoodItem[]) => {\n        const sumField = (key: keyof FoodItem) => {\n          let total = 0\n          let has = false\n          for (const item of items) {\n            const value = item[key]\n            if (typeof value === 'number' && Number.isFinite(value)) {\n              total += value\n              has = true\n            }\n          }\n          return { total, has }\n        }\n\n        const calories = sumField('calories')\n        const protein = sumField('protein')\n        const carbs = sumField('carbs')\n        const fat = sumField('fat')\n        const fiber = sumField('fiber')\n        const saturatedFat = sumField('saturatedFat')\n        const transFat = sumField('transFat')\n        const sugar = sumField('sugar')\n        const sodium = sumField('sodium')\n        const potassium = sumField('potassium')\n        const cholesterol = sumField('cholesterol')\n\n        return {\n          totalCalories: calories.total,\n          hasCalories: calories.has,\n          macros: {\n            protein: protein.total,\n            carbs: carbs.total,\n            fat: fat.total,\n            fiber: fiber.has ? fiber.total : undefined,\n            saturatedFat: saturatedFat.has ? saturatedFat.total : undefined,\n            transFat: transFat.has ? transFat.total : undefined,\n            sugar: sugar.has ? sugar.total : undefined,\n            sodium: sodium.has ? sodium.total : undefined,\n            potassium: potassium.has ? potassium.total : undefined,\n            cholesterol: cholesterol.has ? cholesterol.total : undefined,\n          },\n          hasMacroData: protein.has || carbs.has || fat.has || fiber.has || saturatedFat.has || transFat.has || sugar.has || sodium.has || potassium.has || cholesterol.has,\n        }\n      }\n\n      const formatUnitLabel = (quantity: number, unit: string) => {\n        const base = unit.trim() || 'serving'\n        if (quantity === 1) return base\n        const noPlural = new Set(['oz', 'g', 'kg', 'mg', 'lb', 'lbs', 'ml'])\n        if (noPlural.has(base)) return base\n        if (base.endsWith('s')) return base\n        return `${base}s`\n      }\n\n      const formatMacroCell = (value: number | undefined, unit: string) =>\n        typeof value === 'number' && Number.isFinite(value) ? `${Math.round(value)}${unit}` : '-'\n\n      const buildNutritionTable = (items: FoodItem[], totalCalories: number, macros: ExtendedMacros) => {\n        if (!items.length) return ''\n        const header = [\n          '## Nutrition',\n          '',\n          '| Qty | Item | Calories | Protein | Carbs | Fat | Fiber | Sodium | Potassium |',\n          '| --- | --- | --- | --- | --- | --- | --- | --- | --- |',\n        ]\n        const rows = items.map((item) => {\n          const qty = Number.isFinite(item.quantity) ? item.quantity : 1\n          const unit = item.unit?.trim() || 'serving'\n          const qtyLabel = `${qty} ${formatUnitLabel(qty, unit)}`\n          return `| ${qtyLabel} | ${item.name} | ${formatMacroCell(item.calories, ' kcal')} | ${formatMacroCell(item.protein, 'g')} | ${formatMacroCell(item.carbs, 'g')} | ${formatMacroCell(item.fat, 'g')} | ${formatMacroCell(item.fiber, 'g')} | ${formatMacroCell(item.sodium, 'mg')} | ${formatMacroCell(item.potassium, 'mg')} |`\n        })\n        const totalRow = `| **Total** |  | ${formatMacroCell(totalCalories, ' kcal')} | ${formatMacroCell(macros.protein, 'g')} | ${formatMacroCell(macros.carbs, 'g')} | ${formatMacroCell(macros.fat, 'g')} | ${formatMacroCell(macros.fiber, 'g')} | ${formatMacroCell(macros.sodium, 'mg')} | ${formatMacroCell(macros.potassium, 'mg')} |`\n        return [...header, ...rows, totalRow].join('\\n')\n      }\n\n      const appendNutritionTable = (notes: string | null | undefined, table: string) => {\n        if (!table) return notes ?? ''\n        const existing = notes ?? ''\n        if (existing.includes('## Nutrition') || existing.includes('| Qty | Item |')) return existing\n        const spacer = existing.trim().length ? '\\n\\n' : ''\n        return `${existing}${spacer}${table}`.trim()\n      }\n\n      let items = parsedMeal.items.map((item) => normalizeItem(item as FoodItem))\n      let estimationModel: string | undefined\n\n      const itemsNeedNutrition = items.some((item) =>\n        item.calories == null ||\n        item.protein == null ||\n        item.carbs == null ||\n        item.fat == null ||\n        item.fiber == null ||\n        item.saturatedFat == null ||\n        item.sugar == null ||\n        item.sodium == null ||\n        item.potassium == null ||\n        item.cholesterol == null\n      )\n\n      let needsLocalEstimate = itemsNeedNutrition && !shouldTryLlm\n      if (itemsNeedNutrition && shouldTryLlm) {\n        const description = items\n          .map((item) => `${item.quantity} ${item.unit} ${item.name}`.trim())\n          .filter(Boolean)\n          .join(', ')\n        try {\n          setCaptureAiStatus('Estimating nutrition\u2026')\n          const estimate = await estimateNutritionWithLlm({\n            apiKey: llmKey,\n            model: (llmSettings.nutritionModel ?? llmSettings.chatModel ?? 'gpt-4.1-mini').trim() || 'gpt-4.1-mini',\n            foodDescription: description || captureText,\n            mealType: parsedMeal.type,\n          })\n          items = estimate.items.map((item) => normalizeItem(item))\n          estimationModel = estimate.model\n          const totals = sumMealFromItems(items)\n          parsedMeal.totalCalories = estimate.totalCalories || totals.totalCalories\n          parsedMeal.macros = estimate.macros\n          setCaptureProgress((p) => [...p, `Nutrition estimated (${estimate.model})`].slice(-10))\n        } catch (err) {\n          console.warn('Nutrition estimation failed:', err)\n          setCaptureProgress((p) => [...p, 'Nutrition estimate failed; used local totals'].slice(-10))\n          needsLocalEstimate = true\n        }\n      }\n\n      if (needsLocalEstimate) {\n        items = items.map((item) => {\n          if (item.calories != null && item.protein != null && item.carbs != null && item.fat != null) return item\n          const estimated = estimateFoodNutrition(item.name, item.quantity, item.unit)\n          return {\n            ...item,\n            calories: item.calories ?? estimated.calories,\n            protein: item.protein ?? estimated.protein,\n            carbs: item.carbs ?? estimated.carbs,\n            fat: item.fat ?? estimated.fat,\n            fiber: item.fiber ?? estimated.fiber,\n            saturatedFat: item.saturatedFat ?? estimated.saturatedFat,\n            transFat: item.transFat ?? estimated.transFat,\n            sugar: item.sugar ?? estimated.sugar,\n            sodium: item.sodium ?? estimated.sodium,\n            potassium: item.potassium ?? estimated.potassium,\n            cholesterol: item.cholesterol ?? estimated.cholesterol,\n            confidence: item.confidence ?? estimated.confidence,\n            source: item.source ?? estimated.source,\n          }\n        })\n      }\n\n      const totals = sumMealFromItems(items)\n      const totalCalories = parsedMeal.totalCalories && parsedMeal.totalCalories > 0\n        ? parsedMeal.totalCalories\n        : totals.totalCalories\n      const macros = {\n        protein: parsedMeal.macros?.protein ?? totals.macros.protein ?? 0,\n        carbs: parsedMeal.macros?.carbs ?? totals.macros.carbs ?? 0,\n        fat: parsedMeal.macros?.fat ?? totals.macros.fat ?? 0,\n        fiber: parsedMeal.macros?.fiber ?? totals.macros.fiber,\n        saturatedFat: parsedMeal.macros?.saturatedFat ?? totals.macros.saturatedFat,\n        transFat: parsedMeal.macros?.transFat ?? totals.macros.transFat,\n        sugar: parsedMeal.macros?.sugar ?? totals.macros.sugar,\n        sodium: parsedMeal.macros?.sodium ?? totals.macros.sodium,\n        potassium: parsedMeal.macros?.potassium ?? totals.macros.potassium,\n        cholesterol: parsedMeal.macros?.cholesterol ?? totals.macros.cholesterol,\n      }\n\n      const roundOptional = (value?: number) => (typeof value === 'number' && Number.isFinite(value) ? Math.round(value) : undefined)\n      const nutritionTable = buildNutritionTable(items, totalCalories ?? 0, macros)\n      const mealNotes = appendNutritionTable(parsedMeal.notes ?? '', nutritionTable)\n\n      if (!mealEventId && allowEventCreation) {\n        const startAt = eatenAt\n        const durationMinutes = Math.max(15, durationOverride ?? 30)\n        const endAt = startAt + durationMinutes * 60 * 1000\n        const key = makeEventKey(mealTitle, startAt, endAt)\n        if (!createdEventKeys.has(key)) {\n          const { mergedTags, inferred } = finalizeCategorizedTags({ title: mealTitle, tags: mealTags })\n          const ev = await createEvent({\n            title: mealTitle,\n            startAt,\n            endAt,\n            kind: 'event',\n            tags: mergedTags,\n            contexts: allContexts,\n            entityIds,\n            sourceNoteId: note.id,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            goal: goalOverride,\n            project: projectOverride,\n            importance: importanceOverride ?? 5,\n            difficulty: difficultyOverride ?? 5,\n          })\n          const next = await upsertEvent({\n            ...ev,\n            notes: mealNotes || ev.notes,\n            category: inferred.category,\n            subcategory: inferred.subcategory,\n            estimateMinutes: durationMinutes,\n            location: parsedMeal.location ?? null,\n            people: cleanPeopleList(uniqStrings(personMentions)),\n            skills: [],\n            character: normalizeCharacterSelection([]),\n            importance: importanceOverride ?? ev.importance ?? 5,\n            difficulty: difficultyOverride ?? ev.difficulty ?? 5,\n            goal: ev.goal ?? goalOverride ?? null,\n            project: ev.project ?? projectOverride ?? null,\n            contexts: uniqStrings([...(ev.contexts ?? []), ...allContexts]),\n          })\n          rememberMealEvent(next)\n          setEvents((prev) => [next, ...prev])\n          createdEventKeys.add(makeEventKey(next.title, next.startAt, next.endAt))\n          createdEventCount += 1\n          captureHasNonLogEvent = true\n          if (!capturePrimaryEventId) capturePrimaryEventId = next.id\n          lastCreated = { kind: 'event', id: next.id }\n          if (navigateToMs == null || next.startAt < navigateToMs) navigateToMs = next.startAt\n          setCaptureProgress((p) => [...p, `+ event: ${next.title}`].slice(-10))\n        }\n      }\n\n      await saveMeal({\n        id: `meal_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,\n        eventId: mealEventId ?? capturePrimaryEventId ?? note.id,\n        type: parsedMeal.type,\n        title: mealTitle,\n        items,\n        totalCalories: Math.round(totalCalories ?? 0),\n        macros: {\n          protein: Math.round(macros.protein ?? 0),\n          carbs: Math.round(macros.carbs ?? 0),\n          fat: Math.round(macros.fat ?? 0),\n          fiber: roundOptional(macros.fiber),\n          saturatedFat: roundOptional(macros.saturatedFat),\n          transFat: roundOptional(macros.transFat),\n          sugar: roundOptional(macros.sugar),\n          sodium: roundOptional(macros.sodium),\n          potassium: roundOptional(macros.potassium),\n          cholesterol: roundOptional(macros.cholesterol),\n        },\n        eatenAt,\n        tags: mealTags,\n        estimationModel,\n      })\n\n      if (mealEventId && mealEvent) {\n        const nextNotes = appendNutritionTable(mealEvent.notes, nutritionTable)\n        if (nextNotes !== mealEvent.notes) {\n          const updated = await upsertEvent({ ...mealEvent, notes: nextNotes })\n          setEvents((prev) => prev.map((ev) => (ev.id === updated.id ? updated : ev)))\n          mealEvent = updated\n        }\n      }\n    }\n\n    setCaptureProgress((p) => [...p, `Created: ${createdEventCount} event(s), ${createdLogCount} log(s), ${createdTaskCount} task(s)`].slice(-10))\n\n    if (createdEventCount > 0 || createdLogCount > 0 || createdTaskCount > 0) {\n      await refreshAll()\n    }\n\n    if (lastCreated.kind !== 'none') {\n      setSelection(lastCreated)\n    } else if (captureAttachEventId) {\n      setSelection({ kind: 'event', id: captureAttachEventId })\n    }\n\n    if (captureReturnView) {\n      if (captureReturnView === 'calendar' && navigateToMs != null) {\n        setAgendaDate(new Date(navigateToMs))\n      }\n      openView(captureReturnView)\n    }\n\n\t\t    if (!llmError) {\n\t\t      setCaptureDraft('')\n\t\t      setCaptureInterim('')\n\t\t      setCaptureAttachEventId(null)\n\t\t      setCaptureReturnView(null)\n\t\t      setCaptureOpen(false)\n\t\t    }\n\t\t    } finally {\n\t      setCaptureSaving(false)\n\t      setCaptureAiStatus('')\n\t    }\n\t  }\n\n  function requestDeleteSelection(opts?: { skipConfirm?: boolean }) {\n    void (async () => {\n      if (selection.kind === 'task') {\n        const t = tasks.find((x) => x.id === selection.id)\n        if (!t) return\n        const ok = opts?.skipConfirm ? true : window.confirm(`Delete task: \"${t.title}\"?`)\n        if (!ok) return\n        await deleteTask(t.id)\n        setTasks((prev) => prev.filter((x) => x.id !== t.id))\n        setSelection({ kind: 'none' })\n        return\n      }\n      if (selection.kind === 'event') {\n        const ev = events.find((x) => x.id === selection.id)\n        if (!ev) return\n        const ok = opts?.skipConfirm ? true : window.confirm(`Delete ${ev.kind}: \"${ev.title}\"?`)\n        if (!ok) return\n        await deleteEvent(ev.id)\n        setEvents((prev) => prev.filter((x) => x.id !== ev.id && x.parentEventId !== ev.id))\n        setSelection({ kind: 'none' })\n      }\n    })()\n  }\n\n  useEffect(() => {\n    function onKeyDown(e: KeyboardEvent) {\n      if (isTextInputTarget(e.target)) return\n      if (e.key !== 'Backspace' && e.key !== 'Delete') return\n      if (selection.kind !== 'task' && selection.kind !== 'event') return\n      e.preventDefault()\n      requestDeleteSelection({ skipConfirm: e.shiftKey })\n    }\n    window.addEventListener('keydown', onKeyDown)\n    return () => window.removeEventListener('keydown', onKeyDown)\n  }, [events, selection, tasks])\n\n  function renderView(view: WorkspaceViewKey) {\n    const renderNotes = (initialFilterType?: 'all' | 'category' | 'tag' | 'person' | 'place') => (\n      <NotesView\n        key={initialFilterType ?? 'all'}\n        captures={captures}\n        selectedCaptureId={selection.kind === 'capture' ? selection.id : null}\n        onSelectCapture={(id) => setSelection({ kind: 'capture', id })}\n        onOpenCapture={() => openCapture()}\n        onUpdateCapture={onUpdateCapture}\n        initialFilterType={initialFilterType}\n      />\n    )\n    switch (view) {\n      case 'dashboard':\n        return <DashboardView events={events} tasks={tasks} trackerDefs={trackerDefs} />\n      case 'notes':\n        return renderNotes('all')\n      case 'reflections':\n        return renderNotes('all')\n          case 'tasks':\n            return (          <TickTickTasksView\n            tasks={tasks}\n            selectedTaskId={selection.kind === 'task' ? selection.id : null}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n            onCreateTask={onCreateTaskFromInput}\n            onToggleComplete={onToggleTaskComplete}\n            onMoveTask={onMoveTaskStatus}\n          />\n        )\n      case 'calendar':\n        return (\n          <PlannerView\n            date={agendaDate}\n            onDateChange={setAgendaDate}\n            onRefresh={refreshAll}\n            tasks={tasks}\n            captures={captures}\n            events={events}\n            selection={selection}\n            setSelection={setSelection}\n            onCreateTask={onCreateTaskFromInput}\n            onToggleTaskComplete={onToggleTaskComplete}\n            onToggleTaskChecklistItem={onToggleTaskChecklistItem}\n            onRequestCreateEvent={openEventComposer}\n            onCreateEvent={onCreateEvent}\n            onMoveEvent={onMoveEvent}\n            onToggleEventComplete={onToggleEventComplete}\n            onUpdateEvent={onUpdateEvent}\n            eventTitleDetail={eventTitleDetail}\n          />\n        )\n      case 'assistant':\n        return (\n          <AssistantView\n            captures={captures}\n            events={events}\n            tasks={tasks}\n            onSelectCapture={(id) => setSelection({ kind: 'capture', id })}\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n          />\n        )\n      case 'settings':\n        return <SettingsView />\n      case 'timeline':\n        return (\n          <TimelineView\n            events={events}\n            captures={captures}\n            activeTagFilters={timelineTagFilters}\n            onToggleTag={(t) =>\n              setTimelineTagFilters((prev) => (prev.includes(t) ? prev.filter((x) => x !== t) : [...prev, t].slice(0, 6)))\n            }\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectCapture={(id) => setSelection({ kind: 'capture', id })}\n          />\n        )\n      case 'habits':\n        return (\n          <HabitsView\n            events={events}\n            onCreatedEvent={(ev) => setEvents((prev) => [ev, ...prev])}\n            onOpenReports={(habitId) => openHabitReports(habitId)}\n          />\n        )\n      case 'goals':\n        return (\n          <GoalsView\n            events={events}\n            tasks={tasks}\n            mode=\"list\"\n            onOpenGoal={openGoalDetail}\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n            onCreatedTask={(task) => setTasks((prev) => [task, ...prev])}\n            onCreatedEvent={(ev) => setEvents((prev) => [ev, ...prev])}\n            onUpdateEvent={onUpdateEvent}\n            onDeleteEvent={async (id) => {\n              await deleteEvent(id)\n              setEvents((prev) => prev.filter((x) => x.id !== id && x.parentEventId !== id))\n            }}\n          />\n        )\n      case 'goal-detail':\n        return (\n          <GoalsView\n            events={events}\n            tasks={tasks}\n            mode=\"detail\"\n            goalName={selectedGoal}\n            onOpenGoal={openGoalDetail}\n            onSelectEvent={(id) => setSelection({ kind: 'event', id })}\n            onSelectTask={(id) => setSelection({ kind: 'task', id })}\n            onCreatedTask={(task) => setTasks((prev) => [task, ...prev])}\n            onCreatedEvent={(ev) => setEvents((prev) => [ev, ...prev])}\n            onUpdateEvent={onUpdateEvent}\n            onDeleteEvent={async (id) => {\n              await deleteEvent(id)\n              setEvents((prev) => prev.filter((x) => x.id !== id && x.parentEventId !== id))\n            }}\n          />\n        )\n      case 'ecosystem':\n        return (\n          <EcosystemView\n            events={events}\n            tasks={tasks}\n            trackerDefs={trackerDefs}\n            onOpenGoal={openGoalDetail}\n            onOpenProject={openProjectDetail}\n            onOpenTracker={openTrackerDetail}\n            onTrackerDefsChange={setTrackerDefs}\n          />\n        )\n      case 'projects':\n        return (\n          <ProjectsView\n            events={events}\n            tasks={tasks}\n            projectName={selectedProject}\n            onSelectProject={setSelectedProject}\n          />\n        )\n      case 'trackers':\n        return (\n          <TrackersView\n            events={events}\n            trackerDefs={trackerDefs}\n            trackerKey={selectedTrackerKey}\n            onSelectTracker={setSelectedTrackerKey}\n            onTrackerDefsChange={setTrackerDefs}\n          />\n        )\n      case 'rewards':\n        return <RewardsView events={events} />\n      case 'reports':\n        return renderNotes('category')\n      case 'health':\n        return <HealthDashboard events={events} trackerDefs={trackerDefs} />\n      default:\n        return <PlaceholderView title=\"View\" subtitle=\"Coming soon.\" />\n    }\n  }\n\n\t  const active = getActiveTab(workspace)\n\n  const selectedTask = selection.kind === 'task' ? tasks.find((t) => t.id === selection.id) ?? null : null\n  const selectedEvent = selection.kind === 'event' ? events.find((e) => e.id === selection.id) ?? null : null\n  const selectedCapture = selection.kind === 'capture' ? captures.find((c) => c.id === selection.id) ?? null : null\n  const selectionKey = selection.kind === 'none' ? 'none' : `${selection.kind}:${selection.id}`\n  const docTranscriptText =\n    selection.kind === 'capture'\n      ? selectedCapture?.rawText ?? ''\n      : selection.kind === 'event'\n        ? selectedEvent?.notes ?? ''\n        : selection.kind === 'task'\n          ? selectedTask?.notes ?? ''\n          : ''\n  const docTranscriptLines = useMemo(() => parseTimestampedTranscript(docTranscriptText), [docTranscriptText])\n  const selectedTaskTags = selectedTask?.tags ?? []\n  const selectedTaskContexts = selectedTask?.contexts ?? []\n  const selectedTaskPeople = selectedTask?.people ?? []\n  const selectedTaskLocations = selectedTask?.location ? parseCommaList(selectedTask.location) : []\n  const selectedTaskSkills = selectedTask?.skills ?? []\n  const selectedTaskCharacter = selectedTask?.character ?? []\n  const selectedEventTags = selectedEvent?.tags ?? []\n  const selectedEventContexts = selectedEvent?.contexts ?? []\n  const selectedEventPeople = selectedEvent?.people ?? []\n  const selectedEventLocations = selectedEvent?.location ? parseCommaList(selectedEvent.location) : []\n  const selectedEventSkills = selectedEvent?.skills ?? []\n  const selectedEventTracker = useMemo(() => {\n    if (!selectedEvent?.trackerKey) return null\n    const raw = selectedEvent.trackerKey.trim()\n    if (!raw) return null\n    if (raw.startsWith('habit:')) {\n      const habitId = raw.slice('habit:'.length)\n      const habit = habitDefs.find((h) => h.id === habitId) ?? null\n      return { key: raw, label: habit?.name ?? 'Habit' }\n    }\n    const def = trackerDefs.find((t) => t.key === raw) ?? null\n    return { key: raw, label: def?.label ?? raw }\n  }, [habitDefs, selectedEvent?.trackerKey, trackerDefs])\n  const [nowTick, setNowTick] = useState(() => Date.now())\n\n  useEffect(() => {\n    if (!docOpen) return\n    setDocTab(selection.kind === 'capture' ? 'transcript' : 'notes')\n    setDocTranscriptFocus(null)\n  }, [docOpen, selectionKey])\n\n\t  const selectedEventLogs = useMemo(() => {\n\t    if (!selectedEvent) return []\n\t    return events\n      .filter((e) => e.kind === 'log' && e.parentEventId === selectedEvent.id)\n      .sort((a, b) => a.startAt - b.startAt)\n      .slice(0, 50)\n  }, [events, selectedEvent?.id])\n\n  const selectedEventTasks = useMemo(() => {\n    if (!selectedEvent) return []\n    return tasks\n      .filter((t) => t.parentEventId === selectedEvent.id)\n      .sort((a, b) => b.updatedAt - a.updatedAt)\n      .slice(0, 50)\n  }, [selectedEvent?.id, tasks])\n  const selectedEventNoteTasks = useMemo(() => {\n    if (!selectedEvent) return {}\n    const map: Record<string, { status: string; startedAt?: number | null }> = {}\n    for (const t of selectedEventTasks) {\n      const tokenId = noteItemTokenId(t.notes ?? '')\n      if (!tokenId) continue\n      map[tokenId] = {\n        status: t.status,\n        startedAt: t.status === 'in_progress' ? t.updatedAt : null,\n      }\n    }\n    for (const e of events) {\n      if (e.parentEventId !== selectedEvent.id) continue\n      const tokenId = noteItemTokenId(e.notes ?? '')\n      if (!tokenId) continue\n      const status = e.active ? 'in_progress' : 'done'\n      if (map[tokenId]?.status === 'in_progress' && !e.active) continue\n      map[tokenId] = {\n        status,\n        startedAt: e.active ? e.startAt : null,\n      }\n    }\n    return map\n  }, [events, selectedEvent, selectedEventTasks])\n  const hasRunningNoteTask = useMemo(\n    () => Object.values(selectedEventNoteTasks).some((t) => t.status === 'in_progress'),\n    [selectedEventNoteTasks],\n  )\n\n  useEffect(() => {\n    if (!selectedEvent?.active && !hasRunningNoteTask) return\n    const id = window.setInterval(() => setNowTick(Date.now()), 1000)\n    return () => window.clearInterval(id)\n  }, [selectedEvent?.active, hasRunningNoteTask])\n\n  const selectedEventMinutes = selectedEvent\n    ? Math.max(0, Math.round(((selectedEvent.active ? nowTick : selectedEvent.endAt) - selectedEvent.startAt) / (60 * 1000)))\n    : 0\n  const selectedEventBase = selectedEvent ? basePoints(selectedEvent.importance, selectedEvent.difficulty) : 0\n  const selectedEventMult = selectedEvent ? multiplierFor(selectedEvent.goal ?? null, selectedEvent.project ?? null) : 1\n  const selectedEventPoints = selectedEvent ? pointsForEventAt(selectedEvent, nowTick) : 0\n\n  const explorerTasks = useMemo(() => {\n    const needle = explorerTaskQuery.trim().toLowerCase()\n    const base = tasks.filter((t) => t.status !== 'done')\n    const filtered = needle\n      ? base.filter((t) => t.title.toLowerCase().includes(needle) || (t.tags ?? []).some((x) => x.toLowerCase().includes(needle)))\n      : base\n    return [...filtered].sort((a, b) => (b.dueAt ?? 0) - (a.dueAt ?? 0) || b.updatedAt - a.updatedAt).slice(0, 20)\n  }, [explorerTaskQuery, tasks])\n\n\t  // Pomodoro (MVP)\n\t  const [pomoRunning, setPomoRunning] = useState(false)\n\t  const [pomoSeconds, setPomoSeconds] = useState(25 * 60)\n\t\t  const [pomoActiveTaskId, setPomoActiveTaskId] = useState<string | null>(() => {\n\t\t    try {\n\t\t      return localStorage.getItem('insight5.pomo.activeTaskId') || null\n\t\t    } catch {\n\t\t      return null\n\t\t    }\n\t\t  })\n\t\t  const pomoActiveTask = pomoActiveTaskId ? tasks.find((t) => t.id === pomoActiveTaskId) ?? null : null\n\t\t  const pomoMinutes = Math.floor(pomoSeconds / 60)\n\t\t  const pomoRemainder = pomoSeconds % 60\n\n\t  useEffect(() => {\n\t    if (!pomoRunning) return\n\t    const id = window.setInterval(() => setPomoSeconds((s) => Math.max(0, s - 1)), 1000)\n\t    return () => window.clearInterval(id)\n\t  }, [pomoRunning])\n\n\t  useEffect(() => {\n\t    try {\n\t      if (pomoActiveTaskId) localStorage.setItem('insight5.pomo.activeTaskId', pomoActiveTaskId)\n\t      else localStorage.removeItem('insight5.pomo.activeTaskId')\n\t    } catch {\n\t      // ignore\n\t    }\n\t  }, [pomoActiveTaskId])\n\n\t\t  const pomoProgress = clamp01(1 - pomoSeconds / (25 * 60))\n\n\t\t  const taxonomyCategories = useMemo(() => {\n\t\t    const starter = categoriesFromStarter()\n\t\t    const fromData = uniqStrings([\n\t\t      ...tasks.map((t) => t.category ?? ''),\n\t\t      ...events.map((e) => e.category ?? ''),\n\t\t    ])\n\t\t    const extra = fromData.filter((c) => c && !starter.some((s) => s.toLowerCase() === c.toLowerCase())).sort((a, b) => a.localeCompare(b))\n\t\t    return [...starter, ...extra]\n\t\t  }, [events, tasks])\n\n\t\t  const taxonomyActiveCategory = (selectedTask?.category ?? selectedEvent?.category ?? '').trim() || null\n\n\t\t  const taxonomySubcategories = useMemo(() => {\n\t\t    const starterSubs = taxonomyActiveCategory ? subcategoriesFromStarter(taxonomyActiveCategory) : []\n\t\t    const fromData = uniqStrings([\n\t\t      ...tasks\n\t\t        .filter((t) => (taxonomyActiveCategory ? (t.category ?? '').toLowerCase() === taxonomyActiveCategory.toLowerCase() : true))\n\t\t        .map((t) => t.subcategory ?? ''),\n\t\t      ...events\n\t\t        .filter((e) => (taxonomyActiveCategory ? (e.category ?? '').toLowerCase() === taxonomyActiveCategory.toLowerCase() : true))\n\t\t        .map((e) => e.subcategory ?? ''),\n\t\t    ])\n\t\t    const extra = fromData\n\t\t      .filter((s) => s && !starterSubs.some((x) => x.toLowerCase() === s.toLowerCase()))\n\t\t      .sort((a, b) => a.localeCompare(b))\n\t\t    return [...starterSubs, ...extra]\n\t\t  }, [events, tasks, taxonomyActiveCategory])\n\n\t\t  const composerTagList = useMemo(() => parseTags(eventComposer.tagsRaw), [eventComposer.tagsRaw])\n\t\t  const composerPeopleList = useMemo(() => parseCommaList(eventComposer.peopleRaw), [eventComposer.peopleRaw])\n\t\t  const composerLocationList = useMemo(() => parseCommaList(eventComposer.location), [eventComposer.location])\n\n  function parseTags(raw: string) {\n    return raw\n      .split(/[,\\s]+/)\n      .map((t) => t.trim())\n      .filter(Boolean)\n      .map((t) => (t.startsWith('#') ? t : `#${t}`))\n      .slice(0, 12)\n  }\n\n  function normalizeContextToken(raw: string) {\n    const trimmed = raw.trim()\n    if (!trimmed) return null\n    const withoutPrefix = trimmed.replace(/^[@+]/, '').replace(/^at\\s+/i, '').trim()\n    return withoutPrefix || null\n  }\n\n  function parseContexts(raw: string) {\n    return uniqStrings(parseCommaList(raw).map(normalizeContextToken).filter(Boolean))\n  }\n\n  function formatContextLabel(value: string) {\n    const trimmed = value.trim()\n    if (!trimmed) return ''\n    if (/^(@|\\+|at\\s+)/i.test(trimmed)) return trimmed\n    return `at ${trimmed}`\n  }\n\n  function stopVoiceCapture() {\n    shouldListenRef.current = false\n    if (captureTimeoutRef.current) {\n      clearTimeout(captureTimeoutRef.current)\n      captureTimeoutRef.current = null\n    }\n    if (speechRecognitionRef.current) {\n      try {\n        speechRecognitionRef.current.stop()\n      } catch {}\n      speechRecognitionRef.current = null\n    }\n    setCaptureListening(false)\n    setCaptureInterim('')\n  }\n\n  function toggleVoiceCapture(opts?: { silentIfUnavailable?: boolean }) {\n    // If already listening, stop\n    if (shouldListenRef.current || captureListening) {\n      stopVoiceCapture()\n      return\n    }\n\n    const SpeechRecognition =\n      (window as any).SpeechRecognition ?? (window as any).webkitSpeechRecognition ?? (window as any).mozSpeechRecognition\n    if (!SpeechRecognition) {\n      if (!opts?.silentIfUnavailable) alert('Voice capture is not available in this build yet. (Next: Whisper.)')\n      return\n    }\n\n    const rec = new SpeechRecognition()\n    rec.lang = 'en-US'\n    rec.interimResults = true\n    rec.continuous = true // Enable continuous mode for longer recording\n\n    speechRecognitionRef.current = rec\n    shouldListenRef.current = true\n    setCaptureListening(true)\n    setCaptureInterim('')\n\n    // Set timeout based on mode: default 60s, extended 1hr\n    const timeoutMs = captureExtendedMode ? 60 * 60 * 1000 : 60 * 1000\n    captureTimeoutRef.current = setTimeout(() => {\n      stopVoiceCapture()\n    }, timeoutMs)\n\n    rec.onresult = (e: any) => {\n      let finalText = ''\n      let interim = ''\n      const results: SpeechRecognitionResultList | undefined = e.results\n      if (!results) return\n      for (let i = e.resultIndex ?? 0; i < results.length; i++) {\n        const r: any = results[i]\n        const t = r?.[0]?.transcript\n        if (typeof t !== 'string') continue\n        if (r.isFinal) finalText += ` ${t}`\n        else interim += ` ${t}`\n      }\n      const finalTrim = finalText.trim()\n      const interimTrim = interim.trim()\n      setCaptureInterim(interimTrim)\n      if (finalTrim) setCaptureDraft((prev) => (prev.trim() ? `${prev.trim()} ${finalTrim}` : finalTrim))\n    }\n\n    rec.onerror = (e: any) => {\n      // Only stop on fatal errors, not 'no-speech' or 'aborted'\n      if (e.error !== 'no-speech' && e.error !== 'aborted') {\n        stopVoiceCapture()\n      }\n    }\n\n    rec.onend = () => {\n      // Auto-restart if shouldListen is still true and timeout hasn't fired\n      if (shouldListenRef.current && captureTimeoutRef.current) {\n        try {\n          rec.start()\n        } catch {\n          stopVoiceCapture()\n        }\n      } else {\n        setCaptureListening(false)\n        setCaptureInterim('')\n      }\n    }\n\n    rec.start()\n  }\n\n  // Legacy function name for compatibility\n  function startVoiceCapture(opts?: { silentIfUnavailable?: boolean }) {\n    toggleVoiceCapture(opts)\n  }\n\n  function startComposerTranscription() {\n    const SpeechRecognition =\n      (window as any).SpeechRecognition ?? (window as any).webkitSpeechRecognition ?? (window as any).mozSpeechRecognition\n    if (!SpeechRecognition) {\n      alert('Voice transcription is not available in this build yet. (Next: Whisper.)')\n      return\n    }\n    const rec = new SpeechRecognition()\n    rec.lang = 'en-US'\n    rec.interimResults = true\n    rec.continuous = false\n    setComposerListening(true)\n    setComposerInterim('')\n    rec.onresult = (e: any) => {\n      let finalText = ''\n      let interim = ''\n      const results: SpeechRecognitionResultList | undefined = e.results\n      if (!results) return\n      for (let i = e.resultIndex ?? 0; i < results.length; i++) {\n        const r: any = results[i]\n        const t = r?.[0]?.transcript\n        if (typeof t !== 'string') continue\n        if (r.isFinal) finalText += ` ${t}`\n        else interim += ` ${t}`\n      }\n      const finalTrim = finalText.trim()\n      const interimTrim = interim.trim()\n      setComposerInterim(interimTrim)\n      if (finalTrim) {\n        setEventComposer((prev) => {\n          const base = prev.notes.trim()\n          const nextNotes = base ? `${base}\\n${finalTrim}` : finalTrim\n          return { ...prev, notes: nextNotes }\n        })\n      }\n    }\n    rec.onerror = () => {\n      setComposerListening(false)\n      setComposerInterim('')\n    }\n    rec.onend = () => {\n      setComposerListening(false)\n      setComposerInterim('')\n    }\n    rec.start()\n  }\n\n  useEffect(() => {\n    if (!captureOpen) return\n    if (captureListening) return\n    if (captureDraft.trim().length > 0) return\n    startVoiceCapture({ silentIfUnavailable: true })\n  }, [captureOpen, captureListening, captureDraft])\n\n  async function handleAuthSubmit() {\n    const supabase = getSupabaseClient()\n    if (!supabase) {\n      setAuthError('Supabase is not configured. Check VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.')\n      return\n    }\n    const email = authEmail.trim()\n    const password = authPassword.trim()\n    if (!email || !password) {\n      setAuthError('Email and password are required.')\n      return\n    }\n    setAuthWorking(true)\n    setAuthError('')\n    setAuthStatus('')\n    try {\n      if (authMode === 'signup') {\n        const { data, error } = await supabase.auth.signUp({\n          email,\n          password,\n          options: { emailRedirectTo: window.location.origin },\n        })\n        if (error) throw error\n        if (data.session) {\n          setAuthStatus('Account created and signed in.')\n        } else {\n          setAuthStatus('Check your email to confirm your account.')\n        }\n      } else {\n        const { data, error } = await supabase.auth.signInWithPassword({ email, password })\n        if (error) throw error\n        setAuthStatus(data.session ? 'Signed in.' : 'Signed in.')\n      }\n    } catch (err) {\n      setAuthError(err instanceof Error ? err.message : 'Sign in failed.')\n    } finally {\n      setAuthWorking(false)\n    }\n  }\n\n      return (\n\n        <div className=\"uiShell\">\n          {/* Toast Notifications */}\n          <Toaster\n            position=\"top-right\"\n            expand={false}\n            richColors\n            closeButton\n            toastOptions={{\n              style: {\n                fontFamily: 'Figtree, sans-serif',\n              },\n            }}\n          />\n\n                  <main\n\n                    className=\"uiMain\"\n\n                    style={{\n\n                      gridTemplateColumns: `72px ${leftCollapsed ? 0 : 260}px 1fr ${rightCollapsed ? '0px' : 'var(--right-panel-width)'}`,\n\n                      gap: '16px',\n\n                      padding: '16px'\n\n                    }}>             <aside\n                      className={`rail${railLabelsOpen ? ' showLabels' : ''}`}\n                      onMouseLeave={() => setRailLabelsOpen(false)}>\n\n                    <div\n                      className=\"flex flex-col items-center py-4 mb-4\"\n                      onMouseEnter={() => setRailLabelsOpen(true)}>\n\n                      <div className=\"w-12 h-12 bg-white rounded-2xl flex items-center justify-center shadow-lg border border-black/5\">\n\n                          <Icon name=\"sparkle\" className=\"text-[#D95D39]\" />\n\n                      </div>\n\n                    </div>\n\n                    <button \n\n                className={`railBtn ${getActiveTab(workspace).view === 'dashboard' ? 'active' : ''}`} \n\n                aria-label=\"Dashboard\" title=\"Dashboard\" onClick={() => openView('dashboard')}\n\n              >\n\n  \t            <Icon name=\"home\" />\n                <span className=\"railLabel\" aria-hidden=\"true\">Dashboard</span>\n\n  \t          </button>\n\n  \t          <button\n\n                className=\"railBtn railPrimary group\"\n\n                aria-label=\"Capture\"\n\n                title=\"Capture\"\n\n                          onClick={() => {\n\n                            openCapture()\n\n                          }}>\n\n  \t                        <Icon name=\"plus\" className=\"group-hover:rotate-90 transition-transform duration-500\" />\n                          <span className=\"railLabel\" aria-hidden=\"true\">Capture</span>\n\n  \t                      </button>\n\n  \t          <button \n\n                className={`railBtn ${getActiveTab(workspace).view === 'calendar' ? 'active' : ''}`} \n\n                aria-label=\"Calendar\" title=\"Calendar\" onClick={() => openView('calendar')}\n\n              >\n\n                <Icon name=\"calendar\" />\n                <span className=\"railLabel\" aria-hidden=\"true\">Calendar</span>\n\n  \t          </button>\n\n              <button \n\n                className={`railBtn ${getActiveTab(workspace).view === 'tasks' ? 'active' : ''}`} \n\n                aria-label=\"Tasks\" title=\"Tasks\" onClick={() => openView('tasks')}\n\n              >\n\n                <Icon name=\"check\" />\n                <span className=\"railLabel\" aria-hidden=\"true\">Tasks</span>\n\n              </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'notes' ? 'active' : ''}`} \n\n              aria-label=\"Notes\" title=\"Notes\" onClick={() => openView('notes')}\n\n            >\n\n              <Icon name=\"file\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Notes</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'reflections' ? 'active' : ''}`} \n\n              aria-label=\"Reflections\" title=\"Reflections\" onClick={() => openView('reflections')}\n\n            >\n\n              <Icon name=\"sparkle\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Reflections</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'assistant' ? 'active' : ''}`} \n\n              aria-label=\"Chat\" title=\"Chat\" onClick={() => openView('assistant')}\n\n            >\n\n              <Icon name=\"mic\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Chat</span>\n\n            </button>\n\n            <div className=\"railSep opacity-20\" />\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'habits' ? 'active' : ''}`} \n\n              aria-label=\"Habits\" title=\"Habits\" onClick={() => openView('habits')}\n\n            >\n\n              <Icon name=\"smile\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Habits</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'goals' || getActiveTab(workspace).view === 'goal-detail' ? 'active' : ''}`} \n\n              aria-label=\"Goals\" title=\"Goals\" onClick={() => openView('goals')}\n\n            >\n\n              <Icon name=\"target\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Goals</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'projects' ? 'active' : ''}`} \n\n              aria-label=\"Projects\" title=\"Projects\" onClick={() => openView('projects')}\n\n            >\n\n              <Icon name=\"briefcase\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Projects</span>\n\n            </button>\n\n            <button\n              className={`railBtn ${getActiveTab(workspace).view === 'ecosystem' ? 'active' : ''}`}\n              aria-label=\"Ecosystem\"\n              title=\"Ecosystem\"\n              onClick={() => openView('ecosystem')}\n            >\n              <Icon name=\"monitor\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Ecosystem</span>\n            </button>\n\n            <button\n              className={`railBtn ${getActiveTab(workspace).view === 'trackers' ? 'active' : ''}`}\n              aria-label=\"Trackers\"\n              title=\"Trackers\"\n              onClick={() => openView('trackers')}\n            >\n              <Icon name=\"droplet\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Trackers</span>\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'rewards' ? 'active' : ''}`} \n\n              aria-label=\"Rewards\" title=\"Rewards\" onClick={() => openView('rewards')}\n\n            >\n\n              <Icon name=\"trophy\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Rewards</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'reports' ? 'active' : ''}`} \n\n              aria-label=\"Reports\" title=\"Reports\" onClick={() => openView('reports')}\n\n            >\n\n              <Icon name=\"file\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Reports</span>\n\n            </button>\n\n            <button \n\n              className={`railBtn ${getActiveTab(workspace).view === 'health' ? 'active' : ''}`} \n\n              aria-label=\"Workout & Nutrition\" title=\"Workout & Nutrition\" onClick={() => openView('health')}\n\n            >\n\n              <Icon name=\"dumbbell\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Workout + Nutrition</span>\n\n            </button>\n\n            <button\n\n              className={`railBtn ${getActiveTab(workspace).view === 'timeline' ? 'active' : ''}`} \n\n              aria-label=\"Timeline\" title=\"Timeline\" onClick={() => openView('timeline')}\n\n            >\n\n              <Icon name=\"bolt\" />\n              <span className=\"railLabel\" aria-hidden=\"true\">Timeline</span>\n\n            </button>\n          <div className=\"railGrow\" />\n          <button className=\"railBtn\" aria-label=\"Refresh\" title=\"Refresh\" onClick={refreshAll}>\n            <Icon name=\"bolt\" />\n            <span className=\"railLabel\" aria-hidden=\"true\">Refresh</span>\n          </button>\n          <button\n            className=\"railBtn\"\n            aria-label=\"Toggle theme\"\n            title=\"Toggle theme\"\n            onClick={() => setThemePref((p) => nextThemePref(p))}>\n            <Icon name={resolveTheme(themePref) === 'dark' ? 'sun' : 'moon'} />\n            <span className=\"railLabel\" aria-hidden=\"true\">Theme</span>\n          </button>\n          <button className=\"railBtn\" aria-label=\"Toggle explorer\" title=\"Toggle explorer\" onClick={() => setLeftCollapsed((v) => !v)}>\n            <Icon name=\"panelLeft\" />\n            <span className=\"railLabel\" aria-hidden=\"true\">Explorer</span>\n          </button>\n          <button className=\"railBtn\" aria-label=\"Settings\" title=\"Settings\" onClick={() => openView('settings')}>\n            <Icon name=\"gear\" />\n            <span className=\"railLabel\" aria-hidden=\"true\">Settings</span>\n          </button>\n        </aside>\n\n        <aside className={leftCollapsed ? 'sb explorer collapsed' : 'sb explorer'}>\n          <div className=\"sbTop\">\n            <div className=\"sbTitle\">Vault</div>\n            <div className=\"sbSub\">Local-first (IndexedDB)</div>\n          </div>\n          <div className=\"sbSection\">\n            <div className=\"sbSectionHead\">\n              <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedOpen((v) => !v)} aria-label=\"Toggle pinned\">\n                <Icon name={explorerPinnedOpen ? 'chevronDown' : 'chevronRight'} size={16} />\n              </button>\n              <div className=\"sbSectionTitleInline\">Pinned</div>\n            </div>\n            {explorerPinnedOpen ? (\n              <div className=\"sbPinnedStack\">\n                {pinnedGroupOrder.map((key) => {\n                  if (key === 'tasks') {\n                    return (\n                      <div\n                        key=\"tasks\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('tasks', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('tasks', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedTasksOpen((v) => !v)} aria-label=\"Toggle tasks\">\n                            <Icon name={explorerPinnedTasksOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Tasks</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedTasksOpen ? (\n                          <div className=\"sbTasks\">\n                            <div className=\"sbTasksRow\">\n                              <input className=\"sbTasksSearch\" value={explorerTaskQuery} onChange={(e) => setExplorerTaskQuery(e.target.value)} placeholder=\"Search tasks\u2026\" />\n                            </div>\n                            <div className=\"sbTasksRow\">\n                              <input\n                                className=\"sbTasksQuick\"\n                                value={explorerTaskDraft}\n                                onChange={(e) => setExplorerTaskDraft(e.target.value)}\n                                placeholder=\"Quick add\u2026\"\n                                onKeyDown={(e) => {\n                                  if (e.key !== 'Enter') return\n                                  const title = explorerTaskDraft.trim()\n                                  if (!title) return\n                                  onCreateTaskFromInput({ title })\n                                  setExplorerTaskDraft('')\n                                }}\n                              />\n                              <button\n                                className=\"sbTasksAdd\"\n                                onClick={() => {\n                                  const title = explorerTaskDraft.trim()\n                                  if (!title) return\n                                  onCreateTaskFromInput({ title })\n                                  setExplorerTaskDraft('')\n                                }}>\n                                Add\n                              </button>\n                            </div>\n                            <div className=\"sbTasksList\">\n                              {explorerTasks.map((t) => (\n                                <div\n                                  key={t.id}\n                                  className={\n                                    t.status === 'done'\n                                      ? selection.kind === 'task' && selection.id === t.id\n                                        ? 'sbTaskRow done selected'\n                                        : 'sbTaskRow done'\n                                      : selection.kind === 'task' && selection.id === t.id\n                                        ? 'sbTaskRow selected'\n                                        : 'sbTaskRow'\n                                  }\n                                  draggable\n                                  onDragStart={(e) => {\n                                    e.dataTransfer.setData('text/taskId', t.id)\n                                    e.dataTransfer.setData('text/taskTitle', t.title)\n                                  }}\n                                  onClick={() => {\n                                    setSelection({ kind: 'task', id: t.id })\n                                    setRightCollapsed(false)\n                                    setRightMode('details')\n                                  }}>\n                                  <button\n                                    className={t.status === 'done' ? 'sbTaskCheck checked' : 'sbTaskCheck'}\n                                    onClick={(e) => {\n                                      e.preventDefault()\n                                      e.stopPropagation()\n                                      onToggleTaskComplete(t.id)\n                                    }}\n                                    aria-label={t.status === 'done' ? 'Mark incomplete' : 'Mark complete'}>\n                                    <span className=\"sbTaskBox\" />\n                                  </button>\n                                  <div className=\"sbTaskTitle\">{t.title}</div>\n                                </div>\n                              ))}\n                              {tasks.filter((t) => t.status !== 'done').length === 0 ? <div className=\"sbTasksEmpty\">No open tasks.</div> : null}\n                            </div>\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  if (key === 'habits') {\n                    return (\n                      <div\n                        key=\"habits\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('habits', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('habits', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedHabitsOpen((v) => !v)} aria-label=\"Toggle habits\">\n                            <Icon name={explorerPinnedHabitsOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Habits</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedHabitsOpen ? (\n                          <div className=\"sbQuickList\">\n                            {habitDefs.length === 0 ? (\n                              <div className=\"sbQuickEmpty\">No habits yet. Add one in the Habits tab.</div>\n                            ) : (\n                              habitDefs.map((h) => (\n                                <div\n                                  key={h.id}\n                                  className=\"sbQuickRow\"\n                                  draggable\n                                  onDragStart={(e) => {\n                                    const payload = {\n                                      id: h.id,\n                                      name: h.name,\n                                      tags: h.tags ?? [],\n                                      category: h.category ?? null,\n                                      subcategory: h.subcategory ?? null,\n                                      estimateMinutes: h.estimateMinutes ?? 15,\n                                    }\n                                    e.dataTransfer.setData(DND_HABIT, JSON.stringify(payload))\n                                    e.dataTransfer.setData('text/plain', h.name)\n                                  }}>\n                                  <span className=\"sbQuickIcon\">\n                                    <Icon name=\"check\" size={12} />\n                                  </span>\n                                  <div className=\"sbQuickTitle\">{h.name}</div>\n                                  <div className=\"sbQuickMeta\">{h.category ?? 'Habit'}</div>\n                                </div>\n                              ))\n                            )}\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  if (key === 'trackers') {\n                    return (\n                      <div\n                        key=\"trackers\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('trackers', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('trackers', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedTrackersOpen((v) => !v)} aria-label=\"Toggle trackers\">\n                            <Icon name={explorerPinnedTrackersOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Trackers</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedTrackersOpen ? (\n                          <div className=\"sbQuickList\">\n                            {trackerDefs.length === 0 ? (\n                              <div className=\"sbQuickEmpty\">No trackers yet.</div>\n                            ) : (\n                              trackerDefs.map((t) => (\n                                <div\n                                  key={t.key}\n                                  className=\"sbQuickRow\"\n                                  draggable\n                                  onDragStart={(e) => {\n                                    const payload = { key: t.key, label: t.label, defaultValue: t.defaultValue ?? null }\n                                    e.dataTransfer.setData(DND_TRACKER, JSON.stringify(payload))\n                                    e.dataTransfer.setData('text/plain', t.label)\n                                  }}>\n                                  <span className=\"sbQuickIcon\">\n                                    <Icon name={t.icon ?? 'sparkle'} size={12} />\n                                  </span>\n                                  <div className=\"sbQuickTitle\">{t.label}</div>\n                                  <div className=\"sbQuickMeta\">Tracker</div>\n                                </div>\n                              ))\n                            )}\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  if (key === 'shortcuts') {\n                    return (\n                      <div\n                        key=\"shortcuts\"\n                        className=\"sbPinnedGroup\"\n                        draggable\n                        onDragStart={(e) => onPinnedDragStart('shortcuts', e)}\n                        onDragOver={onPinnedDragOver}\n                        onDrop={(e) => onPinnedDrop('shortcuts', e)}>\n                        <div className=\"sbPinnedHead\">\n                          <button className=\"sbSectionToggle\" onClick={() => setExplorerPinnedShortcutsOpen((v) => !v)} aria-label=\"Toggle shortcuts\">\n                            <Icon name={explorerPinnedShortcutsOpen ? 'chevronDown' : 'chevronRight'} size={14} />\n                          </button>\n                          <div className=\"sbPinnedTitle\">Shortcuts</div>\n                          <span className=\"sbDragHandle\" title=\"Drag to reorder\">\n                            <Icon name=\"dots\" size={12} />\n                          </span>\n                        </div>\n                        {explorerPinnedShortcutsOpen ? (\n                          <div className=\"sbQuickList\">\n                            <button className=\"sbItem\" onClick={() => openView('calendar')}>\n                              Calendar\n                            </button>\n                            <button className=\"sbItem\" onClick={() => openView('notes')}>\n                              Notes\n                            </button>\n                            <button className=\"sbItem\" onClick={() => openView('assistant')}>\n                              Chat\n                            </button>\n                            <button className=\"sbItem\" onClick={() => openView('settings')}>\n                              Settings\n                            </button>\n                          </div>\n                        ) : null}\n                      </div>\n                    )\n                  }\n                  return null\n                })}\n              </div>\n            ) : null}\n          </div>\n          <div className=\"sbSection\">\n            <div className=\"sbSectionHead\">\n              <button className=\"sbSectionToggle\" onClick={() => setExplorerRecentOpen((v) => !v)} aria-label=\"Toggle recent notes\">\n                <Icon name={explorerRecentOpen ? 'chevronDown' : 'chevronRight'} size={16} />\n              </button>\n              <div className=\"sbSectionTitleInline\">Recent Notes</div>\n            </div>\n            {explorerRecentOpen ? (\n              <div className=\"sbTree\">\n                {captures.slice(0, 12).map((c) => {\n                  const title = (c.rawText.split(/\\r?\\n/)[0] ?? '').trim()\n                  const snippet = c.rawText.replace(/\\s+/g, ' ').slice(0, 72)\n                  return (\n                    <button\n                      key={c.id}\n                      className={selection.kind === 'capture' && selection.id === c.id ? 'sbTreeBtn active' : 'sbTreeBtn'}\n                      onClick={() => {\n                        setSelection({ kind: 'capture', id: c.id })\n                        openView('notes')\n                      }}\n                      title={c.rawText}>\n                      <span className=\"sbTreeTitle\">{(title || 'Untitled').slice(0, 40)}</span>\n                      <span className=\"sbTreeMeta\">{new Date(c.createdAt).toLocaleDateString()}</span>\n                      <span className=\"sbTreeSnippet\">{snippet}</span>\n                    </button>\n                  )\n                })}\n              </div>\n            ) : null}\n          </div>\n          <div className=\"sbSection\">\n            <div className=\"sbSectionHead\">\n              <button className=\"sbSectionToggle\" onClick={() => setExplorerPomoOpen((v) => !v)} aria-label=\"Toggle pomodoro\">\n                <Icon name={explorerPomoOpen ? 'chevronDown' : 'chevronRight'} size={16} />\n              </button>\n              <div className=\"sbSectionTitleInline\">Pomodoro</div>\n            </div>\n\t            {explorerPomoOpen ? (\n\t              <div className=\"sbPomodoro\">\n\t                <div className=\"pomoHeader\">\n\t                  <div className=\"pomoTitle\">Ready To Start</div>\n\t                </div>\n                <div className=\"pomoCircle\" style={{ ['--pomo' as any]: pomoProgress }}>\n                  <div className=\"pomoTime\">\n                    {String(pomoMinutes).padStart(2, '0')}:{String(pomoRemainder).padStart(2, '0')}\n                  </div>\n                </div>\n                <div className=\"pomoActions\">\n                  <button className=\"pomoBtn\" onClick={() => setPomoRunning((v) => !v)} aria-label={pomoRunning ? 'Pause' : 'Start'}>\n                    {pomoRunning ? 'Pause' : 'Start'}\n                  </button>\n                  <button\n                    className=\"pomoBtn secondary\"\n                    onClick={() => {\n                      setPomoRunning(false)\n                      setPomoSeconds(25 * 60)\n                    }}>\n                    Reset\n                  </button>\n                </div>\n\t                <div className=\"pomoTask\">\n\t                  <div className=\"pomoTaskLabel\">Active task</div>\n\t                  <div className=\"pomoTaskValueRow\">\n\t                    <div className=\"pomoTaskValue\">{pomoActiveTask?.title ?? selectedTask?.title ?? '\u2014'}</div>\n\t                    <button\n\t                      className=\"pomoTaskClear\"\n\t                      onClick={() => setPomoActiveTaskId(null)}\n\t                      disabled={!pomoActiveTaskId}\n\t                      aria-label=\"Clear active task\">\n\t                      \u00d7\n\t                    </button>\n\t                  </div>\n\t                  <div className=\"pomoPickRow\">\n\t                    <button\n\t                      className=\"pomoPickBtn\"\n\t                      onClick={() => {\n\t                        if (!selectedTask) return\n\t                        setPomoActiveTaskId(selectedTask.id)\n\t                      }}\n\t                      disabled={!selectedTask}\n\t                      aria-label=\"Set active task to selected task\">\n\t                      Use selected\n\t                    </button>\n\t                    <button\n\t                      className=\"pomoPickBtn secondary\"\n\t                      onClick={() => openView('tasks')}\n\t                      aria-label=\"Open tasks\">\n\t                      Open tasks\n\t                    </button>\n\t                  </div>\n\t                  <div className=\"pomoPickList\" aria-label=\"Quick pick tasks\">\n\t                    {explorerTasks.slice(0, 6).map((t) => (\n\t                      <button\n\t                        key={t.id}\n\t                        className={t.id === pomoActiveTaskId ? 'pomoPickItem active' : 'pomoPickItem'}\n\t                        onClick={() => setPomoActiveTaskId(t.id)}>\n\t                        {t.title}\n\t                      </button>\n\t                    ))}\n\t                    {explorerTasks.length === 0 ? <div className=\"pomoPickEmpty\">No open tasks.</div> : null}\n\t                  </div>\n\t                </div>\n\t                <div className=\"pomoNotes\">\n\t                  <div className=\"pomoNotesLabel\">Recent notes</div>\n\t                  <div className=\"pomoNotesList\" aria-label=\"Recent notes\">\n\t                    {captures.slice(0, 3).map((c) => {\n\t                      const title = (c.rawText.split(/\\r?\\n/)[0] ?? '').trim() || 'Untitled'\n\t                      return (\n\t                        <button\n\t                          key={c.id}\n\t                          className=\"pomoNoteItem\"\n\t                        onClick={() => {\n\t                          setSelection({ kind: 'capture', id: c.id })\n\t                            openView('notes')\n\t                          }}\n\t                          title={c.rawText}>\n\t                          {title}\n\t                        </button>\n\t                      )\n\t                    })}\n\t                  </div>\n\t                </div>\n\t              </div>\n\t            ) : null}\n\t          </div>\n\t        </aside>\n\n      <div className=\"ws\">\n        <Pane\n          tabs={workspace.tabs}\n          activeTabId={workspace.activeTabId}\n          onActivate={(id) => setWorkspace((p) => ({ ...p, activeTabId: id }))}\n          onClose={(id) => closeTab(id)}>\n          {renderView(active.view)}\n        </Pane>\n      </div>\n\n\t      <AnimatePresence>\n\t      {rightCollapsed ? null : (\n\t        <motion.aside\n\t          className=\"details\"\n\t          initial={{ x: 16, opacity: 0 }}\n\t          animate={{ x: 0, opacity: 1 }}\n\t          exit={{ x: 16, opacity: 0 }}\n\t          transition={{ duration: 0.16, ease: 'easeOut' }}>\n\t        <div className=\"detailsHeader\">\n\t          <div className=\"detailsHeaderRow\">\n\t            <div>\n\t              <div className=\"detailsTitle\">{rightMode === 'ai' ? 'AI' : 'Details'}</div>\n              <div className=\"detailsSub\">{rightMode === 'ai' ? 'Chat with your notes and calendar.' : 'Edit fields like importance and difficulty/energy plus notes.'}</div>\n\t            </div>\n\t            <div className=\"detailsHeaderActions\">\n\t              <button\n\t                className={rightMode === 'ai' ? 'detailsIconBtn active' : 'detailsIconBtn'}\n\t                onClick={() => setRightMode((m) => (m === 'ai' ? 'details' : 'ai'))}\n\t                aria-label=\"Toggle AI\">\n\t                <Icon name=\"sparkle\" size={16} />\n\t              </button>\n\t              <button\n\t                className=\"detailsIconBtn\"\n\t                onClick={() => {\n\t                  if (rightMode === 'ai') openView('assistant')\n\t                  else setDocOpen(true)\n\t                }}\n\t                aria-label={rightMode === 'ai' ? 'Open full chat' : 'Open page'}>\n\t                <Icon name=\"maximize\" size={16} />\n\t              </button>\n\t              <button className=\"detailsIconBtn\" onClick={() => setRightCollapsed(true)} aria-label=\"Collapse right panel\">\n\t                <Icon name=\"panelRight\" size={16} />\n\t              </button>\n\t            </div>\n\t          </div>\n\t        </div>\n\n\t        {rightMode === 'ai' ? (\n\t          <div className=\"detailsBody\">\n\t\t            <AssistantView\n\t\t              embedded\n\t\t              captures={captures}\n\t\t              events={events}\n\t\t              tasks={tasks}\n\t\t              onSelectCapture={(id) => {\n\t\t                setSelection({ kind: 'capture', id })\n\t\t                setRightMode('details')\n\t\t              }}\n\t\t              onSelectEvent={(id) => {\n\t\t                setSelection({ kind: 'event', id })\n\t\t                setRightMode('details')\n\t\t              }}\n\t\t              onSelectTask={(id) => {\n\t\t                setSelection({ kind: 'task', id })\n\t\t                setRightMode('details')\n\t\t              }}\n\t\t            />\n\t          </div>\n\t        ) : selection.kind === 'none' ? (\n\t          <div className=\"detailsBody\">\n\t            <div className=\"detailCard\">\n\t              <div className=\"detailTitle\">No selection</div>\n\t              <div className=\"detailMeta\">Click a task or calendar event to edit.</div>\n\t            </div>\n\t          </div>\n\t        ) : selection.kind === 'task' && selectedTask ? (\n\t          <div className=\"detailsBody\">\n\t            <div className=\"detailCard\">\n              <div className=\"detailTitle\">Task</div>\n              <div className=\"detailBadgeRow\">\n                <span className=\"detailBadge\">{selectedTask.status}</span>\n                <button\n                  className={selectedTask.status === 'done' ? 'detailToggle active' : 'detailToggle'}\n                  onClick={() => onToggleTaskComplete(selectedTask.id)}>\n                  {selectedTask.status === 'done' ? 'Completed' : 'Mark complete'}\n                </button>\n                <button className=\"secondaryButton\" onClick={() => requestDeleteSelection()}>\n                  Delete\n                </button>\n              </div>\n              <input\n                className=\"detailInput detailTitleInput\"\n                value={selectedTask.title}\n                onChange={(e) => commitTask({ ...selectedTask, title: e.target.value })}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault()\n                    ;(e.target as HTMLInputElement).blur()\n                    setSelection({ kind: 'none' })\n                  }\n                }}\n                placeholder=\"Task title...\"\n              />\n              <div className=\"detailRow\">\n                <label className=\"detailLabel\">\n                  Tags\n                  <input\n                    className=\"detailSmall\"\n                    value={(selectedTask.tags ?? []).join(' ')}\n                    onChange={(e) => commitTask({ ...selectedTask, tags: parseTags(e.target.value) })}\n                    placeholder=\"#work #health\"\n                  />\n                </label>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Context</div>\n                <div className=\"detailChips\">\n                  {selectedTaskContexts.map((ctx) => (\n                    <button\n                      key={ctx}\n                      className=\"detailChip\"\n                      onClick={() => commitTask({ ...selectedTask, contexts: selectedTaskContexts.filter((x) => x !== ctx) })}\n                      type=\"button\">\n                      {formatContextLabel(ctx)}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={contextDraft}\n                    onChange={(e) => setContextDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitTask({ ...selectedTask, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitTask({ ...selectedTask, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    placeholder=\"at computer, at email\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">People</div>\n                <div className=\"detailChips\">\n                  {selectedTaskPeople.map((person) => (\n                    <button\n                      key={person}\n                      className=\"detailChip\"\n                      onClick={() => commitTask({ ...selectedTask, people: selectedTaskPeople.filter((x) => x !== person) })}\n                      type=\"button\">\n                      {person}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={peopleDraft}\n                    onChange={(e) => setPeopleDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskPeople, ...next])\n                      commitTask({ ...selectedTask, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskPeople, ...next])\n                      commitTask({ ...selectedTask, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    placeholder=\"Mom, Alex\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Location</div>\n                <div className=\"detailChips\">\n                  {selectedTaskLocations.map((loc) => (\n                    <button\n                      key={loc}\n                      className=\"detailChip\"\n                      onClick={() => {\n                        const next = selectedTaskLocations.filter((x) => x !== loc)\n                        commitTask({ ...selectedTask, location: next.length ? next.join(', ') : null })\n                      }}\n                      type=\"button\">\n                      {loc}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={locationDraft}\n                    onChange={(e) => setLocationDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(locationDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskLocations, ...next])\n                      commitTask({ ...selectedTask, location: merged.length ? merged.join(', ') : null })\n                      setLocationDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(locationDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskLocations, ...next])\n                      commitTask({ ...selectedTask, location: merged.length ? merged.join(', ') : null })\n                      setLocationDraft('')\n                    }}\n                    placeholder=\"Home\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Skills</div>\n                <div className=\"detailChips\">\n                  {selectedTaskSkills.map((skill) => (\n                    <button\n                      key={skill}\n                      className=\"detailChip\"\n                      onClick={() => commitTask({ ...selectedTask, skills: selectedTaskSkills.filter((x) => x !== skill) })}\n                      type=\"button\">\n                      {skill}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={skillDraft}\n                    onChange={(e) => setSkillDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskSkills, ...next])\n                      commitTask({ ...selectedTask, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedTaskSkills, ...next])\n                      commitTask({ ...selectedTask, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    placeholder=\"communication, lifting\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Character</div>\n                <div className=\"detailCharacterRow\">\n                  {CHARACTER_KEYS.map((k) => {\n                    const selected = normalizeCharacterSelection(selectedTaskCharacter).includes(k)\n                    return (\n                      <button\n                        key={k}\n                        className={selected ? 'detailCharacterBtn active' : 'detailCharacterBtn'}\n                        onClick={() => commitTask({ ...selectedTask, character: toggleCharacterSelection(selectedTaskCharacter, k) })}>\n                        {k}\n                      </button>\n                    )\n                  })}\n                </div>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Due\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedTask.dueAt)}\n                    onChange={(e) => commitTask({ ...selectedTask, dueAt: fromLocalDateTimeInput(e.target.value) })}\n                  />\n                </label>\n                <label>\n                  Scheduled\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedTask.scheduledAt)}\n                    onChange={(e) => commitTask({ ...selectedTask, scheduledAt: fromLocalDateTimeInput(e.target.value) })}\n                  />\n                </label>\n              </div>\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Goal\n\t                  <input\n\t                    className=\"detailSmall\"\n\t                    value={selectedTask.goal ?? ''}\n\t                    onChange={(e) => commitTask({ ...selectedTask, goal: e.target.value || null })}\n\t                    placeholder=\"get shredded\"\n\t                  />\n\t                </label>\n\t                <label>\n\t                  Project\n\t                  <input\n\t                    className=\"detailSmall\"\n\t                    value={selectedTask.project ?? ''}\n\t                    onChange={(e) => commitTask({ ...selectedTask, project: e.target.value || null })}\n\t                    placeholder=\"workout plan\"\n\t                  />\n\t                </label>\n\t              </div>\n\t\t              <div className=\"detailGrid\">\n\t\t                <label>\n\t\t                  Category\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxCatList\"\n\t\t                    value={selectedTask.category ?? ''}\n\t\t                    onChange={(e) => commitTask({ ...selectedTask, category: e.target.value || null })}\n\t\t                    placeholder=\"Work / Health / Study\"\n\t\t                  />\n\t\t                </label>\n\t\t                <label>\n\t\t                  Subcategory\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxSubcatList\"\n\t\t                    value={selectedTask.subcategory ?? ''}\n\t\t                    onChange={(e) => commitTask({ ...selectedTask, subcategory: e.target.value || null })}\n\t\t                    placeholder=\"Clinic / Surgery / Gym\"\n\t\t                  />\n\t\t                </label>\n\t\t              </div>\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Importance\n\t                  <div className=\"detailRangeRow\">\n\t                    <input\n\t                      className=\"detailRange\"\n\t                      type=\"range\"\n\t                      min={0}\n\t                      max={10}\n\t                      step={1}\n\t                      value={selectedTask.importance ?? 5}\n\t                      onChange={(e) => commitTask({ ...selectedTask, importance: Number(e.target.value) })}\n\t                      aria-label=\"Importance\"\n\t                    />\n\t                    <span className=\"detailRangeValue\">{selectedTask.importance ?? '\u2014'}</span>\n\t                    <button\n\t                      className=\"detailRangeClear\"\n\t                      type=\"button\"\n\t                      onClick={() => commitTask({ ...selectedTask, importance: null })}\n\t                      disabled={selectedTask.importance == null}\n\t                      aria-label=\"Clear importance\">\n\t                      \u00d7\n\t                    </button>\n\t                  </div>\n\t                </label>\n                <label>\n                  Difficulty / Energy\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={selectedTask.difficulty ?? 5}\n                      onChange={(e) => commitTask({ ...selectedTask, difficulty: Number(e.target.value) })}\n                      aria-label=\"Difficulty / Energy\"\n                    />\n                    <span className=\"detailRangeValue\">{selectedTask.difficulty ?? '\u2014'}</span>\n                    <button\n                      className=\"detailRangeClear\"\n                      type=\"button\"\n                      onClick={() => commitTask({ ...selectedTask, difficulty: null })}\n                      disabled={selectedTask.difficulty == null}\n                      aria-label=\"Clear difficulty or energy\">\n                      \u00d7\n                    </button>\n                  </div>\n                </label>\n\t                <label>\n\t                  Estimate (min)\n\t                  <input\n\t                    className=\"detailSmall\"\n                    value={selectedTask.estimateMinutes ?? ''}\n                    onChange={(e) => commitTask({ ...selectedTask, estimateMinutes: numberOrNull(e.target.value) })}\n                    placeholder=\"25\"\n                  />\n                </label>\n\t              </div>\n\t              {(() => {\n\t                const items = parseChecklistMarkdown(selectedTask.notes)\n\t                if (!items.length) return null\n\t                const remaining = items.filter((x) => !x.checked).length\n\t                return (\n\t                  <div className=\"detailRow\" style={{ marginTop: 8 }}>\n\t                    <div className=\"detailLabel\" style={{ marginBottom: 6 }}>\n\t                      Checklist <span style={{ color: 'var(--muted)', fontWeight: 800 }}>({remaining}/{items.length})</span>\n\t                    </div>\n\t                    <div className=\"detailChecklist\" aria-label=\"Task checklist\">\n\t                      {items.slice(0, 24).map((it) => (\n\t                        <button\n\t                          key={`${selectedTask.id}_${it.lineIndex}`}\n\t                          className={it.checked ? 'detailCheckItem checked' : 'detailCheckItem'}\n\t                          onClick={() => commitTask({ ...selectedTask, notes: toggleChecklistLine(selectedTask.notes, it.lineIndex) })}\n\t                          aria-label={it.checked ? `Uncheck ${it.text}` : `Check ${it.text}`}>\n\t                          <span className=\"detailCheckBox\" aria-hidden=\"true\" />\n\t                          <span className=\"detailCheckText\">{it.text}</span>\n\t                        </button>\n\t                      ))}\n\t                    </div>\n\t                  </div>\n\t                )\n\t              })()}\n\t            </div>\n\t          </div>\n\t        ) : selection.kind === 'event' && selectedEvent ? (\n          <div className=\"detailsBody\">\n            <div className=\"detailCard\">\n              {selectedEvent.active ? (\n                <div className=\"detailActiveSession\">\n                  <ActiveSessionBanner\n                    title={selectedEvent.title}\n                    category={selectedEvent.category}\n                    subcategory={selectedEvent.subcategory}\n                    startedAt={selectedEvent.startAt}\n                    estimatedMinutes={selectedEvent.estimateMinutes ?? Math.round((selectedEvent.endAt - selectedEvent.startAt) / (60 * 1000))}\n                    importance={selectedEvent.importance}\n                    difficulty={selectedEvent.difficulty}\n                    goal={selectedEvent.goal}\n                    project={selectedEvent.project}\n                    onStop={() => {\n                      const now = Date.now()\n                      commitEvent({ ...selectedEvent, endAt: Math.max(now, selectedEvent.startAt + 5 * 60 * 1000), active: false })\n                    }}\n                  />\n                </div>\n              ) : null}\n              <div className={selectedEvent.kind === 'task' ? 'detailBadgeRow detailBadgeRowSplit' : 'detailBadgeRow'}>\n                <div className=\"detailBadgeGroup\">\n                  <span className=\"detailBadge\">{selectedEvent.kind ?? 'event'}</span>\n                  {selectedEvent.kind !== 'log' && selectedEvent.kind !== 'task' ? (\n                    <button\n                      className={selectedEvent.allDay ? 'detailToggle active' : 'detailToggle'}\n                      onClick={() => commitEvent({ ...selectedEvent, allDay: !selectedEvent.allDay })}>\n                      All-day\n                    </button>\n                  ) : null}\n                  {selectedEvent.kind !== 'log' && selectedEvent.kind !== 'task' ? (\n                    <button\n                      className={selectedEvent.active ? 'detailToggle active' : 'detailToggle'}\n                      onClick={() => {\n                        if (selectedEvent.active) {\n                          const now = Date.now()\n                          commitEvent({ ...selectedEvent, endAt: Math.max(now, selectedEvent.startAt + 5 * 60 * 1000), active: false })\n                        } else {\n                          commitEvent({ ...selectedEvent, active: true })\n                        }\n                      }}>\n                      {selectedEvent.active ? 'Active' : 'Inactive'}\n                    </button>\n                  ) : null}\n                  {selectedEvent.kind !== 'task' ? (\n                    <>\n                      <button\n                        className=\"secondaryButton detailAiBtn\"\n                        onClick={() => {\n                          setCaptureDraft('')\n                          setCaptureInterim('')\n                          openCapture({ attachEventId: selectedEvent.id })\n                        }}>\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                      <button className=\"secondaryButton\" onClick={() => autoFillEventFromText(selectedEvent)}>\n                        Auto-fill\n                      </button>\n                      <button className=\"secondaryButton\" onClick={() => requestDeleteSelection()}>\n                        Delete\n                      </button>\n                    </>\n                  ) : null}\n                </div>\n                {selectedEvent.kind === 'task' ? (\n                  <button\n                    className={selectedEvent.completedAt ? 'detailCompleteToggle checked' : 'detailCompleteToggle'}\n                    onClick={() => onToggleEventComplete(selectedEvent.id)}\n                    aria-label={selectedEvent.completedAt ? 'Mark incomplete' : 'Mark complete'}\n                    title={selectedEvent.completedAt ? 'Mark incomplete' : 'Mark complete'}\n                    type=\"button\">\n                    <Icon name=\"check\" size={14} />\n                  </button>\n                ) : null}\n              </div>\n              {selectedEvent.kind !== 'log' ? (\n                <div className={selectedEvent.kind === 'task' ? 'detailActions compact' : 'detailActions'}>\n                  <button\n                    className=\"secondaryButton\"\n                    onClick={() => {\n                      const now = Date.now()\n                      const dur = Math.max(5 * 60 * 1000, selectedEvent.endAt - selectedEvent.startAt)\n                      commitEvent({ ...selectedEvent, startAt: now, endAt: now + dur, active: true })\n                    }}>\n                    Start now\n                  </button>\n                  {selectedEvent.kind !== 'task' ? (\n                    <button\n                      className=\"secondaryButton\"\n                      onClick={() => {\n                        setCaptureDraft('')\n                        setCaptureInterim('')\n                        openCapture({ attachEventId: selectedEvent.id })\n                      }}>\n                      Take note\n                    </button>\n                  ) : null}\n                  <button\n                    className=\"secondaryButton\"\n                    onClick={() => {\n                      const now = Date.now()\n                      commitEvent({ ...selectedEvent, endAt: Math.max(now, selectedEvent.startAt + 5 * 60 * 1000), active: false })\n                    }}\n                    disabled={!selectedEvent.active}>\n                    Stop now\n                  </button>\n                </div>\n              ) : null}\n              <input\n                className=\"detailInput detailTitleInput\"\n                value={selectedEvent.title}\n                onChange={(e) => commitEvent({ ...selectedEvent, title: e.target.value })}\n                onKeyDown={(e) => {\n                  if (e.key === 'Enter' && !e.shiftKey) {\n                    e.preventDefault()\n                    ;(e.target as HTMLInputElement).blur()\n                    setSelection({ kind: 'none' })\n                  }\n                }}\n                placeholder=\"Event title...\"\n              />\n              {selectedEventTracker ? (\n                <div className=\"detailRow\">\n                  <div className=\"detailLabel\">Active tracker</div>\n                  <div className=\"detailChips\">\n                    <button\n                      className=\"detailChip active\"\n                      onClick={() => openTrackerDetail(selectedEventTracker.key)}\n                      type=\"button\">\n                      {selectedEventTracker.label}\n                    </button>\n                  </div>\n                </div>\n              ) : null}\n\n              <div className=\"detailRow detailNotesSection\" style={{ marginTop: 12 }}>\n                <div className=\"detailLabelRow\">\n                  <div className=\"detailLabel\">Notes</div>\n                  <div className=\"detailLabelActions\">\n                    <button\n                      className=\"detailInlineBtn\"\n                      onClick={() => {\n                        setCaptureDraft('')\n                        setCaptureInterim('')\n                        openCapture({ attachEventId: selectedEvent.id })\n                      }}\n                      type=\"button\">\n                      <Icon name=\"mic\" size={12} />\n                      Transcribe\n                    </button>\n                  </div>\n                </div>\n                <MarkdownEditor\n                  value={selectedEvent.notes ?? ''}\n                  onChange={(next) => commitEvent({ ...selectedEvent, notes: next })}\n                  onToggleChecklist={(lineIndex) => {\n                    if (selectedEvent.kind === 'task' && selectedEvent.taskId) {\n                      onToggleTaskChecklistItem(selectedEvent.taskId, lineIndex)\n                      return\n                    }\n                    void onToggleEventNoteChecklist(selectedEvent, lineIndex)\n                  }}\n                  onStartTask={(task) => onStartNoteTask(selectedEvent.id, task)}\n                  taskStateByToken={selectedEventNoteTasks}\n                  nowMs={nowTick}\n                  placeholder=\"Write notes\u2026\"\n                  ariaLabel=\"Event notes\"\n                />\n                <button\n                  className=\"secondaryButton detailSegmentBtn\"\n                  onClick={() => {\n                    const label = window.prompt('Segment label (e.g., Inpatient)')\n                    if (!label) return\n                    const t = new Date()\n                    const hh = String(t.getHours()).padStart(2, '0')\n                    const mm = String(t.getMinutes()).padStart(2, '0')\n                    const next = `${(selectedEvent.notes ?? '').trim()}\\n**${hh}:${mm}** - ${label}\\n`\n                    commitEvent({ ...selectedEvent, notes: next.trim() })\n                  }}>\n                  + Segment\n                </button>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Start\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedEvent.startAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      const dur = Math.max(5 * 60 * 1000, selectedEvent.endAt - selectedEvent.startAt)\n                      commitEvent({ ...selectedEvent, startAt: ms, endAt: ms + dur })\n                    }}\n                  />\n                </label>\n                <label>\n                  End\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(selectedEvent.endAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      commitEvent({ ...selectedEvent, endAt: Math.max(ms, selectedEvent.startAt + 5 * 60 * 1000) })\n                    }}\n                  />\n                </label>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Icon\n                  <div className=\"detailIconSelect\">\n                    <select\n                      className=\"detailSmall\"\n                      value={selectedEvent.icon ?? ''}\n                      onChange={(e) => commitEvent({ ...selectedEvent, icon: e.target.value || null })}>\n                      <option value=\"\">Auto</option>\n                      {EVENT_ICON_OPTIONS.map((o) => (\n                        <option key={o.value} value={o.value}>\n                          {o.label}\n                        </option>\n                      ))}\n                    </select>\n                    <span className=\"detailIconPreview\">\n                      <Icon name={eventAccent(selectedEvent).icon} size={14} />\n                    </span>\n                  </div>\n                </label>\n                <label>\n                  Color\n                  <div className=\"detailColorRow\">\n                    <input\n                      className=\"detailColorInput\"\n                      type=\"color\"\n                      value={selectedEvent.color ?? eventAccent(selectedEvent).color}\n                      onChange={(e) => commitEvent({ ...selectedEvent, color: e.target.value })}\n                    />\n                    <button className=\"detailColorAuto\" onClick={() => commitEvent({ ...selectedEvent, color: null })}>\n                      Auto\n                    </button>\n                  </div>\n                  <div className=\"detailSwatches\">\n                    {EVENT_COLOR_PRESETS.slice(0, 9).map((c) => (\n                      <button\n                        key={c.hex}\n                        className={selectedEvent.color === c.hex ? 'detailSwatch active' : 'detailSwatch'}\n                        title={c.name}\n                        style={{ background: c.hex }}\n                        onClick={() => commitEvent({ ...selectedEvent, color: c.hex })}\n                      />\n                    ))}\n                  </div>\n                </label>\n              </div>\n\n              {/* Collapsible Properties Section */}\n              <button\n                className=\"detailPropsHeader\"\n                onClick={() => setPropsCollapsed(!propsCollapsed)}\n                type=\"button\">\n                <span className=\"detailPropsLabel\">Properties</span>\n                <span className={propsCollapsed ? 'detailPropsChevron' : 'detailPropsChevron open'}>\n                  <svg width=\"14\" height=\"14\" viewBox=\"0 0 24 24\" fill=\"none\" stroke=\"currentColor\" strokeWidth=\"2\">\n                    <polyline points=\"6 9 12 15 18 9\" />\n                  </svg>\n                </span>\n              </button>\n\n              {!propsCollapsed && (\n                <>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Tags</div>\n                <div className=\"detailChips\">\n                  {selectedEventTags.map((t) => (\n                    <button\n                      key={t}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, tags: selectedEventTags.filter((x) => x !== t) })}\n                      type=\"button\">\n                      {t}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={tagDraft}\n                    onChange={(e) => setTagDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',' && e.key !== ' ') return\n                      e.preventDefault()\n                      const next = parseTags(tagDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                      commitEvent({ ...selectedEvent, tags: merged })\n                      setTagDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseTags(tagDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                      commitEvent({ ...selectedEvent, tags: merged })\n                      setTagDraft('')\n                    }}\n                    placeholder=\"#work #meeting\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Context</div>\n                <div className=\"detailChips\">\n                  {selectedEventContexts.map((ctx) => (\n                    <button\n                      key={ctx}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, contexts: selectedEventContexts.filter((x) => x !== ctx) })}\n                      type=\"button\">\n                      {formatContextLabel(ctx)}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={contextDraft}\n                    onChange={(e) => setContextDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitEvent({ ...selectedEvent, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseContexts(contextDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                      commitEvent({ ...selectedEvent, contexts: merged })\n                      setContextDraft('')\n                    }}\n                    placeholder=\"at computer, at email\"\n                  />\n                </div>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Estimate (min)\n                  <input\n                    className=\"detailSmall\"\n                    value={selectedEvent.estimateMinutes ?? ''}\n                    onChange={(e) => commitEvent({ ...selectedEvent, estimateMinutes: numberOrNull(e.target.value) })}\n                    placeholder=\"30\"\n                  />\n                </label>\n                <label>\n                  Location\n                  <div className=\"detailChips\">\n                    {selectedEventLocations.map((loc) => (\n                      <button\n                        key={loc}\n                        className=\"detailChip\"\n                        onClick={() => {\n                          const next = selectedEventLocations.filter((x) => x !== loc)\n                          commitEvent({ ...selectedEvent, location: next.length ? next.join(', ') : null })\n                        }}\n                        type=\"button\">\n                        {loc}\n                        <span className=\"detailChipRemove\">\u00d7</span>\n                      </button>\n                    ))}\n                    <input\n                      className=\"detailChipInput\"\n                      value={locationDraft}\n                      onChange={(e) => setLocationDraft(e.target.value)}\n                      onKeyDown={(e) => {\n                        if (e.key !== 'Enter' && e.key !== ',') return\n                        e.preventDefault()\n                        const next = parseCommaList(locationDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...selectedEventLocations, ...next])\n                        commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                        setLocationDraft('')\n                      }}\n                      onBlur={() => {\n                        const next = parseCommaList(locationDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...selectedEventLocations, ...next])\n                        commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                        setLocationDraft('')\n                      }}\n                      placeholder=\"Home\"\n                    />\n                  </div>\n                </label>\n              </div>\n              <div className=\"detailGrid\">\n                <label>\n                  Points\n                  <div className=\"detailPoints\">\n                    <div className=\"detailPointsValue\">{selectedEventPoints.toFixed(1)}</div>\n                    <div className=\"detailPointsMeta\">\n                      {selectedEventBase} \u00d7 {formatMinutesSpan(selectedEventMinutes)} \u00f7 60 \u00d7 {selectedEventMult.toFixed(2)}\n                    </div>\n                  </div>\n                </label>\n                <label>\n                  Running\n                  <div className=\"detailPoints\">\n                    <div className=\"detailPointsValue\">{selectedEvent.active ? 'Active' : '\u2014'}</div>\n                    <div className=\"detailPointsMeta\">\n                      {selectedEvent.active ? `${formatMinutesSpan(selectedEventMinutes)} elapsed` : 'Not running'}\n                    </div>\n                  </div>\n                </label>\n              </div>\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">People</div>\n                <div className=\"detailChips\">\n                  {selectedEventPeople.map((p) => (\n                    <button\n                      key={p}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, people: selectedEventPeople.filter((x) => x !== p) })}\n                      type=\"button\">\n                      {p}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={peopleDraft}\n                    onChange={(e) => setPeopleDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventPeople, ...next])\n                      commitEvent({ ...selectedEvent, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(peopleDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventPeople, ...next])\n                      commitEvent({ ...selectedEvent, people: merged })\n                      setPeopleDraft('')\n                    }}\n                    placeholder=\"Mom, Alex\"\n                  />\n                </div>\n              </div>\n\t              {selectedEventLogs.length ? (\n\t                <div className=\"detailRow\">\n\t                  <div className=\"detailLabel\">Signals</div>\n\t                  <div className=\"detailLogChips\">\n\t                    {selectedEventLogs.map((l) => (\n                        <button\n                          key={l.id}\n                          className=\"detailLogChip\"\n                          onClick={() => {\n                            setSelection({ kind: 'event', id: l.id })\n                            setRightMode('details')\n                          }}>\n                          <span className=\"detailLogChipTime\">{new Date(l.startAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>\n                          <span className=\"detailLogChipTitle\">{l.title}</span>\n                        </button>\n                      ))}\n\t                  </div>\n\t                </div>\n\t              ) : null}\n\t\t              {selectedEventTasks.length ? (\n\t\t                <div className=\"detailRow\">\n\t\t                  <div className=\"detailLabel\">\n\t\t                    Linked tasks\n\t\t                    <div className=\"detailLogList\">\n\t\t                      {selectedEventTasks.map((t) => {\n\t\t                        const checklist = parseChecklistMarkdown(t.notes)\n\t\t                        const remaining = checklist.filter((x) => !x.checked).length\n\t\t                        const checklistHint = checklist.length ? ` \u2022 ${remaining}/${checklist.length}` : ''\n\t\t                        return (\n\t\t                          <div key={t.id} className=\"detailTaskRow\">\n\t\t                            <button\n\t\t                              className={t.status === 'done' ? 'detailTaskCheck checked' : 'detailTaskCheck'}\n\t\t                              onClick={() => onToggleTaskComplete(t.id)}\n\t\t                              aria-label={t.status === 'done' ? 'Mark incomplete' : 'Mark complete'}>\n\t\t                              <Icon name=\"check\" size={14} />\n\t\t                            </button>\n\t\t                            <button\n\t\t                              className=\"detailTaskOpen\"\n\t\t                              onClick={() => {\n\t\t                                setSelection({ kind: 'task', id: t.id })\n\t\t                                setRightMode('details')\n\t\t                              }}\n\t\t                              title={t.title}>\n\t\t                              <span className=\"detailTaskTitle\">{t.title}</span>\n\t\t                              <span className=\"detailTaskMeta\">{t.status}{checklistHint}</span>\n\t\t                            </button>\n\t\t                          </div>\n\t\t                        )\n\t\t                      })}\n\t\t                    </div>\n\t\t                  </div>\n\t\t                </div>\n\t\t              ) : null}\n              <div className=\"detailRow\">\n                <div className=\"detailLabel\">Skills</div>\n                <div className=\"detailChips\">\n                  {selectedEventSkills.map((skill) => (\n                    <button\n                      key={skill}\n                      className=\"detailChip\"\n                      onClick={() => commitEvent({ ...selectedEvent, skills: selectedEventSkills.filter((x) => x !== skill) })}\n                      type=\"button\">\n                      {skill}\n                      <span className=\"detailChipRemove\">\u00d7</span>\n                    </button>\n                  ))}\n                  <input\n                    className=\"detailChipInput\"\n                    value={skillDraft}\n                    onChange={(e) => setSkillDraft(e.target.value)}\n                    onKeyDown={(e) => {\n                      if (e.key !== 'Enter' && e.key !== ',') return\n                      e.preventDefault()\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventSkills, ...next])\n                      commitEvent({ ...selectedEvent, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    onBlur={() => {\n                      const next = parseCommaList(skillDraft)\n                      if (!next.length) return\n                      const merged = uniqStrings([...selectedEventSkills, ...next])\n                      commitEvent({ ...selectedEvent, skills: merged })\n                      setSkillDraft('')\n                    }}\n                    placeholder=\"communication, lifting\"\n                  />\n                </div>\n              </div>\n\t              <div className=\"detailRow\">\n\t                <label className=\"detailLabel\">\n\t                  Character\n\t                  <div className=\"charGrid\" role=\"group\" aria-label=\"Character stats\">\n\t                    {CHARACTER_KEYS.map((k) => {\n\t                      const selected = normalizeCharacterSelection(selectedEvent.character).includes(k)\n\t                      return (\n\t                        <button\n\t                          key={k}\n\t                          className={selected ? 'charChip active' : 'charChip'}\n\t                          onClick={() => commitEvent({ ...selectedEvent, character: toggleCharacterSelection(selectedEvent.character, k) })}\n\t                          type=\"button\"\n\t                          aria-label={selected ? `Remove ${k}` : `Add ${k}`}>\n\t                          {k}\n\t                        </button>\n\t                      )\n\t                    })}\n\t                  </div>\n\t                </label>\n\t              </div>\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Goal\n\t                  <input\n\t                    className=\"detailSmall\"\n                    value={selectedEvent.goal ?? ''}\n                    onChange={(e) => commitEvent({ ...selectedEvent, goal: e.target.value || null })}\n                    placeholder=\"get shredded\"\n                  />\n\t                </label>\n\t                <label>\n\t                  Project\n\t                  <input\n\t                    className=\"detailSmall\"\n                    value={selectedEvent.project ?? ''}\n                    onChange={(e) => commitEvent({ ...selectedEvent, project: e.target.value || null })}\n                    placeholder=\"workout plan\"\n                  />\n\t                </label>\n\t              </div>\n\t\t              <div className=\"detailGrid\">\n\t\t                <label>\n\t\t                  Category\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxCatList\"\n\t\t                    value={selectedEvent.category ?? ''}\n\t\t                    onChange={(e) => commitEvent({ ...selectedEvent, category: e.target.value || null })}\n\t\t                    placeholder=\"Work / Health / Study\"\n\t\t                  />\n\t\t                </label>\n\t\t                <label>\n\t\t                  Subcategory\n\t\t                  <input\n\t\t                    className=\"detailSmall\"\n\t\t                    list=\"taxSubcatList\"\n\t\t                    value={selectedEvent.subcategory ?? ''}\n\t\t                    onChange={(e) => commitEvent({ ...selectedEvent, subcategory: e.target.value || null })}\n\t\t                    placeholder=\"Clinic / Surgery / Gym\"\n\t\t                  />\n\t\t                </label>\n\t\t              </div>\n\t\t              <div className=\"detailRow\">\n\t\t                <div className=\"detailLabel\">Category shortcuts</div>\n\t\t                <div className=\"detailChips\">\n\t\t                  {taxonomyCategories.slice(0, 12).map((c) => (\n\t\t                    <button\n\t\t                      key={c}\n\t\t                      className={selectedEvent.category?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n\t\t                      onClick={() => commitEvent({ ...selectedEvent, category: c })}\n\t\t                      type=\"button\">\n\t\t                      {c}\n\t\t                    </button>\n\t\t                  ))}\n\t\t                </div>\n\t\t              </div>\n\t\t              {taxonomySubcategories.length ? (\n\t\t                <div className=\"detailRow\">\n\t\t                  <div className=\"detailLabel\">Subcategory shortcuts</div>\n\t\t                  <div className=\"detailChips\">\n\t\t                    {taxonomySubcategories.slice(0, 12).map((c) => (\n\t\t                      <button\n\t\t                        key={c}\n\t\t                        className={selectedEvent.subcategory?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n\t\t                        onClick={() => commitEvent({ ...selectedEvent, subcategory: c })}\n\t\t                        type=\"button\">\n\t\t                        {c}\n\t\t                      </button>\n\t\t                    ))}\n\t\t                  </div>\n\t\t                </div>\n\t\t              ) : null}\n\t              <div className=\"detailGrid\">\n\t                <label>\n\t                  Importance\n\t                  <div className=\"detailRangeRow\">\n\t                    <input\n\t                      className=\"detailRange\"\n\t                      type=\"range\"\n\t                      min={0}\n\t                      max={10}\n\t                      step={1}\n\t                      value={selectedEvent.importance ?? 5}\n\t                      onChange={(e) => commitEvent({ ...selectedEvent, importance: Number(e.target.value) })}\n\t                      aria-label=\"Importance\"\n\t                    />\n\t                    <span className=\"detailRangeValue\">{selectedEvent.importance ?? '\u2014'}</span>\n\t                    <button\n\t                      className=\"detailRangeClear\"\n\t                      type=\"button\"\n\t                      onClick={() => commitEvent({ ...selectedEvent, importance: null })}\n\t                      disabled={selectedEvent.importance == null}\n\t                      aria-label=\"Clear importance\">\n\t                      \u00d7\n\t                    </button>\n\t                  </div>\n\t                </label>\n                <label>\n                  Difficulty / Energy\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={selectedEvent.difficulty ?? 5}\n                      onChange={(e) => commitEvent({ ...selectedEvent, difficulty: Number(e.target.value) })}\n                      aria-label=\"Difficulty / Energy\"\n                    />\n                    <span className=\"detailRangeValue\">{selectedEvent.difficulty ?? '\u2014'}</span>\n                    <button\n                      className=\"detailRangeClear\"\n                      type=\"button\"\n                      onClick={() => commitEvent({ ...selectedEvent, difficulty: null })}\n                      disabled={selectedEvent.difficulty == null}\n                      aria-label=\"Clear difficulty or energy\">\n                      \u00d7\n                    </button>\n                  </div>\n                </label>\n              </div>\n                </>\n              )}\n            </div>\n          </div>\n        ) : selection.kind === 'capture' && selectedCapture ? (\n          <div className=\"detailsBody\">\n            <div className=\"detailCard\">\n              <div className=\"detailTitle\">Capture</div>\n              <div className=\"detailMeta\">{new Date(selectedCapture.createdAt).toLocaleString()}</div>\n              <div className=\"detailText\">{selectedCapture.rawText}</div>\n              <div className=\"detailActions\">\n                <button className=\"secondaryButton\" onClick={() => openView('assistant')}>\n                  Ask about this\n                </button>\n                <button\n                  className=\"secondaryButton\"\n                  onClick={() => {\n                    setCaptureDraft(selectedCapture.rawText)\n                    openCapture()\n                  }}>\n                  Restore to editor\n                </button>\n                <button\n                  className=\"secondaryButton\"\n                  onClick={() => {\n                    const titles = extractTaskLines(selectedCapture.rawText)\n                    if (titles.length === 0) {\n                      alert('No tasks found. Use lines like: \"- [ ] pick up dry cleaning\"')\n                      return\n                    }\n                    for (const t of titles) onCreateTaskFromInput({ title: t })\n                    alert(`Created ${titles.length} task(s) from this note.`)\n                  }}>\n                  Extract tasks\n                </button>\n                <button\n                  className=\"secondaryButton\"\n                  onClick={() => {\n                    void (async () => {\n                      const result = await createTrackerLogsFromText({\n                        text: selectedCapture.rawText,\n                        atMs: selectedCapture.createdAt,\n                        sourceNoteId: selectedCapture.id,\n                        events,\n                        ensureTrackerDefinition,\n                        defaultTrackerUnit,\n                        findBestActiveEventAt,\n                        createEvent,\n                        setEvents,\n                      })\n                      if (result.created === 0) {\n                        alert('No trackers found. Try \u201cmood 7/10\u201d, \u201cenergy 6\u201d, or \u201cI feel great\u201d.')\n                      } else {\n                        alert(`Created ${result.created} tracker log(s) from this note.`)\n                      }\n                    })()\n                  }}>\n                  Extract trackers\n                </button>\n              </div>\n            </div>\n          </div>\n        ) : null}\n\t        </motion.aside>\n\t      )}\n                              </AnimatePresence>\n                              </main>      <button\n        className=\"captureFab\"\n        onClick={() => {\n          openCapture()\n        }}\n        aria-label=\"Capture\">\n        <Icon name=\"plus\" size={18} />\n      </button>\n\n      {rightCollapsed && !(active?.view && rightPanelHideViews.has(active.view)) ? (\n        <button className=\"rightExpand\" onClick={() => setRightCollapsed(false)} aria-label=\"Show details\">\n          <Icon name=\"panelRight\" />\n        </button>\n      ) : null}\n\n      <AnimatePresence>\n      {eventComposerOpen ? (\n        <motion.div\n          className=\"modalOverlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          transition={{ duration: 0.16, ease: 'easeOut' }}\n          onMouseDown={(e) => {\n            if (e.target === e.currentTarget) setEventComposerOpen(false)\n          }}>\n          <motion.div\n            className=\"modalCard\"\n            initial={{ y: 12, opacity: 0, scale: 0.98 }}\n            animate={{ y: 0, opacity: 1, scale: 1 }}\n            exit={{ y: 12, opacity: 0, scale: 0.98 }}\n            transition={{ duration: 0.18, ease: 'easeOut' }}>\n            <div className=\"modalHeader\">\n              <div>\n                <div className=\"modalTitle\">New event</div>\n                <div className=\"modalSub\">Title + time + tags + people/places + estimate (MVP).</div>\n              </div>\n              <div className=\"modalHeaderActions\">\n                <button className=\"secondaryButton modalMagic\" onClick={() => startComposerTranscription()}>\n                  <Icon name=\"mic\" size={14} />\n                  Magic\n                </button>\n                <button className=\"secondaryButton\" onClick={() => autoFillComposerFromText()}>\n                  Auto-fill\n                </button>\n                <button className=\"modalClose\" onClick={() => setEventComposerOpen(false)} aria-label=\"Close\">\n                  <Icon name=\"x\" />\n                </button>\n              </div>\n            </div>\n            <div className=\"eventBody\">\n              <div className=\"eventTitleRow\">\n                <input\n                  className=\"eventTitleInput\"\n                  value={eventComposer.title}\n                  onChange={(e) => setEventComposer((p) => ({ ...p, title: e.target.value }))}\n                  placeholder=\"Dinner with @Mom\"\n                  autoFocus\n                />\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Start\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(eventComposer.startAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      setEventComposer((p) => {\n                        const dur = Math.max(5 * 60 * 1000, p.endAt - p.startAt)\n                        const startAt = ms\n                        const endAt = startAt + dur\n                        return { ...p, startAt, endAt, estimateMinutesRaw: p.estimateMinutesRaw || estimateMinutesFromRange(startAt, endAt) }\n                      })\n                    }}\n                  />\n                </label>\n                <label>\n                  End\n                  <input\n                    className=\"detailSmall\"\n                    type=\"datetime-local\"\n                    value={toLocalDateTimeInput(eventComposer.endAt)}\n                    onChange={(e) => {\n                      const ms = fromLocalDateTimeInput(e.target.value)\n                      if (!ms) return\n                      setEventComposer((p) => ({ ...p, endAt: Math.max(ms, p.startAt + 5 * 60 * 1000), estimateMinutesRaw: p.estimateMinutesRaw }))\n                    }}\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Kind\n                  <select\n                    className=\"detailSmall\"\n                    value={eventComposer.kind}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, kind: e.target.value as any }))}>\n                    <option value=\"event\">Event</option>\n                    <option value=\"task\">Task block</option>\n                    <option value=\"log\">Log</option>\n                    <option value=\"episode\">Episode (multi-day)</option>\n                  </select>\n                </label>\n                <label>\n                  Estimate (min)\n                  <input\n                    className=\"detailSmall\"\n                    value={eventComposer.estimateMinutesRaw}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, estimateMinutesRaw: e.target.value }))}\n                    placeholder=\"60\"\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label className=\"eventCheck\">\n                  <input\n                    type=\"checkbox\"\n                    checked={eventComposer.allDay || eventComposer.kind === 'episode'}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, allDay: e.target.checked }))}\n                  />\n                  All-day\n                </label>\n                <label className=\"eventCheck\">\n                  <input type=\"checkbox\" checked={eventComposer.active} onChange={(e) => setEventComposer((p) => ({ ...p, active: e.target.checked }))} />\n                  Active (running)\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Icon\n                  <div className=\"detailIconSelect\">\n                    <select\n                      className=\"detailSmall\"\n                      value={eventComposer.icon ?? ''}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, icon: e.target.value || null }))}>\n                      <option value=\"\">Auto</option>\n                      {EVENT_ICON_OPTIONS.map((o) => (\n                        <option key={o.value} value={o.value}>\n                          {o.label}\n                        </option>\n                      ))}\n                    </select>\n                    <span className=\"detailIconPreview\">\n                      <Icon name={eventComposer.icon ? (eventComposer.icon as any) : 'calendar'} size={14} />\n                    </span>\n                  </div>\n                </label>\n                <label>\n                  Color\n                  <div className=\"detailColorRow\">\n                    <input\n                      className=\"detailColorInput\"\n                      type=\"color\"\n                      value={eventComposer.color ?? '#7c3aed'}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, color: e.target.value }))}\n                    />\n                    <button className=\"detailColorAuto\" onClick={() => setEventComposer((p) => ({ ...p, color: null }))}>\n                      Auto\n                    </button>\n                  </div>\n                </label>\n              </div>\n\t              <div className=\"eventGrid\">\n\t                <label>\n\t                  Tags\n\t                  <div className=\"detailChips\">\n\t                    {composerTagList.map((t) => (\n\t                      <button\n\t                        key={t}\n\t                        className=\"detailChip\"\n\t                        onClick={() => {\n\t                          const next = composerTagList.filter((x) => x !== t)\n\t                          setEventComposer((p) => ({ ...p, tagsRaw: next.join(' ') }))\n\t                        }}\n\t                        type=\"button\">\n\t                        {t}\n\t                        <span className=\"detailChipRemove\">\u00d7</span>\n\t                      </button>\n\t                    ))}\n\t                    <input\n\t                      className=\"detailChipInput\"\n\t                      value={composerTagDraft}\n\t                      onChange={(e) => setComposerTagDraft(e.target.value)}\n\t                      onKeyDown={(e) => {\n\t                        if (e.key !== 'Enter' && e.key !== ',' && e.key !== ' ') return\n\t                        e.preventDefault()\n\t                        const next = parseTags(composerTagDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerTagList, ...next].map(normalizeHashTag).filter(Boolean))\n\t                        setEventComposer((p) => ({ ...p, tagsRaw: merged.join(' ') }))\n\t                        setComposerTagDraft('')\n\t                      }}\n\t                      onBlur={() => {\n\t                        const next = parseTags(composerTagDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerTagList, ...next].map(normalizeHashTag).filter(Boolean))\n\t                        setEventComposer((p) => ({ ...p, tagsRaw: merged.join(' ') }))\n\t                        setComposerTagDraft('')\n\t                      }}\n\t                      placeholder=\"#work #health\"\n\t                    />\n\t                  </div>\n\t                </label>\n\t                <label>\n\t                  Location\n\t                  <div className=\"detailChips\">\n\t                    {composerLocationList.map((loc) => (\n\t                      <button\n\t                        key={loc}\n\t                        className=\"detailChip\"\n\t                        onClick={() => {\n\t                          const next = composerLocationList.filter((x) => x !== loc)\n\t                          setEventComposer((p) => ({ ...p, location: next.join(', ') }))\n\t                        }}\n\t                        type=\"button\">\n\t                        {loc}\n\t                        <span className=\"detailChipRemove\">\u00d7</span>\n\t                      </button>\n\t                    ))}\n\t                    <input\n\t                      className=\"detailChipInput\"\n\t                      value={composerLocationDraft}\n\t                      onChange={(e) => setComposerLocationDraft(e.target.value)}\n\t                      onKeyDown={(e) => {\n\t                        if (e.key !== 'Enter' && e.key !== ',') return\n\t                        e.preventDefault()\n\t                        const next = parseCommaList(composerLocationDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerLocationList, ...next])\n\t                        setEventComposer((p) => ({ ...p, location: merged.join(', ') }))\n\t                        setComposerLocationDraft('')\n\t                      }}\n\t                      onBlur={() => {\n\t                        const next = parseCommaList(composerLocationDraft)\n\t                        if (!next.length) return\n\t                        const merged = uniqStrings([...composerLocationList, ...next])\n\t                        setEventComposer((p) => ({ ...p, location: merged.join(', ') }))\n\t                        setComposerLocationDraft('')\n\t                      }}\n\t                      placeholder=\"Home\"\n\t                    />\n\t                  </div>\n\t                </label>\n\t              </div>\n\t              <div className=\"eventGrid\">\n\t                <label>\n\t                  Category\n\t                  <input\n\t                    className=\"detailSmall\"\n\t                    list=\"taxCatList\"\n\t                    value={eventComposer.category}\n\t                    onChange={(e) => setEventComposer((p) => ({ ...p, category: e.target.value }))}\n\t                    placeholder=\"Work / Health / Study\"\n\t                  />\n\t                </label>\n                <label>\n                  Subcategory\n                  <input\n                    className=\"detailSmall\"\n                    list=\"taxSubcatList\"\n                    value={eventComposer.subcategory}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, subcategory: e.target.value }))}\n                    placeholder=\"Clinic / Surgery / Gym\"\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Importance\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={eventComposer.importance ?? 5}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, importance: Number(e.target.value) }))}\n                      aria-label=\"Importance\"\n                    />\n                    <span className=\"detailRangeValue\">{eventComposer.importance ?? 5}</span>\n                  </div>\n                </label>\n                <label>\n                  Difficulty / Energy\n                  <div className=\"detailRangeRow\">\n                    <input\n                      className=\"detailRange\"\n                      type=\"range\"\n                      min={0}\n                      max={10}\n                      step={1}\n                      value={eventComposer.difficulty ?? 5}\n                      onChange={(e) => setEventComposer((p) => ({ ...p, difficulty: Number(e.target.value) }))}\n                      aria-label=\"Difficulty / Energy\"\n                    />\n                    <span className=\"detailRangeValue\">{eventComposer.difficulty ?? 5}</span>\n                  </div>\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  People\n                  <div className=\"detailChips\">\n                    {composerPeopleList.map((p) => (\n                      <button\n                        key={p}\n                        className=\"detailChip\"\n                        onClick={() => {\n                          const next = composerPeopleList.filter((x) => x !== p)\n                          setEventComposer((prev) => ({ ...prev, peopleRaw: next.join(', ') }))\n                        }}\n                        type=\"button\">\n                        {p}\n                        <span className=\"detailChipRemove\">\u00d7</span>\n                      </button>\n                    ))}\n                    <input\n                      className=\"detailChipInput\"\n                      value={composerPeopleDraft}\n                      onChange={(e) => setComposerPeopleDraft(e.target.value)}\n                      onKeyDown={(e) => {\n                        if (e.key !== 'Enter' && e.key !== ',') return\n                        e.preventDefault()\n                        const next = parseCommaList(composerPeopleDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...composerPeopleList, ...next])\n                        setEventComposer((prev) => ({ ...prev, peopleRaw: merged.join(', ') }))\n                        setComposerPeopleDraft('')\n                      }}\n                      onBlur={() => {\n                        const next = parseCommaList(composerPeopleDraft)\n                        if (!next.length) return\n                        const merged = uniqStrings([...composerPeopleList, ...next])\n                        setEventComposer((prev) => ({ ...prev, peopleRaw: merged.join(', ') }))\n                        setComposerPeopleDraft('')\n                      }}\n                      placeholder=\"Mom, Alex\"\n                    />\n                  </div>\n                </label>\n                <label>\n                  Tracker key (optional)\n                  <input\n                    className=\"detailSmall\"\n                    value={eventComposer.trackerKey}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, trackerKey: e.target.value }))}\n                    placeholder=\"workout / pain / mood\"\n                  />\n                </label>\n              </div>\n              <div className=\"eventGrid\">\n                <label>\n                  Skills\n                  <input\n                    className=\"detailSmall\"\n                    value={eventComposer.skillsRaw}\n                    onChange={(e) => setEventComposer((p) => ({ ...p, skillsRaw: e.target.value }))}\n                    placeholder=\"communication, lifting\"\n                  />\n                </label>\n\t              <label>\n\t                Character\n\t                <div className=\"charGrid\" role=\"group\" aria-label=\"Character stats\">\n\t                  {CHARACTER_KEYS.map((k) => {\n\t                    const selected = normalizeCharacterSelection(eventComposer.character).includes(k)\n\t                    return (\n\t                      <button\n\t                        key={k}\n\t                        className={selected ? 'charChip active' : 'charChip'}\n\t                        onClick={() => setEventComposer((p) => ({ ...p, character: toggleCharacterSelection(p.character, k) }))}\n\t                        type=\"button\"\n\t                        aria-label={selected ? `Remove ${k}` : `Add ${k}`}>\n\t                        {k}\n\t                      </button>\n\t                    )\n\t                  })}\n\t                </div>\n\t              </label>\n\t            </div>\n              <div className=\"eventNotes\">\n                <div className=\"eventNotesHeader\">\n                  <span>Notes</span>\n                  <button className=\"detailInlineBtn\" onClick={() => startComposerTranscription()} type=\"button\">\n                    <Icon name=\"mic\" size={12} />\n                    {composerListening ? 'Listening\u2026' : 'Transcribe'}\n                  </button>\n                </div>\n                <textarea\n                  className=\"eventNotesArea\"\n                  value={eventComposer.notes}\n                  onChange={(e) => setEventComposer((p) => ({ ...p, notes: e.target.value }))}\n                  placeholder=\"Segments: use **HH:MM** - label (e.g., **13:00** - Clinic)\u2026\"\n                  aria-label=\"Event notes\"\n                />\n                {composerInterim ? <div className=\"capInterim\">\u2026 {composerInterim}</div> : null}\n              </div>\n            </div>\n            <div className=\"modalActions\">\n              <button className=\"secondaryButton\" onClick={() => setEventComposerOpen(false)}>\n                Cancel\n              </button>\n              <div className=\"modalSpacer\" />\n              <button\n                className=\"primaryButton\"\n                disabled={eventComposer.title.trim().length === 0}\n                onClick={() => {\n                  const title = eventComposer.title.trim()\n                  const kind = eventComposer.kind\n\t\t                  const tags = parseTags(eventComposer.tagsRaw)\n\t\t                  const people = parseCommaList(eventComposer.peopleRaw)\n\t\t                  const skills = parseCommaList(eventComposer.skillsRaw)\n\t\t                  const character = normalizeCharacterSelection(eventComposer.character)\n\t\t                  const estimateMinutesInput = numberOrNull(eventComposer.estimateMinutesRaw)\n\t\t                  const category = eventComposer.category.trim() ? eventComposer.category.trim() : null\n\t\t                  const subcategory = eventComposer.subcategory.trim() ? eventComposer.subcategory.trim() : null\n\t\t                  const importance = eventComposer.importance\n\t\t                  const difficulty = eventComposer.difficulty\n\n                  let startAt = eventComposer.startAt\n                  let endAt = Math.max(eventComposer.endAt, startAt + 5 * 60 * 1000)\n\n                  const allDay = eventComposer.allDay || kind === 'episode'\n                  if (allDay) {\n                    const s = new Date(startAt)\n                    s.setHours(0, 0, 0, 0)\n                    const e = new Date(endAt)\n                    e.setHours(0, 0, 0, 0)\n                    startAt = s.getTime()\n                    endAt = Math.max(e.getTime() + 24 * 60 * 60 * 1000, startAt + 24 * 60 * 60 * 1000)\n                  }\n\n                  const estimateMinutes =\n                    estimateMinutesInput ?? (allDay ? null : Math.round(Math.max(5 * 60 * 1000, endAt - startAt) / (60 * 1000)))\n\n\t                  onCreateEvent({\n\t                    title,\n\t                    startAt,\n\t                    endAt,\n\t                    kind,\n\t                    taskId: eventComposer.taskId || null,\n\t                    allDay,\n\t                    active: eventComposer.active,\n\t                    tags,\n\t                    notes: eventComposer.notes || null,\n\t                    icon: eventComposer.icon || null,\n\t                    color: eventComposer.color || null,\n\t                    estimateMinutes,\n\t                    location: eventComposer.location.trim() ? eventComposer.location.trim() : null,\n\t                    people,\n\t                    skills,\n\t                    character,\n\t                    category,\n\t                    subcategory,\n\t                    importance,\n\t                    difficulty,\n\t                    trackerKey: eventComposer.trackerKey.trim() ? eventComposer.trackerKey.trim() : null,\n\t                  })\n                  setEventComposerOpen(false)\n                }}>\n                Create\n              </button>\n            </div>\n          </motion.div>\n        </motion.div>\n      ) : null}\n      </AnimatePresence>\n\n      <CaptureModal\n        isOpen={captureOpen}\n        onClose={() => {\n          stopVoiceCapture()\n          setCaptureOpen(false)\n        }}\n        draft={captureDraft}\n        setDraft={setCaptureDraft}\n        isListening={captureListening}\n        onToggleListening={() => toggleVoiceCapture()}\n        interimTranscript={captureInterim}\n        isSaving={captureSaving}\n        onSave={onSaveCapture}\n        aiStatus={captureAiStatus}\n        error={captureError}\n        progress={captureProgress}\n        attachEventId={captureAttachEventId}\n        onDetachEvent={() => setCaptureAttachEventId(null)}\n        attachedEventTitle={captureAttachEventId ? events.find((e) => e.id === captureAttachEventId)?.title ?? 'Event' : null}\n        habitNames={habitDefs.map((h) => h.name).filter(Boolean)}\n        extendedMode={captureExtendedMode}\n        onToggleExtendedMode={() => setCaptureExtendedMode(!captureExtendedMode)}\n        anchorMs={captureAnchorMs}\n      />\n        \n              <AnimatePresence>\n              {docOpen ? (\t        <motion.div\n\t          className=\"modalOverlay docOverlay\"\n          role=\"dialog\"\n          aria-modal=\"true\"\n          initial={{ opacity: 0 }}\n          animate={{ opacity: 1 }}\n          exit={{ opacity: 0 }}\n          transition={{ duration: 0.16, ease: 'easeOut' }}\n          onMouseDown={(e) => {\n            if (e.target === e.currentTarget) setDocOpen(false)\n          }}>\n          <motion.div\n            className=\"docCard\"\n            initial={{ y: 12, opacity: 0, scale: 0.98 }}\n            animate={{ y: 0, opacity: 1, scale: 1 }}\n            exit={{ y: 12, opacity: 0, scale: 0.98 }}\n            transition={{ duration: 0.18, ease: 'easeOut' }}>\n            <div className=\"modalHeader\">\n              <div>\n                <div className=\"modalTitle\">Page</div>\n              </div>\n              <button className=\"modalClose\" onClick={() => setDocOpen(false)} aria-label=\"Close\">\n                <Icon name=\"x\" />\n              </button>\n            </div>\n            <div className=\"docGrid\">\n              <div className=\"docBody\">\n                {selection.kind === 'task' && selectedTask ? (\n                  <>\n                    <div className=\"docTitleRow\">\n                      <input\n                        className=\"docTitleInput\"\n                        value={selectedTask.title}\n                        onChange={(e) => commitTask({ ...selectedTask, title: e.target.value })}\n                      />\n                      <button className=\"docMagicBtn\" type=\"button\">\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                    </div>\n                    <div className=\"docTabsRow\">\n                      <div className=\"docTabs\">\n                        <button\n                          className={docTab === 'notes' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('notes')}>\n                          Notes\n                        </button>\n                        <button\n                          className={docTab === 'transcript' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('transcript')}>\n                          Transcript\n                        </button>\n                      </div>\n                    </div>\n                    {docTab === 'notes' ? (\n                      <MarkdownEditor\n                        value={selectedTask.notes ?? ''}\n                        onChange={(next) => commitTask({ ...selectedTask, notes: next })}\n                        onToggleChecklist={(lineIndex) => onToggleTaskChecklistItem(selectedTask.id, lineIndex)}\n                        placeholder=\"Write markdown notes\u2026\"\n                        ariaLabel=\"Task notes (markdown)\"\n                      />\n                    ) : (\n                      <div className=\"docTranscriptPanel\">\n                        <div className=\"docTranscriptChips\">\n                          {docTranscriptLines.length ? (\n                            docTranscriptLines.map((line, index) => (\n                              <button\n                                key={`${line.time}-${index}`}\n                                className={docTranscriptFocus === line.time ? 'docTranscriptChip active' : 'docTranscriptChip'}\n                                type=\"button\"\n                                onClick={() => setDocTranscriptFocus(line.time)}\n                                title={line.text}>\n                                {line.time}\n                              </button>\n                            ))\n                          ) : (\n                            <div className=\"docTranscriptEmpty\">No timestamped lines yet.</div>\n                          )}\n                        </div>\n                        <div className=\"docTranscriptBox\">\n                          <textarea\n                            className=\"docTranscriptTextarea\"\n                            value={selectedTask.notes ?? ''}\n                            onChange={(e) => commitTask({ ...selectedTask, notes: e.target.value })}\n                            placeholder=\"Paste raw transcript with [HH:MM] timestamps\u2026\"\n                          />\n                        </div>\n                      </div>\n                    )}\n                  </>\n                ) : selection.kind === 'event' && selectedEvent ? (\n                  <>\n                    <div className=\"docTitleRow\">\n                      <input\n                        className=\"docTitleInput\"\n                        value={selectedEvent.title}\n                        onChange={(e) => commitEvent({ ...selectedEvent, title: e.target.value })}\n                      />\n                      <button className=\"docMagicBtn\" type=\"button\">\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                    </div>\n                    <div className=\"docTabsRow\">\n                      <div className=\"docTabs\">\n                        <button\n                          className={docTab === 'notes' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('notes')}>\n                          Notes\n                        </button>\n                        <button\n                          className={docTab === 'transcript' ? 'docTab active' : 'docTab'}\n                          type=\"button\"\n                          onClick={() => setDocTab('transcript')}>\n                          Transcript\n                        </button>\n                      </div>\n                    </div>\n                    {docTab === 'notes' ? (\n                      <MarkdownEditor\n                        value={selectedEvent.notes ?? ''}\n                        onChange={(next) => commitEvent({ ...selectedEvent, notes: next })}\n                        onToggleChecklist={(lineIndex) => {\n                          if (selectedEvent.kind === 'task' && selectedEvent.taskId) {\n                            onToggleTaskChecklistItem(selectedEvent.taskId, lineIndex)\n                            return\n                          }\n                          void onToggleEventNoteChecklist(selectedEvent, lineIndex)\n                        }}\n                        onStartTask={(task) => onStartNoteTask(selectedEvent.id, task)}\n                        taskStateByToken={selectedEventNoteTasks}\n                        nowMs={nowTick}\n                        placeholder=\"Write markdown notes\u2026\"\n                        ariaLabel=\"Event notes (markdown)\"\n                      />\n                    ) : (\n                      <div className=\"docTranscriptPanel\">\n                        <div className=\"docTranscriptChips\">\n                          {docTranscriptLines.length ? (\n                            docTranscriptLines.map((line, index) => (\n                              <button\n                                key={`${line.time}-${index}`}\n                                className={docTranscriptFocus === line.time ? 'docTranscriptChip active' : 'docTranscriptChip'}\n                                type=\"button\"\n                                onClick={() => setDocTranscriptFocus(line.time)}\n                                title={line.text}>\n                                {line.time}\n                              </button>\n                            ))\n                          ) : (\n                            <div className=\"docTranscriptEmpty\">No timestamped lines yet.</div>\n                          )}\n                        </div>\n                        <div className=\"docTranscriptBox\">\n                          <textarea\n                            className=\"docTranscriptTextarea\"\n                            value={selectedEvent.notes ?? ''}\n                            onChange={(e) => commitEvent({ ...selectedEvent, notes: e.target.value })}\n                            placeholder=\"Paste raw transcript with [HH:MM] timestamps\u2026\"\n                          />\n                        </div>\n                      </div>\n                    )}\n                  </>\n                ) : selection.kind === 'capture' && selectedCapture ? (\n                  <>\n                    <div className=\"docTitleRow\">\n                      <input className=\"docTitleInput\" value=\"Inbox note\" readOnly />\n                      <button className=\"docMagicBtn\" type=\"button\">\n                        <Icon name=\"sparkle\" size={14} />\n                        Magic\n                      </button>\n                    </div>\n                    <div className=\"docTabsRow\">\n                      <div className=\"docTabs\">\n                        <button className=\"docTab active\" type=\"button\">\n                          Transcript\n                        </button>\n                      </div>\n                    </div>\n                    <div className=\"docTranscriptPanel\">\n                      <div className=\"docTranscriptChips\">\n                        {docTranscriptLines.length ? (\n                          docTranscriptLines.map((line, index) => (\n                            <button\n                              key={`${line.time}-${index}`}\n                              className={docTranscriptFocus === line.time ? 'docTranscriptChip active' : 'docTranscriptChip'}\n                              type=\"button\"\n                              onClick={() => setDocTranscriptFocus(line.time)}\n                              title={line.text}>\n                              {line.time}\n                            </button>\n                          ))\n                        ) : (\n                          <div className=\"docTranscriptEmpty\">No timestamped lines yet.</div>\n                        )}\n                      </div>\n                      <div className=\"docTranscriptBox\">\n                        <textarea\n                          className=\"docTranscriptTextarea\"\n                          value={selectedCapture.rawText}\n                          onChange={(e) => {\n                            void onUpdateCapture(selectedCapture.id, e.target.value)\n                          }}\n                          placeholder=\"Paste raw transcript with [HH:MM] timestamps\u2026\"\n                        />\n                      </div>\n                    </div>\n                  </>\n                ) : (\n                  <div className=\"docEmpty\">Select a task, event, or capture to open as a page.</div>\n                )}\n              </div>\n              <div className=\"docProps\">\n                <div className=\"docPropsTitle\">Properties</div>\n                {selection.kind === 'task' && selectedTask ? (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"detailRow\">\n                      <label className=\"detailLabel\">\n                        Tags\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTaskTags.join(' ')}\n                          onChange={(e) => commitTask({ ...selectedTask, tags: parseTags(e.target.value) })}\n                          placeholder=\"#work #health\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Context</div>\n                      <div className=\"detailChips\">\n                        {selectedTaskContexts.map((ctx) => (\n                          <button\n                            key={ctx}\n                            className=\"detailChip\"\n                            onClick={() =>\n                              commitTask({ ...selectedTask, contexts: selectedTaskContexts.filter((x) => x !== ctx) })\n                            }\n                            type=\"button\">\n                            {formatContextLabel(ctx)}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={contextDraft}\n                          onChange={(e) => setContextDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitTask({ ...selectedTask, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedTask.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitTask({ ...selectedTask, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          placeholder=\"at computer, at email\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Due\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedTask.dueAt)}\n                          onChange={(e) => commitTask({ ...selectedTask, dueAt: fromLocalDateTimeInput(e.target.value) })}\n                        />\n                      </label>\n                      <label>\n                        Scheduled\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedTask.scheduledAt)}\n                          onChange={(e) => commitTask({ ...selectedTask, scheduledAt: fromLocalDateTimeInput(e.target.value) })}\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Goal\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTask.goal ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, goal: e.target.value || null })}\n                          placeholder=\"get shredded\"\n                        />\n                      </label>\n                      <label>\n                        Project\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTask.project ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, project: e.target.value || null })}\n                          placeholder=\"workout plan\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Category\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxCatList\"\n                          value={selectedTask.category ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, category: e.target.value || null })}\n                          placeholder=\"Work / Health / Study\"\n                        />\n                      </label>\n                      <label>\n                        Subcategory\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxSubcatList\"\n                          value={selectedTask.subcategory ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, subcategory: e.target.value || null })}\n                          placeholder=\"Clinic / Surgery / Gym\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Category shortcuts</div>\n                      <div className=\"detailChips\">\n                        {taxonomyCategories.slice(0, 12).map((c) => (\n                          <button\n                            key={c}\n                            className={selectedTask.category?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                            onClick={() => commitTask({ ...selectedTask, category: c })}\n                            type=\"button\">\n                            {c}\n                          </button>\n                        ))}\n                      </div>\n                    </div>\n                    {taxonomySubcategories.length ? (\n                      <div className=\"detailRow\">\n                        <div className=\"detailLabel\">Subcategory shortcuts</div>\n                        <div className=\"detailChips\">\n                          {taxonomySubcategories.slice(0, 12).map((c) => (\n                            <button\n                              key={c}\n                              className={selectedTask.subcategory?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                              onClick={() => commitTask({ ...selectedTask, subcategory: c })}\n                              type=\"button\">\n                              {c}\n                            </button>\n                          ))}\n                        </div>\n                      </div>\n                    ) : null}\n                    <div className=\"detailGrid\">\n                      <label>\n                        Importance\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedTask.importance ?? 5}\n                            onChange={(e) => commitTask({ ...selectedTask, importance: Number(e.target.value) })}\n                            aria-label=\"Importance\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedTask.importance ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitTask({ ...selectedTask, importance: null })}\n                            disabled={selectedTask.importance == null}\n                            aria-label=\"Clear importance\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                      <label>\n                        Difficulty / Energy\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedTask.difficulty ?? 5}\n                            onChange={(e) => commitTask({ ...selectedTask, difficulty: Number(e.target.value) })}\n                            aria-label=\"Difficulty / Energy\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedTask.difficulty ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitTask({ ...selectedTask, difficulty: null })}\n                            disabled={selectedTask.difficulty == null}\n                            aria-label=\"Clear difficulty or energy\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                      <label>\n                        Estimate (min)\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedTask.estimateMinutes ?? ''}\n                          onChange={(e) => commitTask({ ...selectedTask, estimateMinutes: numberOrNull(e.target.value) })}\n                          placeholder=\"25\"\n                        />\n                      </label>\n                    </div>\n                  </div>\n                ) : selection.kind === 'event' && selectedEvent ? (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"detailGrid\">\n                      <label>\n                        Start\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedEvent.startAt)}\n                          onChange={(e) => {\n                            const ms = fromLocalDateTimeInput(e.target.value)\n                            if (!ms) return\n                            const dur = Math.max(5 * 60 * 1000, selectedEvent.endAt - selectedEvent.startAt)\n                            commitEvent({ ...selectedEvent, startAt: ms, endAt: ms + dur })\n                          }}\n                        />\n                      </label>\n                      <label>\n                        End\n                        <input\n                          className=\"detailSmall\"\n                          type=\"datetime-local\"\n                          value={toLocalDateTimeInput(selectedEvent.endAt)}\n                          onChange={(e) => {\n                            const ms = fromLocalDateTimeInput(e.target.value)\n                            if (!ms) return\n                            commitEvent({ ...selectedEvent, endAt: Math.max(ms, selectedEvent.startAt + 5 * 60 * 1000) })\n                          }}\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Icon\n                        <div className=\"detailIconSelect\">\n                          <select\n                            className=\"detailSmall\"\n                            value={selectedEvent.icon ?? ''}\n                            onChange={(e) => commitEvent({ ...selectedEvent, icon: e.target.value || null })}>\n                            <option value=\"\">Auto</option>\n                            {EVENT_ICON_OPTIONS.map((o) => (\n                              <option key={o.value} value={o.value}>\n                                {o.label}\n                              </option>\n                            ))}\n                          </select>\n                          <span className=\"detailIconPreview\">\n                            <Icon name={eventAccent(selectedEvent).icon} size={14} />\n                          </span>\n                        </div>\n                      </label>\n                      <label>\n                        Color\n                        <div className=\"detailColorRow\">\n                          <input\n                            className=\"detailColorInput\"\n                            type=\"color\"\n                            value={selectedEvent.color ?? eventAccent(selectedEvent).color}\n                            onChange={(e) => commitEvent({ ...selectedEvent, color: e.target.value })}\n                          />\n                          <button className=\"detailColorAuto\" onClick={() => commitEvent({ ...selectedEvent, color: null })}>\n                            Auto\n                          </button>\n                        </div>\n                        <div className=\"detailSwatches\">\n                          {EVENT_COLOR_PRESETS.slice(0, 9).map((c) => (\n                            <button\n                              key={c.hex}\n                              className={selectedEvent.color === c.hex ? 'detailSwatch active' : 'detailSwatch'}\n                              title={c.name}\n                              style={{ background: c.hex }}\n                              onClick={() => commitEvent({ ...selectedEvent, color: c.hex })}\n                            />\n                          ))}\n                        </div>\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Tags</div>\n                      <div className=\"detailChips\">\n                        {selectedEventTags.map((t) => (\n                          <button\n                            key={t}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, tags: selectedEventTags.filter((x) => x !== t) })}\n                            type=\"button\">\n                            {t}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={tagDraft}\n                          onChange={(e) => setTagDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',' && e.key !== ' ') return\n                            e.preventDefault()\n                            const next = parseTags(tagDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                            commitEvent({ ...selectedEvent, tags: merged })\n                            setTagDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseTags(tagDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventTags, ...next].map(normalizeHashTag).filter(Boolean))\n                            commitEvent({ ...selectedEvent, tags: merged })\n                            setTagDraft('')\n                          }}\n                          placeholder=\"#work #meeting\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Context</div>\n                      <div className=\"detailChips\">\n                        {selectedEventContexts.map((ctx) => (\n                          <button\n                            key={ctx}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, contexts: selectedEventContexts.filter((x) => x !== ctx) })}\n                            type=\"button\">\n                            {formatContextLabel(ctx)}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={contextDraft}\n                          onChange={(e) => setContextDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitEvent({ ...selectedEvent, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseContexts(contextDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...(selectedEvent.contexts ?? []), ...next].map((c) => normalizeContextToken(c) ?? '').filter(Boolean))\n                            commitEvent({ ...selectedEvent, contexts: merged })\n                            setContextDraft('')\n                          }}\n                          placeholder=\"at computer, at email\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Estimate (min)\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedEvent.estimateMinutes ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, estimateMinutes: numberOrNull(e.target.value) })}\n                          placeholder=\"30\"\n                        />\n                      </label>\n                      <label>\n                        Location\n                        <div className=\"detailChips\">\n                          {selectedEventLocations.map((loc) => (\n                            <button\n                              key={loc}\n                              className=\"detailChip\"\n                              onClick={() => {\n                                const next = selectedEventLocations.filter((x) => x !== loc)\n                                commitEvent({ ...selectedEvent, location: next.length ? next.join(', ') : null })\n                              }}\n                              type=\"button\">\n                              {loc}\n                              <span className=\"detailChipRemove\">\u00d7</span>\n                            </button>\n                          ))}\n                          <input\n                            className=\"detailChipInput\"\n                            value={locationDraft}\n                            onChange={(e) => setLocationDraft(e.target.value)}\n                            onKeyDown={(e) => {\n                              if (e.key !== 'Enter' && e.key !== ',') return\n                              e.preventDefault()\n                              const next = parseCommaList(locationDraft)\n                              if (!next.length) return\n                              const merged = uniqStrings([...selectedEventLocations, ...next])\n                              commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                              setLocationDraft('')\n                            }}\n                            onBlur={() => {\n                              const next = parseCommaList(locationDraft)\n                              if (!next.length) return\n                              const merged = uniqStrings([...selectedEventLocations, ...next])\n                              commitEvent({ ...selectedEvent, location: merged.length ? merged.join(', ') : null })\n                              setLocationDraft('')\n                            }}\n                            placeholder=\"Home\"\n                          />\n                        </div>\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Points\n                        <div className=\"detailPoints\">\n                          <div className=\"detailPointsValue\">{selectedEventPoints.toFixed(1)}</div>\n                          <div className=\"detailPointsMeta\">\n                            {selectedEventBase} \u00d7 {formatMinutesSpan(selectedEventMinutes)} \u00f7 60 \u00d7 {selectedEventMult.toFixed(2)}\n                          </div>\n                        </div>\n                      </label>\n                      <label>\n                        Running\n                        <div className=\"detailPoints\">\n                          <div className=\"detailPointsValue\">{selectedEvent.active ? 'Active' : '\u2014'}</div>\n                          <div className=\"detailPointsMeta\">\n                            {selectedEvent.active ? `${formatMinutesSpan(selectedEventMinutes)} elapsed` : 'Not running'}\n                          </div>\n                        </div>\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">People</div>\n                      <div className=\"detailChips\">\n                        {selectedEventPeople.map((p) => (\n                          <button\n                            key={p}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, people: selectedEventPeople.filter((x) => x !== p) })}\n                            type=\"button\">\n                            {p}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={peopleDraft}\n                          onChange={(e) => setPeopleDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseCommaList(peopleDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventPeople, ...next])\n                            commitEvent({ ...selectedEvent, people: merged })\n                            setPeopleDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseCommaList(peopleDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventPeople, ...next])\n                            commitEvent({ ...selectedEvent, people: merged })\n                            setPeopleDraft('')\n                          }}\n                          placeholder=\"Mom, Alex\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Skills</div>\n                      <div className=\"detailChips\">\n                        {selectedEventSkills.map((skill) => (\n                          <button\n                            key={skill}\n                            className=\"detailChip\"\n                            onClick={() => commitEvent({ ...selectedEvent, skills: selectedEventSkills.filter((x) => x !== skill) })}\n                            type=\"button\">\n                            {skill}\n                            <span className=\"detailChipRemove\">\u00d7</span>\n                          </button>\n                        ))}\n                        <input\n                          className=\"detailChipInput\"\n                          value={skillDraft}\n                          onChange={(e) => setSkillDraft(e.target.value)}\n                          onKeyDown={(e) => {\n                            if (e.key !== 'Enter' && e.key !== ',') return\n                            e.preventDefault()\n                            const next = parseCommaList(skillDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventSkills, ...next])\n                            commitEvent({ ...selectedEvent, skills: merged })\n                            setSkillDraft('')\n                          }}\n                          onBlur={() => {\n                            const next = parseCommaList(skillDraft)\n                            if (!next.length) return\n                            const merged = uniqStrings([...selectedEventSkills, ...next])\n                            commitEvent({ ...selectedEvent, skills: merged })\n                            setSkillDraft('')\n                          }}\n                          placeholder=\"communication, lifting\"\n                        />\n                      </div>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">\n                        Character\n                        <div className=\"charGrid\" role=\"group\" aria-label=\"Character stats\">\n                          {CHARACTER_KEYS.map((k) => {\n                            const selected = normalizeCharacterSelection(selectedEvent.character).includes(k)\n                            return (\n                              <button\n                                key={k}\n                                className={selected ? 'charChip active' : 'charChip'}\n                                onClick={() => commitEvent({ ...selectedEvent, character: toggleCharacterSelection(selectedEvent.character, k) })}\n                                type=\"button\"\n                                aria-label={selected ? `Remove ${k}` : `Add ${k}`}>\n                                {k}\n                              </button>\n                            )\n                          })}\n                        </div>\n                      </div>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Goal\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedEvent.goal ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, goal: e.target.value || null })}\n                          placeholder=\"get shredded\"\n                        />\n                      </label>\n                      <label>\n                        Project\n                        <input\n                          className=\"detailSmall\"\n                          value={selectedEvent.project ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, project: e.target.value || null })}\n                          placeholder=\"workout plan\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailGrid\">\n                      <label>\n                        Category\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxCatList\"\n                          value={selectedEvent.category ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, category: e.target.value || null })}\n                          placeholder=\"Work / Health / Study\"\n                        />\n                      </label>\n                      <label>\n                        Subcategory\n                        <input\n                          className=\"detailSmall\"\n                          list=\"taxSubcatList\"\n                          value={selectedEvent.subcategory ?? ''}\n                          onChange={(e) => commitEvent({ ...selectedEvent, subcategory: e.target.value || null })}\n                          placeholder=\"Clinic / Surgery / Gym\"\n                        />\n                      </label>\n                    </div>\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Category shortcuts</div>\n                      <div className=\"detailChips\">\n                        {taxonomyCategories.slice(0, 12).map((c) => (\n                          <button\n                            key={c}\n                            className={selectedEvent.category?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                            onClick={() => commitEvent({ ...selectedEvent, category: c })}\n                            type=\"button\">\n                            {c}\n                          </button>\n                        ))}\n                      </div>\n                    </div>\n                    {taxonomySubcategories.length ? (\n                      <div className=\"detailRow\">\n                        <div className=\"detailLabel\">Subcategory shortcuts</div>\n                        <div className=\"detailChips\">\n                          {taxonomySubcategories.slice(0, 12).map((c) => (\n                            <button\n                              key={c}\n                              className={selectedEvent.subcategory?.toLowerCase() === c.toLowerCase() ? 'detailChip active' : 'detailChip'}\n                              onClick={() => commitEvent({ ...selectedEvent, subcategory: c })}\n                              type=\"button\">\n                              {c}\n                            </button>\n                          ))}\n                        </div>\n                      </div>\n                    ) : null}\n                    <div className=\"detailGrid\">\n                      <label>\n                        Importance\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedEvent.importance ?? 5}\n                            onChange={(e) => commitEvent({ ...selectedEvent, importance: Number(e.target.value) })}\n                            aria-label=\"Importance\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedEvent.importance ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitEvent({ ...selectedEvent, importance: null })}\n                            disabled={selectedEvent.importance == null}\n                            aria-label=\"Clear importance\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                      <label>\n                        Difficulty / Energy\n                        <div className=\"detailRangeRow\">\n                          <input\n                            className=\"detailRange\"\n                            type=\"range\"\n                            min={0}\n                            max={10}\n                            step={1}\n                            value={selectedEvent.difficulty ?? 5}\n                            onChange={(e) => commitEvent({ ...selectedEvent, difficulty: Number(e.target.value) })}\n                            aria-label=\"Difficulty / Energy\"\n                          />\n                          <span className=\"detailRangeValue\">{selectedEvent.difficulty ?? '\u2014'}</span>\n                          <button\n                            className=\"detailRangeClear\"\n                            type=\"button\"\n                            onClick={() => commitEvent({ ...selectedEvent, difficulty: null })}\n                            disabled={selectedEvent.difficulty == null}\n                            aria-label=\"Clear difficulty or energy\">\n                            \u00d7\n                          </button>\n                        </div>\n                      </label>\n                    </div>\n                  </div>\n                ) : selection.kind === 'capture' && selectedCapture ? (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"detailRow\">\n                      <div className=\"detailLabel\">Created</div>\n                      <div className=\"docPropValue\">{new Date(selectedCapture.createdAt).toLocaleString()}</div>\n                    </div>\n                  </div>\n                ) : (\n                  <div className=\"docPropsGrid\">\n                    <div className=\"docPropValue\">Select something first.</div>\n                  </div>\n                )}\n              </div>\n            </div>\n          </motion.div>\n        </motion.div>\n\t      ) : null}\n\t      </AnimatePresence>\n\n\t      <datalist id=\"taxCatList\">\n\t        {taxonomyCategories.map((c) => (\n\t          <option key={c} value={c} />\n\t        ))}\n\t      </datalist>\n      <datalist id=\"taxSubcatList\">\n        {taxonomySubcategories.map((s) => (\n          <option key={s} value={s} />\n        ))}\n      </datalist>\n      {authReady && !authSession && !authDismissed ? (\n        <div className=\"authOverlay\">\n          <div className=\"authCard\">\n            <div className=\"authHeader\">\n              <div>\n                <div className=\"authTitle\">Sign in to sync</div>\n                <div className=\"authSubtitle\">Use the same account on web and iPhone.</div>\n              </div>\n              <button className=\"authDismiss\" type=\"button\" onClick={() => setAuthDismissed(true)}>\n                Not now\n              </button>\n            </div>\n            {!supabaseConfigured ? (\n              <div className=\"authError\">\n                Supabase is not configured. Set VITE_SUPABASE_URL and VITE_SUPABASE_ANON_KEY.\n              </div>\n            ) : (\n              <>\n                <div className=\"authField\">\n                  <label className=\"authLabel\" htmlFor=\"authEmail\">Email</label>\n                  <input\n                    id=\"authEmail\"\n                    type=\"email\"\n                    value={authEmail}\n                    onChange={(e) => setAuthEmail(e.target.value)}\n                    placeholder=\"you@example.com\"\n                  />\n                </div>\n                <div className=\"authField\">\n                  <label className=\"authLabel\" htmlFor=\"authPassword\">Password</label>\n                  <input\n                    id=\"authPassword\"\n                    type=\"password\"\n                    value={authPassword}\n                    onChange={(e) => setAuthPassword(e.target.value)}\n                    placeholder=\"password\"\n                  />\n                </div>\n                {authError ? <div className=\"authError\">{authError}</div> : null}\n                {authStatus ? <div className=\"authStatus\">{authStatus}</div> : null}\n                <div className=\"authActions\">\n                  <button className=\"primaryButton\" type=\"button\" onClick={handleAuthSubmit} disabled={authWorking}>\n                    {authWorking ? 'Working...' : authMode === 'signup' ? 'Create account' : 'Sign in'}\n                  </button>\n                  <button\n                    className=\"secondaryButton\"\n                    type=\"button\"\n                    onClick={() => setAuthMode(authMode === 'signin' ? 'signup' : 'signin')}\n                  >\n                    {authMode === 'signin' ? 'Create account' : 'Have an account? Sign in'}\n                  </button>\n                </div>\n              </>\n            )}\n          </div>\n        </div>\n      ) : null}\n    </div>\n  )\n}\n\nexport default App\n",
        "last_modified": "2026-01-13T13:00:06.747622"
      },
      "task_intent": {
        "title": "004-need-you-to-reframe-the-notes-explorer-page-becaus",
        "description": "",
        "from_plan": false
      },
      "commits_behind_main": 3,
      "status": "active",
      "merged_at": null
    }
  },
  "created_at": "2026-01-13T11:38:11.829142",
  "last_updated": "2026-01-13T11:38:50.985287"
}