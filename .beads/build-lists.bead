# build-lists.bead
# List/Grid System Components for Insight Swift App
# Bead ID: hq-leg-f3fxk

## Overview

This bead implements a comprehensive list/grid system for the Insight Swift app including:
- InsightList (LazyVStack with pagination)
- InsightGrid (Bento-style layout)
- InsightCarousel (horizontal scroll)
- Pull-to-refresh (custom animation)
- Empty states (illustrated)
- Loading skeletons (shimmer effect)
- Swipe actions (leading/trailing)

All components integrate with the existing ThemeStore and follow the MV architecture pattern.

---

## File: ListComponents.swift
## Path: apps/insight_swift/InsightSwiftPackage/Sources/InsightSwiftFeature/Views/Components/ListComponents.swift

```swift
import SwiftUI

// MARK: - Shimmer Effect

struct ShimmerModifier: ViewModifier {
    @State private var phase: CGFloat = 0
    let duration: Double
    let delay: Double

    init(duration: Double = 1.5, delay: Double = 0) {
        self.duration = duration
        self.delay = delay
    }

    func body(content: Content) -> some View {
        content
            .overlay(
                GeometryReader { geometry in
                    LinearGradient(
                        gradient: Gradient(colors: [
                            .clear,
                            .white.opacity(0.4),
                            .clear
                        ]),
                        startPoint: .leading,
                        endPoint: .trailing
                    )
                    .frame(width: geometry.size.width * 2)
                    .offset(x: -geometry.size.width + (phase * geometry.size.width * 3))
                    .mask(content)
                }
            )
            .onAppear {
                withAnimation(
                    .linear(duration: duration)
                    .repeatForever(autoreverses: false)
                    .delay(delay)
                ) {
                    phase = 1
                }
            }
    }
}

extension View {
    func shimmer(duration: Double = 1.5, delay: Double = 0) -> some View {
        modifier(ShimmerModifier(duration: duration, delay: delay))
    }
}

// MARK: - Loading Skeleton

struct SkeletonView: View {
    @Environment(ThemeStore.self) private var theme
    let height: CGFloat
    let cornerRadius: CGFloat

    init(height: CGFloat = 16, cornerRadius: CGFloat? = nil) {
        self.height = height
        self.cornerRadius = cornerRadius ?? 8
    }

    var body: some View {
        RoundedRectangle(cornerRadius: cornerRadius, style: .continuous)
            .fill(theme.palette.border.opacity(0.3))
            .frame(height: height)
            .shimmer()
    }
}

struct SkeletonRow: View {
    @Environment(ThemeStore.self) private var theme

    var body: some View {
        HStack(spacing: theme.metrics.spacingSmall) {
            // Avatar skeleton
            Circle()
                .fill(theme.palette.border.opacity(0.3))
                .frame(width: 44, height: 44)
                .shimmer(delay: 0)

            VStack(alignment: .leading, spacing: 8) {
                // Title skeleton
                SkeletonView(height: 14)
                    .frame(width: 160)
                    .shimmer(delay: 0.1)

                // Subtitle skeleton
                SkeletonView(height: 12)
                    .frame(width: 100)
                    .shimmer(delay: 0.2)
            }

            Spacer()

            // Trailing skeleton
            SkeletonView(height: 12)
                .frame(width: 50)
                .shimmer(delay: 0.3)
        }
        .padding(theme.metrics.cardPadding)
        .background(theme.palette.surface)
        .clipShape(RoundedRectangle(cornerRadius: theme.metrics.radiusSmall, style: .continuous))
    }
}

struct SkeletonCard: View {
    @Environment(ThemeStore.self) private var theme

    var body: some View {
        VStack(alignment: .leading, spacing: theme.metrics.spacingSmall) {
            // Image skeleton
            RoundedRectangle(cornerRadius: theme.metrics.radiusSmall, style: .continuous)
                .fill(theme.palette.border.opacity(0.3))
                .aspectRatio(1.5, contentMode: .fit)
                .shimmer()

            // Title skeleton
            SkeletonView(height: 16)
                .shimmer(delay: 0.1)

            // Description skeleton
            VStack(spacing: 6) {
                SkeletonView(height: 12)
                    .shimmer(delay: 0.2)
                SkeletonView(height: 12)
                    .frame(width: 120)
                    .shimmer(delay: 0.3)
            }
        }
        .padding(theme.metrics.cardPadding)
        .background(theme.palette.surface)
        .clipShape(RoundedRectangle(cornerRadius: theme.metrics.radius, style: .continuous))
    }
}

// MARK: - Staggered Animation

struct StaggeredAnimationModifier: ViewModifier {
    let index: Int
    let baseDelay: Double
    @State private var appeared = false

    func body(content: Content) -> some View {
        content
            .opacity(appeared ? 1 : 0)
            .offset(y: appeared ? 0 : 20)
            .onAppear {
                withAnimation(
                    .spring(response: 0.5, dampingFraction: 0.8)
                    .delay(Double(index) * baseDelay)
                ) {
                    appeared = true
                }
            }
    }
}

extension View {
    func staggeredAppear(index: Int, baseDelay: Double = 0.05) -> some View {
        modifier(StaggeredAnimationModifier(index: index, baseDelay: baseDelay))
    }
}

// MARK: - Empty State

enum EmptyStateIllustration: String {
    case noData = "tray"
    case noSearch = "magnifyingglass"
    case noConnection = "wifi.slash"
    case noItems = "square.stack.3d.up.slash"
    case noFavorites = "heart.slash"
    case noNotifications = "bell.slash"
    case error = "exclamationmark.triangle"

    var symbolName: String { rawValue }
}

struct EmptyStateView: View {
    @Environment(ThemeStore.self) private var theme

    let illustration: EmptyStateIllustration
    let title: String
    let message: String
    let actionTitle: String?
    let action: (() -> Void)?

    init(
        illustration: EmptyStateIllustration = .noData,
        title: String,
        message: String,
        actionTitle: String? = nil,
        action: (() -> Void)? = nil
    ) {
        self.illustration = illustration
        self.title = title
        self.message = message
        self.actionTitle = actionTitle
        self.action = action
    }

    var body: some View {
        VStack(spacing: theme.metrics.spacing) {
            // Illustrated icon
            ZStack {
                Circle()
                    .fill(theme.palette.tintLight)
                    .frame(width: 100, height: 100)

                Image(systemName: illustration.symbolName)
                    .font(.system(size: 40, weight: .medium))
                    .foregroundStyle(theme.palette.tint)
            }
            .padding(.bottom, theme.metrics.spacingSmall)

            // Title
            Text(title)
                .font(AppFont.title(theme.metrics.sectionTitle))
                .foregroundStyle(theme.palette.text)
                .multilineTextAlignment(.center)

            // Message
            Text(message)
                .font(AppFont.body(theme.metrics.bodyText))
                .foregroundStyle(theme.palette.textSecondary)
                .multilineTextAlignment(.center)
                .padding(.horizontal, theme.metrics.spacing)

            // Action button
            if let actionTitle, let action {
                Button(action: action) {
                    Text(actionTitle)
                        .font(AppFont.body(theme.metrics.bodyText))
                        .foregroundStyle(.white)
                        .padding(.horizontal, theme.metrics.spacing)
                        .frame(height: theme.metrics.buttonHeightSmall)
                        .background(theme.palette.tint)
                        .clipShape(Capsule())
                }
                .padding(.top, theme.metrics.spacingSmall)
            }
        }
        .frame(maxWidth: .infinity, maxHeight: .infinity)
        .padding(theme.metrics.spacing)
    }
}

// MARK: - Pull to Refresh

struct InsightRefreshControl: View {
    @Environment(ThemeStore.self) private var theme
    @Binding var isRefreshing: Bool
    let threshold: CGFloat
    let onRefresh: () async -> Void

    @State private var pullProgress: CGFloat = 0
    @State private var rotation: Double = 0

    init(
        isRefreshing: Binding<Bool>,
        threshold: CGFloat = 80,
        onRefresh: @escaping () async -> Void
    ) {
        self._isRefreshing = isRefreshing
        self.threshold = threshold
        self.onRefresh = onRefresh
    }

    var body: some View {
        GeometryReader { geometry in
            let offset = geometry.frame(in: .global).minY
            let progress = min(max(offset / threshold, 0), 1)

            ZStack {
                // Background circle
                Circle()
                    .stroke(theme.palette.border, lineWidth: 3)
                    .frame(width: 32, height: 32)

                // Progress arc
                Circle()
                    .trim(from: 0, to: isRefreshing ? 0.8 : progress)
                    .stroke(theme.palette.tint, style: StrokeStyle(lineWidth: 3, lineCap: .round))
                    .frame(width: 32, height: 32)
                    .rotationEffect(.degrees(isRefreshing ? rotation : -90))

                // Arrow
                if !isRefreshing {
                    Image(systemName: "arrow.down")
                        .font(.system(size: 14, weight: .bold))
                        .foregroundStyle(theme.palette.tint)
                        .rotationEffect(.degrees(progress * 180))
                        .opacity(progress)
                }
            }
            .frame(maxWidth: .infinity)
            .offset(y: offset > 0 ? offset - 50 : -50)
            .opacity(offset > 20 ? 1 : 0)
            .onChange(of: offset) { _, newOffset in
                pullProgress = newOffset
                if newOffset > threshold && !isRefreshing {
                    triggerRefresh()
                }
            }
            .onChange(of: isRefreshing) { _, refreshing in
                if refreshing {
                    withAnimation(.linear(duration: 1).repeatForever(autoreverses: false)) {
                        rotation = 360
                    }
                } else {
                    rotation = 0
                }
            }
        }
        .frame(height: 0)
    }

    private func triggerRefresh() {
        guard !isRefreshing else { return }
        isRefreshing = true
        Task {
            await onRefresh()
            await MainActor.run {
                isRefreshing = false
            }
        }
    }
}

// MARK: - Swipe Actions

struct SwipeAction: Identifiable {
    let id = UUID()
    let title: String
    let icon: String
    let color: Color
    let action: () -> Void
}

struct SwipeActionsModifier<Leading: View, Trailing: View>: ViewModifier {
    @Environment(ThemeStore.self) private var theme

    let leadingActions: [SwipeAction]
    let trailingActions: [SwipeAction]
    let leadingContent: () -> Leading
    let trailingContent: () -> Trailing

    @State private var offset: CGFloat = 0
    @State private var activeAction: SwipeAction?

    private let actionWidth: CGFloat = 80
    private let triggerThreshold: CGFloat = 100

    init(
        leadingActions: [SwipeAction] = [],
        trailingActions: [SwipeAction] = [],
        @ViewBuilder leadingContent: @escaping () -> Leading = { EmptyView() },
        @ViewBuilder trailingContent: @escaping () -> Trailing = { EmptyView() }
    ) {
        self.leadingActions = leadingActions
        self.trailingActions = trailingActions
        self.leadingContent = leadingContent
        self.trailingContent = trailingContent
    }

    func body(content: Content) -> some View {
        ZStack {
            // Leading actions background
            HStack(spacing: 0) {
                ForEach(leadingActions) { action in
                    Button {
                        withAnimation(.spring(response: 0.3)) {
                            offset = 0
                        }
                        action.action()
                    } label: {
                        VStack(spacing: 4) {
                            Image(systemName: action.icon)
                                .font(.system(size: 20))
                            Text(action.title)
                                .font(AppFont.body(10))
                        }
                        .foregroundStyle(.white)
                        .frame(width: actionWidth, height: .infinity)
                        .background(action.color)
                    }
                }
                Spacer()
            }
            .opacity(offset > 0 ? 1 : 0)

            // Trailing actions background
            HStack(spacing: 0) {
                Spacer()
                ForEach(trailingActions.reversed()) { action in
                    Button {
                        withAnimation(.spring(response: 0.3)) {
                            offset = 0
                        }
                        action.action()
                    } label: {
                        VStack(spacing: 4) {
                            Image(systemName: action.icon)
                                .font(.system(size: 20))
                            Text(action.title)
                                .font(AppFont.body(10))
                        }
                        .foregroundStyle(.white)
                        .frame(width: actionWidth, height: .infinity)
                        .background(action.color)
                    }
                }
            }
            .opacity(offset < 0 ? 1 : 0)

            // Main content
            content
                .offset(x: offset)
                .gesture(
                    DragGesture(minimumDistance: 10)
                        .onChanged { value in
                            let translation = value.translation.width

                            // Limit swipe based on available actions
                            if translation > 0 && leadingActions.isEmpty { return }
                            if translation < 0 && trailingActions.isEmpty { return }

                            // Rubber band effect at edges
                            let maxOffset = CGFloat(max(leadingActions.count, trailingActions.count)) * actionWidth
                            if abs(translation) > maxOffset {
                                offset = translation > 0
                                    ? maxOffset + (translation - maxOffset) * 0.2
                                    : -maxOffset + (translation + maxOffset) * 0.2
                            } else {
                                offset = translation
                            }
                        }
                        .onEnded { value in
                            let velocity = value.predictedEndTranslation.width - value.translation.width
                            let targetOffset: CGFloat

                            if abs(offset) > actionWidth / 2 || abs(velocity) > 200 {
                                // Snap to reveal actions
                                let actionCount = offset > 0 ? leadingActions.count : trailingActions.count
                                targetOffset = offset > 0
                                    ? CGFloat(actionCount) * actionWidth
                                    : -CGFloat(actionCount) * actionWidth
                            } else {
                                // Snap back
                                targetOffset = 0
                            }

                            withAnimation(.spring(response: 0.3, dampingFraction: 0.8)) {
                                offset = targetOffset
                            }
                        }
                )
        }
        .clipShape(RoundedRectangle(cornerRadius: theme.metrics.radiusSmall, style: .continuous))
    }
}

extension View {
    func swipeActions(
        leading: [SwipeAction] = [],
        trailing: [SwipeAction] = []
    ) -> some View {
        modifier(SwipeActionsModifier(
            leadingActions: leading,
            trailingActions: trailing
        ))
    }
}

// MARK: - Insight List

struct InsightList<Data: RandomAccessCollection, Content: View>: View
where Data.Element: Identifiable {
    @Environment(ThemeStore.self) private var theme

    let data: Data
    let spacing: CGFloat?
    let showSkeleton: Bool
    let skeletonCount: Int
    let emptyState: EmptyStateView?
    let loadMore: (() async -> Void)?
    let isLoadingMore: Bool
    let content: (Data.Element, Int) -> Content

    @State private var hasAppeared = false

    init(
        _ data: Data,
        spacing: CGFloat? = nil,
        showSkeleton: Bool = false,
        skeletonCount: Int = 5,
        emptyState: EmptyStateView? = nil,
        isLoadingMore: Bool = false,
        loadMore: (() async -> Void)? = nil,
        @ViewBuilder content: @escaping (Data.Element, Int) -> Content
    ) {
        self.data = data
        self.spacing = spacing
        self.showSkeleton = showSkeleton
        self.skeletonCount = skeletonCount
        self.emptyState = emptyState
        self.isLoadingMore = isLoadingMore
        self.loadMore = loadMore
        self.content = content
    }

    var body: some View {
        Group {
            if showSkeleton {
                // Skeleton loading state
                LazyVStack(spacing: spacing ?? theme.metrics.rowGap) {
                    ForEach(0..<skeletonCount, id: \.self) { index in
                        SkeletonRow()
                            .staggeredAppear(index: index)
                    }
                }
            } else if data.isEmpty {
                // Empty state
                if let emptyState {
                    emptyState
                } else {
                    EmptyStateView(
                        illustration: .noData,
                        title: "No Items",
                        message: "There's nothing here yet."
                    )
                }
            } else {
                // Data list with staggered animation
                LazyVStack(spacing: spacing ?? theme.metrics.rowGap) {
                    ForEach(Array(data.enumerated()), id: \.element.id) { index, item in
                        content(item, index)
                            .staggeredAppear(index: hasAppeared ? 0 : index)
                            .onAppear {
                                // Trigger load more when near end
                                if index == data.count - 3 {
                                    Task {
                                        await loadMore?()
                                    }
                                }
                            }
                    }

                    // Loading more indicator
                    if isLoadingMore {
                        HStack {
                            Spacer()
                            ProgressView()
                                .tint(theme.palette.tint)
                            Spacer()
                        }
                        .padding()
                    }
                }
                .onAppear {
                    DispatchQueue.main.asyncAfter(deadline: .now() + 0.5) {
                        hasAppeared = true
                    }
                }
            }
        }
    }
}

// MARK: - Insight Grid (Bento Style)

enum BentoSize {
    case small      // 1x1
    case medium     // 2x1
    case large      // 2x2
    case wide       // 3x1 or full width

    var columns: Int {
        switch self {
        case .small: return 1
        case .medium: return 2
        case .large: return 2
        case .wide: return 3
        }
    }

    var rows: Int {
        switch self {
        case .small, .medium, .wide: return 1
        case .large: return 2
        }
    }
}

struct BentoItem<Content: View>: View {
    @Environment(ThemeStore.self) private var theme

    let size: BentoSize
    let content: Content

    init(size: BentoSize = .small, @ViewBuilder content: () -> Content) {
        self.size = size
        self.content = content()
    }

    var body: some View {
        content
            .frame(maxWidth: .infinity, maxHeight: .infinity)
            .background(theme.palette.surface)
            .clipShape(RoundedRectangle(cornerRadius: theme.metrics.radius, style: .continuous))
            .overlay(
                RoundedRectangle(cornerRadius: theme.metrics.radius, style: .continuous)
                    .stroke(theme.palette.border, lineWidth: 1)
            )
            .shadow(color: theme.palette.borderLight, radius: 8, x: 0, y: 4)
    }
}

struct InsightGrid<Data: RandomAccessCollection, Content: View>: View
where Data.Element: Identifiable {
    @Environment(ThemeStore.self) private var theme

    let data: Data
    let columns: Int
    let spacing: CGFloat?
    let showSkeleton: Bool
    let skeletonCount: Int
    let emptyState: EmptyStateView?
    let content: (Data.Element, Int) -> Content

    init(
        _ data: Data,
        columns: Int = 2,
        spacing: CGFloat? = nil,
        showSkeleton: Bool = false,
        skeletonCount: Int = 6,
        emptyState: EmptyStateView? = nil,
        @ViewBuilder content: @escaping (Data.Element, Int) -> Content
    ) {
        self.data = data
        self.columns = columns
        self.spacing = spacing
        self.showSkeleton = showSkeleton
        self.skeletonCount = skeletonCount
        self.emptyState = emptyState
        self.content = content
    }

    private var gridColumns: [GridItem] {
        Array(repeating: GridItem(.flexible(), spacing: spacing ?? theme.metrics.cardGap), count: columns)
    }

    var body: some View {
        Group {
            if showSkeleton {
                LazyVGrid(columns: gridColumns, spacing: spacing ?? theme.metrics.cardGap) {
                    ForEach(0..<skeletonCount, id: \.self) { index in
                        SkeletonCard()
                            .aspectRatio(1, contentMode: .fill)
                            .staggeredAppear(index: index)
                    }
                }
            } else if data.isEmpty {
                if let emptyState {
                    emptyState
                } else {
                    EmptyStateView(
                        illustration: .noItems,
                        title: "No Items",
                        message: "Nothing to display in the grid."
                    )
                }
            } else {
                LazyVGrid(columns: gridColumns, spacing: spacing ?? theme.metrics.cardGap) {
                    ForEach(Array(data.enumerated()), id: \.element.id) { index, item in
                        content(item, index)
                            .staggeredAppear(index: index)
                    }
                }
            }
        }
    }
}

// MARK: - Insight Carousel

struct InsightCarousel<Data: RandomAccessCollection, Content: View>: View
where Data.Element: Identifiable {
    @Environment(ThemeStore.self) private var theme

    let data: Data
    let itemWidth: CGFloat?
    let spacing: CGFloat?
    let showSkeleton: Bool
    let skeletonCount: Int
    let showIndicators: Bool
    let content: (Data.Element, Int) -> Content

    @State private var currentIndex: Int = 0
    @State private var scrollOffset: CGFloat = 0

    init(
        _ data: Data,
        itemWidth: CGFloat? = nil,
        spacing: CGFloat? = nil,
        showSkeleton: Bool = false,
        skeletonCount: Int = 3,
        showIndicators: Bool = true,
        @ViewBuilder content: @escaping (Data.Element, Int) -> Content
    ) {
        self.data = data
        self.itemWidth = itemWidth
        self.spacing = spacing
        self.showSkeleton = showSkeleton
        self.skeletonCount = skeletonCount
        self.showIndicators = showIndicators
        self.content = content
    }

    var body: some View {
        VStack(spacing: theme.metrics.spacingSmall) {
            ScrollView(.horizontal, showsIndicators: false) {
                LazyHStack(spacing: spacing ?? theme.metrics.cardGap) {
                    if showSkeleton {
                        ForEach(0..<skeletonCount, id: \.self) { index in
                            SkeletonCard()
                                .frame(width: itemWidth ?? 280)
                                .staggeredAppear(index: index)
                        }
                    } else {
                        ForEach(Array(data.enumerated()), id: \.element.id) { index, item in
                            content(item, index)
                                .frame(width: itemWidth)
                                .staggeredAppear(index: index)
                                .id(index)
                        }
                    }
                }
                .padding(.horizontal, theme.metrics.spacing)
                .scrollTargetLayout()
            }
            .scrollTargetBehavior(.viewAligned)
            .scrollPosition(id: .init(get: { currentIndex }, set: { newValue in
                if let newValue {
                    currentIndex = newValue
                }
            }))

            // Page indicators
            if showIndicators && !showSkeleton && data.count > 1 {
                HStack(spacing: 6) {
                    ForEach(0..<min(data.count, 10), id: \.self) { index in
                        Circle()
                            .fill(index == currentIndex ? theme.palette.tint : theme.palette.border)
                            .frame(width: 6, height: 6)
                            .scaleEffect(index == currentIndex ? 1.2 : 1)
                            .animation(.spring(response: 0.3), value: currentIndex)
                    }

                    if data.count > 10 {
                        Text("+\(data.count - 10)")
                            .font(AppFont.body(theme.metrics.tinyText))
                            .foregroundStyle(theme.palette.textSecondary)
                    }
                }
                .padding(.top, theme.metrics.spacingSmall)
            }
        }
    }
}

// MARK: - Search & Filter Integration

struct ListSearchBar: View {
    @Environment(ThemeStore.self) private var theme

    @Binding var searchText: String
    let placeholder: String
    let onSubmit: (() -> Void)?

    @FocusState private var isFocused: Bool

    init(
        text: Binding<String>,
        placeholder: String = "Search...",
        onSubmit: (() -> Void)? = nil
    ) {
        self._searchText = text
        self.placeholder = placeholder
        self.onSubmit = onSubmit
    }

    var body: some View {
        HStack(spacing: theme.metrics.spacingSmall) {
            Image(systemName: "magnifyingglass")
                .font(.system(size: theme.metrics.iconSizeSmall))
                .foregroundStyle(theme.palette.textSecondary)

            TextField(placeholder, text: $searchText)
                .font(AppFont.body(theme.metrics.bodyText))
                .foregroundStyle(theme.palette.text)
                .focused($isFocused)
                .onSubmit {
                    onSubmit?()
                }

            if !searchText.isEmpty {
                Button {
                    searchText = ""
                } label: {
                    Image(systemName: "xmark.circle.fill")
                        .font(.system(size: theme.metrics.iconSizeSmall))
                        .foregroundStyle(theme.palette.textSecondary)
                }
            }
        }
        .padding(.horizontal, theme.metrics.spacingSmall)
        .frame(height: theme.metrics.buttonHeightSmall)
        .background(theme.palette.surface)
        .clipShape(RoundedRectangle(cornerRadius: theme.metrics.radiusSmall, style: .continuous))
        .overlay(
            RoundedRectangle(cornerRadius: theme.metrics.radiusSmall, style: .continuous)
                .stroke(isFocused ? theme.palette.tint : theme.palette.border, lineWidth: 1)
        )
    }
}

struct FilterChip: View {
    @Environment(ThemeStore.self) private var theme

    let label: String
    let isSelected: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: 4) {
                Text(label)
                    .font(AppFont.body(theme.metrics.smallText))

                if isSelected {
                    Image(systemName: "checkmark")
                        .font(.system(size: 10, weight: .bold))
                }
            }
            .padding(.horizontal, theme.metrics.chipPadding)
            .frame(height: theme.metrics.chipHeight)
            .background(isSelected ? theme.palette.tint : theme.palette.surface)
            .foregroundStyle(isSelected ? .white : theme.palette.text)
            .clipShape(Capsule())
            .overlay(
                Capsule()
                    .stroke(isSelected ? .clear : theme.palette.border, lineWidth: 1)
            )
        }
    }
}

struct FilterBar<Filter: Hashable>: View {
    @Environment(ThemeStore.self) private var theme

    let filters: [Filter]
    @Binding var selected: Set<Filter>
    let label: (Filter) -> String

    var body: some View {
        ScrollView(.horizontal, showsIndicators: false) {
            HStack(spacing: theme.metrics.spacingSmall) {
                ForEach(Array(filters.enumerated()), id: \.element) { _, filter in
                    FilterChip(
                        label: label(filter),
                        isSelected: selected.contains(filter)
                    ) {
                        withAnimation(.spring(response: 0.3)) {
                            if selected.contains(filter) {
                                selected.remove(filter)
                            } else {
                                selected.insert(filter)
                            }
                        }
                    }
                }
            }
            .padding(.horizontal, theme.metrics.spacing)
        }
    }
}

// MARK: - Refreshable List Container

struct RefreshableListContainer<Content: View>: View {
    @Environment(ThemeStore.self) private var theme

    let content: Content
    let onRefresh: () async -> Void

    @State private var isRefreshing = false

    init(
        onRefresh: @escaping () async -> Void,
        @ViewBuilder content: () -> Content
    ) {
        self.onRefresh = onRefresh
        self.content = content()
    }

    var body: some View {
        ScrollView {
            InsightRefreshControl(
                isRefreshing: $isRefreshing,
                onRefresh: onRefresh
            )

            content
                .padding(.horizontal, theme.metrics.spacing)
        }
        .refreshable {
            await onRefresh()
        }
    }
}
```

---

## Usage Examples

### Basic List with Loading

```swift
struct ExampleListView: View {
    @State private var items: [Item] = []
    @State private var isLoading = true
    @State private var isLoadingMore = false

    var body: some View {
        InsightList(
            items,
            showSkeleton: isLoading,
            isLoadingMore: isLoadingMore,
            loadMore: loadMoreItems
        ) { item, index in
            ItemRow(item: item)
                .swipeActions(
                    leading: [
                        SwipeAction(title: "Pin", icon: "pin", color: .blue) {
                            pinItem(item)
                        }
                    ],
                    trailing: [
                        SwipeAction(title: "Delete", icon: "trash", color: .red) {
                            deleteItem(item)
                        }
                    ]
                )
        }
        .task {
            await loadItems()
        }
    }

    func loadItems() async {
        // Simulate loading
        try? await Task.sleep(for: .seconds(1))
        items = fetchItems()
        isLoading = false
    }

    func loadMoreItems() async {
        guard !isLoadingMore else { return }
        isLoadingMore = true
        try? await Task.sleep(for: .seconds(1))
        items.append(contentsOf: fetchMoreItems())
        isLoadingMore = false
    }
}
```

### Bento Grid

```swift
struct ExampleGridView: View {
    @State private var items: [GridItem] = []
    @State private var isLoading = true

    var body: some View {
        InsightGrid(
            items,
            columns: 2,
            showSkeleton: isLoading
        ) { item, index in
            BentoItem(size: index % 3 == 0 ? .large : .small) {
                VStack {
                    Image(systemName: item.icon)
                        .font(.largeTitle)
                    Text(item.title)
                }
                .padding()
            }
        }
    }
}
```

### Carousel with Indicators

```swift
struct ExampleCarouselView: View {
    let items: [CarouselItem]

    var body: some View {
        InsightCarousel(items, itemWidth: 300) { item, index in
            VStack(alignment: .leading, spacing: 12) {
                AsyncImage(url: item.imageURL) { image in
                    image.resizable().aspectRatio(contentMode: .fill)
                } placeholder: {
                    Color.gray.opacity(0.3)
                }
                .frame(height: 160)
                .clipped()

                Text(item.title)
                    .font(AppFont.title(16))

                Text(item.description)
                    .font(AppFont.body(14))
                    .foregroundStyle(.secondary)
            }
            .padding()
            .background(Color(.systemBackground))
            .clipShape(RoundedRectangle(cornerRadius: 16))
        }
    }
}
```

### With Search and Filters

```swift
struct SearchableListView: View {
    @State private var searchText = ""
    @State private var selectedFilters: Set<Category> = []
    @State private var items: [Item] = []

    var filteredItems: [Item] {
        items.filter { item in
            let matchesSearch = searchText.isEmpty ||
                item.title.localizedCaseInsensitiveContains(searchText)
            let matchesFilter = selectedFilters.isEmpty ||
                selectedFilters.contains(item.category)
            return matchesSearch && matchesFilter
        }
    }

    var body: some View {
        VStack(spacing: 12) {
            ListSearchBar(text: $searchText)
                .padding(.horizontal)

            FilterBar(
                filters: Category.allCases,
                selected: $selectedFilters
            ) { $0.rawValue }

            RefreshableListContainer(onRefresh: refreshItems) {
                InsightList(
                    filteredItems,
                    emptyState: EmptyStateView(
                        illustration: .noSearch,
                        title: "No Results",
                        message: "Try adjusting your search or filters.",
                        actionTitle: "Clear Filters"
                    ) {
                        searchText = ""
                        selectedFilters = []
                    }
                ) { item, index in
                    ItemRow(item: item)
                }
            }
        }
    }
}
```

---

## Integration Notes

1. **Theme Integration**: All components use `@Environment(ThemeStore.self)` for consistent theming
2. **Animations**: Staggered reveal animations are applied automatically with configurable delays
3. **Skeleton Loading**: Pass `showSkeleton: true` to show loading placeholders
4. **Infinite Scroll**: Use `loadMore` callback - triggered when 3rd-to-last item appears
5. **Pull-to-Refresh**: Use `RefreshableListContainer` or native `.refreshable` modifier
6. **Swipe Actions**: Apply `.swipeActions(leading:trailing:)` modifier to row views
7. **Empty States**: Provide custom `EmptyStateView` or use default

## Dependencies

- SwiftUI (iOS 17.0+)
- InsightTheme.swift (ThemeStore, ThemePalette, DisplayMetrics, AppFont)
- InsightComponents.swift (InsightCard, InsightChip)
